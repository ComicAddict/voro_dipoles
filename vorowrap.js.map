{"version":3,"file":"vorowrap.js","sources":["vorowrap.cpp","/usr/local/Cellar/emscripten/1.35.23/libexec/system/include/libcxx/vector","./voro++/container.hh","/usr/local/Cellar/emscripten/1.35.23/libexec/system/include/libcxx/iterator","/usr/local/Cellar/emscripten/1.35.23/libexec/system/include/libcxx/ostream","/usr/local/Cellar/emscripten/1.35.23/libexec/system/include/libcxx/memory","/usr/local/Cellar/emscripten/1.35.23/libexec/system/include/libcxx/type_traits","/usr/local/Cellar/emscripten/1.35.23/libexec/system/include/libcxx/unordered_set","/usr/local/Cellar/emscripten/1.35.23/libexec/system/include/libcxx/__hash_table","/usr/local/Cellar/emscripten/1.35.23/libexec/system/include/libcxx/utility","/usr/local/Cellar/emscripten/1.35.23/libexec/system/include/libcxx/ios","/usr/local/Cellar/emscripten/1.35.23/libexec/system/include/libcxx/__locale","/usr/local/Cellar/emscripten/1.35.23/libexec/system/include/emscripten/bind.h","/usr/local/Cellar/emscripten/1.35.23/libexec/system/include/libcxx/string","/usr/local/Cellar/emscripten/1.35.23/libexec/system/include/libcxx/unordered_map","./voro++/pre_container.hh","./voro++/c_loops.hh","./voro++/v_compute.hh","/usr/local/Cellar/emscripten/1.35.23/libexec/system/include/libcxx/algorithm","/usr/local/Cellar/emscripten/1.35.23/libexec/system/include/libcxx/__split_buffer","/usr/local/Cellar/emscripten/1.35.23/libexec/system/include/libcxx/new","/usr/local/Cellar/emscripten/1.35.23/libexec/system/include/libcxx/__functional_base","/usr/local/Cellar/emscripten/1.35.23/libexec/system/include/libcxx/functional","/usr/local/Cellar/emscripten/1.35.23/libexec/system/include/libcxx/cmath","/usr/local/Cellar/emscripten/1.35.23/libexec/system/include/emscripten/val.h","./glm/detail/type_vec3.inl","/usr/local/Cellar/emscripten/1.35.23/libexec/system/include/emscripten/wire.h","/usr/local/Cellar/emscripten/1.35.23/libexec/system/include/libcxx/locale","/usr/local/Cellar/emscripten/1.35.23/libexec/system/include/libcxx/streambuf","./glm/gtx/norm.inl","./glm/detail/func_geometric.inl","/usr/local/Cellar/emscripten/1.35.23/libexec/system/include/libcxx/iomanip","voro++/cell.cc","voro++/cell.hh","voro++/common.hh","voro++/common.cc","voro++/v_base.cc","voro++/container.cc","voro++/v_base.hh","voro++/v_compute.cc","voro++/v_compute.hh","voro++/container.hh","voro++/rad_option.hh","voro++/pre_container.cc","voro++/pre_container.hh","/usr/local/Cellar/emscripten/1.35.23/libexec/system/lib/embind/bind.cpp","/usr/local/Cellar/emscripten/1.35.23/libexec/system/include/libcxx/typeinfo"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6CA;AACA;;;;;;;;;;;;;;;;;AA6zBA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AC/NA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD+NA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AConBA;AAAA;AAAA;ADpnBA;AAEA;AAAA;;AAIA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AC4mBA;AAAA;AAAA;AD5mBA;AAAA;AAEA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;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AAA;AAAA;AAAA;AAAA;AYoJA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAr1BA;AAs1BA;AACA;AAPA;AZvJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AYoJA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAr1BA;AAs1BA;AACA;AAPA;AZvJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AYoJA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAr1BA;AAs1BA;AACA;AAPA;AZvJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AYoJA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAr1BA;AAs1BA;AACA;AAPA;AZvJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AYoJA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAr1BA;AAs1BA;AACA;AAPA;AZvJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AYoJA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAr1BA;AAs1BA;AACA;AAPA;AZvJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AYoJA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAr1BA;AAs1BA;AACA;AAPA;AZvJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AYoJA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAr1BA;AAs1BA;AACA;AAPA;AZvJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AYoJA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAr1BA;AAs1BA;AACA;AAPA;AZvJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AYoJA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAr1BA;AAs1BA;AACA;AAPA;AZvJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AYoJA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAr1BA;AAs1BA;AACA;AAPA;AZvJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AYoJA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAr1BA;AAs1BA;AACA;AAPA;AZvJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AYoJA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAr1BA;AAs1BA;AACA;AAPA;AZvJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AYoJA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAr1BA;AAs1BA;AACA;AAPA;AZvJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AYoJA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAr1BA;AAs1BA;AACA;AAPA;AZvJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AYoJA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAr1BA;AAs1BA;AACA;AAPA;AZvJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AYoJA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAr1BA;AAs1BA;AACA;AAPA;AZvJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AYoJA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAr1BA;AAs1BA;AACA;AAPA;AZvJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AYoJA;AAIA;AACA;AACA;AACA;AACA;AAAA;AAr1BA;AAs1BA;AACA;AAPA;AZvJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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A;AAAA;AAAA;AH0nCA;AC5rBA;AD4rBA;AAAA;AAAA;AAAA;AAnLA;ACzgBA;ADygBA;AAAA;AGt8BA;AAAA;AAAA;AAAA;AHynCA;AC5rBA;AD4rBA;AAAA;AAAA;AAAA;AAnLA;ACzgBA;ADygBA;AAAA;AL18CA;;AAAA;AAAA;AAAA;;;;;;AACA;;;;;;;AAAA;;AAAA;;;;;;;AAAA;AAAA;AACA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;ACLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADKA;;;;;AAKA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;;AAAA;;;;;;;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;;AAAA;;;;;;;AAAA;;AAAA;;;;;;;AAAA;AAAA;;AAAA;;;;;;;AAAA;;AAAA;;;;;;;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;AACA;;;;;;;AAAA;AAAA;AAAA;AIvVA;;AAAA;;;;;;;;;;;AJ2VA;AAAA;AAAA;AAAA;AAAA;ACo0BA;AAAA;AAAA;ADp0BA;AACA;AAAA;AAAA;AO7KA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AEtLA;AAAA;AHsxCA;AGtxCA;AAAA;AAAA;ADvDA;AAAA;AAAA;ACwDA;AAAA;AAAA;AAAA;AHqxCA;AGrxCA;AAAA;AAAA;AAAA;ATmWA;AAAA;AAAA;ACZA;AAAA;AAAA;AAAA;;;;ADaA;AAAA;AAAA;ACnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADmBA;AAAA;AAAA;ACnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADmBA;;;;;AACA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AC8zBA;AAAA;AAAA;AD9zBA;AAAA;AAAA;AAAA;AAAA;AC8zBA;AAAA;AAAA;AD9zBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;AAAA;AACA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AC4zBA;AAAA;AAAA;AD5zBA;AAAA;;;;;;;AAlBA;;;;;;;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AIjVA;;AAAA;;;;;;;;AJ8UA;AAAA;AAAA;;;;;AA+BA;AAAA;AA9BA;;;;;AA8BA;AAAA;;;;;;AAAA;AAAA;;;;;;AAAA;AAAA;;;;;;AAAA;AAAA;;;;;;AAAA;AAAA;;;;;;AAAA;AAAA;AAxBA;;;;;AASA;;;;;AAWA;;AAAA;;;;;;AAIA;AAAA;;;;;;AAAA;AAAA;;;AAxBA;;;;AAAA;;;;AAAA;;;;AAAA;;;;AAAA;;AAwBA;AAjCA;AAAA;;;;;;;;;;;;;;;;;;;AA0HA;AAAA;;AAQA;;AARA;AAAA;AAAA;AAAA;AC3HA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD2HA;;AAQA;;AARA;AAAA;AAAA;AAAA;AAAA;AAAA;ACytBA;AAAA;AAAA;ADztBA;AAAA;AAAA;;AAQA;;AALA;AAAA;AAAA;AAAA;AAAA;ACstBA;AAAA;AAAA;ADttBA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;ACqtBA;AAAA;AAAA;ADrtBA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AChIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADgIA;;AAGA;;AAFA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;AAjQA;;AAAA;AAAA;AAAA;AAAA;AC8HA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD9HA;;;;AACA;AAAA;AAAA;AADA;AAAA;AAAA;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAxHA;AAEA;AAAA;AAAA;;;AACA;AAAA;;AAAA;;;;AAAA;AAAA;AAAA;;;;;AAmFA;AAAA;AAnFA;AAAA;AAAA;;;;;AAEA;;AAAA;AAAA;AAAA;AAAA;AC8OA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AD9OA;;;;AACA;AAAA;AAAA;AAAA;AAAA;ACikCA;AAAA;AAAA;ADjkCA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AIhGA;AAAA;AJiGA;;;AAJA;AAAA;AAAA;;AAOA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;ACsOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADtOA;;AACA;AAAA;AAAA;AAAA;ACqOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADrOA;AAAA;AAAA;ACqOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADrOA;;AACA;AAAA;AAAA;AAAA;AAAA;ACoOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADpOA;AAAA;AAAA;AAAA;AAAA;ACoOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADpOA;AAAA;AAAA;AAAA;AIvGA;AAAA;AJwGA;;AAEA;;AAAA;AAAA;AAAA;AAAA;ACiOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;ADjOA;;;;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;ACmjCA;AAAA;AAAA;ADnjCA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;ACkjCA;AAAA;AAAA;ADljCA;AACA;;AAAA;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AC+iCA;AAAA;AAAA;AD/iCA;AAAA;;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AC8iCA;AAAA;AAAA;AD9iCA;AAAA;AAAA;AACA;AAAA;;AAAA;;;;;;;AAAA;;AAAA;;;;;;;AAAA;AAAA;AAAA;Aam4BA;AAAA;ARo9BA;AAAA;AAnLA;AQvIA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;Ab7hDA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;;;;;;;;AAAA;;;;;;;AAAA;AAAA;AAAA;Aak4BA;AAAA;ARo9BA;AAAA;AAnLA;AQvIA;AAAA;;AAAA;;;;;;;;AAAA;;;;;;;Ab5hDA;;AAAA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;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CzgBA;ADygBA;AAAA;AGt8BA;AAAA;AAAA;AAAA;AHynCA;AC5rBA;AD4rBA;AAAA;AAAA;AAAA;AApLA;AACA;ACzgBA;ADygBA;AAAA;ALvtDA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAlPA;AAAA;ACsWA;AAAA;AA7IA;AAyFA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AIw0DA;AC5rBA;AD4rBA;AAAA;AAAA;AAAA;AApLA;AACA;ACzgBA;ADygBA;AAAA;ALz8DA;AAAA;AAAA;ACsWA;AAAA;AA7IA;AAyFA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AIw0DA;AC5rBA;AD4rBA;AAAA;AAAA;AAAA;AApLA;AACA;ACzgBA;ADygBA;AAAA;ALz8DA;AAAA;AAAA;ACsWA;AAAA;AA7IA;AAyFA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AIw0DA;AC5rBA;AD4rBA;AAAA;AAAA;AAAA;AApLA;AACA;ACzgBA;ADygBA;AAAA;ALz8DA;AAAA;AAAA;ACsWA;AAAA;AA7IA;AAyFA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AIw0DA;AC5rBA;AD4rBA;AAAA;AAAA;AAAA;AApLA;AACA;ACzgBA;ADygBA;AAAA;ALz8DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;ACsWA;AAAA;AA7IA;AAyFA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AIw0DA;AC5rBA;AD4rBA;AAAA;AAAA;AAAA;AApLA;AACA;ACzgBA;ADygBA;AAAA;ALz8DA;;AAAA;;;;AAAA;AAAA;AAAA;ACsWA;AAAA;AA7IA;AAyFA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AIw0DA;AC5rBA;AD4rBA;AAAA;AAAA;AAAA;AApLA;AACA;ACzgBA;ADygBA;AAAA;ALz8DA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;ACoXA;AAAA;AA3JA;AAyFA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AIw0DA;AC5rBA;AD4rBA;AAAA;AAAA;AAAA;AApLA;AACA;ACzgBA;ADygBA;AAAA;AJliCA;AAAA;;AAKA;;AAHA;;AAAA;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;AAFA;;AAAA;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;;;;AWplBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;;;AACA;AAAA;AADA;AADA;AAAA;;;;;;;;AcjSA;;;;;;;;AAIA;AAAA;;;;;;;;Ad8VA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;Ac5NA;AAAA;AAAA;ApBowCA;AoBpwCA;AAAA;;;;;;;;AAdA;AAAA;;;;;AAxIA;;;;;;;;;;;;;;AdkTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;;;AACA;AAAA;AADA;AAAA;AADA;AAAA;;;;;;;;AcjSA;;;;;;;;AAIA;AAAA;;;;;;;;Ad8VA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AclXA;;;;;;;;;;;;;;AdkTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;;;AACA;AAAA;AADA;AADA;AAAA;;;;;;;;AcjSA;;;;;;;;AAIA;AAAA;;;;;;;;Ad8VA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;Ac5NA;AAAA;AAAA;ApBowCA;AoBpwCA;AAAA;;;;;AAtJA;;;;;;;;;;;;;;;;;;AdkTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AADA;AAAA;;;;;;;;AcjSA;;;;;;;;AAIA;AAAA;;;;;;;;Ad8VA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AclXA;;;;;AdyMA;;;;;;;;;;AAyHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;;;;;AclTA;;;;;;;;AAIA;AAAA;;;;;;;;Ad8VA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AclXA;;;;;AdyMA;;;;;;;;;;;;;;;;;AAyHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;;;;;;;;AclTA;;;;;;;;AAIA;AAAA;;;;;;;;Ad8VA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AclXA;;;;;AdyMA;;;;;;;;;;;;AAyGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;;;AAAA;AAAA;AADA;AAAA;;;;;;;;AcjSA;;;;;;;;AAIA;AAAA;;;;;;;;Ad8VA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AchUA;AAAA;AAAA;;;;;AAlDA;;;;;;;;;;;;AdkTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;;;AAAA;AAAA;AADA;AAAA;;;;;;;;AcjSA;;;;;;;;AAIA;AAAA;;;;;;;;Ad8VA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AclXA;;;;;;;;;;;;;AdkUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;;;AACA;AAAA;AADA;AAAA;;;;;;;;AclTA;;;;;;;;AAIA;AAAA;;;;;;;;Ad8VA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AclXA;;;;;;;;;;;;;AdkTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AAAA;;;AACA;AAAA;AADA;AADA;AAAA;;;;;;;;AcjSA;;;;;;;;AAIA;AAAA;;;;;;;;Ad8VA;AAAA;AAAA;AAAA;AAA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AAAA;;AACA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;AA/2CA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AC9BA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;;AAAA;AAAA;;;;;;;;;;;;;ADMA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;ACmMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AD1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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A;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;;AACA;AAAA;AAAA;;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;;;AACA;AAAA;AAAA;AAKA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAFA;AAAA;AAycA;AAAA;AAAA;;AAncA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAUA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;;AAEA;AAAA;AAGA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAFA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAQA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAOA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;;AAOA;AAAA;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAKA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAEA;AAAA;;AA4CA;AAAA;;AAYA;;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;;;AACA;;;;AAlDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AAAA;;AA0BA;;;AAtBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;;;AACA;;;;AASA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AACA;AAAA;AAAA;;;;;AACA;;;;AA2BA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AA0BA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAvBA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAKA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAGA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAKA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AANA;AAAA;AAAA;;AAWA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AATA;AAAA;AAAA;;AAFA;AAAA;AAAA;;AAeA;AAAA;;AAGA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;;AAkBA;AAAA;AAAA;AAAA;;;AAlBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;AAAA;;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;AAr8BA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAFA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;AC6RA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;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AA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;;;;;;;;;;;;;ACqTA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AA0BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA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ACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;AC3xBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;AD5dA;AAPA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;AAAA;;AAIA;;;;;;;;;;;;;;AC6JA;AAAA;AAAA;AhCwiBA;AAAA;AAhGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgGA;AACA;AAAA;AA9XA;AAAA;AAAA;AAAA;;AA2EA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AA9FA;AAAA;AAAA;AIu+DA;AAAA;AJz4DA;AAAA;AAAA;AAAA;AAAA;AIulBA;AJvlBA;AAAA;AImhCA;AAAA;AAAA;AAAA;AAAA;AAiGA;AAAA;AAAA;AAAA;;AJj0BA;;AAAA;;;;;;AAAA;AAAA;;AACA;AgC3iBA;;;;;;;;;;;AAMA;;;;;;;;;;AAMA;;;;;;;;;;;;ADtKA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AACA;;AADA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgNA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;A/B6lBA;;;;;;;;AACA;;;;;;;;;;;;;;;;;AAuEA;AAAA;AA5lBA;AAAA;AAAA;AIq+DA;AAAA;AJz4CA;AIshBA;AAAA;AAAA;AAuGA;AAAA;AJ7nBA;AAAA;AAAA;AAAA;AAAA;AiB0lDA;AAAA;AAAA;AAAA;AAAA;AARA;AAAA;AAAA;AAAA;AAAA;AAj1DA;AAAA;AAAA;AAAA;AAAA;AAi1DA;AAAA;AAAA;AjBllDA;AAAA;;;;;;;;;;;;;;;;;;;;AkB1nBA;AAAA;AAAA;AAAA;AAAA;AAAA;Ad88DA;AChsBA;ADgsBA;AAAA;AAAA;AChsBA;ADgsBA;AAAA;AAAA;AAAA;AA1WA;ACtVA;ADsVA;AAAA;AAAA;AAAA;AAAA;ACtVA;ADsVA;AclmDA;AAAA;;AAAA;AAAA;AA/QA;AAAA;AAAA;Ad+wEA;AAAA;AApWA;AAAA;Ac5pDA;AAAA;AAAA;Ad0lCA;AAAA;AAAA;AAAA;AAAA;AAmMA;AAAA;AAAA;Aet8CA;AAAA;;;;;ADyKA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AA/QA;AAAA;AAAA;Ad0wEA;AAAA;Ac3/DA;AACA;;;;;;;;;;;;;;;;;;;AlBwjBA;AACA;AAAA;AAniBA;AAAA;AAAA;AIu+DA;AAAA;AJp8CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AI+oBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AJhpBA;AAAA;AAAA;AAAA;AK8kFA;AAAA;AAv4DA;AAu4DA;AAAA;AACA;AAAA;AAx4DA;AAw4DA;AAAA;AAAA;AACA;AAz4DA;AAy4DA;AAAA;AAAA;AL/kFA;AAAA;AAAA;AAAA;AAAA;AK6kFA;AAAA;AAv4DA;AAu4DA;AAAA;AACA;AAAA;AAx4DA;AAw4DA;AAAA;AAAA;AACA;AAz4DA;AAy4DA;AAAA;AAAA;AL9kFA;AAAA;AAhiBA;AAAA;AAAA;AI89DA;AAAA;AJ97CA;AAAA;AAAA;AkB50BA;AAAA;AAAA;Ad0wEA;AAAA;AJ97CA;AAAA;AK4kFA;AAAA;AAv4DA;AAu4DA;AAAA;AACA;AAAA;AAx4DA;AAw4DA;AAAA;AAAA;AACA;AAz4DA;AAy4DA;AAAA;AAAA;AL7kFA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAzPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyPA;AACA;AACA;;;;;;;;;;;;AAnDA;AAAA;AA9JA;AAAA;AI4VA;AJ9LA;AAAA;AA9JA;AAAA;AI4VA;AJ9LA;AAAA;AArMA;AAAA;AA7RA;AAAA;AAZA;AAAA;AAAA;AI49DA;AAAA;AJh9DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAkeA;AACA;AAAA;AA/JA;AAAA;AI4VA;AJ7LA;AAAA;AAzMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAyMA;AAAA;AAAA;AA/JA;AAAA;AI4VA;AJ7LA;AAAA;AAtMA;AAAA;AA7RA;AAAA;AAZA;AAAA;AAAA;AI49DA;AAAA;AJh9DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmeA;AADA;AAEA;;;;;;;;;;;;;;AAPA;AAAA;AAzJA;AAAA;AI4VA;AJnMA;AAAA;AAzJA;AAAA;AI4VA;AJnMA;AAAA;AAhMA;AAAA;AA7RA;AAAA;AAZA;AAAA;AAAA;AI49DA;AAAA;AJh9DA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6dA;AACA;AAAA;AA1JA;AAAA;AI4VA;AJlMA;AAAA;AAjMA;AAAA;AA7RA;AAAA;AAZA;AAAA;AAAA;AI49DA;AAAA;AJh9DA;AAAA;AAAA;AAAA;AAAA;AAAA;AA8dA;AAAA;AAAA;AA1JA;AAAA;AI4VA;AJlMA;AAAA;AADA;AAEA;;;;;;;;;;;;;;;;;AkB/eA;AAAA;AAhRA;AAAA;AAAA;AAAA;AAAA;AAqDA;AAAA;AAAA;AAAA;AAAA;;AA6KA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAhQA;AAAA;AAAA;Ad+wEA;AAAA;AApWA;AAAA;Ac3qDA;AAAA;AAAA;AAAA;AAAA;Ad6tBA;Ac7tBA;AAAA;AdypCA;AAAA;AAAA;AAAA;AAAA;AAiGA;AAAA;AAAA;AAAA;;Ac5sCA;AAAA;;AAEA;;AADA;AAAA;AA/SA;AAAA;AAAA;Ad+wEA;AAAA;AApWA;AAAA;Ac5nDA;AAAA;AAAA;AA/QA;AAAA;AA7BA;AAAA;AAAA;Ad0wEA;AAAA;Ac7uEA;AAAA;AAAA;AAAA;AAAA;AAAA;AA+QA;AAAA;AAAA;AdkkCA;AAAA;AAAA;AAAA;AAAA;AAAA;AA6LA;AAAA;Aeh8CA;AAAA;ADkMA;;;;;;;;;;;;AaykCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAAA;AAAA;;AAEA;AAAA;;;;;;;;;;;;;;;;A/BshBA;AAAA;AAh0CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAg0CA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAGA;;AAFA;AAAA;AAAA;;AAEA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAhqCA;AAAA;AApKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAoKA;AACA;AAAA;AAAA;AAAA;;AAvXA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AA9FA;AAAA;AAAA;AIu+DA;AAAA;AJz4DA;AAAA;AAAA;AAAA;AAAA;AIulBA;AJvlBA;AAAA;AImhCA;AAAA;AAAA;AAAA;AAAA;AAiGA;AAAA;AAAA;AAAA;;AJ7vBA;;AAAA;;;;;;AAAA;AAAA;;AA+pCA;;;;;;;;;;;;;;;;;;;;;;;AA97BA;AAAA;AAhrBA;AAAA;AAAA;AI89DA;AAAA;AJ9yCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAQA;;AALA;AAAA;AA1rBA;AAAA;AAAA;AIu+DA;AAAA;AJ7yCA;AACA;AAAA;AA5YA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA4YA;AAAA;AAAA;AAAA;AAAA;AAnFA;AAAA;AACA;AAAA;AAAA;;AACA;;AACA;AAAA;AAzTA;AAAA;AA7RA;AAAA;AAZA;AAAA;AAAA;AI49DA;AAAA;AJh9DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAslBA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AiBopDA;AAAA;AAAA;AAAA;AAAA;AARA;AAAA;AAAA;AAAA;AAAA;AA15DA;AAAA;AAAA;AAAA;AAAA;AA05DA;AAAA;AAAA;AjB5oDA;AAAA;;AACA;AA4EA;AAAA;AA5YA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA4YA;AAAA;AACA;;AAAA;;;;;;AAGA;AAAA;AADA;AAAA;AAAA;;;;;AADA;;;;;;AAEA;AAAA;AADA;AAAA;AAAA;;;;AAAA;AACA;;;;;;;;;;;;;;;AArEA;AAAA;AA1nBA;AAAA;AAAA;AIu+DA;AAAA;AJ72CA;;AAGA;AACA;AAAA;AAAA;AAAA;AIuDA;AJvDA;AAAA;AIkdA;AAAA;AADA;AAAA;AAAA;AAuHA;AAAA;AAAA;AAAA;AAyEA;AAAA;AJhpBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAAA;;;;;AACA;;;;;;;;;;;;;;AkB3wBA;AAAA;AAhKA;AAAA;AAAA;Ad+wEA;AAAA;AApWA;AAAA;Ac3wDA;;AAGA;AAAA;AAAA;AAAA;Ad0zBA;Ac1zBA;AAAA;AdqtCA;AAAA;AADA;AAAA;AAAA;AAuHA;AAAA;AAAA;AAAA;AAyEA;AAAA;Acn5CA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;;;;AACA;;;;;;;;;;;;;;;;;;;;Aa4hDA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A/B3RA;AAAA;AAAA;A+B2RA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A/B5RA;AAAA;AAAA;A+B4RA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A/B7RA;AAAA;AAAA;A+B6RA;AAHA;AAAA;AAAA;;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAgDA;AACA;AAAA;AAAA;A/BpkCA;AAAA;AAhGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAgGA;AACA;AAAA;AA9XA;AAAA;AAAA;AAAA;;AA2EA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AA9FA;AAAA;AAAA;AIu+DA;AAAA;AJz4DA;AAAA;AAAA;AAAA;AAAA;AIulBA;AJvlBA;AAAA;AImhCA;AAAA;AAAA;AAAA;AAAA;AAiGA;AAAA;AAAA;AAAA;;AJj0BA;;AAAA;;;;;;AAAA;AAAA;;AACA;A+BkkCA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;A/B3OA;AAAA;AAAA;AAAA;AAtuCA;AAAA;AAAA;AI89DA;AAAA;AJxvBA;AAAA;;AAEA;AACA;AAAA;AA/uCA;AAAA;AAAA;AIu+DA;AAAA;AJvvBA;AAAA;AAAA;AI3jBA;AJ4jBA;AAAA;AKNA;ALIA;AAAA;AAAA;AI/JA;AAAA;AAAA;AAAA;ACmKA;ADpKA;AAAA;AAAA;AAAA;AAuHA;AAAA;AAAA;AAAA;AC6CA;AD7CA;AAAA;AAAA;AAyEA;AAAA;AAAA;AC5BA;AD4BA;AAAA;AJ7BA;AACA;AAAA;AAAA;AAAA;;AAGA;AAAA;AKXA;ALWA;;A+BkOA;AAAA;AAAA;AAAA;A/B/PA;AAAA;AAAA;AAAA;AAntCA;AAAA;AAAA;AI89DA;AAAA;AJ3wBA;AAAA;;AAEA;AACA;AAAA;AA5tCA;AAAA;AAAA;AIu+DA;AAAA;AJ1wBA;AAAA;AAAA;AIxiBA;AJwiBA;AADA;AAAA;AAAA;AI5IA;AAAA;AAAA;AAAA;ACmKA;ADpKA;AAAA;AAAA;AAAA;AAuHA;AAAA;AAAA;AAAA;AC6CA;AD7CA;AAAA;AAAA;AAyEA;AAAA;AAAA;AC5BA;AD4BA;AAAA;AJjDA;AACA;AAAA;AAAA;AAAA;;AAGA;AAAA;;A+BuPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;A/BnQA;AAAA;AAAA;AAAA;AAntCA;AAAA;AAAA;AI89DA;AAAA;AJ3wBA;AAAA;;AAEA;AACA;AAAA;AA5tCA;AAAA;AAAA;AIu+DA;AAAA;AJ1wBA;AAAA;AAAA;AIxiBA;AJwiBA;AADA;AAAA;AAAA;AI5IA;AAAA;AAAA;AAAA;ACmKA;ADpKA;AAAA;AAAA;AAAA;AAuHA;AAAA;AAAA;AAAA;AC6CA;AD7CA;AAAA;AAAA;AAyEA;AAAA;AAAA;AC5BA;AD4BA;AAAA;AJjDA;AACA;AAAA;AAAA;AAAA;;AAGA;AAAA;;A+B2PA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;A/BnrCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A+BmrCA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;A/BhWA;AAAA;AAAA;A+BgWA;AACA;AAAA;;AAhBA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAmBA;AACA;;;;;;;;;;;;;;;;;;;;;;;;A/B5RA;AAAA;AA5sCA;AAAA;AAAA;AIu+DA;AAAA;AJ3xBA;AACA;AAAA;AA95BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA85BA;AAAA;AAAA;AAAA;AArmBA;AAAA;AACA;AAAA;AAAA;;AACA;;AACA;AAAA;AAzTA;AAAA;AA7RA;AAAA;AAZA;AAAA;AAAA;AI49DA;AAAA;AJh9DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAslBA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AiBopDA;AAAA;AAAA;AAAA;AAAA;AARA;AAAA;AAAA;AAAA;AAAA;AA15DA;AAAA;AAAA;AAAA;AAAA;AA05DA;AAAA;AAAA;AjB5oDA;AAAA;;AACA;AA8lBA;AAAA;AA95BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AA85BA;AAAA;AAEA;AAAA;AAAA;AAAA;AI1hBA;AJ0hBA;AAAA;AKoCA;ALpCA;AAAA;AAAA;AI/HA;AAAA;AAAA;AAAA;ACmKA;ADpKA;AAAA;AAAA;AAAA;AAuHA;AAAA;AAAA;AAAA;AC6CA;AD7CA;AAAA;AAAA;AAyEA;AAAA;AAAA;AC5BA;AD4BA;AAAA;AJ/DA;AAAA;AAAA;AAAA;;AACA;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;A+BiVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;;AADA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA;AAIA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAHA;AAAA;AAAA;;;AAsCA;AAAA;AACA;AAAA;AAAA;;AAnCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAWA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAHA;AAAA;AAAA;;AAKA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAtBA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AA4BA;AAAA;AAAA;;;AA3BA;AAAA;AA2BA;AAAA;AAAA;;;;AARA;AAAA;AAQA;AAAA;AAAA;;;AAJA;AAAA;AAIA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AArEA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAaA;AAAA;AACA;AAAA;AAAA;;AAbA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAHA;AAAA;AAQA;AAAA;AAAA;;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AA8DA;;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;AAAA;AAAA;AACA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;;;;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;AAIA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;;AADA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AI3nEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;AACA;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AACA;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAhBA;AAAA;AAAA;;AAkBA;AAAA;;AACA;AAAA;AACA;;;;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAhCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAsCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAcA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;;;;;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;;AACA;;AADA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;;AALA;;;;;;AAWA;AAAA;AAAA;AAAA;AAAA;;;;AARA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;AAukBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;;;;;AAKA;AAAA;;AAAA;;AACA;;;;;;;;;AC5jBA;AAAA;AAAA;;AAAA;;AAAA;AAAA;;;;;;;;;;;ADbA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AACA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AADA;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AE5CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;ACgHA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;;;;;;;;;;;;;;;;;;;;;;AHtDA;;AAKA;;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;AAkJA;AAAA;AAAA;AAAA;AAAA;;AAOA;AAAA;AACA;AAAA;AAAA;;AAPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;AAMA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAcA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAYA;AAAA;AAAA;;;AAVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAQA;AAAA;AAAA;;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAIA;AAAA;AAAA;;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;AClNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;AAOA;AAAA;;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;;;;;;;;;;;;;;;;ADgVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;;AACA;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAtUA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAGA;AAAA;AAAA;;AADA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;AAOA;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;;AAQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AARA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAEA;AAGA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AACA;AAAA;;;AAzCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAsCA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAmGA;AACA;;AAWA;AAAA;AAAA;;AAVA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;;AAPA;AAAA;AAAA;;AAUA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AIhEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAeA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;AF8sBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;AAJA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA7tBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;;AAGA;AAAA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAHA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;;AAFA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA3BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AADA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiDA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAkUA;AAAA;AAAA;;AAjUA;AAAA;AAAA;AAAA;AAKA;AAAA;AAGA;;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AALA;AAAA;AAAA;;;AAKA;AAAA;AAoTA;AAAA;AAAA;;AAlTA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;;AADA;AAAA;AA4SA;AAAA;AAAA;;AArSA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AASA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;AAAA;;AAKA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA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AAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;;AAIA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;;;;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;;;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;AAIA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;;AAAA;;AAIA;AAAA;AAAA;AAAA;;;AAVA;AAAA;AAcA;AAAA;AAAA;;;AADA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE1aA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;AAHA;AAAA;AAGA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;AAjHA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAEA;AAAA;AAAA;;;AADA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;AC/DA;;;;;;;;;;;;;;AAgCA;AAAA;;;;;;;;;;;;AAtBA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHwvBA;AAAA;AACA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AADA;AAAA;AAyIA;AAAA;AAAA;;AAvIA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AADA;AAAA;AAqIA;AAAA;AAAA;;AAlIA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AADA;AAAA;AAkIA;AAAA;AAAA;;;AA/HA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AADA;AAAA;AA0HA;AAAA;AAAA;;AAxHA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AADA;AAAA;AAsHA;AAAA;AAAA;;AAnHA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AADA;AAAA;AAmHA;AAAA;AAAA;;;AA/GA;AAAA;AACA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AADA;AAAA;AA6GA;AAAA;AAAA;;AA3GA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AADA;AAAA;AAyGA;AAAA;AAAA;;AAtGA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;AADA;AAAA;AAsGA;AAAA;AAAA;;;;AAnGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AADA;AAAA;AAyFA;AAAA;AAAA;;AAvFA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AADA;AAAA;AAqFA;AAAA;AAAA;;AAlFA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AADA;AAAA;AAkFA;AAAA;AAAA;;;AA/EA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AADA;AAAA;AA0EA;AAAA;AAAA;;AAxEA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AADA;AAAA;AAsEA;AAAA;AAAA;;AAnEA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AADA;AAAA;AAmEA;AAAA;AAAA;;;AA/DA;AAAA;AACA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AADA;AAAA;AA6DA;AAAA;AAAA;;AA3DA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AADA;AAAA;AAyDA;AAAA;AAAA;;AAtDA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;AADA;AAAA;AAsDA;AAAA;AAAA;;;;AAnDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AACA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AADA;AAAA;AA2CA;AAAA;AAAA;;AAzCA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AADA;AAAA;AAuCA;AAAA;AAAA;;AApCA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;AADA;AAAA;AAoCA;AAAA;AAAA;;;;AAjCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;;AAiBA;AAAA;AACA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AADA;AAAA;AAcA;AAAA;AAAA;;AAZA;;AAIA;AAAA;AACA;;;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AADA;AAAA;AAWA;AAAA;AAAA;;;AALA;AAAA;AAAA;AAAA;AAAA;;;AA1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AADA;AAAA;AA2BA;AAAA;AAAA;;AAzBA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AADA;AAAA;AAuBA;AAAA;AAAA;;AApBA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;AADA;AAAA;AAoBA;AAAA;AAAA;;;;AAjBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAcA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;AGx2BA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHkjBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAOA;AAAA;AAAA;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAMA;AAAA;AAAA;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAKA;AAAA;AAAA;;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAIA;AAAA;AAAA;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAGA;AAAA;AAAA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAEA;AAAA;AAAA;;AADA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;AGlmBA;;;;;;;;;;AAWA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AHypBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAOA;AAAA;AAAA;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAMA;AAAA;AAAA;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAKA;AAAA;AAAA;;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAIA;AAAA;AAAA;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAGA;AAAA;AAAA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAEA;AAAA;AAAA;;AADA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAhCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAOA;AAAA;AAAA;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAMA;AAAA;AAAA;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAKA;AAAA;AAAA;;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAIA;AAAA;AAAA;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAGA;AAAA;AAAA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAEA;AAAA;AAAA;;AADA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuCA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;;;;;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA9EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAOA;AAAA;AAAA;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAMA;AAAA;AAAA;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAKA;AAAA;AAAA;;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAIA;AAAA;AAAA;;AAHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAGA;AAAA;AAAA;;AAFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAEA;AAAA;AAAA;;AADA;AAAA;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqFA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;;;;;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;AAeA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;AACA;AAAA;;;;;AACA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AI7uBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;AAAA;;AAEA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;;AACA;;AADA;AACA;;;;;;;;;;;;;;;;;AAMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;ADWA;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAQA;;AARA;AAAA;AAAA;AAAA;;AAQA;;;AARA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAQA;;AARA;AAAA;AAAA;AAAA;;AAQA;;;AARA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAQA;;AARA;AAAA;AAAA;AAAA;;AAQA;;;AAPA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;;;;;;;;;;AAmIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAIA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AADA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;;AAtIA;AAAA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AAGA;AAAA;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;;;;;;;;;;;AEpBA;AAAA;;;;;;;;AAGA;AAAA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAQA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;AnB3EA;AAAA;;;;;AAjBA;;;;;AAiBA;AAAA;;;;;AAjBA;;;;;;;;AmBNA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;AnBsBA;AAAA;;;;;AAjBA;;;;;;;;AmBNA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;AnBsBA;AAAA;;;;;AAjBA;;;;;;;;AmBNA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;AnBsBA;AAAA;;;;;AAjBA;;;;;;;;AmBNA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;AnBsBA;AAAA;;;;;AAjBA;;;;;;;;AmBNA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;AnBsBA;AAAA;;;;;AAjBA;;;;;;;;AmBNA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AACA;;;;;AnBsBA;AAAA;;;;;AAjBA;;;;;;;;AmBNA;AAAA;AAAA;AACA;;;;;AnBsBA;AAAA;;;;;AAjBA;;;;;;;;AmBNA;AAAA;AAAA;AACA;;;;;AnBsBA;AAAA;;;;;AAjBA;;;;;;;;AmBAA;AAAA;AAAA;AACA;;;;;;;;AADA;AAAA;AAAA;AACA;;;;;AnBgBA;AAAA;;;;;AAjBA;;;;;AAiBA;AAAA;;;;;AAjBA;;;;;AAiBA;AAAA;;;;;AAjBA;;;;;AAiBA;AAAA;;;;;AAjBA;;;;;AAiBA;AAAA;;;;;AAjBA;;;;;;;;AmBoCA;AAAA;AAAA;AAAA;AACA;;;;;AnBpBA;AAAA;;;;;AAjBA;;;;;AmBsBA;;;;;;;;AAcA;AAAA;AAAA;AAAA;AACA;;;;;AnBpBA;AAAA;;;;;AAjBA;;;;;AmBsBA;;;;;;;;AAcA;AAAA;AAAA;AAAA;AACA;;;;;AnBpBA;AAAA;;;;;AAjBA;;;;;AmBsBA;;;;;;;;AAcA;AAAA;AAAA;AAAA;AACA;;;;;AnBpBA;AAAA;;;;;AAjBA;;;;;AmBsBA;;;;;;;;AAcA;AAAA;AAAA;AAAA;AACA;;;;;AnBpBA;AAAA;;;;;AAjBA;;;;;AmBsBA;;;;;;;;AAcA;AAAA;AAAA;AAAA;AACA;;;;;AnBpBA;AAAA;;;;;AAjBA;;;;;AmBsBA;;;;;;;;AAcA;AAAA;AAAA;AAAA;AACA;;;;;AnBpBA;AAAA;;;;;AAjBA;;;;;AmBsBA;;;;;;;;AAcA;AAAA;AAAA;AAAA;AACA;;;;;AnBpBA;AAAA;;;;;AAjBA;;;;;AmBsBA;;;;;;;;AAcA;AAAA;AAAA;AAAA;AACA;;;;;AnBpBA;AAAA;;;;;AAjBA;;;;;AmBsBA;;;;;;;;AAcA;AAAA;AAAA;AAAA;AACA;;;;;AnBpBA;AAAA;;;;;AAjBA;;;;;AmBsBA;;;;;;;;AAcA;AAAA;AAAA;AAAA;AACA;;;;;AnBpBA;AAAA;;;;;AAjBA;;;;;AmBsBA;;;;;;;;AAcA;AAAA;AAAA;AAAA;AACA;;;;;AnBpBA;AAAA;;;;;AAjBA;;;;;AmBsBA;;;;;;;;AA1CA;AAAA;AAAA;AC8DA;AAAA;AD9DA;AAAA","sourcesContent":["// this will be a wrapper around voro++ functionality, helping exposing it to js (and threejs specifically)\n\n#include <iostream>\n#include <algorithm>\n#include <unordered_set>\n#include <unordered_map>\n#include <stdlib.h>\n#include <math.h>\n\n#ifdef EMSCRIPTEN\n#include <emscripten.h>\n#include <emscripten/bind.h>\n#include <emscripten/val.h>\n#endif\n\n#include \"voro++/voro++.hh\"\n#include \"glm/vec3.hpp\"\n#include \"glm/gtx/norm.hpp\"\n\nusing namespace std;\nusing namespace emscripten;\n\n// define this to disable all (expensive, debugging-only) sanity checking; INSANITY is recommended for a final build\n#define INSANITY\n// define this to 1 to add the shared faces of neighboring cells that are both toggled 'on'; if the cells are solid, 0 is preferred\n#define ADD_ALL_FACES_ALL_THE_TIME 0\n// the minimum squared distance between two cells.  If you try to move or add a cell closer to another cell than this threshold, the move\n// or add may be prevented.  (TODO: instead of preventing the move or add, keep the cell out of the diagram but track the cell explicitly as 'shadowed')\n//      note on shadowing: this is needed b/c:\n//          1. cells that are directly on top of one another would break things\n//          2. cells that are very very close to one another create inconsistencies due to floating point error.\n//              these inconsistencies make maintaining the diagram over time much more difficult\n//                  - cell shapes begin to depend on insertion order\n//                  - it seems that cells can be created in ways that would break the sanity check? e.g., broken back-links\n#define SHADOW_THRESHOLD .00001\n\n#ifdef INSANITY\n#define SANITY(WHEN) {}\n#else\n#define SANITY(WHEN) {sanity(WHEN);}\n#endif\n\n// main is called once emscripten has asynchronously loaded all it needs to call the other C functions\n// so we wait for its call to run the js init\nint main() {\n    emscripten_run_script(\"ready_for_emscripten_calls = true;\");\n}\n\n// indices to connect cell to voro++ container\nstruct CellConLink {\n    int ijk;    // block index in voro++ container\n    int q;      // index of the cell within the block (following var naming from c_loops.hh)\n    \n    CellConLink() : ijk(-1), q(-1) {} // invalid / fail-fast defaults\n    CellConLink(const voro::c_loop_base &loop) : ijk(loop.ijk), q(loop.q) {}\n    CellConLink(int ijk, int q) : ijk(ijk), q(q) {}\n\n    bool valid() {\n        return ijk >= 0 && q >= 0;\n    }\n    void set(const voro::c_loop_base &loop) {\n        ijk = loop.ijk;\n        q = loop.q;\n    }\n};\n\n// defining information about cell\nstruct Cell {\n    glm::vec3 pos;\n    int type; // 0 is empty, non-zero is non-empty; can use different numbers as tags or material types\n\n    Cell() {}\n    Cell(glm::vec3 pos, int type) : pos(pos), type(type) {}\n};\n\nstruct CellCache { // computations from a voro++ computed cell\n    vector<int> faces; // faces as voro++ likes to store them -- packed as [#vs in f0, f0 v0, f0 v1, ..., #vs in f1, ...]\n    vector<double> vertices; // vertex coordinates, indexed by faces array\n    vector<int> neighbors; // cells neighboring each face\n    \n    void clear() { faces.clear(); vertices.clear(); neighbors.clear(); }\n    void create(const glm::vec3 &pos, voro::voronoicell_neighbor &c) {\n        c.neighbors(neighbors);\n        // fills facev w/ faces as (#verts in face 1, face vert ind 1, ind 2, ..., #vs in f 2, f v ind 1, etc)\n        c.face_vertices(faces);\n        // makes all the vertices for the faces to reference\n        c.vertices(pos.x, pos.y, pos.z, vertices);\n    }\n    double doublearea(int i, int j, int k) {\n        double a[3] = {\n            vertices[j*3+0]-vertices[i*3+0],\n            vertices[j*3+1]-vertices[i*3+1],\n            vertices[j*3+2]-vertices[i*3+2]\n        };\n        double b[3] = {\n            vertices[k*3+0]-vertices[i*3+0],\n            vertices[k*3+1]-vertices[i*3+1],\n            vertices[k*3+2]-vertices[i*3+2]\n        };\n        double o[3] = {\n            a[1]*b[2]-a[2]*b[1],\n            a[2]*b[0]-a[0]*b[2],\n            a[0]*b[1]-a[1]*b[0]\n        };\n        return sqrt(o[0]*o[0]+o[1]*o[1]+o[2]*o[2]);\n    }\n    double face_size(int face) {\n        size_t i=0, fi=0;\n        for (; fi<face && i<faces.size(); fi++,i+=faces[i]+1) {}\n        double area = 0;\n        if (i<faces.size()) {\n            int vicount = faces[i];\n            int vs[3] = {faces[i+1], 0, faces[i+2]};\n            for (int j = i+3; j < i+vicount+1; j++) { // facev\n                vs[1] = faces[j];\n                \n                area += doublearea(vs[0],vs[1],vs[2]);\n                \n                vs[2] = vs[1];\n            }\n        }\n        return area*.5;\n    }\n};\n\nstruct CellToTris {\n    vector<int> tri_inds; // indices into the GLBufferManager's vertices array, indicating which triangles are from this cell\n                            // i.e. if tri_inds[0]==47, then vertices[47*3] ... vertices[47*3+2] (incl.) are from this cell\n    vector<short> tri_faces;\n    CellCache cache;\n};\n\nstruct Voro;\n\nstruct GLBufferManager {\n    vector<float> vertices, wire_vertices, cell_sites, cell_site_sizes;\n    int tri_count, max_tris, max_sites;\n    int wire_vert_count, wire_max_verts;\n    vector<int> cell_inds; // map from tri indices to cell indices\n    vector<short> cell_internal_inds; // map from tri indices to internal tri backref\n    voro::voronoicell_neighbor vorocell; // reused temp var, holds computed cell info\n    \n    vector<CellToTris*> info;\n    \n    GLBufferManager() : wire_vert_count(0), wire_max_verts(0), tri_count(0), max_tris(0), cell_inds(0) {}\n    \n    bool sanity(string when, bool doassert=true) {\n        bool valid = true;\n        for (int ci=0; ci<tri_count; ci++) {\n            if (cell_inds[ci] < 0 || cell_inds[ci] >= info.size()) {\n                valid = false;\n                cout << \"invalid cell! \" << cell_inds[ci] << \" vs \" << info.size() << endl;\n            }\n        }\n        for (int i=0; i<info.size(); i++) {\n            if (info[i]) {\n                for (int ti : info[i]->tri_inds) {\n                    if (cell_inds[ti] != i) {\n                        valid = false;\n                        cout << \"invalid backlink \" << cell_inds[ti] << \" vs \" << i << endl;\n                    }\n                }\n                for (size_t nii=0; nii<info[i]->cache.neighbors.size(); nii++) {//(int ni : info[i]->cache.neighbors) {\n                    int ni = info[i]->cache.neighbors[nii];\n                    if (ni >= int(info.size())) {\n                        valid = false;\n                        cout << \"neighbor index is out of bounds: \" << i << \": \" << ni << \" vs \" << info.size() << endl;\n                    }\n                    if (ni >= 0 && ni < int(info.size()) && info[ni]) {\n                        bool backlink = false;\n                        for (int nni : info[ni]->cache.neighbors) {\n                            if (nni == i) {\n                                backlink = true;\n                            }\n                        }\n                        if (!backlink) {\n                            cout << \"neighbor \" << i << \" -> \" << ni << \" lacks backlink\" << endl;\n                            double face_area = info[i]->cache.face_size(nii);\n                            if (face_area < 4.84704e-14) {\n                                cout << \"backlink error on face so small (\" << face_area  << \") so maybe we don't care?\" << endl;\n                            } else {\n                                valid = false;\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        \n        if (!valid) {\n            cout << \"invalid \" << when << endl;\n        }\n        \n        assert(!doassert || valid);\n        \n        return valid;\n    }\n    \n    void resize_buffers() {\n        vertices.resize(max_tris*9);\n        cell_inds.resize(max_tris);\n        cell_internal_inds.resize(max_tris);\n    }\n    void resize_wire_buffers() {\n        wire_vertices.resize(wire_max_verts*3);\n    }\n    void resize_sites_buffers() {\n        cell_sites.resize(max_sites*3);\n        cell_site_sizes.resize(max_sites);\n    }\n\n    void init(int numCells, int triCapacity, int wiresCapacity, int sitesCapacity) {\n        clear();\n        \n        max_tris = triCapacity;\n        wire_max_verts = wiresCapacity;\n        max_sites = numCells*2;\n        if (max_sites < sitesCapacity) max_sites = sitesCapacity;\n        \n        resize_buffers();\n        resize_wire_buffers();\n        resize_sites_buffers();\n        tri_count = 0;\n        wire_vert_count = 0;\n        \n        info.resize(numCells, 0);\n    }\n    \n    void add_cell(Voro &src);\n    \n    int vert2cell(int vi) {\n        if (vi < 0 || vi >= tri_count*3)\n            return -1;\n        return cell_inds[vi/3];\n    }\n    int vert2cell_neighbor(int vi) {\n        if (vi < 0 || vi >= tri_count*3) return -1;\n        int tri = vi / 3;\n        int cell = cell_inds[tri];\n        CellToTris *in = info[cell];\n        if (!in) return -1;\n        int fi = in->tri_faces[cell_internal_inds[tri]];\n        return in->cache.neighbors[fi];\n    }\n    \n    inline void clear_cell_tris(CellToTris &c2t) {\n        for (int tri : c2t.tri_inds) {\n            swapnpop_tri(tri);\n        }\n        c2t.tri_inds.clear();\n        c2t.tri_faces.clear();\n    }\n    inline void clear_cell_cache(CellToTris &c2t) {\n        c2t.cache.clear();\n    }\n    inline void clear_cell_all(CellToTris &c2t) {\n        clear_cell_tris(c2t);\n        clear_cell_cache(c2t);\n    }\n    \n    inline CellToTris& get_clean_cell(int cell) {\n        if (!info[cell]) {\n            info[cell] = new CellToTris();\n        } else {\n            clear_cell_all(*info[cell]);\n        }\n        return *info[cell];\n    }\n    \n    void recompute_neighbors(Voro &src, int cell);\n    \n    CellCache *get_cache(int cell) {\n        if (cell < 0 || cell >= info.size() || !info[cell]) {\n            return 0;\n        }\n        return &info[cell]->cache;\n    }\n    \n    \n    inline bool add_tri(const vector<double> &input_v, int* vs, int cell, CellToTris &c2t, int f) {\n        if (tri_count+1 >= max_tris) {\n            max_tris *= 2;\n            resize_buffers();\n        }\n        \n        float *v = &vertices[0] + tri_count*9;\n        for (int vii=0; vii<3; vii++) {\n            int ibase = vs[vii]*3;\n            for (int ii=0; ii<3; ii++) {\n                *v = input_v[ibase+ii];\n                v++;\n            }\n        }\n        cell_inds[tri_count] = cell;\n        cell_internal_inds[tri_count] = (short)c2t.tri_inds.size();\n        c2t.tri_inds.push_back(tri_count);\n        c2t.tri_faces.push_back(f);\n\n        \n        tri_count++;\n        \n        return true;\n    }\n    \n    void set_cell(Voro &src, int cell, int oldtype);\n    \n    void compute_cell(Voro &src, int cell); // compute caches for all cells and add tris for non-zero cells\n\n    void compute_all(Voro &src, int tricap, int wirecap, int sitescap);\n    \n    void add_cell_tris(Voro &src, int cell, CellToTris &c2t);\n   \n    void swapnpop_tri(int tri) {\n        if (tri+1 != tri_count) {\n            int ts = tri_count-1;\n            assert(ts > 0);\n            for (int ii=0; ii<9; ii++) {\n                vertices[tri*9+ii] = vertices[ts*9+ii];\n            }\n            cell_inds[tri] = cell_inds[ts];\n            cell_internal_inds[tri] = cell_internal_inds[ts];\n            info[cell_inds[tri]]->tri_inds[cell_internal_inds[tri]] = tri;\n        }\n        tri_count--;\n    }\n    \n    void swapnpop_cell(Voro &src, int cell, int lasti);\n    void move_cell(Voro &src, int cell);\n    void move_cells(Voro &src, const unordered_set<int> &cells);\n    \n    void update_site(Voro &src, int cell);\n    inline void update_site_pos(const glm::vec3 &pos, int cell) {\n        assert(cell >= 0 && cell < cell_sites.size());\n        cell_sites[cell*3]   = pos.x;\n        cell_sites[cell*3+1] = pos.y;\n        cell_sites[cell*3+2] = pos.z;\n\n    }\n    inline void update_site_size(float size, int cell) {\n        if (size>0) {\n            cout << \"cell \" << cell << \" -> size \" << size << \"; \" << cell_sites[cell*3] << \",\" << cell_sites[cell*3+1] << \",\" << cell_sites[cell*3+2] << endl;\n        }\n        cell_site_sizes[cell] = size;\n    }\n    \n    void add_wires(Voro &src, int cell);\n    inline void add_wire_vert(const vector<double> &vertices, int vi) {\n        assert(vi*3+2 < vertices.size());\n        if (wire_vert_count >= wire_max_verts) {\n            wire_max_verts *= 2;\n            resize_wire_buffers();\n        }\n        float *buf = &wire_vertices[0] + (wire_vert_count*3);\n\n        *buf = vertices[vi*3]; buf++;\n        *buf = vertices[vi*3+1]; buf++;\n        *buf = vertices[vi*3+2]; buf++;\n        wire_vert_count++;\n    }\n    void clear_wires() {\n        wire_vert_count = 0;\n    }\n    \n    void clear() {\n        vertices.clear();\n        //normals.clear();\n        cell_inds.clear();\n        wire_vertices.clear();\n        cell_sites.clear();\n        cell_site_sizes.clear();\n        \n        tri_count = max_tris = max_sites = 0;\n        \n        for (auto *c : info) {\n            delete c;\n        }\n        info.clear();\n    }\n};\n\nenum { SANITY_MINIMAL, SANITY_FULL, SANITY_EXCESSIVE };\n\nstruct Voro {\n    Voro()\n        : b_min(glm::vec3(-10)), b_max(glm::vec3(10)), con(0), sanity_level(SANITY_FULL), tracked_ids(0) {}\n    Voro(glm::vec3 bound_min, glm::vec3 bound_max)\n        : b_min(bound_min), b_max(bound_max), con(0), sanity_level(SANITY_FULL), tracked_ids(0) {}\n    ~Voro() {\n        clear_computed();\n    }\n    \n    template<typename T> bool compare_vecs(vector<T> a, vector<T> b, string name, int tag) {\n        sort(a.begin(), a.end());\n        sort(b.begin(), b.end());\n        if (!equal(a.begin(), a.end(), b.begin())) {\n            cout << name << \" mismatched on \" << tag << endl << \"F: \";\n            for (const auto &i: a)\n                cout << i << ' ';\n            cout << endl << \"T: \";\n            for (const auto &i: b)\n                cout << i << ' ';\n            cout << endl;\n            return false;\n        } else {\n            return true;\n        }\n    }\n    \n    bool sanity(string when) {\n        bool valid = true;\n        \n        if (sanity_level > 0) {\n            valid = gl_computed.sanity(when, false);\n        }\n        for (int cell=0; cell<links.size(); cell++) {\n            const auto &link = links[cell];\n            if (link.ijk >= 0 && link.q < 0) {\n                cout << \"partially valid link \" << cell << \": \" << link.ijk << \" \" << link.q << endl;\n                valid = false;\n            }\n        }\n        if (sanity_level > 0) {\n            if (gl_computed.info.size() > 0) {\n                if (gl_computed.info.size() != cells.size()) {\n                    cout << \"computed info cells mismatch voro cells: \" << gl_computed.info.size() << \" vs \" << cells.size() << endl;\n                    valid = false;\n                }\n                for (int i=0; i<cells.size(); i++) {\n                    CellCache cache;\n                    if (gl_computed.info[i]) {\n                        auto &link = links[i];\n                        if (link.valid()) {\n                            if (con->compute_cell(gl_computed.vorocell, link.ijk, link.q)) {\n                                cache.create(cells[i].pos, gl_computed.vorocell);\n                                auto &vs = gl_computed.info[i]->cache;\n                                valid = compare_vecs(vs.neighbors, cache.neighbors, \"neighbors\", i) && valid;\n                                valid = compare_vecs(vs.faces, cache.faces, \"faces\", i) && valid;\n    //                            valid = compare_vecs(vs.vertices, cache.vertices, \"vertices\", i) && valid;\n                            }\n                        }\n                    }\n                }\n                if (sanity_level > 1) {\n                    // Use a pre_container to automatically figure out the right settings for the container we create\n                    voro::pre_container pcon(b_min.x,b_max.x,b_min.y,b_max.y,b_min.z,b_max.z,false,false,false);\n                    \n                    {\n                        // iterating through particles && try to match order in the blocks to guarantee same numerical result\n                        voro::c_loop_all vl(*con);\n                        if (vl.start()) do {\n                            int i = vl.pid();\n                            pcon.put(i,cells[i].pos.x,cells[i].pos.y,cells[i].pos.z);\n                        } while(vl.inc());\n                    }\n                    \n                    // Set up the number of blocks that the container is divided into\n                    int n_x, n_y, n_z;\n                    pcon.guess_optimal(n_x,n_y,n_z);\n                    \n                    // Set up the container class and import the particles from the pre-container\n                    voro::container dcon(pcon.ax,pcon.bx,pcon.ay,pcon.by,pcon.az,pcon.bz,n_x,n_y,n_z,false,false,false,10);\n                    pcon.setup(dcon);\n                    \n                    // build links\n                    voro::c_loop_all vl(dcon);\n                    voro::voronoicell_neighbor vorocell;\n                    CellCache cache;\n                    if(vl.start()) do {\n                        int i = vl.pid();\n                        if (dcon.compute_cell(vorocell, vl.ijk, vl.q)) {\n                            cache.create(cells[i].pos, vorocell);\n                            if (gl_computed.info[i]) {\n                                auto &vs = gl_computed.info[i]->cache;\n                                bool nvalid = compare_vecs(vs.neighbors, cache.neighbors, \" full-recon neighbors\", i);\n                                bool fvalid = compare_vecs(vs.faces, cache.faces, \" full-recon faces\", i);\n                                valid = valid && nvalid && fvalid;\n                                if (!nvalid || !fvalid) {\n                                    cout << \"cell[\" << i << \"].pos = \" << cells[i].pos.x << \", \" << cells[i].pos.y << \", \" << cells[i].pos.z << endl;\n                                }\n                            } else {\n                                cout << \"no info for valid cell?\" << endl;\n                                valid = false;\n                            }\n                        }\n                        \n                    } while(vl.inc());\n                }\n            }\n        }\n        \n        if (!valid) {\n            cout << \"sanity check on Voro failed: \" << when << endl;\n        }\n        assert(valid);\n        return valid;\n    }\n    \n    // clears the input from which the voronoi diagram would be build (the point set)\n    void clear_input() {\n        cells.clear();\n    }\n    \n    // clears out all computed structures of the voronoi diagram.\n    void clear_computed() {\n        delete con; con = 0;\n        links.clear();\n        gl_computed.clear();\n    }\n    \n    void set_only_centermost(int centermost_type, int other_type) {\n        if (cells.empty()) return;\n        int minc = 0;\n        double minl = glm::length2(cells[0].pos);\n        set_cell(0, other_type);\n        for (size_t i=1; i<cells.size(); i++) {\n            double pl = glm::length2(cells[i].pos);\n            if (pl < minl) {\n                minc = i;\n                minl = pl;\n            }\n            set_cell(i, other_type);\n        }\n        set_cell(minc, centermost_type);\n    }\n    \n    void set_all(int type) {\n        for (size_t i=0; i<cells.size(); i++) {\n            set_cell(i, type);\n        }\n    }\n    \n    void set_fill(double target_fill, int rand_seed) {\n        if (cells.empty()) return;\n        srand(rand_seed);\n        \n        if (target_fill <= 0 || target_fill >= 1) {\n            set_all(target_fill >= 1);\n            return;\n        }\n        \n        float fill = get_fill();\n        float newfill = fill;\n        const float one_cell_fill = (1.0/float(cells.size()));\n        int needs_more_fill = fill < target_fill;\n        while (needs_more_fill == (newfill < target_fill)) {\n            int ci = rand() % cells.size();\n            if ((!cells[ci].type) == needs_more_fill) {\n                set_cell(ci, needs_more_fill);\n                newfill = newfill + (2*needs_more_fill-1)*one_cell_fill;\n            }\n        }\n    }\n    \n    float get_fill() {\n        int nonz = 0;\n        for (size_t i=0; i<cells.size(); i++) {\n            nonz += !!cells[i].type;\n        }\n        return float(nonz) / float(cells.size());\n    }\n    \n    // assuming cells vector is already created, now create the container for holding the cells\n    void build_container() {\n        cout << \"build container\" << endl;\n        clear_computed(); // clear out any existing computation\n        \n        // Use a pre_container to automatically figure out the right settings for the container we create\n        voro::pre_container pcon(b_min.x,b_max.x,b_min.y,b_max.y,b_min.z,b_max.z,false,false,false);\n        for (int i=0; i<cells.size(); i++) {\n            pcon.put(i,cells[i].pos.x,cells[i].pos.y,cells[i].pos.z);\n        }\n        \n        // Set up the number of blocks that the container is divided into\n        int n_x, n_y, n_z;\n        pcon.guess_optimal(n_x,n_y,n_z);\n        \n        // Set up the container class and import the particles from the pre-container\n        con = new voro::container(pcon.ax,pcon.bx,pcon.ay,pcon.by,pcon.az,pcon.bz,n_x,n_y,n_z,false,false,false,10);\n        pcon.setup(*con);\n        \n        // build links\n        assert(links.size() == 0);\n        links.resize(cells.size());\n        voro::c_loop_all vl(*con);\n        if(vl.start()) do {\n            links[vl.pid()].set(vl);\n        } while(vl.inc());\n    }\n    \n    int add_cell(glm::vec3 pt, int type) {\n        if (con && con->already_in_block(pt.x, pt.y, pt.z, SHADOW_THRESHOLD)) {\n            // todo: implement a proper notion of shadowing, not this hack.\n            cout << \"not adding cell; it's too close!\" << endl;\n            return -1;\n        }\n        int id = int(cells.size());\n        \n        cells.push_back(Cell(pt, type));\n        if (con) {\n            CellConLink link;\n            bool ret = con->put(id, pt.x, pt.y, pt.z, link.ijk, link.q);\n            if (!ret) { link = CellConLink(); } // reset to invalid default when put fails\n            links.push_back(link);\n            assert(cells.size() == links.size());\n            \n            gl_computed.add_cell(*this);\n        } else {\n            cout << \"ncy \";\n        }\n        SANITY(\"after add_cell\");\n        return id;\n    }\n    \n    void debug_print_block(int ijk, int q) {\n        if (con) {\n            con->print_block(ijk, q);\n        } else {\n            cout << \"no con; cannot print any block yet!\" << endl;\n        }\n    }\n    \n    bool move_cell(int cell, glm::vec3 pt) { // similar to a delete+add, but w/ no swapping and less recomputation\n        if (cell < 0 || cell >= cells.size()) {\n            cout << \"move_cell called w/ invalid cell (index out of range): \" << cell << endl;\n            return false;\n        }\n        if (con && con->already_in_block(pt.x, pt.y, pt.z, SHADOW_THRESHOLD, cell)) {\n            // todo: implement shadowing\n            cout << \"can't move cell on top of another cell until shadowing is implemented\" << endl;\n            return false;\n        }\n        \n        cells[cell].pos = pt;\n        \n        if (!links.empty()) {\n            assert(links.size() == cells.size());\n            if (con) {\n                int needsupdate_q;\n                int needsupdate = con->move(links[cell].ijk, links[cell].q, cell, pt.x, pt.y, pt.z, needsupdate_q);\n                if (needsupdate > -1) { // we updated q of this element, so we need to update external backrefs to reflect that\n                    links[needsupdate].q = needsupdate_q; // only updating q is ok, since the swapnpop won't change the ijk\n                } \n            }\n\n            gl_computed.move_cell(*this, cell);\n        }\n        \n        \n        \n        SANITY(\"after move_cell\");\n        return true;\n    }\n    bool move_cells(val cells_to_move, val posns) { // similar to a delete+add, but w/ no swapping and less recomputation'\n        int len = cells_to_move[\"length\"].as<int>();\n        unordered_set<int> moved_cells;\n        for (int i=0; i<len; i++) {\n            int cell = cells_to_move[i].as<int>();\n            if (cell < 0 || cell >= cells.size()) {\n                cout << \"move_cell called w/ invalid cell (index out of range): \" << cell << endl;\n                continue;\n            }\n            \n            glm::vec3 pt(posns[i][0].as<float>(), posns[i][1].as<float>(), posns[i][2].as<float>());\n            if (con && con->already_in_block(pt.x, pt.y, pt.z, SHADOW_THRESHOLD, cell)) {\n                cout << \"can't move cell on top of another cell until shadowing is implemented\" << endl;\n                continue;\n            }\n            \n            cells[cell].pos = pt;\n            moved_cells.insert(cell);\n            if (!links.empty()) {\n                assert(links.size() == cells.size());\n                if (con) {\n                    int needsupdate_q;\n                    int needsupdate = con->move(links[cell].ijk, links[cell].q, cell, pt.x, pt.y, pt.z, needsupdate_q);\n                    if (needsupdate > -1) { // we updated q of this element, so we need to update external backrefs to reflect that\n                        links[needsupdate].q = needsupdate_q; // only updating q is ok, since the swapnpop won't change the ijk\n                    }\n                }\n            }\n        }\n        \n        gl_computed.move_cells(*this, moved_cells);\n        \n        SANITY(\"after move_cells\");\n        return true;\n    }\n    \n    bool delete_cell(int cell) { // this is a swapnpop deletion\n        if (cell < 0 || cell >= cells.size()) { // can't delete out of range\n            cout << \"trying to delete out of range \" << cell << \" vs \" << cells.size() << endl;\n            return false;\n        }\n\n        int end_ind = int(cells.size())-1;\n        cells[cell] = cells[end_ind];\n        update_stable_id(end_ind, cell);\n        cells.pop_back();\n        if (!links.empty()) {\n            assert(links.size() == cells.size()+1);\n            if (con) { // swapnpop inside the container\n                if (links[cell].valid()) {\n                    int needsupdate = con->swapnpop(links[cell].ijk, links[cell].q);\n                    if (needsupdate > -1) { // we updated q of this element, so we need to update external backrefs to reflect that\n                        links[needsupdate].q = links[cell].q;\n                    }\n                }\n                if (end_ind != cell && links[end_ind].valid()) {\n                    con->id[links[end_ind].ijk][links[end_ind].q] = cell; // update the id of the cell we're swapping back\n                }\n            }\n            links[cell] = links[end_ind];\n            links.pop_back();\n            \n            gl_computed.swapnpop_cell(*this, cell, end_ind);\n        }\n        SANITY(\"after delete_cell\");\n        return true;\n    }\n    \n    void gl_build(int max_tris_guess, int max_wire_verts_guess, int max_sites_guess) {\n        cout << \"gl build\" << endl;\n        // populate gl_computed with current whole voronoi diagram\n        gl_computed.compute_all(*this, max_tris_guess, max_wire_verts_guess, max_sites_guess);\n        \n    }\n    uintptr_t gl_vertices() {\n        return reinterpret_cast<uintptr_t>(&gl_computed.vertices[0]);\n    }\n    void gl_add_wires(int cell) {\n        gl_computed.add_wires(*this, cell);\n        SANITY(\"after gl_add_wires\");\n    }\n    void gl_clear_wires() {\n        gl_computed.clear_wires();\n    }\n    uintptr_t gl_wire_vertices() {\n        return reinterpret_cast<uintptr_t>(&gl_computed.wire_vertices[0]);\n    }\n    int gl_wire_vert_count() {\n        return gl_computed.wire_vert_count;\n    }\n    int gl_wire_max_verts() {\n        return gl_computed.wire_max_verts;\n    }\n    uintptr_t gl_cell_sites() {\n        return reinterpret_cast<uintptr_t>(&gl_computed.cell_sites[0]);\n    }\n    uintptr_t gl_cell_site_sizes() {\n        return reinterpret_cast<uintptr_t>(&gl_computed.cell_site_sizes[0]);\n    }\n    int gl_max_sites() {\n        return gl_computed.max_sites;\n    }\n    int gl_tri_count() {\n        return gl_computed.tri_count;\n    }\n    int gl_max_tris() {\n        return gl_computed.max_tris;\n    }\n    int cell_count() {\n        return cells.size();\n    }\n    void set_sanity_level(int sanity) {\n        sanity_level = sanity;\n    }\n    void toggle_cell(int cell) {\n        if (cell < 0 || cell >= cells.size())\n            return;\n        \n        int oldtype = cells[cell].type;\n        cells[cell].type = !oldtype;\n        gl_computed.set_cell(*this, cell, oldtype);\n    }\n    void set_cell(int cell, int type) {\n        if (cell < 0 || cell >= cells.size() || type==cells[cell].type)\n            return;\n        \n        int oldtype = cells[cell].type;\n        cells[cell].type = type;\n        if (cell < gl_computed.info.size()) {\n            gl_computed.set_cell(*this, cell, oldtype);\n        }\n    }\n    int cell_from_vertex(int vert_ind) {\n        return gl_computed.vert2cell(vert_ind);\n    }\n    int cell_neighbor_from_vertex(int vert_ind) {\n        return gl_computed.vert2cell_neighbor(vert_ind);\n    }\n    glm::vec3 cell_pos(int cell) {\n        assert(cell>=0 && cell<cells.size());\n        return cells[cell].pos;\n    }\n    int cell_type(int cell) {\n        assert(cell>=0 && cell<cells.size());\n        return cells[cell].type;\n    }\n    Cell cell(int c) {\n        assert(c>=0 && c<cells.size());\n        return cells[c];\n    }\n    \n    size_t stable_id(int cell) {\n\n        if (!cell_to_id.count(cell)) {\n            auto id = tracked_ids++;\n            cell_to_id[cell] = id;\n            id_to_cell[id] = cell;\n        }\n        return cell_to_id[cell];\n    }\n    // use this to re-associate cells to ids, e.g. if you undo a deletion.\n    // cell and id must both be unmapped when this is called.\n    // id must be one that has already been used (< tracked_ids) so that it will not collide with new ids.\n    void set_stable_id(int cell, size_t id) {\n        // only allow setting id for cells that do not have an id yet\n        assert(!id_to_cell.count(id));\n        assert(!cell_to_id.count(cell));\n        assert(id < tracked_ids);\n        \n        id_to_cell[id] = cell;\n        cell_to_id[cell] = id;\n    }\n    int index_from_id(size_t id) {\n        if (!id_to_cell.count(id)) {\n            return -1;\n        } else {\n            return id_to_cell[id];\n        }\n    }\n\n\nprotected:\n    friend class GLBufferManager;\n    \n    // library user populates the bounds and the cells vector\n    // these define the truth of what the voronoi diagram should be.\n    union { // bounding box range\n        struct {glm::vec3 b_min, b_max;};\n        glm::vec3 bounds[2];\n    };\n    vector<Cell> cells;\n    \n    voro::container *con;\n    int sanity_level; // level of error checking.  define \"INSANITY\" for zero error checking\n    // note: the below three vectors MUST be kept in 1:1, ordered correspondence with the cells vector\n    vector<CellConLink> links; // link cells to container\n    GLBufferManager gl_computed;\n    \n    // this sparse mapping gives stable ids to cells as needed (via the stable_id() function)\n    // use stable ids to track cells externally -- cell indices will change on deletion, but stable ids remain as long as the cell does.\n    unordered_map<int, size_t> cell_to_id;\n    unordered_map<size_t, int> id_to_cell;\n    size_t tracked_ids;\n    \n    // this puts the old_index into the new_index and removes everything related to what used to be at the new_index\n    void update_stable_id(int old_index, int new_index) {\n        if (cell_to_id.count(new_index)) {\n            auto id_to_remove = cell_to_id[new_index];\n            id_to_cell.erase(id_to_remove);\n        }\n        if (cell_to_id.count(old_index)) {\n            auto id = cell_to_id[old_index];\n            cell_to_id.erase(old_index);\n            if (old_index!=new_index) {\n                cell_to_id[new_index] = id;\n                id_to_cell[id] = new_index;\n            }\n        }\n    }\n\n};\n\nvoid GLBufferManager::compute_cell(Voro &src, int cell) { // compute caches for all cells and add tris for non-zero cells\n    assert(cell >= 0 && cell < info.size());\n    auto &link = src.links[cell];\n    \n    if (!link.valid()) {\n        if (info[cell]) { clear_cell_all(*info[cell]); }\n        return;\n    }\n    CellToTris &c = get_clean_cell(cell);\n    if (src.con->compute_cell(vorocell, link.ijk, link.q)) {\n        c.cache.create(src.cells[cell].pos, vorocell);\n        \n        add_cell_tris(src, cell, c);\n    }\n    update_site(src, cell);\n}\n\nvoid GLBufferManager::compute_all(Voro &src, int tricap, int wirecap, int sitescap) {\n    if (!src.con) {\n        src.build_container();\n    }\n    init(src.cells.size(), tricap, wirecap, sitescap);\n    \n    assert(src.cells.size()==src.links.size());\n    for (size_t i=0; i < src.cells.size(); i++) {\n        compute_cell(src, i);\n    }\n}\n\nvoid GLBufferManager::add_wires(Voro &src, int cell) {\n    assert(cell >= 0 && cell < info.size());\n    if (!info[cell]) {\n        compute_cell(src, cell);\n        if (!info[cell]) return; // happens if cell couldn't be computed -- e.g., if the cell is out of bounds\n    }\n    const vector<int> &faces = info[cell]->cache.faces;\n    const vector<double> &vertices = info[cell]->cache.vertices;\n    for (int i=0; i<faces.size(); i+=faces[i]+1) {\n        int len = faces[i];\n        for (int fi=0; fi<len; fi++) {\n            add_wire_vert(vertices, faces[i+1+fi]);\n            add_wire_vert(vertices, faces[i+1+((fi+1)%len)]);\n        }\n    }\n}\n\n\nvoid GLBufferManager::add_cell_tris(Voro &src, int cell, CellToTris &c2t) { // assuming the cache is fine, just add the tris for it\n    assert(cell >= 0 && cell < info.size());\n    CellCache &c = c2t.cache;\n    int type = src.cells[cell].type;\n    if (type == 0) return;\n    \n    for (int i = 0, ni = 0; i < (int)c.faces.size(); i+=c.faces[i]+1, ni++) {\n        if ((src.cells[c.neighbors[ni]].type != type) || ADD_ALL_FACES_ALL_THE_TIME) {\n            // make a fan of triangles to cover the face\n            int vicount = (i+c.faces[i]+1)-(i+1);\n            int vs[3] = {c.faces[i+1], 0, c.faces[i+2]};\n            for (int j = i+3; j < i+c.faces[i]+1; j++) { // facev\n                vs[1] = c.faces[j];\n                \n                add_tri(c.vertices, vs, cell, c2t, ni);\n                \n                vs[2] = vs[1];\n            }\n        }\n    }\n}\n\nvoid GLBufferManager::set_cell(Voro &src, int cell, int oldtype) {\n    assert(cell >= 0 && cell < info.size());\n    if (oldtype == src.cells[cell].type) return;\n    int type = src.cells[cell].type;\n    \n    if (info[cell]) {\n        if (oldtype) clear_cell_tris(*info[cell]);\n        if (!ADD_ALL_FACES_ALL_THE_TIME) { // re-add neighbors faces to manage internal faces\n            // (we could try to optimize this to just look at shared faces but this seems 'fast enough' for me now)\n            for (int ni : info[cell]->cache.neighbors) {\n                if (ni >= 0 && info[ni]) {\n                    update_site(src, ni);\n                    if (src.cells[ni].type) {\n                        clear_cell_tris(*info[ni]);\n                        add_cell_tris(src, ni, *info[ni]);\n                    }\n                }\n            }\n        }\n    }\n    \n    if (src.cells[cell].type == 0) {\n        return;\n    }\n    \n    if (!info[cell]) {\n        compute_cell(src, cell);\n    } else {\n        add_cell_tris(src, cell, *info[cell]);\n        update_site(src, cell);\n    }\n}\n\nvoid GLBufferManager::recompute_neighbors(Voro &src, int cell) {\n    assert(cell >= 0 && cell < info.size());\n    if (info[cell]) {\n        for (int ni : info[cell]->cache.neighbors) {\n            if (ni >= 0) {\n                compute_cell(src, ni);\n            }\n        }\n    }\n}\n\nvoid GLBufferManager::swapnpop_cell(Voro &src, int cell, int lasti) {\n    vector<int> to_recompute;\n    if (info[cell]) {\n        to_recompute = info[cell]->cache.neighbors;\n        clear_cell_all(*info[cell]); // clears everything pointing to cell\n        delete info[cell]; info[cell] = 0;\n    }\n    \n    info[cell] = info[lasti]; // overwrite cell\n    if (info[cell]) { // if the swap cell exists, fix backpointers to it\n        for (int ni : info[cell]->cache.neighbors) { // redirect neighbor backptrs\n            if (ni >= 0) {\n                for (int nii=0; info[ni] && nii < info[ni]->cache.neighbors.size(); nii++) {\n                    if (info[ni]->cache.neighbors[nii] == lasti) {\n                        info[ni]->cache.neighbors[nii] = cell;\n                    }\n                }\n            }\n        }\n        for (int ti : info[cell]->tri_inds) { // redirect tri backptrs\n            cell_inds[ti] = cell;\n        }\n    }\n    for (int ni : to_recompute) { // recompute former cell neighbors\n        if (ni >= 0) {\n            ni = ni<lasti? ni : cell;\n            compute_cell(src, ni);\n        }\n    }\n    \n    update_site(src, cell);\n    info.pop_back();\n}\n\nvoid GLBufferManager::move_cell(Voro &src, int cell) {\n    if (info[cell]) {\n        for (int ni : info[cell]->cache.neighbors) { if (ni >= 0) { compute_cell(src, ni); } }\n    }\n    compute_cell(src, cell);\n    update_site(src, cell);\n    if (info[cell]) {\n        // todo: possible optimization: don't recompute a neighbor here if it was already computed above.\n        for (int ni : info[cell]->cache.neighbors) { if (ni >= 0) { compute_cell(src, ni); } }\n    }\n}\n\nvoid GLBufferManager::update_site(Voro &src, int cell) {\n    update_site_pos(src.cells[cell].pos, cell);\n    float size = 0;\n    if (info[cell]) {\n        for (auto ni : info[cell]->cache.neighbors) {\n            if (ni >= 0) {\n                size += float(src.cells[ni].type > 0);\n            }\n        }\n    }\n    update_site_size(size, cell);\n}\n\nvoid GLBufferManager::move_cells(Voro &src, const unordered_set<int> &cells) {\n    unordered_set<int> computed;\n    for (int cell : cells) {\n        if (info[cell]) {\n            for (int ni : info[cell]->cache.neighbors) { if (ni >= 0 && !cells.count(ni) && !computed.count(ni)) { compute_cell(src, ni); computed.insert(ni); } }\n        }\n    }\n    for (int cell : cells) {\n        compute_cell(src, cell);\n        update_site(src, cell);\n        computed.insert(cell);\n    }\n    for (int cell : cells) {\n        if (info[cell]) {\n            for (int ni : info[cell]->cache.neighbors) { if (ni >= 0 && !cells.count(ni) && !computed.count(ni)) { compute_cell(src, ni); computed.insert(ni); } }\n        }\n    }\n}\n\nvoid GLBufferManager::add_cell(Voro &src) {\n    int id = (int)info.size();\n    info.push_back(0);\n    if (info.size() > max_sites) {\n        cout << \"resizing sites b/c \" << info.size() << \" > \" << max_sites << endl;\n        max_sites *= 2;\n        resize_sites_buffers();\n    }\n    \n    compute_cell(src, id);\n    recompute_neighbors(src, id);\n    update_site(src, id);\n}\n\n\nEMSCRIPTEN_BINDINGS(voro) {\n    value_array<glm::vec3>(\"vec3\")\n        .element(&glm::vec3::x)\n        .element(&glm::vec3::y)\n        .element(&glm::vec3::z)\n        ;\n    value_object<Cell>(\"Cell\")\n        .field(\"pos\", &Cell::pos)\n        .field(\"type\", &Cell::type)\n        ;\n    class_<Voro>(\"Voro\")\n    .constructor<glm::vec3, glm::vec3>()\n    .function(\"cell_pos\", &Voro::cell_pos)\n    .function(\"cell_type\", &Voro::cell_type)\n    .function(\"cell\", &Voro::cell)\n    .function(\"add_cell\", &Voro::add_cell)\n    .function(\"build_container\", &Voro::build_container)\n    .function(\"gl_build\", &Voro::gl_build)\n    .function(\"gl_vertices\", &Voro::gl_vertices)\n    .function(\"gl_tri_count\", &Voro::gl_tri_count)\n    .function(\"gl_max_tris\", &Voro::gl_max_tris)\n    .function(\"gl_cell_sites\", &Voro::gl_cell_sites)\n    .function(\"gl_cell_site_sizes\", &Voro::gl_cell_site_sizes)\n    .function(\"gl_max_sites\", &Voro::gl_max_sites)\n    .function(\"cell_count\", &Voro::cell_count)\n    .function(\"toggle_cell\", &Voro::toggle_cell)\n    .function(\"cell_neighbor_from_vertex\", &Voro::cell_neighbor_from_vertex)\n    .function(\"cell_from_vertex\", &Voro::cell_from_vertex)\n    .function(\"delete_cell\", &Voro::delete_cell)\n    .function(\"move_cell\", &Voro::move_cell)\n    .function(\"move_cells\", &Voro::move_cells)\n    .function(\"set_cell\", &Voro::set_cell)\n    .function(\"set_all\", &Voro::set_all)\n    .function(\"sanity\", &Voro::sanity)\n    .function(\"set_sanity_level\", &Voro::set_sanity_level)\n    .function(\"set_fill\", &Voro::set_fill)\n    .function(\"set_only_centermost\", &Voro::set_only_centermost)\n    .function(\"gl_add_wires\", &Voro::gl_add_wires)\n    .function(\"gl_clear_wires\", &Voro::gl_clear_wires)\n    .function(\"gl_wire_vert_count\", &Voro::gl_wire_vert_count)\n    .function(\"gl_wire_vertices\", &Voro::gl_wire_vertices)\n    .function(\"gl_wire_max_verts\", &Voro::gl_wire_max_verts)\n    .function(\"debug_print_block\", &Voro::debug_print_block)\n    .function(\"stable_id\", &Voro::stable_id)\n    .function(\"set_stable_id\", &Voro::set_stable_id)\n    .function(\"index_from_id\", &Voro::index_from_id)\n//    .property(\"min\", &Voro::b_min)\n//    .property(\"max\", &Voro::b_max)\n    ;\n}\n","// -*- C++ -*-\n//===------------------------------ vector --------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_VECTOR\n#define _LIBCPP_VECTOR\n\n/*\n    vector synopsis\n\nnamespace std\n{\n\ntemplate <class T, class Allocator = allocator<T> >\nclass vector\n{\npublic:\n    typedef T                                        value_type;\n    typedef Allocator                                allocator_type;\n    typedef typename allocator_type::reference       reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::pointer         pointer;\n    typedef typename allocator_type::const_pointer   const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n);\n    explicit vector(size_type n, const allocator_type&); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    value_type*       data() noexcept;\n    const value_type* data() const noexcept;\n\n    void push_back(const value_type& x);\n    void push_back(value_type&& x);\n    template <class... Args>\n        void emplace_back(Args&&... args);\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, value_type&& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, const value_type& c);\n\n    void swap(vector&)\n        noexcept(!allocator_type::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<allocator_type>::value);\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator = allocator<T> >\nclass vector<bool, Allocator>\n{\npublic:\n    typedef bool                                     value_type;\n    typedef Allocator                                allocator_type;\n    typedef implementation-defined                   iterator;\n    typedef implementation-defined                   const_iterator;\n    typedef typename allocator_type::size_type       size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef iterator                                 pointer;\n    typedef const_iterator                           const_pointer;\n    typedef std::reverse_iterator<iterator>          reverse_iterator;\n    typedef std::reverse_iterator<const_iterator>    const_reverse_iterator;\n\n    class reference\n    {\n    public:\n        reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        reference& operator=(const bool x) noexcept;\n        reference& operator=(const reference& x) noexcept;\n        iterator operator&() const noexcept;\n        void flip() noexcept;\n    };\n\n    class const_reference\n    {\n    public:\n        const_reference(const reference&) noexcept;\n        operator bool() const noexcept;\n        const_iterator operator&() const noexcept;\n    };\n\n    vector()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit vector(const allocator_type&);\n    explicit vector(size_type n, const allocator_type& a = allocator_type()); // C++14\n    vector(size_type n, const value_type& value, const allocator_type& = allocator_type());\n    template <class InputIterator>\n        vector(InputIterator first, InputIterator last, const allocator_type& = allocator_type());\n    vector(const vector& x);\n    vector(vector&& x)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    vector(initializer_list<value_type> il);\n    vector(initializer_list<value_type> il, const allocator_type& a);\n    ~vector();\n    vector& operator=(const vector& x);\n    vector& operator=(vector&& x)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n    vector& operator=(initializer_list<value_type> il);\n    template <class InputIterator>\n        void assign(InputIterator first, InputIterator last);\n    void assign(size_type n, const value_type& u);\n    void assign(initializer_list<value_type> il);\n\n    allocator_type get_allocator() const noexcept;\n\n    iterator               begin() noexcept;\n    const_iterator         begin()   const noexcept;\n    iterator               end() noexcept;\n    const_iterator         end()     const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin()  const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend()    const noexcept;\n\n    const_iterator         cbegin()  const noexcept;\n    const_iterator         cend()    const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend()   const noexcept;\n\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n    bool empty() const noexcept;\n    void reserve(size_type n);\n    void shrink_to_fit() noexcept;\n\n    reference       operator[](size_type n);\n    const_reference operator[](size_type n) const;\n    reference       at(size_type n);\n    const_reference at(size_type n) const;\n\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    void push_back(const value_type& x);\n    template <class... Args> void emplace_back(Args&&... args);  // C++14\n    void pop_back();\n\n    template <class... Args> iterator emplace(const_iterator position, Args&&... args);  // C++14\n    iterator insert(const_iterator position, const value_type& x);\n    iterator insert(const_iterator position, size_type n, const value_type& x);\n    template <class InputIterator>\n        iterator insert(const_iterator position, InputIterator first, InputIterator last);\n    iterator insert(const_iterator position, initializer_list<value_type> il);\n\n    iterator erase(const_iterator position);\n    iterator erase(const_iterator first, const_iterator last);\n\n    void clear() noexcept;\n\n    void resize(size_type sz);\n    void resize(size_type sz, value_type x);\n\n    void swap(vector&)\n        noexcept(!allocator_type::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<allocator_type>::value);\n    void flip() noexcept;\n\n    bool __invariants() const;\n};\n\ntemplate <class Allocator> struct hash<std::vector<bool, Allocator>>;\n\ntemplate <class T, class Allocator> bool operator==(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator< (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator!=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator> (const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator>=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\ntemplate <class T, class Allocator> bool operator<=(const vector<T,Allocator>& x, const vector<T,Allocator>& y);\n\ntemplate <class T, class Allocator>\nvoid swap(vector<T,Allocator>& x, vector<T,Allocator>& y)\n    noexcept(noexcept(x.swap(y)));\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__bit_reference>\n#include <type_traits>\n#include <climits>\n#include <limits>\n#include <initializer_list>\n#include <memory>\n#include <stdexcept>\n#include <algorithm>\n#include <cstring>\n#include <__split_buffer>\n#include <__functional_base>\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __vector_base_common\n{\nprotected:\n    _LIBCPP_ALWAYS_INLINE __vector_base_common() {}\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_length_error() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(\"vector\");\n#else\n    assert(!\"vector length_error\");\n#endif\n}\n\ntemplate <bool __b>\nvoid\n__vector_base_common<__b>::__throw_out_of_range() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(\"vector\");\n#else\n    assert(!\"vector out_of_range\");\n#endif\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS __vector_base_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\ntemplate <class _Tp, class _Allocator>\nclass __vector_base\n    : protected __vector_base_common<true>\n{\nprotected:\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer& __end_cap() _NOEXCEPT\n        {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const pointer& __end_cap() const _NOEXCEPT\n        {return __end_cap_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY __vector_base(const allocator_type& __a);\n    ~__vector_base();\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return static_cast<size_type>(__end_cap() - __begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c)\n        {__copy_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_swap::value ||\n            __is_nothrow_swappable<allocator_type>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_swap::value>());}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n            {\n                clear();\n                __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n                __begin_ = __end_ = __end_cap() = nullptr;\n            }\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __vector_base&, false_type)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__vector_base&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type&, allocator_type&, false_type)\n        _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__vector_base<_Tp, _Allocator>::__destruct_at_end(pointer __new_last) _NOEXCEPT\n{\n    while (__new_last != __end_)\n        __alloc_traits::destroy(__alloc(), _VSTD::__to_raw_pointer(--__end_));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__vector_base<_Tp, _Allocator>::__vector_base(const allocator_type& __a)\n    : __begin_(nullptr),\n      __end_(nullptr),\n      __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__vector_base<_Tp, _Allocator>::~__vector_base()\n{\n    if (__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(__alloc(), __begin_, capacity());\n    }\n}\n\ntemplate <class _Tp, class _Allocator = allocator<_Tp> >\nclass _LIBCPP_TYPE_VIS_ONLY vector\n    : private __vector_base<_Tp, _Allocator>\n{\nprivate:\n    typedef __vector_base<_Tp, _Allocator>           __base;\n    typedef allocator<_Tp>                           __default_allocator_type;\npublic:\n    typedef vector                                   __self;\n    typedef _Tp                                      value_type;\n    typedef _Allocator                               allocator_type;\n    typedef typename __base::__alloc_traits          __alloc_traits;\n    typedef typename __base::reference               reference;\n    typedef typename __base::const_reference         const_reference;\n    typedef typename __base::size_type               size_type;\n    typedef typename __base::difference_type         difference_type;\n    typedef typename __base::pointer                 pointer;\n    typedef typename __base::const_pointer           const_pointer;\n    typedef __wrap_iter<pointer>                     iterator;\n    typedef __wrap_iter<const_pointer>               const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n\n    _LIBCPP_INLINE_VISIBILITY\n    vector()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a)\n        : __base(__a)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_c(this);\n#endif\n    }\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const_reference __x);\n    vector(size_type __n, const_reference __x, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value,\n                                 _InputIterator>::type __last);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_InputIterator>::reference>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value,\n                                 _ForwardIterator>::type __last);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                 is_constructible<\n                                    value_type,\n                                    typename iterator_traits<_ForwardIterator>::reference>::value>::type* = 0);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    ~vector()\n    {\n        __get_db()->__erase_c(this);\n    }\n#endif\n\n    vector(const vector& __x);\n    vector(const vector& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(const vector& __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __x, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __x)\n        _NOEXCEPT_(\n             __alloc_traits::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const_reference __u);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return this->__alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY iterator               begin() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         begin()   const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY iterator               end() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY const_iterator         end()     const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin()  const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator       rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()    const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return static_cast<size_type>(this->__end_ - this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __base::capacity();}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return this->__begin_ == this->__end_;}\n    size_type max_size() const _NOEXCEPT;\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n);\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const;\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const\n    {\n        _LIBCPP_ASSERT(!empty(), \"front() called for empty vector\");\n        return *this->__begin_;\n    }\n    _LIBCPP_INLINE_VISIBILITY reference       back()\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const\n    {\n        _LIBCPP_ASSERT(!empty(), \"back() called for empty vector\");\n        return *(this->__end_ - 1);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    value_type*       data() _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT\n        {return _VSTD::__to_raw_pointer(this->__begin_);}\n\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY void push_back(value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        void emplace_back(_Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    void pop_back();\n\n    iterator insert(const_iterator __position, const_reference __x);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __position, value_type&& __x);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args>\n        iterator emplace(const_iterator __position, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_InputIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value &&\n            is_constructible<\n                 value_type,\n                 typename iterator_traits<_ForwardIterator>::reference>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n    {\n        size_type __old_size = size();\n        __base::clear();\n        __annotate_shrink(__old_size);\n        __invalidate_all_iterators();\n    }\n\n    void resize(size_type __sz);\n    void resize(size_type __sz, const_reference __x);\n\n    void swap(vector&)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value);\n\n    bool __invariants() const;\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type __recommend(size_type __new_size) const;\n    void __construct_at_end(size_type __n);\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n    void __append(size_type __n);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       __make_iter(pointer __p) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(const_pointer __p) const _NOEXCEPT;\n    void __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v);\n    pointer __swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p);\n    void __move_range(pointer __from_s, pointer __from_e, pointer __to);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    void __move_assign(vector& __c, false_type);\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __c_node* __c = __get_db()->__find_c_and_lock(this);\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->base() > __new_last)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n#endif\n        size_type __old_size = size();\n        __base::__destruct_at_end(__new_last);\n        __annotate_shrink(__old_size);\n    }\n    template <class _Up>\n        void\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        __push_back_slow_path(_Up&& __x);\n#else\n        __push_back_slow_path(_Up& __x);\n#endif\n#if !defined(_LIBCPP_HAS_NO_VARIADICS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class... _Args>\n        void\n        __emplace_back_slow_path(_Args&&... __args);\n#endif\n    // The following functions are no-ops outside of AddressSanitizer mode.\n    // We call annotatations only for the default Allocator because other allocators\n    // may not meet the AddressSanitizer alignment constraints.\n    // See the documentation for __sanitizer_annotate_contiguous_container for more details.\n    void __annotate_contiguous_container\n    (const void *__beg, const void *__end, const void *__old_mid, const void *__new_mid) const\n    {\n#ifndef _LIBCPP_HAS_NO_ASAN\n      if (__beg && is_same<allocator_type, __default_allocator_type>::value)\n        __sanitizer_annotate_contiguous_container(__beg, __end, __old_mid, __new_mid);\n#endif\n    }\n\n    void __annotate_new(size_type __current_size) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + capacity(), data() + __current_size);\n    }\n    void __annotate_delete() const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + size(), data() + capacity());\n    }\n    void __annotate_increase(size_type __n) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + size(), data() + size() + __n);\n    }\n    void __annotate_shrink(size_type __old_size) const\n    {\n      __annotate_contiguous_container(data(), data() + capacity(),\n                                      data() + __old_size, data() + size());\n    }\n#ifndef _LIBCPP_HAS_NO_ASAN\n    // The annotation for size increase should happen before the actual increase,\n    // but if an exception is thrown after that the annotation has to be undone.\n    struct __RAII_IncreaseAnnotator {\n      __RAII_IncreaseAnnotator(const vector &__v, size_type __n = 1)\n        : __commit(false), __v(__v), __n(__n) {\n        __v.__annotate_increase(__n);\n      }\n      void __done() { __commit = true; }\n      ~__RAII_IncreaseAnnotator() {\n        if (__commit) return;\n        __v.__annotate_shrink(__v.size() + __n);\n      }\n      bool __commit;\n      size_type __n;\n      const vector &__v;\n    };\n#else\n    struct __RAII_IncreaseAnnotator {\n      inline __RAII_IncreaseAnnotator(const vector &, size_type __n = 1) {}\n      inline void __done() {}\n    };\n#endif\n\n};\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v)\n{\n    __annotate_delete();\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, this->__end_, __v.__begin_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __annotate_new(size());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::pointer\nvector<_Tp, _Allocator>::__swap_out_circular_buffer(__split_buffer<value_type, allocator_type&>& __v, pointer __p)\n{\n    __annotate_delete();\n    pointer __r = __v.__begin_;\n    __alloc_traits::__construct_backward(this->__alloc(), this->__begin_, __p, __v.__begin_);\n    __alloc_traits::__construct_forward(this->__alloc(), __p, this->__end_, __v.__end_);\n    _VSTD::swap(this->__begin_, __v.__begin_);\n    _VSTD::swap(this->__end_, __v.__end_);\n    _VSTD::swap(this->__end_cap(), __v.__end_cap());\n    __v.__first_ = __v.__begin_;\n    __annotate_new(size());\n    __invalidate_all_iterators();\n    return __r;\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __end_cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    this->__begin_ = this->__end_ = __alloc_traits::allocate(this->__alloc(), __n);\n    this->__end_cap() = this->__begin_ + __n;\n    __annotate_new(0);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        clear();\n        __alloc_traits::deallocate(this->__alloc(), this->__begin_, capacity());\n        this->__begin_ = this->__end_ = this->__end_cap() = nullptr;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::max_size() const _NOEXCEPT\n{\n    return _VSTD::min<size_type>(__alloc_traits::max_size(this->__alloc()), numeric_limits<size_type>::max() / 2);  // end() >= begin(), always\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::size_type\nvector<_Tp, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max<size_type>(2*__cap, __new_size);\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n        __annotator.__done();\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    allocator_type& __a = this->__alloc();\n    do\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n        __annotator.__done();\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    allocator_type& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        __annotator.__done();\n        ++this->__end_;\n    }\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Postcondition:  size() == size() + __n\n//  Exception safety: strong.\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__append(size_type __n, const_reference __x)\n{\n    if (static_cast<size_type>(this->__end_cap() - this->__end_) >= __n)\n        this->__construct_at_end(__n, __x);\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), size(), __a);\n        __v.__construct_at_end(__n, __x);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n);\n    }\n}\n#endif\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(size_type __n, const_reference __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value,\n                          _InputIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\nvector<_Tp, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value &&\n                         is_constructible<\n                            value_type,\n                            typename iterator_traits<_InputIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value,\n                                                   _ForwardIterator>::type __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\nvector<_Tp, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value &&\n                                is_constructible<\n                                   value_type,\n                                   typename iterator_traits<_ForwardIterator>::reference>::value>::type*)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x)\n    : __base(__alloc_traits::select_on_container_copy_construction(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvector<_Tp, _Allocator>::vector(const vector& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    size_type __n = __x.size();\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__x.__begin_, __x.__end_);\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __base(_VSTD::move(__x.__alloc()))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__x);\n#endif\n    this->__begin_ = __x.__begin_;\n    this->__end_ = __x.__end_;\n    this->__end_cap() = __x.__end_cap();\n    __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(vector&& __x, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a == __x.__alloc())\n    {\n        this->__begin_ = __x.__begin_;\n        this->__end_ = __x.__end_;\n        this->__end_cap() = __x.__end_cap();\n        __x.__begin_ = __x.__end_ = __x.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->swap(this, &__x);\n#endif\n    }\n    else\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__x.begin()), _Ip(__x.end()));\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __base(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__il.size() > 0)\n    {\n        allocate(__il.size());\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(vector&& __x)\n        _NOEXCEPT_(\n             __alloc_traits::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value)\n{\n    __move_assign(__x, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, false_type)\n{\n    if (__base::__alloc() != __c.__alloc())\n    {\n        typedef move_iterator<iterator> _Ip;\n        assign(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    __base::__move_assign_alloc(__c); // this can throw\n    this->__begin_ = __c.__begin_;\n    this->__end_ = __c.__end_;\n    this->__end_cap() = __c.__end_cap();\n    __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__c);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<_Tp, _Allocator>&\nvector<_Tp, _Allocator>::operator=(const vector& __x)\n{\n    if (this != &__x)\n    {\n        __base::__copy_assign_alloc(__x);\n        assign(__x.__begin_, __x.__end_);\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    void\n>::type\nvector<_Tp, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typename iterator_traits<_ForwardIterator>::difference_type __new_size = _VSTD::distance(__first, __last);\n    if (static_cast<size_type>(__new_size) <= capacity())\n    {\n        _ForwardIterator __mid = __last;\n        bool __growing = false;\n        if (static_cast<size_type>(__new_size) > size())\n        {\n            __growing = true;\n            __mid =  __first;\n            _VSTD::advance(__mid, size());\n        }\n        pointer __m = _VSTD::copy(__first, __mid, this->__begin_);\n        if (__growing)\n            __construct_at_end(__mid, __last);\n        else\n            this->__destruct_at_end(__m);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(static_cast<size_type>(__new_size)));\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::assign(size_type __n, const_reference __u)\n{\n    if (__n <= capacity())\n    {\n        size_type __s = size();\n        _VSTD::fill_n(this->__begin_, _VSTD::min(__n, __s), __u);\n        if (__n > __s)\n            __construct_at_end(__n - __s, __u);\n        else\n            this->__destruct_at_end(this->__begin_ + __n);\n    }\n    else\n    {\n        deallocate();\n        allocate(__recommend(static_cast<size_type>(__n)));\n        __construct_at_end(__n, __u);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::__make_iter(pointer __p) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(this, __p);\n#else\n    return iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::__make_iter(const_pointer __p) const _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return const_iterator(this, __p);\n#else\n    return const_iterator(__p);\n#endif\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::begin() _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::begin() const _NOEXCEPT\n{\n    return __make_iter(this->__begin_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::end() _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_iterator\nvector<_Tp, _Allocator>::end() const _NOEXCEPT\n{\n    return __make_iter(this->__end_);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::operator[](size_type __n)\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::operator[](size_type __n) const\n{\n    _LIBCPP_ASSERT(__n < size(), \"vector[] index out of bounds\");\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::reference\nvector<_Tp, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::const_reference\nvector<_Tp, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return this->__begin_[__n];\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__n, size(), __a);\n        __swap_out_circular_buffer(__v);\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(size(), size(), __a);\n            __swap_out_circular_buffer(__v);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _Up>\nvoid\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up&& __x)\n#else\nvector<_Tp, _Allocator>::__push_back_slow_path(_Up& __x)\n#endif\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n    // __v.push_back(_VSTD::forward<_Up>(__x));\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Up>(__x));\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (this->__end_ != this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_), __x);\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(__x);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(__x));\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __push_back_slow_path(_VSTD::move(__x));\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\nvector<_Tp, _Allocator>::__emplace_back_slow_path(_Args&&... __args)\n{\n    allocator_type& __a = this->__alloc();\n    __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), size(), __a);\n//    __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n    __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(__v.__end_), _VSTD::forward<_Args>(__args)...);\n    __v.__end_++;\n    __swap_out_circular_buffer(__v);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::forward<_Args>(__args)...);\n        __annotator.__done();\n        ++this->__end_;\n    }\n    else\n        __emplace_back_slow_path(_VSTD::forward<_Args>(__args)...);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"vector::pop_back called for empty vector\");\n    this->__destruct_at_end(this->__end_ - 1);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __position)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::erase(iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__position != end(),\n        \"vector::erase(iterator) called with a non-dereferenceable iterator\");\n    difference_type __ps = __position - cbegin();\n    pointer __p = this->__begin_ + __ps;\n    iterator __r = __make_iter(__p);\n    this->__destruct_at_end(_VSTD::move(__p + 1, this->__end_, __p));\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"vector::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"vector::erase(first, last) called with invalid range\");\n    pointer __p = this->__begin_ + (__first - begin());\n    iterator __r = __make_iter(__p);\n    if (__first != __last)\n        this->__destruct_at_end(_VSTD::move(__p + (__last - __first), this->__end_, __p));\n    return __r;\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::__move_range(pointer __from_s, pointer __from_e, pointer __to)\n{\n    pointer __old_last = this->__end_;\n    difference_type __n = __old_last - __to;\n    for (pointer __i = __from_s + __n; __i < __from_e; ++__i, ++this->__end_)\n        __alloc_traits::construct(this->__alloc(),\n                                  _VSTD::__to_raw_pointer(this->__end_),\n                                  _VSTD::move(*__i));\n    _VSTD::move_backward(__from_s, __from_s + __n, __old_last);\n}\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_), __x);\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n            if (__p <= __xr && __xr < this->__end_)\n                ++__xr;\n            *__p = *__xr;\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(__x);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, value_type&& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::move(__x));\n            ++this->__end_;\n        }\n        else\n        {\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__x);\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.push_back(_VSTD::move(__x));\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::emplace(const_iterator __position, _Args&&... __args)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::emplace(iterator, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (this->__end_ < this->__end_cap())\n    {\n        __RAII_IncreaseAnnotator __annotator(*this);\n        if (__p == this->__end_)\n        {\n            __alloc_traits::construct(this->__alloc(),\n                                      _VSTD::__to_raw_pointer(this->__end_),\n                                      _VSTD::forward<_Args>(__args)...);\n            ++this->__end_;\n        }\n        else\n        {\n            value_type __tmp(_VSTD::forward<_Args>(__args)...);\n            __move_range(__p, this->__end_, __p + 1);\n            *__p = _VSTD::move(__tmp);\n        }\n        __annotator.__done();\n    }\n    else\n    {\n        allocator_type& __a = this->__alloc();\n        __split_buffer<value_type, allocator_type&> __v(__recommend(size() + 1), __p - this->__begin_, __a);\n        __v.emplace_back(_VSTD::forward<_Args>(__args)...);\n        __p = __swap_out_circular_buffer(__v, __p);\n    }\n    return __make_iter(__p);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ntypename vector<_Tp, _Allocator>::iterator\nvector<_Tp, _Allocator>::insert(const_iterator __position, size_type __n, const_reference __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, n, x) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    if (__n > 0)\n    {\n        if (__n <= static_cast<size_type>(this->__end_cap() - this->__end_))\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            if (__n > static_cast<size_type>(this->__end_ - __p))\n            {\n                size_type __cx = __n - (this->__end_ - __p);\n                __construct_at_end(__cx, __x);\n                __n -= __cx;\n            }\n            if (__n > 0)\n            {\n                __RAII_IncreaseAnnotator __annotator(*this);\n                __move_range(__p, __old_last, __p + __old_n);\n                __annotator.__done();\n                const_pointer __xr = pointer_traits<const_pointer>::pointer_to(__x);\n                if (__p <= __xr && __xr < this->__end_)\n                    __xr += __old_n;\n                _VSTD::fill_n(__p, __n, *__xr);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__n, __x);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_InputIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    difference_type __off = __position - begin();\n    pointer __p = this->__begin_ + __off;\n    allocator_type& __a = this->__alloc();\n    pointer __old_last = this->__end_;\n    for (; this->__end_ != this->__end_cap() && __first != __last; ++__first)\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_),\n                                  *__first);\n        ++this->__end_;\n    }\n    __split_buffer<value_type, allocator_type&> __v(__a);\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.__construct_at_end(__first, __last);\n            difference_type __old_size = __old_last - this->__begin_;\n            difference_type __old_p = __p - this->__begin_;\n            reserve(__recommend(size() + __v.size()));\n            __p = this->__begin_ + __old_p;\n            __old_last = this->__begin_ + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__make_iter(__old_last), end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_last, this->__end_);\n    insert(__make_iter(__p), make_move_iterator(__v.begin()),\n                                    make_move_iterator(__v.end()));\n    return begin() + __off;\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value &&\n    is_constructible<\n       _Tp,\n       typename iterator_traits<_ForwardIterator>::reference>::value,\n    typename vector<_Tp, _Allocator>::iterator\n>::type\nvector<_Tp, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__position) == this,\n        \"vector::insert(iterator, range) called with an iterator not\"\n        \" referring to this vector\");\n#endif\n    pointer __p = this->__begin_ + (__position - begin());\n    difference_type __n = _VSTD::distance(__first, __last);\n    if (__n > 0)\n    {\n        if (__n <= this->__end_cap() - this->__end_)\n        {\n            size_type __old_n = __n;\n            pointer __old_last = this->__end_;\n            _ForwardIterator __m = __last;\n            difference_type __dx = this->__end_ - __p;\n            if (__n > __dx)\n            {\n                __m = __first;\n                _VSTD::advance(__m, this->__end_ - __p);\n                __construct_at_end(__m, __last);\n                __n = __dx;\n            }\n            if (__n > 0)\n            {\n                __RAII_IncreaseAnnotator __annotator(*this, __n);\n                __move_range(__p, __old_last, __p + __old_n);\n                __annotator.__done();\n                _VSTD::copy(__first, __m, __p);\n            }\n        }\n        else\n        {\n            allocator_type& __a = this->__alloc();\n            __split_buffer<value_type, allocator_type&> __v(__recommend(size() + __n), __p - this->__begin_, __a);\n            __v.__construct_at_end(__first, __last);\n            __p = __swap_out_circular_buffer(__v, __p);\n        }\n    }\n    return __make_iter(__p);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::resize(size_type __sz, const_reference __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n        this->__append(__sz - __cs, __x);\n    else if (__cs > __sz)\n        this->__destruct_at_end(this->__begin_ + __sz);\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\nvector<_Tp, _Allocator>::swap(vector& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n{\n    _LIBCPP_ASSERT(__alloc_traits::propagate_on_container_swap::value ||\n                   this->__alloc() == __x.__alloc(),\n                   \"vector::swap: Either propagate_on_container_swap must be true\"\n                   \" or the allocators must compare equal\");\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__end_, __x.__end_);\n    _VSTD::swap(this->__end_cap(), __x.__end_cap());\n    __base::__swap_alloc(this->__alloc(), __x.__alloc());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__x);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__end_ != nullptr || this->__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (this->__begin_ > this->__end_)\n            return false;\n        if (this->__begin_ == this->__end_cap())\n            return false;\n        if (this->__end_ > this->__end_cap())\n            return false;\n    }\n    return true;\n}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->__begin_ <= __i->base() && __i->base() < this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->__begin_ < __i->base() && __i->base() <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p <= this->__end_;\n}\n\ntemplate <class _Tp, class _Allocator>\nbool\nvector<_Tp, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const_pointer __p = __i->base() + __n;\n    return this->__begin_ <= __p && __p < this->__end_;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<_Tp, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\n// vector<bool>\n\ntemplate <class _Allocator> class vector<bool, _Allocator>;\n\ntemplate <class _Allocator> struct hash<vector<bool, _Allocator> >;\n\ntemplate <class _Allocator>\nstruct __has_storage_type<vector<bool, _Allocator> >\n{\n    static const bool value = true;\n};\n\ntemplate <class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY vector<bool, _Allocator>\n    : private __vector_base_common<true>\n{\npublic:\n    typedef vector                                   __self;\n    typedef bool                                     value_type;\n    typedef _Allocator                               allocator_type;\n    typedef allocator_traits<allocator_type>         __alloc_traits;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n    typedef size_type __storage_type;\n    typedef __bit_iterator<vector, false>            pointer;\n    typedef __bit_iterator<vector, true>             const_pointer;\n    typedef pointer                                  iterator;\n    typedef const_pointer                            const_iterator;\n    typedef _VSTD::reverse_iterator<iterator>         reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>   const_reverse_iterator;\n\nprivate:\n    typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                rebind_alloc<__storage_type>\n#else\n                rebind_alloc<__storage_type>::other\n#endif\n                                                     __storage_allocator;\n    typedef allocator_traits<__storage_allocator>    __storage_traits;\n    typedef typename __storage_traits::pointer       __storage_pointer;\n    typedef typename __storage_traits::const_pointer __const_storage_pointer;\n\n    __storage_pointer                                      __begin_;\n    size_type                                              __size_;\n    __compressed_pair<size_type, __storage_allocator> __cap_alloc_;\npublic:\n    typedef __bit_reference<vector>                  reference;\n    typedef __bit_const_reference<vector>            const_reference;\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    size_type& __cap() _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    const size_type& __cap() const _NOEXCEPT\n        {return __cap_alloc_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    __storage_allocator& __alloc() _NOEXCEPT\n        {return __cap_alloc_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const __storage_allocator& __alloc() const _NOEXCEPT\n        {return __cap_alloc_.second();}\n\n    static const unsigned __bits_per_word = static_cast<unsigned>(sizeof(__storage_type) * CHAR_BIT);\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __internal_cap_to_external(size_type __n) _NOEXCEPT\n        {return __n * __bits_per_word;}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __external_cap_to_internal(size_type __n) _NOEXCEPT\n        {return (__n - 1) / __bits_per_word + 1;}\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    vector()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY explicit vector(const allocator_type& __a);\n    ~vector();\n    explicit vector(size_type __n);\n#if _LIBCPP_STD_VER > 11\n    explicit vector(size_type __n, const allocator_type& __a);\n#endif\n    vector(size_type __n, const value_type& __v);\n    vector(size_type __n, const value_type& __v, const allocator_type& __a);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _InputIterator>\n        vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n               typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                                 !__is_forward_iterator<_InputIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n    template <class _ForwardIterator>\n        vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n               typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type* = 0);\n\n    vector(const vector& __v);\n    vector(const vector& __v, const allocator_type& __a);\n    vector& operator=(const vector& __v);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    vector(initializer_list<value_type> __il);\n    vector(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    vector(vector&& __v)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    vector(vector&& __v, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(vector&& __v)\n        _NOEXCEPT_(\n             __alloc_traits::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    vector& operator=(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end()); return *this;}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    template <class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value &&\n           !__is_forward_iterator<_InputIterator>::value,\n           void\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n           void\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n\n    void assign(size_type __n, const value_type& __x);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void assign(initializer_list<value_type> __il)\n        {assign(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(this->__alloc());}\n\n    size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type capacity() const _NOEXCEPT\n        {return __internal_cap_to_external(__cap());}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT\n        {return __size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool empty() const _NOEXCEPT\n        {return __size_ == 0;}\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()   const _NOEXCEPT\n        {return __make_iter(__size_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return       reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return       reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend()   const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cbegin()  const _NOEXCEPT\n        {return __make_iter(0);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator         cend()    const _NOEXCEPT\n        {return __make_iter(__size_);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend()   const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __n)       {return __make_ref(__n);}\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __n) const {return __make_ref(__n);}\n    reference       at(size_type __n);\n    const_reference at(size_type __n) const;\n\n    _LIBCPP_INLINE_VISIBILITY reference       front()       {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return __make_ref(0);}\n    _LIBCPP_INLINE_VISIBILITY reference       back()        {return __make_ref(__size_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back()  const {return __make_ref(__size_ - 1);}\n\n    void push_back(const value_type& __x);\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n    _LIBCPP_INLINE_VISIBILITY void emplace_back(_Args&&... __args)\n        { push_back ( value_type ( _VSTD::forward<_Args>(__args)... )); }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {--__size_;}\n\n#if _LIBCPP_STD_VER > 11\n    template <class... _Args>\n   _LIBCPP_INLINE_VISIBILITY iterator emplace(const_iterator position, _Args&&... __args)\n        { return insert ( position, value_type ( _VSTD::forward<_Args>(__args)... )); }\n#endif\n\n    iterator insert(const_iterator __position, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const value_type& __x);\n    iterator insert(const_iterator __position, size_type __n, const_reference __x);\n    template <class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _InputIterator __first, _InputIterator __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __position, initializer_list<value_type> __il)\n        {return insert(__position, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY iterator erase(const_iterator __position);\n    iterator erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__size_ = 0;}\n\n    void swap(vector&)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value);\n\n    void resize(size_type __sz, value_type __x = false);\n    void flip() _NOEXCEPT;\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    void allocate(size_type __n);\n    void deallocate() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __align_it(size_type __new_size) _NOEXCEPT\n        {return __new_size + (__bits_per_word-1) & ~((size_type)__bits_per_word-1);};\n    _LIBCPP_INLINE_VISIBILITY  size_type __recommend(size_type __new_size) const;\n    _LIBCPP_INLINE_VISIBILITY void __construct_at_end(size_type __n, bool __x);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n    void __append(size_type __n, const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY\n    reference __make_ref(size_type __pos) _NOEXCEPT\n        {return reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reference __make_ref(size_type __pos) const _NOEXCEPT\n        {return const_reference(__begin_ + __pos / __bits_per_word, __storage_type(1) << __pos % __bits_per_word);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __make_iter(size_type __pos) _NOEXCEPT\n        {return iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator __make_iter(size_type __pos) const _NOEXCEPT\n        {return const_iterator(__begin_ + __pos / __bits_per_word, static_cast<unsigned>(__pos % __bits_per_word));}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator __const_iterator_cast(const_iterator __p) _NOEXCEPT\n        {return begin() + (__p - cbegin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __v)\n        {__copy_assign_alloc(__v, integral_constant<bool,\n                      __storage_traits::propagate_on_container_copy_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector& __c, true_type)\n        {\n            if (__alloc() != __c.__alloc())\n                deallocate();\n            __alloc() = __c.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const vector&, false_type)\n        {}\n\n    void __move_assign(vector& __c, false_type);\n    void __move_assign(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c)\n        _NOEXCEPT_(\n            !__storage_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n        {__move_assign_alloc(__c, integral_constant<bool,\n                      __storage_traits::propagate_on_container_move_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(vector&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__storage_allocator& __x, __storage_allocator& __y)\n        _NOEXCEPT_(\n            !__storage_traits::propagate_on_container_swap::value ||\n            __is_nothrow_swappable<allocator_type>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __storage_traits::propagate_on_container_swap::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__storage_allocator& __x, __storage_allocator& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<allocator_type>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__storage_allocator&, __storage_allocator&, false_type)\n        _NOEXCEPT\n        {}\n\n    size_t __hash_code() const _NOEXCEPT;\n\n    friend class __bit_reference<vector>;\n    friend class __bit_const_reference<vector>;\n    friend class __bit_iterator<vector, false>;\n    friend class __bit_iterator<vector, true>;\n    friend struct __bit_array<vector>;\n    friend struct _LIBCPP_TYPE_VIS_ONLY hash<vector>;\n};\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__invalidate_all_iterators()\n{\n}\n\n//  Allocate space for __n objects\n//  throws length_error if __n > max_size()\n//  throws (probably bad_alloc) if memory run out\n//  Precondition:  __begin_ == __end_ == __cap() == 0\n//  Precondition:  __n > 0\n//  Postcondition:  capacity() == __n\n//  Postcondition:  size() == 0\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::allocate(size_type __n)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    __n = __external_cap_to_internal(__n);\n    this->__begin_ = __storage_traits::allocate(this->__alloc(), __n);\n    this->__size_ = 0;\n    this->__cap() = __n;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::deallocate() _NOEXCEPT\n{\n    if (this->__begin_ != nullptr)\n    {\n        __storage_traits::deallocate(this->__alloc(), this->__begin_, __cap());\n        __invalidate_all_iterators();\n        this->__begin_ = nullptr;\n        this->__size_ = this->__cap() = 0;\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __amax = __storage_traits::max_size(__alloc());\n    size_type __nmax = numeric_limits<size_type>::max() / 2;  // end() >= begin(), always\n    if (__nmax / __bits_per_word <= __amax)\n        return __nmax;\n    return __internal_cap_to_external(__amax);\n}\n\n//  Precondition:  __new_size > capacity()\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::size_type\nvector<bool, _Allocator>::__recommend(size_type __new_size) const\n{\n    const size_type __ms = max_size();\n    if (__new_size > __ms)\n        this->__throw_length_error();\n    const size_type __cap = capacity();\n    if (__cap >= __ms / 2)\n        return __ms;\n    return _VSTD::max(2*__cap, __align_it(__new_size));\n}\n\n//  Default constructs __n objects starting at __end_\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nvector<bool, _Allocator>::__construct_at_end(size_type __n, bool __x)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += __n;\n    _VSTD::fill_n(__make_iter(__old_size), __n, __x);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nvector<bool, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __old_size = this->__size_;\n    this->__size_ += _VSTD::distance(__first, __last);\n    _VSTD::copy(__first, __last, __make_iter(__old_size));\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, false);\n    }\n}\n#endif\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(size_type __n, const value_type& __x, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__n, __x);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\nvector<bool, _Allocator>::vector(_InputIterator __first, _InputIterator __last, const allocator_type& __a,\n       typename enable_if<__is_input_iterator  <_InputIterator>::value &&\n                         !__is_forward_iterator<_InputIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        for (; __first != __last; ++__first)\n            push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__begin_ != nullptr)\n            __storage_traits::deallocate(__alloc(), __begin_, __cap());\n        __invalidate_all_iterators();\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\nvector<bool, _Allocator>::vector(_ForwardIterator __first, _ForwardIterator __last, const allocator_type& __a,\n                                typename enable_if<__is_forward_iterator<_ForwardIterator>::value>::type*)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__first, __last);\n    }\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0)\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(initializer_list<value_type> __il, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, static_cast<__storage_allocator>(__a))\n{\n    size_type __n = static_cast<size_type>(__il.size());\n    if (__n > 0)\n    {\n        allocate(__n);\n        __construct_at_end(__il.begin(), __il.end());\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::~vector()\n{\n    if (__begin_ != nullptr)\n        __storage_traits::deallocate(__alloc(), __begin_, __cap());\n    __invalidate_all_iterators();\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __storage_traits::select_on_container_copy_construction(__v.__alloc()))\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(const vector& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(const vector& __v)\n{\n    if (this != &__v)\n    {\n        __copy_assign_alloc(__v);\n        if (__v.__size_)\n        {\n            if (__v.__size_ > capacity())\n            {\n                deallocate();\n                allocate(__v.__size_);\n            }\n            _VSTD::copy(__v.__begin_, __v.__begin_ + __external_cap_to_internal(__v.__size_), __begin_);\n        }\n        __size_ = __v.__size_;\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>::vector(vector&& __v)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __begin_(__v.__begin_),\n      __size_(__v.__size_),\n      __cap_alloc_(__v.__cap_alloc_)\n{\n    __v.__begin_ = nullptr;\n    __v.__size_ = 0;\n    __v.__cap() = 0;\n}\n\ntemplate <class _Allocator>\nvector<bool, _Allocator>::vector(vector&& __v, const allocator_type& __a)\n    : __begin_(nullptr),\n      __size_(0),\n      __cap_alloc_(0, __a)\n{\n    if (__a == allocator_type(__v.__alloc()))\n    {\n        this->__begin_ = __v.__begin_;\n        this->__size_ = __v.__size_;\n        this->__cap() = __v.__cap();\n        __v.__begin_ = nullptr;\n        __v.__cap() = __v.__size_ = 0;\n    }\n    else if (__v.size() > 0)\n    {\n        allocate(__v.size());\n        __construct_at_end(__v.begin(), __v.end());\n    }\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvector<bool, _Allocator>&\nvector<bool, _Allocator>::operator=(vector&& __v)\n        _NOEXCEPT_(\n             __alloc_traits::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value)\n{\n    __move_assign(__v, integral_constant<bool,\n          __storage_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, false_type)\n{\n    if (__alloc() != __c.__alloc())\n        assign(__c.begin(), __c.end());\n    else\n        __move_assign(__c, true_type());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::__move_assign(vector& __c, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    deallocate();\n    __move_assign_alloc(__c);\n    this->__begin_ = __c.__begin_;\n    this->__size_ = __c.__size_;\n    this->__cap() = __c.__cap();\n    __c.__begin_ = nullptr;\n    __c.__cap() = __c.__size_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::assign(size_type __n, const value_type& __x)\n{\n    __size_ = 0;\n    if (__n > 0)\n    {\n        size_type __c = capacity();\n        if (__n <= __c)\n            __size_ = __n;\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__n));\n            __v.__size_ = __n;\n            swap(__v);\n        }\n        _VSTD::fill_n(begin(), __n, __x);\n    }\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_forward_iterator<_InputIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n   void\n>::type\nvector<bool, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    clear();\n    difference_type __n = _VSTD::distance(__first, __last);\n    if (__n)\n    {\n        if (__n > capacity())\n        {\n            deallocate();\n            allocate(__n);\n        }\n        __construct_at_end(__first, __last);\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::reserve(size_type __n)\n{\n    if (__n > capacity())\n    {\n        vector __v(this->__alloc());\n        __v.allocate(__n);\n        __v.__construct_at_end(this->begin(), this->end());\n        swap(__v);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (__external_cap_to_internal(size()) > __cap())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            vector(*this, allocator_type(__alloc())).swap(*this);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::reference\nvector<bool, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::const_reference\nvector<bool, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::push_back(const value_type& __x)\n{\n    if (this->__size_ == this->capacity())\n        reserve(__recommend(this->__size_ + 1));\n    ++this->__size_;\n    back() = __x;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, const value_type& __x)\n{\n    iterator __r;\n    if (size() < capacity())\n    {\n        const_iterator __old_end = end();\n        ++__size_;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + 1));\n        __v.__size_ = __size_ + 1;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    *__r = __x;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::insert(const_iterator __position, size_type __n, const value_type& __x)\n{\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::fill_n(__r, __n, __x);\n    return __r;\n}\n\ntemplate <class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _InputIterator __first, _InputIterator __last)\n{\n    difference_type __off = __position - begin();\n    iterator __p = __const_iterator_cast(__position);\n    iterator __old_end = end();\n    for (; size() != capacity() && __first != __last; ++__first)\n    {\n        ++this->__size_;\n        back() = *__first;\n    }\n    vector __v(__alloc());\n    if (__first != __last)\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __v.assign(__first, __last);\n            difference_type __old_size = static_cast<difference_type>(__old_end - begin());\n            difference_type __old_p = __p - begin();\n            reserve(__recommend(size() + __v.size()));\n            __p = begin() + __old_p;\n            __old_end = begin() + __old_size;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            erase(__old_end, end());\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n    __p = _VSTD::rotate(__p, __old_end, end());\n    insert(__p, __v.begin(), __v.end());\n    return begin() + __off;\n}\n\ntemplate <class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    typename vector<bool, _Allocator>::iterator\n>::type\nvector<bool, _Allocator>::insert(const_iterator __position, _ForwardIterator __first, _ForwardIterator __last)\n{\n    difference_type __n = _VSTD::distance(__first, __last);\n    iterator __r;\n    size_type __c = capacity();\n    if (__n <= __c && size() <= __c - __n)\n    {\n        const_iterator __old_end = end();\n        __size_ += __n;\n        _VSTD::copy_backward(__position, __old_end, end());\n        __r = __const_iterator_cast(__position);\n    }\n    else\n    {\n        vector __v(__alloc());\n        __v.reserve(__recommend(__size_ + __n));\n        __v.__size_ = __size_ + __n;\n        __r = _VSTD::copy(cbegin(), __position, __v.begin());\n        _VSTD::copy_backward(__position, cend(), __v.end());\n        swap(__v);\n    }\n    _VSTD::copy(__first, __last, __r);\n    return __r;\n}\n\ntemplate <class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __position)\n{\n    iterator __r = __const_iterator_cast(__position);\n    _VSTD::copy(__position + 1, this->cend(), __r);\n    --__size_;\n    return __r;\n}\n\ntemplate <class _Allocator>\ntypename vector<bool, _Allocator>::iterator\nvector<bool, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n    iterator __r = __const_iterator_cast(__first);\n    difference_type __d = __last - __first;\n    _VSTD::copy(__last, this->cend(), __r);\n    __size_ -= __d;\n    return __r;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::swap(vector& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n{\n    _VSTD::swap(this->__begin_, __x.__begin_);\n    _VSTD::swap(this->__size_, __x.__size_);\n    _VSTD::swap(this->__cap(), __x.__cap());\n    __swap_alloc(this->__alloc(), __x.__alloc());\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::resize(size_type __sz, value_type __x)\n{\n    size_type __cs = size();\n    if (__cs < __sz)\n    {\n        iterator __r;\n        size_type __c = capacity();\n        size_type __n = __sz - __cs;\n        if (__n <= __c && __cs <= __c - __n)\n        {\n            __r = end();\n            __size_ += __n;\n        }\n        else\n        {\n            vector __v(__alloc());\n            __v.reserve(__recommend(__size_ + __n));\n            __v.__size_ = __size_ + __n;\n            __r = _VSTD::copy(cbegin(), cend(), __v.begin());\n            swap(__v);\n        }\n        _VSTD::fill_n(__r, __n, __x);\n    }\n    else\n        __size_ = __sz;\n}\n\ntemplate <class _Allocator>\nvoid\nvector<bool, _Allocator>::flip() _NOEXCEPT\n{\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        *__p = ~*__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __storage_type __b = *__p & __m;\n        *__p &= ~__m;\n        *__p |= ~__b & __m;\n    }\n}\n\ntemplate <class _Allocator>\nbool\nvector<bool, _Allocator>::__invariants() const\n{\n    if (this->__begin_ == nullptr)\n    {\n        if (this->__size_ != 0 || this->__cap() != 0)\n            return false;\n    }\n    else\n    {\n        if (this->__cap() == 0)\n            return false;\n        if (this->__size_ > this->capacity())\n            return false;\n    }\n    return true;\n}\n\ntemplate <class _Allocator>\nsize_t\nvector<bool, _Allocator>::__hash_code() const _NOEXCEPT\n{\n    size_t __h = 0;\n    // do middle whole words\n    size_type __n = __size_;\n    __storage_pointer __p = __begin_;\n    for (; __n >= __bits_per_word; ++__p, __n -= __bits_per_word)\n        __h ^= *__p;\n    // do last partial word\n    if (__n > 0)\n    {\n        const __storage_type __m = ~__storage_type(0) >> (__bits_per_word - __n);\n        __h ^= *__p & __m;\n    }\n    return __h;\n}\n\ntemplate <class _Allocator>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<vector<bool, _Allocator> >\n    : public unary_function<vector<bool, _Allocator>, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const vector<bool, _Allocator>& __vec) const _NOEXCEPT\n        {return __vec.__hash_code();}\n};\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    const typename vector<_Tp, _Allocator>::size_type __sz = __x.size();\n    return __sz == __y.size() && _VSTD::equal(__x.begin(), __x.end(), __y.begin());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return _VSTD::lexicographical_compare(__x.begin(), __x.end(), __y.begin(), __y.end());\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const vector<_Tp, _Allocator>& __x, const vector<_Tp, _Allocator>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(vector<_Tp, _Allocator>& __x, vector<_Tp, _Allocator>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_VECTOR\n","// Voro++, a 3D cell-based Voronoi library\n//\n// Author   : Chris H. Rycroft (LBL / UC Berkeley)\n// Email    : chr@alum.mit.edu\n// Date     : August 30th 2011\n\n/** \\file container.hh\n * \\brief Header file for the container_base and related classes. */\n\n#ifndef VOROPP_CONTAINER_HH\n#define VOROPP_CONTAINER_HH\n\n#include <cstdio>\n#include <vector>\n\n#include \"config.hh\"\n#include \"common.hh\"\n#include \"v_base.hh\"\n#include \"cell.hh\"\n#include \"c_loops.hh\"\n#include \"v_compute.hh\"\n#include \"rad_option.hh\"\n\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n\nnamespace voro {\n\n/** \\brief Pure virtual class from which wall objects are derived.\n *\n * This is a pure virtual class for a generic wall object. A wall object\n * can be specified by deriving a new class from this and specifying the\n * functions.*/\nclass wall {\n\tpublic:\n\t\tvirtual ~wall() {}\n\t\t/** A pure virtual function for testing whether a point is\n\t\t * inside the wall object. */\n\t\tvirtual bool point_inside(double x,double y,double z) = 0;\n\t\t/** A pure virtual function for cutting a cell without\n\t\t * neighbor-tracking with a wall. */\n\t\tvirtual bool cut_cell(voronoicell &c,double x,double y,double z) = 0;\n\t\t/** A pure virtual function for cutting a cell with\n\t\t * neighbor-tracking enabled with a wall. */\n\t\tvirtual bool cut_cell(voronoicell_neighbor &c,double x,double y,double z) = 0;\n};\n\n/** \\brief A class for storing a list of pointers to walls.\n *\n * This class stores a list of pointers to wall classes. It contains several\n * simple routines that make use of the wall classes (such as telling whether a\n * given position is inside all of the walls or not). It can be used by itself,\n * but also forms part of container_base, for associating walls with this\n * class. */\nclass wall_list {\n\tpublic:\n\t\t/** An array holding pointers to wall objects. */\n\t\twall **walls;\n\t\t/** A pointer to the next free position to add a wall pointer.\n\t\t */\n\t\twall **wep;\n\t\twall_list();\n\t\t~wall_list();\n\t\t/** Adds a wall to the list.\n\t\t * \\param[in] w the wall to add. */\n\t\tinline void add_wall(wall *w) {\n\t\t\tif(wep==wel) increase_wall_memory();\n\t\t\t*(wep++)=w;\n\t\t}\n\t\t/** Adds a wall to the list.\n\t\t * \\param[in] w a reference to the wall to add. */\n\t\tinline void add_wall(wall &w) {add_wall(&w);}\n\t\tvoid add_wall(wall_list &wl);\n\t\t/** Determines whether a given position is inside all of the\n\t\t * walls on the list.\n\t\t * \\param[in] (x,y,z) the position to test.\n\t\t * \\return True if it is inside, false if it is outside. */\n\t\tinline bool point_inside_walls(double x,double y,double z) {\n\t\t\tfor(wall **wp=walls;wp<wep;wp++) if(!((*wp)->point_inside(x,y,z))) return false;\n\t\t\treturn true;\n\t\t}\n\t\t/** Cuts a Voronoi cell by all of the walls currently on\n\t\t * the list.\n\t\t * \\param[in] c a reference to the Voronoi cell class.\n\t\t * \\param[in] (x,y,z) the position of the cell.\n\t\t * \\return True if the cell still exists, false if the cell is\n\t\t * deleted. */\n\t\ttemplate<class c_class>\n\t\tbool apply_walls(c_class &c,double x,double y,double z) {\n\t\t\tfor(wall **wp=walls;wp<wep;wp++) if(!((*wp)->cut_cell(c,x,y,z))) return false;\n\t\t\treturn true;\n\t\t}\n\t\tvoid deallocate();\n\tprotected:\n\t\tvoid increase_wall_memory();\n\t\t/** A pointer to the limit of the walls array, used to\n\t\t * determine when array is full. */\n\t\twall **wel;\n\t\t/** The current amount of memory allocated for walls. */\n\t\tint current_wall_size;\n};\n\n/** \\brief Class for representing a particle system in a three-dimensional\n * rectangular box.\n *\n * This class represents a system of particles in a three-dimensional\n * rectangular box. Any combination of non-periodic and periodic coordinates\n * can be used in the three coordinate directions. The class is not intended\n * for direct use, but instead forms the base of the container and\n * container_poly classes that add specialized routines for computing the\n * regular and radical Voronoi tessellations respectively. It contains routines\n * that are commonly between these two classes, such as those for drawing the\n * domain, and placing particles within the internal data structure.\n *\n * The class is derived from the wall_list class, which encapsulates routines\n * for associating walls with the container, and the voro_base class, which\n * encapsulates routines about the underlying computational grid. */\nclass container_base : public voro_base, public wall_list {\n\tpublic:\n\t\t/** The minimum x coordinate of the container. */\n\t\tconst double ax;\n\t\t/** The maximum x coordinate of the container. */\n\t\tconst double bx;\n\t\t/** The minimum y coordinate of the container. */\n\t\tconst double ay;\n\t\t/** The maximum y coordinate of the container. */\n\t\tconst double by;\n\t\t/** The minimum z coordinate of the container. */\n\t\tconst double az;\n\t\t/** The maximum z coordinate of the container. */\n\t\tconst double bz;\n\t\t/** A boolean value that determines if the x coordinate in\n\t\t * periodic or not. */\n\t\tconst bool xperiodic;\n\t\t/** A boolean value that determines if the y coordinate in\n\t\t * periodic or not. */\n\t\tconst bool yperiodic;\n\t\t/** A boolean value that determines if the z coordinate in\n\t\t * periodic or not. */\n\t\tconst bool zperiodic;\n\t\t/** This array holds the numerical IDs of each particle in each\n\t\t * computational box. */\n\t\tint **id;\n\t\t/** A two dimensional array holding particle positions. For the\n\t\t * derived container_poly class, this also holds particle\n\t\t * radii. */\n\t\tdouble **p;\n\t\t/** This array holds the number of particles within each\n\t\t * computational box of the container. */\n\t\tint *co;\n\t\t/** This array holds the maximum amount of particle memory for\n\t\t * each computational box of the container. If the number of\n\t\t * particles in a particular box ever approaches this limit,\n\t\t * more is allocated using the add_particle_memory() function.\n\t\t */\n\t\tint *mem;\n\t\t/** The amount of memory in the array structure for each\n\t\t * particle. This is set to 3 when the basic class is\n\t\t * initialized, so that the array holds (x,y,z) positions. If\n\t\t * the container class is initialized as part of the derived\n\t\t * class container_poly, then this is set to 4, to also hold\n\t\t * the particle radii. */\n\t\tconst int ps;\n\t\tcontainer_base(double ax_,double bx_,double ay_,double by_,double az_,double bz_,\n\t\t\t\tint nx_,int ny_,int nz_,bool xperiodic_,bool yperiodic_,bool zperiodic_,\n\t\t\t\tint init_mem,int ps_);\n\t\t~container_base();\n\t\tbool point_inside(double x,double y,double z);\n\t\tvoid region_count();\n\t\t/** Initializes the Voronoi cell prior to a compute_cell\n\t\t * operation for a specific particle being carried out by a\n\t\t * voro_compute class. The cell is initialized to fill the\n\t\t * entire container. For non-periodic coordinates, this is set\n\t\t * by the position of the walls. For periodic coordinates, the\n\t\t * space is equally divided in either direction from the\n\t\t * particle's initial position. Plane cuts made by any walls\n\t\t * that have been added are then applied to the cell.\n\t\t * \\param[in,out] c a reference to a voronoicell object.\n\t\t * \\param[in] ijk the block that the particle is within.\n\t\t * \\param[in] q the index of the particle within its block.\n\t\t * \\param[in] (ci,cj,ck) the coordinates of the block in the\n\t\t * \t\t\t container coordinate system.\n\t\t * \\param[out] (i,j,k) the coordinates of the test block\n\t\t * \t\t       relative to the voro_compute\n\t\t * \t\t       coordinate system.\n\t\t * \\param[out] (x,y,z) the position of the particle.\n\t\t * \\param[out] disp a block displacement used internally by the\n\t\t *\t\t    compute_cell routine.\n\t\t * \\return False if the plane cuts applied by walls completely\n\t\t * removed the cell, true otherwise. */\n\t\ttemplate<class v_cell>\n\t\tinline bool initialize_voronoicell(v_cell &c,int ijk,int q,int ci,int cj,int ck,\n\t\t\t\tint &i,int &j,int &k,double &x,double &y,double &z,int &disp) {\n\t\t\tdouble x1,x2,y1,y2,z1,z2,*pp=p[ijk]+ps*q;\n\t\t\tx=*(pp++);y=*(pp++);z=*pp;\n\t\t\tif(xperiodic) {x1=-(x2=0.5*(bx-ax));i=nx;} else {x1=ax-x;x2=bx-x;i=ci;}\n\t\t\tif(yperiodic) {y1=-(y2=0.5*(by-ay));j=ny;} else {y1=ay-y;y2=by-y;j=cj;}\n\t\t\tif(zperiodic) {z1=-(z2=0.5*(bz-az));k=nz;} else {z1=az-z;z2=bz-z;k=ck;}\n\t\t\tc.init(x1,x2,y1,y2,z1,z2);\n\t\t\tif(!apply_walls(c,x,y,z)) return false;\n\t\t\tdisp=ijk-i-nx*(j+ny*k);\n\t\t\treturn true;\n\t\t}\n\t\t/** Initializes parameters for a find_voronoi_cell call within\n\t\t * the voro_compute template.\n\t\t * \\param[in] (ci,cj,ck) the coordinates of the test block in\n\t\t * \t\t\t the container coordinate system.\n\t\t * \\param[in] ijk the index of the test block\n\t\t * \\param[out] (i,j,k) the coordinates of the test block\n\t\t * \t\t       relative to the voro_compute\n\t\t * \t\t       coordinate system.\n\t\t * \\param[out] disp a block displacement used internally by the\n\t\t *\t\t    find_voronoi_cell routine. */\n\t\tinline void initialize_search(int ci,int cj,int ck,int ijk,int &i,int &j,int &k,int &disp) {\n\t\t\ti=xperiodic?nx:ci;\n\t\t\tj=yperiodic?ny:cj;\n\t\t\tk=zperiodic?nz:ck;\n\t\t\tdisp=ijk-i-nx*(j+ny*k);\n\t\t}\n\t\t/** Returns the position of a particle currently being computed\n\t\t * relative to the computational block that it is within. It is\n\t\t * used to select the optimal worklist entry to use.\n\t\t * \\param[in] (x,y,z) the position of the particle.\n\t\t * \\param[in] (ci,cj,ck) the block that the particle is within.\n\t\t * \\param[out] (fx,fy,fz) the position relative to the block.\n\t\t */\n\t\tinline void frac_pos(double x,double y,double z,double ci,double cj,double ck,\n\t\t\t\tdouble &fx,double &fy,double &fz) {\n\t\t\tfx=x-ax-boxx*ci;\n\t\t\tfy=y-ay-boxy*cj;\n\t\t\tfz=z-az-boxz*ck;\n\t\t}\n\t\t/** Calculates the index of block in the container structure\n\t\t * corresponding to given coordinates.\n\t\t * \\param[in] (ci,cj,ck) the coordinates of the original block\n\t\t * \t\t\t in the current computation, relative\n\t\t * \t\t\t to the container coordinate system.\n\t\t * \\param[in] (ei,ej,ek) the displacement of the current block\n\t\t * \t\t\t from the original block.\n\t\t * \\param[in,out] (qx,qy,qz) the periodic displacement that\n\t\t * \t\t\t     must be added to the particles\n\t\t * \t\t\t     within the computed block.\n\t\t * \\param[in] disp a block displacement used internally by the\n\t\t * \t\t    find_voronoi_cell and compute_cell routines.\n\t\t * \\return The block index. */\n\t\tinline int region_index(int ci,int cj,int ck,int ei,int ej,int ek,double &qx,double &qy,double &qz,int &disp) {\n\t\t\tif(xperiodic) {if(ci+ei<nx) {ei+=nx;qx=-(bx-ax);} else if(ci+ei>=(nx<<1)) {ei-=nx;qx=bx-ax;} else qx=0;}\n\t\t\tif(yperiodic) {if(cj+ej<ny) {ej+=ny;qy=-(by-ay);} else if(cj+ej>=(ny<<1)) {ej-=ny;qy=by-ay;} else qy=0;}\n\t\t\tif(zperiodic) {if(ck+ek<nz) {ek+=nz;qz=-(bz-az);} else if(ck+ek>=(nz<<1)) {ek-=nz;qz=bz-az;} else qz=0;}\n\t\t\treturn disp+ei+nx*(ej+ny*ek);\n\t\t}\n\t\tvoid draw_domain_gnuplot(FILE *fp=stdout);\n\t\t/** Draws an outline of the domain in Gnuplot format.\n\t\t * \\param[in] filename the filename to write to. */\n\t\tinline void draw_domain_gnuplot(const char* filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"w\");\n\t\t\tdraw_domain_gnuplot(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\tvoid draw_domain_pov(FILE *fp=stdout);\n\t\t/** Draws an outline of the domain in Gnuplot format.\n\t\t * \\param[in] filename the filename to write to. */\n\t\tinline void draw_domain_pov(const char* filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"w\");\n\t\t\tdraw_domain_pov(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\t/** Sums up the total number of stored particles.\n\t\t * \\return The number of particles. */\n\t\tinline int total_particles() {\n\t\t\tint tp=*co;\n\t\t\tfor(int *cop=co+1;cop<co+nxyz;cop++) tp+=*cop;\n\t\t\treturn tp;\n\t\t}\n        bool already_in_block(double x, double y, double z, double threshold, int except_cell=-1); // checks if pt w/ these coords is already in the same block\n    \n\tprotected:\n\t\tvoid add_particle_memory(int i);\n\t\tbool put_locate_block(int &ijk,double &x,double &y,double &z);\n\t\tinline bool put_remap(int &ijk,double &x,double &y,double &z);\n\t\tinline bool remap(int &ai,int &aj,int &ak,int &ci,int &cj,int &ck,double &x,double &y,double &z,int &ijk);\n};\n\n/** \\brief Extension of the container_base class for computing regular Voronoi\n * tessellations.\n *\n * This class is an extension of the container_base class that has routines\n * specifically for computing the regular Voronoi tessellation with no\n * dependence on particle radii. */\nclass container : public container_base, public radius_mono {\n\tpublic:\n\t\tcontainer(double ax_,double bx_,double ay_,double by_,double az_,double bz_,\n\t\t\t\tint nx_,int ny_,int nz_,bool xperiodic_,bool yperiodic_,bool zperiodic_,int init_mem);\n\t\tvoid clear();\n\t\tvoid put(int n,double x,double y,double z);\n        bool put(int n,double x,double y,double z,int &ijk,int &q);\n\t\tvoid put(particle_order &vo,int n,double x,double y,double z);\n        int swapnpop(int ijk, int q);\n        int move(int &ijk, int &q, int n, double x, double y, double z, int &needsupdate_q);\n\t\tvoid import(FILE *fp=stdin);\n\t\tvoid import(particle_order &vo,FILE *fp=stdin);\n\t\t/** Imports a list of particles from an open file stream into\n\t\t * the container. Entries of four numbers (Particle ID, x\n\t\t * position, y position, z position) are searched for. If the\n\t\t * file cannot be successfully read, then the routine causes a\n\t\t * fatal error.\n\t\t * \\param[in] filename the name of the file to open and read\n\t\t *                     from. */\n\t\tinline void import(const char* filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"r\");\n\t\t\timport(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\t/** Imports a list of particles from an open file stream into\n\t\t * the container. Entries of four numbers (Particle ID, x\n\t\t * position, y position, z position) are searched for. In\n\t\t * addition, the order in which particles are read is saved\n\t\t * into an ordering class. If the file cannot be successfully\n\t\t * read, then the routine causes a fatal error.\n\t\t * \\param[in,out] vo the ordering class to use.\n\t\t * \\param[in] filename the name of the file to open and read\n\t\t *                     from. */\n\t\tinline void import(particle_order &vo,const char* filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"r\");\n\t\t\timport(vo,fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\tvoid compute_all_cells();\n\t\tdouble sum_cell_volumes();\n\t\t/** Dumps particle IDs and positions to a file.\n\t\t * \\param[in] vl the loop class to use.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\ttemplate<class c_loop>\n\t\tvoid draw_particles(c_loop &vl,FILE *fp) {\n\t\t\tdouble *pp;\n\t\t\tif(vl.start()) do {\n\t\t\t\tpp=p[vl.ijk]+3*vl.q;\n\t\t\t\tfprintf(fp,\"%d %g %g %g\\n\",id[vl.ijk][vl.q],*pp,pp[1],pp[2]);\n\t\t\t} while(vl.inc());\n\t\t}\n\t\t/** Dumps all of the particle IDs and positions to a file.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\tinline void draw_particles(FILE *fp=stdout) {\n\t\t\tc_loop_all vl(*this);\n\t\t\tdraw_particles(vl,fp);\n\t\t}\n\t\t/** Dumps all of the particle IDs and positions to a file.\n\t\t * \\param[in] filename the name of the file to write to. */\n\t\tinline void draw_particles(const char *filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"w\");\n\t\t\tdraw_particles(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\t/** Dumps particle positions in POV-Ray format.\n\t\t * \\param[in] vl the loop class to use.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\ttemplate<class c_loop>\n\t\tvoid draw_particles_pov(c_loop &vl,FILE *fp) {\n\t\t\tdouble *pp;\n\t\t\tif(vl.start()) do {\n\t\t\t\tpp=p[vl.ijk]+3*vl.q;\n\t\t\t\tfprintf(fp,\"// id %d\\nsphere{<%g,%g,%g>,s}\\n\",\n\t\t\t\t\t\tid[vl.ijk][vl.q],*pp,pp[1],pp[2]);\n\t\t\t} while(vl.inc());\n\t\t}\n\t\t/** Dumps all particle positions in POV-Ray format.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\tinline void draw_particles_pov(FILE *fp=stdout) {\n\t\t\tc_loop_all vl(*this);\n\t\t\tdraw_particles_pov(vl,fp);\n\t\t}\n\t\t/** Dumps all particle positions in POV-Ray format.\n\t\t * \\param[in] filename the name of the file to write to. */\n\t\tinline void draw_particles_pov(const char *filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"w\");\n\t\t\tdraw_particles_pov(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\t/** Computes Voronoi cells and saves the output in gnuplot\n\t\t * format.\n\t\t * \\param[in] vl the loop class to use.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\ttemplate<class c_loop>\n\t\tvoid draw_cells_gnuplot(c_loop &vl,FILE *fp) {\n\t\t\tvoronoicell c;double *pp;\n\t\t\tif(vl.start()) do if(compute_cell(c,vl)) {\n\t\t\t\tpp=p[vl.ijk]+ps*vl.q;\n\t\t\t\tc.draw_gnuplot(*pp,pp[1],pp[2],fp);\n\t\t\t} while(vl.inc());\n\t\t}\n\t\t/** Computes all Voronoi cells and saves the output in gnuplot\n\t\t * format.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\tinline void draw_cells_gnuplot(FILE *fp=stdout) {\n\t\t\tc_loop_all vl(*this);\n\t\t\tdraw_cells_gnuplot(vl,fp);\n\t\t}\n\t\t/** Computes all Voronoi cells and saves the output in gnuplot\n\t\t * format.\n\t\t * \\param[in] filename the name of the file to write to. */\n\t\tinline void draw_cells_gnuplot(const char *filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"w\");\n\t\t\tdraw_cells_gnuplot(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\t/** Computes Voronoi cells and saves the output in POV-Ray\n\t\t * format.\n\t\t * \\param[in] vl the loop class to use.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\ttemplate<class c_loop>\n\t\tvoid draw_cells_pov(c_loop &vl,FILE *fp) {\n\t\t\tvoronoicell c;double *pp;\n\t\t\tif(vl.start()) do if(compute_cell(c,vl)) {\n\t\t\t\tfprintf(fp,\"// cell %d\\n\",id[vl.ijk][vl.q]);\n\t\t\t\tpp=p[vl.ijk]+ps*vl.q;\n\t\t\t\tc.draw_pov(*pp,pp[1],pp[2],fp);\n\t\t\t} while(vl.inc());\n\t\t}\n\t\t/** Computes all Voronoi cells and saves the output in POV-Ray\n\t\t * format.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\tinline void draw_cells_pov(FILE *fp=stdout) {\n\t\t\tc_loop_all vl(*this);\n\t\t\tdraw_cells_pov(vl,fp);\n\t\t}\n\t\t/** Computes all Voronoi cells and saves the output in POV-Ray\n\t\t * format.\n\t\t * \\param[in] filename the name of the file to write to. */\n\t\tinline void draw_cells_pov(const char *filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"w\");\n\t\t\tdraw_cells_pov(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\t/** Computes the Voronoi cells and saves customized information\n\t\t * about them.\n\t\t * \\param[in] vl the loop class to use.\n\t\t * \\param[in] format the custom output string to use.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\ttemplate<class c_loop>\n\t\tvoid print_custom(c_loop &vl,const char *format,FILE *fp) {\n\t\t\tint ijk,q;double *pp;\n\t\t\tif(contains_neighbor(format)) {\n\t\t\t\tvoronoicell_neighbor c;\n\t\t\t\tif(vl.start()) do if(compute_cell(c,vl)) {\n\t\t\t\t\tijk=vl.ijk;q=vl.q;pp=p[ijk]+ps*q;\n\t\t\t\t\tc.output_custom(format,id[ijk][q],*pp,pp[1],pp[2],default_radius,fp);\n\t\t\t\t} while(vl.inc());\n\t\t\t} else {\n\t\t\t\tvoronoicell c;\n\t\t\t\tif(vl.start()) do if(compute_cell(c,vl)) {\n\t\t\t\t\tijk=vl.ijk;q=vl.q;pp=p[ijk]+ps*q;\n\t\t\t\t\tc.output_custom(format,id[ijk][q],*pp,pp[1],pp[2],default_radius,fp);\n\t\t\t\t} while(vl.inc());\n\t\t\t}\n\t\t}\n\t\tvoid print_custom(const char *format,FILE *fp=stdout);\n\t\tvoid print_custom(const char *format,const char *filename);\n\t\tbool find_voronoi_cell(double x,double y,double z,double &rx,double &ry,double &rz,int &pid);\n\t\t/** Computes the Voronoi cell for a particle currently being\n\t\t * referenced by a loop class.\n\t\t * \\param[out] c a Voronoi cell class in which to store the\n\t\t * \t\t computed cell.\n\t\t * \\param[in] vl the loop class to use.\n\t\t * \\return True if the cell was computed. If the cell cannot be\n\t\t * computed, if it is removed entirely by a wall or boundary\n\t\t * condition, then the routine returns false. */\n\t\ttemplate<class v_cell,class c_loop>\n\t\tinline bool compute_cell(v_cell &c,c_loop &vl) {\n\t\t\treturn vc.compute_cell(c,vl.ijk,vl.q,vl.i,vl.j,vl.k);\n\t\t}\n\t\t/** Computes the Voronoi cell for given particle.\n\t\t * \\param[out] c a Voronoi cell class in which to store the\n\t\t * \t\t computed cell.\n\t\t * \\param[in] ijk the block that the particle is within.\n\t\t * \\param[in] q the index of the particle within the block.\n\t\t * \\return True if the cell was computed. If the cell cannot be\n\t\t * computed, if it is removed entirely by a wall or boundary\n\t\t * condition, then the routine returns false. */\n\t\ttemplate<class v_cell>\n\t\tinline bool compute_cell(v_cell &c,int ijk,int q) {\n            assert(q >= 0 && ijk >= 0 && ijk < nxyz && co[ijk] >= 0 && q < co[ijk]);\n\n\t\t\tint k=ijk/nxy,ijkt=ijk-nxy*k,j=ijkt/nx,i=ijkt-j*nx;\n\t\t\treturn vc.compute_cell(c,ijk,q,i,j,k);\n\t\t}\n        inline bool valid_coords(int ijk, int q) {\n            return (q>=0 && ijk >= 0 && ijk < nxyz && co[ijk] >= 0 && q < co[ijk]);\n        }\n        inline void print_block(int ijk, int q) {\n            bool v = valid_coords(ijk, q);\n            std::cout << \"v=\" << v << \"; \";\n            if (v) {\n                std::cout << \"co[ijk]=\" << co[ijk] << \"; \";\n                for (int ii=0; ii<co[ijk]; ii++) {\n                    double *pp=p[ijk]+ii*3;\n                    std::cout << std::setprecision(17) << \"(\" << pp[0] << \",\" << pp[1] << \",\" << pp[2] << \") \";\n                }\n            }\n            std::cout << std::endl;\n        }\n\t\t/** Computes the Voronoi cell for a ghost particle at a given\n\t\t * location.\n\t\t * \\param[out] c a Voronoi cell class in which to store the\n\t\t * \t\t computed cell.\n\t\t * \\param[in] (x,y,z) the location of the ghost particle.\n\t\t * \\return True if the cell was computed. If the cell cannot be\n\t\t * computed, if it is removed entirely by a wall or boundary\n\t\t * condition, then the routine returns false. */\n\t\ttemplate<class v_cell>\n\t\tinline bool compute_ghost_cell(v_cell &c,double x,double y,double z) {\n\t\t\tint ijk;\n\t\t\tif(put_locate_block(ijk,x,y,z)) {\n\t\t\t\tdouble *pp=p[ijk]+3*co[ijk]++;\n\t\t\t\t*(pp++)=x;*(pp++)=y;*pp=z;\n\t\t\t\tbool q=compute_cell(c,ijk,co[ijk]-1);\n\t\t\t\tco[ijk]--;\n\t\t\t\treturn q;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\tprivate:\n\t\tvoro_compute<container> vc;\n\t\tfriend class voro_compute<container>;\n};\n\n/** \\brief Extension of the container_base class for computing radical Voronoi\n * tessellations.\n *\n * This class is an extension of container_base class that has routines\n * specifically for computing the radical Voronoi tessellation that depends on\n * the particle radii. */\nclass container_poly : public container_base, public radius_poly {\n\tpublic:\n\t\tcontainer_poly(double ax_,double bx_,double ay_,double by_,double az_,double bz_,\n\t\t\t\tint nx_,int ny_,int nz_,bool xperiodic_,bool yperiodic_,bool zperiodic_,int init_mem);\n\t\tvoid clear();\n\t\tvoid put(int n,double x,double y,double z,double r);\n\t\tvoid put(particle_order &vo,int n,double x,double y,double z,double r);\n\t\tvoid import(FILE *fp=stdin);\n\t\tvoid import(particle_order &vo,FILE *fp=stdin);\n\t\t/** Imports a list of particles from an open file stream into\n\t\t * the container_poly class. Entries of five numbers (Particle\n\t\t * ID, x position, y position, z position, radius) are searched\n\t\t * for. If the file cannot be successfully read, then the\n\t\t * routine causes a fatal error.\n\t\t * \\param[in] filename the name of the file to open and read\n\t\t *                     from. */\n\t\tinline void import(const char* filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"r\");\n\t\t\timport(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\t/** Imports a list of particles from an open file stream into\n\t\t * the container_poly class. Entries of five numbers (Particle\n\t\t * ID, x position, y position, z position, radius) are searched\n\t\t * for. In addition, the order in which particles are read is\n\t\t * saved into an ordering class. If the file cannot be\n\t\t * successfully read, then the routine causes a fatal error.\n\t\t * \\param[in,out] vo the ordering class to use.\n\t\t * \\param[in] filename the name of the file to open and read\n\t\t *                     from. */\n\t\tinline void import(particle_order &vo,const char* filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"r\");\n\t\t\timport(vo,fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\tvoid compute_all_cells();\n\t\tdouble sum_cell_volumes();\n\t\t/** Dumps particle IDs, positions and radii to a file.\n\t\t * \\param[in] vl the loop class to use.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\ttemplate<class c_loop>\n\t\tvoid draw_particles(c_loop &vl,FILE *fp) {\n\t\t\tdouble *pp;\n\t\t\tif(vl.start()) do {\n\t\t\t\tpp=p[vl.ijk]+4*vl.q;\n\t\t\t\tfprintf(fp,\"%d %g %g %g %g\\n\",id[vl.ijk][vl.q],*pp,pp[1],pp[2],pp[3]);\n\t\t\t} while(vl.inc());\n\t\t}\n\t\t/** Dumps all of the particle IDs, positions and radii to a\n\t\t * file.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\tinline void draw_particles(FILE *fp=stdout) {\n\t\t\tc_loop_all vl(*this);\n\t\t\tdraw_particles(vl,fp);\n\t\t}\n\t\t/** Dumps all of the particle IDs, positions and radii to a\n\t\t * file.\n\t\t * \\param[in] filename the name of the file to write to. */\n\t\tinline void draw_particles(const char *filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"w\");\n\t\t\tdraw_particles(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\t/** Dumps particle positions in POV-Ray format.\n\t\t * \\param[in] vl the loop class to use.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\ttemplate<class c_loop>\n\t\tvoid draw_particles_pov(c_loop &vl,FILE *fp) {\n\t\t\tdouble *pp;\n\t\t\tif(vl.start()) do {\n\t\t\t\tpp=p[vl.ijk]+4*vl.q;\n\t\t\t\tfprintf(fp,\"// id %d\\nsphere{<%g,%g,%g>,%g}\\n\",\n\t\t\t\t\t\tid[vl.ijk][vl.q],*pp,pp[1],pp[2],pp[3]);\n\t\t\t} while(vl.inc());\n\t\t}\n\t\t/** Dumps all the particle positions in POV-Ray format.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\tinline void draw_particles_pov(FILE *fp=stdout) {\n\t\t\tc_loop_all vl(*this);\n\t\t\tdraw_particles_pov(vl,fp);\n\t\t}\n\t\t/** Dumps all the particle positions in POV-Ray format.\n\t\t * \\param[in] filename the name of the file to write to. */\n\t\tinline void draw_particles_pov(const char *filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"w\");\n\t\t\tdraw_particles_pov(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\t/** Computes Voronoi cells and saves the output in gnuplot\n\t\t * format.\n\t\t * \\param[in] vl the loop class to use.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\ttemplate<class c_loop>\n\t\tvoid draw_cells_gnuplot(c_loop &vl,FILE *fp) {\n\t\t\tvoronoicell c;double *pp;\n\t\t\tif(vl.start()) do if(compute_cell(c,vl)) {\n\t\t\t\tpp=p[vl.ijk]+ps*vl.q;\n\t\t\t\tc.draw_gnuplot(*pp,pp[1],pp[2],fp);\n\t\t\t} while(vl.inc());\n\t\t}\n\t\t/** Compute all Voronoi cells and saves the output in gnuplot\n\t\t * format.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\tinline void draw_cells_gnuplot(FILE *fp=stdout) {\n\t\t\tc_loop_all vl(*this);\n\t\t\tdraw_cells_gnuplot(vl,fp);\n\t\t}\n\t\t/** Compute all Voronoi cells and saves the output in gnuplot\n\t\t * format.\n\t\t * \\param[in] filename the name of the file to write to. */\n\t\tinline void draw_cells_gnuplot(const char *filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"w\");\n\t\t\tdraw_cells_gnuplot(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\t/** Computes Voronoi cells and saves the output in POV-Ray\n\t\t * format.\n\t\t * \\param[in] vl the loop class to use.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\ttemplate<class c_loop>\n\t\tvoid draw_cells_pov(c_loop &vl,FILE *fp) {\n\t\t\tvoronoicell c;double *pp;\n\t\t\tif(vl.start()) do if(compute_cell(c,vl)) {\n\t\t\t\tfprintf(fp,\"// cell %d\\n\",id[vl.ijk][vl.q]);\n\t\t\t\tpp=p[vl.ijk]+ps*vl.q;\n\t\t\t\tc.draw_pov(*pp,pp[1],pp[2],fp);\n\t\t\t} while(vl.inc());\n\t\t}\n\t\t/** Computes all Voronoi cells and saves the output in POV-Ray\n\t\t * format.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\tinline void draw_cells_pov(FILE *fp=stdout) {\n\t\t\tc_loop_all vl(*this);\n\t\t\tdraw_cells_pov(vl,fp);\n\t\t}\n\t\t/** Computes all Voronoi cells and saves the output in POV-Ray\n\t\t * format.\n\t\t * \\param[in] filename the name of the file to write to. */\n\t\tinline void draw_cells_pov(const char *filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"w\");\n\t\t\tdraw_cells_pov(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\t/** Computes the Voronoi cells and saves customized information\n\t\t * about them.\n\t\t * \\param[in] vl the loop class to use.\n\t\t * \\param[in] format the custom output string to use.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\ttemplate<class c_loop>\n\t\tvoid print_custom(c_loop &vl,const char *format,FILE *fp) {\n\t\t\tint ijk,q;double *pp;\n\t\t\tif(contains_neighbor(format)) {\n\t\t\t\tvoronoicell_neighbor c;\n\t\t\t\tif(vl.start()) do if(compute_cell(c,vl)) {\n\t\t\t\t\tijk=vl.ijk;q=vl.q;pp=p[ijk]+ps*q;\n\t\t\t\t\tc.output_custom(format,id[ijk][q],*pp,pp[1],pp[2],pp[3],fp);\n\t\t\t\t} while(vl.inc());\n\t\t\t} else {\n\t\t\t\tvoronoicell c;\n\t\t\t\tif(vl.start()) do if(compute_cell(c,vl)) {\n\t\t\t\t\tijk=vl.ijk;q=vl.q;pp=p[ijk]+ps*q;\n\t\t\t\t\tc.output_custom(format,id[ijk][q],*pp,pp[1],pp[2],pp[3],fp);\n\t\t\t\t} while(vl.inc());\n\t\t\t}\n\t\t}\n\t\t/** Computes the Voronoi cell for a particle currently being\n\t\t * referenced by a loop class.\n\t\t * \\param[out] c a Voronoi cell class in which to store the\n\t\t * \t\t computed cell.\n\t\t * \\param[in] vl the loop class to use.\n\t\t * \\return True if the cell was computed. If the cell cannot be\n\t\t * computed, if it is removed entirely by a wall or boundary\n\t\t * condition, then the routine returns false. */\n\t\ttemplate<class v_cell,class c_loop>\n\t\tinline bool compute_cell(v_cell &c,c_loop &vl) {\n\t\t\treturn vc.compute_cell(c,vl.ijk,vl.q,vl.i,vl.j,vl.k);\n\t\t}\n\t\t/** Computes the Voronoi cell for given particle.\n\t\t * \\param[out] c a Voronoi cell class in which to store the\n\t\t * \t\t computed cell.\n\t\t * \\param[in] ijk the block that the particle is within.\n\t\t * \\param[in] q the index of the particle within the block.\n\t\t * \\return True if the cell was computed. If the cell cannot be\n\t\t * computed, if it is removed entirely by a wall or boundary\n\t\t * condition, then the routine returns false. */\n\t\ttemplate<class v_cell>\n\t\tinline bool compute_cell(v_cell &c,int ijk,int q) {\n\t\t\tint k=ijk/nxy,ijkt=ijk-nxy*k,j=ijkt/nx,i=ijkt-j*nx;\n\t\t\treturn vc.compute_cell(c,ijk,q,i,j,k);\n\t\t}\n\t\t/** Computes the Voronoi cell for a ghost particle at a given\n\t\t * location.\n\t\t * \\param[out] c a Voronoi cell class in which to store the\n\t\t * \t\t computed cell.\n\t\t * \\param[in] (x,y,z) the location of the ghost particle.\n\t\t * \\param[in] r the radius of the ghost particle.\n\t\t * \\return True if the cell was computed. If the cell cannot be\n\t\t * computed, if it is removed entirely by a wall or boundary\n\t\t * condition, then the routine returns false. */\n\t\ttemplate<class v_cell>\n\t\tinline bool compute_ghost_cell(v_cell &c,double x,double y,double z,double r) {\n\t\t\tint ijk;\n\t\t\tif(put_locate_block(ijk,x,y,z)) {\n\t\t\t\tdouble *pp=p[ijk]+4*co[ijk]++,tm=max_radius;\n\t\t\t\t*(pp++)=x;*(pp++)=y;*(pp++)=z;*pp=r;\n\t\t\t\tif(r>max_radius) max_radius=r;\n\t\t\t\tbool q=compute_cell(c,ijk,co[ijk]-1);\n\t\t\t\tco[ijk]--;max_radius=tm;\n\t\t\t\treturn q;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tvoid print_custom(const char *format,FILE *fp=stdout);\n\t\tvoid print_custom(const char *format,const char *filename);\n\t\tbool find_voronoi_cell(double x,double y,double z,double &rx,double &ry,double &rz,int &pid);\n\tprivate:\n\t\tvoro_compute<container_poly> vc;\n\t\tfriend class voro_compute<container_poly>;\n};\n\n}\n\n#endif\n","// -*- C++ -*-\n//===-------------------------- iterator ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ITERATOR\n#define _LIBCPP_ITERATOR\n\n/*\n    iterator synopsis\n\nnamespace std\n{\n\ntemplate<class Iterator>\nstruct iterator_traits\n{\n    typedef typename Iterator::difference_type difference_type;\n    typedef typename Iterator::value_type value_type;\n    typedef typename Iterator::pointer pointer;\n    typedef typename Iterator::reference reference;\n    typedef typename Iterator::iterator_category iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef T* pointer;\n    typedef T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class T>\nstruct iterator_traits<const T*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef T value_type;\n    typedef const T* pointer;\n    typedef const T& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate<class Category, class T, class Distance = ptrdiff_t,\n         class Pointer = T*, class Reference = T&>\nstruct iterator\n{\n    typedef T         value_type;\n    typedef Distance  difference_type;\n    typedef Pointer   pointer;\n    typedef Reference reference;\n    typedef Category  iterator_category;\n};\n\nstruct input_iterator_tag  {};\nstruct output_iterator_tag {};\nstruct forward_iterator_tag       : public input_iterator_tag         {};\nstruct bidirectional_iterator_tag : public forward_iterator_tag       {};\nstruct random_access_iterator_tag : public bidirectional_iterator_tag {};\n\n// extension: second argument not conforming to C++03\ntemplate <class InputIterator>\nvoid advance(InputIterator& i,\n             typename iterator_traits<InputIterator>::difference_type n);\n\ntemplate <class InputIterator>\ntypename iterator_traits<InputIterator>::difference_type\ndistance(InputIterator first, InputIterator last);\n\ntemplate <class Iterator>\nclass reverse_iterator\n    : public iterator<typename iterator_traits<Iterator>::iterator_category,\n                      typename iterator_traits<Iterator>::value_type,\n                      typename iterator_traits<Iterator>::difference_type,\n                      typename iterator_traits<Iterator>::pointer,\n                      typename iterator_traits<Iterator>::reference>\n{\nprotected:\n    Iterator current;\npublic:\n    typedef Iterator                                            iterator_type;\n    typedef typename iterator_traits<Iterator>::difference_type difference_type;\n    typedef typename iterator_traits<Iterator>::reference       reference;\n    typedef typename iterator_traits<Iterator>::pointer         pointer;\n\n    reverse_iterator();\n    explicit reverse_iterator(Iterator x);\n    template <class U> reverse_iterator(const reverse_iterator<U>& u);\n    Iterator base() const;\n    reference operator*() const;\n    pointer   operator->() const;\n    reverse_iterator& operator++();\n    reverse_iterator  operator++(int);\n    reverse_iterator& operator--();\n    reverse_iterator  operator--(int);\n    reverse_iterator  operator+ (difference_type n) const;\n    reverse_iterator& operator+=(difference_type n);\n    reverse_iterator  operator- (difference_type n) const;\n    reverse_iterator& operator-=(difference_type n);\n    reference         operator[](difference_type n) const;\n};\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator==(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator<(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator!=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator>(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator>=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\nbool\noperator<=(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator1, class Iterator2>\ntypename reverse_iterator<Iterator1>::difference_type\noperator-(const reverse_iterator<Iterator1>& x, const reverse_iterator<Iterator2>& y);\n\ntemplate <class Iterator>\nreverse_iterator<Iterator>\noperator+(typename reverse_iterator<Iterator>::difference_type n, const reverse_iterator<Iterator>& x);\n\ntemplate <class Iterator> reverse_iterator<Iterator> make_reverse_iterator(Iterator i); // C++14\n\ntemplate <class Container>\nclass back_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                   container_type;\n    typedef void                        value_type;\n    typedef void                        difference_type;\n    typedef back_insert_iterator<Cont>& reference;\n    typedef void                        pointer;\n\n    explicit back_insert_iterator(Container& x);\n    back_insert_iterator& operator=(const typename Container::value_type& value);\n    back_insert_iterator& operator*();\n    back_insert_iterator& operator++();\n    back_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> back_insert_iterator<Container> back_inserter(Container& x);\n\ntemplate <class Container>\nclass front_insert_iterator\n{\nprotected:\n    Container* container;\npublic:\n    typedef Container                    container_type;\n    typedef void                         value_type;\n    typedef void                         difference_type;\n    typedef front_insert_iterator<Cont>& reference;\n    typedef void                         pointer;\n\n    explicit front_insert_iterator(Container& x);\n    front_insert_iterator& operator=(const typename Container::value_type& value);\n    front_insert_iterator& operator*();\n    front_insert_iterator& operator++();\n    front_insert_iterator  operator++(int);\n};\n\ntemplate <class Container> front_insert_iterator<Container> front_inserter(Container& x);\n\ntemplate <class Container>\nclass insert_iterator\n{\nprotected:\n    Container* container;\n    typename Container::iterator iter;\npublic:\n    typedef Container              container_type;\n    typedef void                   value_type;\n    typedef void                   difference_type;\n    typedef insert_iterator<Cont>& reference;\n    typedef void                   pointer;\n\n    insert_iterator(Container& x, typename Container::iterator i);\n    insert_iterator& operator=(const typename Container::value_type& value);\n    insert_iterator& operator*();\n    insert_iterator& operator++();\n    insert_iterator& operator++(int);\n};\n\ntemplate <class Container, class Iterator>\ninsert_iterator<Container> inserter(Container& x, Iterator i);\n\ntemplate <class T, class charT = char, class traits = char_traits<charT>, class Distance = ptrdiff_t>\nclass istream_iterator\n    : public iterator<input_iterator_tag, T, Distance, const T*, const T&>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_istream<charT,traits> istream_type;\n\n    istream_iterator();\n    istream_iterator(istream_type& s);\n    istream_iterator(const istream_iterator& x);\n    ~istream_iterator();\n\n    const T& operator*() const;\n    const T* operator->() const;\n    istream_iterator& operator++();\n    istream_iterator  operator++(int);\n};\n\ntemplate <class T, class charT, class traits, class Distance>\nbool operator==(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\ntemplate <class T, class charT, class traits, class Distance>\nbool operator!=(const istream_iterator<T,charT,traits,Distance>& x,\n                const istream_iterator<T,charT,traits,Distance>& y);\n\ntemplate <class T, class charT = char, class traits = char_traits<charT> >\nclass ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void ,void>\n{\npublic:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef basic_ostream<charT,traits> ostream_type;\n\n    ostream_iterator(ostream_type& s);\n    ostream_iterator(ostream_type& s, const charT* delimiter);\n    ostream_iterator(const ostream_iterator& x);\n    ~ostream_iterator();\n    ostream_iterator& operator=(const T& value);\n\n    ostream_iterator& operator*();\n    ostream_iterator& operator++();\n    ostream_iterator& operator++(int);\n};\n\ntemplate<class charT, class traits = char_traits<charT> >\nclass istreambuf_iterator\n    : public iterator<input_iterator_tag, charT,\n                      typename traits::off_type, unspecified,\n                      charT>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef typename traits::int_type     int_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_istream<charT,traits>   istream_type;\n\n    istreambuf_iterator() noexcept;\n    istreambuf_iterator(istream_type& s) noexcept;\n    istreambuf_iterator(streambuf_type* s) noexcept;\n    istreambuf_iterator(a-private-type) noexcept;\n\n    charT                operator*() const;\n    pointer operator->() const;\n    istreambuf_iterator& operator++();\n    a-private-type       operator++(int);\n\n    bool equal(const istreambuf_iterator& b) const;\n};\n\ntemplate <class charT, class traits>\nbool operator==(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\ntemplate <class charT, class traits>\nbool operator!=(const istreambuf_iterator<charT,traits>& a,\n                const istreambuf_iterator<charT,traits>& b);\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef charT                         char_type;\n    typedef traits                        traits_type;\n    typedef basic_streambuf<charT,traits> streambuf_type;\n    typedef basic_ostream<charT,traits>   ostream_type;\n\n    ostreambuf_iterator(ostream_type& s) noexcept;\n    ostreambuf_iterator(streambuf_type* s) noexcept;\n    ostreambuf_iterator& operator=(charT c);\n    ostreambuf_iterator& operator*();\n    ostreambuf_iterator& operator++();\n    ostreambuf_iterator& operator++(int);\n    bool failed() const noexcept;\n};\n\ntemplate <class C> auto begin(C& c) -> decltype(c.begin());\ntemplate <class C> auto begin(const C& c) -> decltype(c.begin());\ntemplate <class C> auto end(C& c) -> decltype(c.end());\ntemplate <class C> auto end(const C& c) -> decltype(c.end());\ntemplate <class T, size_t N> T* begin(T (&array)[N]);\ntemplate <class T, size_t N> T* end(T (&array)[N]);\n\ntemplate <class C> auto cbegin(const C& c) -> decltype(std::begin(c));        // C++14\ntemplate <class C> auto cend(const C& c) -> decltype(std::end(c));            // C++14\ntemplate <class C> auto rbegin(C& c) -> decltype(c.rbegin());                 // C++14\ntemplate <class C> auto rbegin(const C& c) -> decltype(c.rbegin());           // C++14\ntemplate <class C> auto rend(C& c) -> decltype(c.rend());                     // C++14\ntemplate <class C> auto rend(const C& c) -> decltype(c.rend());               // C++14\ntemplate <class E> reverse_iterator<const E*> rbegin(initializer_list<E> il); // C++14\ntemplate <class E> reverse_iterator<const E*> rend(initializer_list<E> il);   // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> rbegin(T (&array)[N]);      // C++14\ntemplate <class T, size_t N> reverse_iterator<T*> rend(T (&array)[N]);        // C++14\ntemplate <class C> auto crbegin(const C& c) -> decltype(std::rbegin(c));      // C++14\ntemplate <class C> auto crend(const C& c) -> decltype(std::rend(c));          // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__functional_base>\n#include <type_traits>\n#include <cstddef>\n#include <iosfwd>\n#include <initializer_list>\n#ifdef __APPLE__\n#include <Availability.h>\n#endif\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nstruct _LIBCPP_TYPE_VIS_ONLY input_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY output_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY forward_iterator_tag       : public input_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY bidirectional_iterator_tag : public forward_iterator_tag {};\nstruct _LIBCPP_TYPE_VIS_ONLY random_access_iterator_tag : public bidirectional_iterator_tag {};\n\ntemplate <class _Tp>\nstruct __has_iterator_category\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::iterator_category* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits_impl {};\n\ntemplate <class _Iter>\nstruct __iterator_traits_impl<_Iter, true>\n{\n    typedef typename _Iter::difference_type   difference_type;\n    typedef typename _Iter::value_type        value_type;\n    typedef typename _Iter::pointer           pointer;\n    typedef typename _Iter::reference         reference;\n    typedef typename _Iter::iterator_category iterator_category;\n};\n\ntemplate <class _Iter, bool> struct __iterator_traits {};\n\ntemplate <class _Iter>\nstruct __iterator_traits<_Iter, true>\n    :  __iterator_traits_impl\n      <\n        _Iter,\n        is_convertible<typename _Iter::iterator_category, input_iterator_tag>::value ||\n        is_convertible<typename _Iter::iterator_category, output_iterator_tag>::value\n      >\n{};\n\n// iterator_traits<Iterator> will only have the nested types if Iterator::iterator_category\n//    exists.  Else iterator_traits<Iterator> will be an empty class.  This is a\n//    conforming extension which allows some programs to compile and behave as\n//    the client expects instead of failing at compile time.\n\ntemplate <class _Iter>\nstruct _LIBCPP_TYPE_VIS_ONLY iterator_traits\n    : __iterator_traits<_Iter, __has_iterator_category<_Iter>::value> {};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY iterator_traits<_Tp*>\n{\n    typedef ptrdiff_t difference_type;\n    typedef typename remove_const<_Tp>::type value_type;\n    typedef _Tp* pointer;\n    typedef _Tp& reference;\n    typedef random_access_iterator_tag iterator_category;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_iterator_category<iterator_traits<_Tp> >::value>\nstruct __has_iterator_category_convertible_to\n    : public integral_constant<bool, is_convertible<typename iterator_traits<_Tp>::iterator_category, _Up>::value>\n{};\n\ntemplate <class _Tp, class _Up>\nstruct __has_iterator_category_convertible_to<_Tp, _Up, false> : public false_type {};\n\ntemplate <class _Tp>\nstruct __is_input_iterator : public __has_iterator_category_convertible_to<_Tp, input_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_forward_iterator : public __has_iterator_category_convertible_to<_Tp, forward_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_bidirectional_iterator : public __has_iterator_category_convertible_to<_Tp, bidirectional_iterator_tag> {};\n\ntemplate <class _Tp>\nstruct __is_random_access_iterator : public __has_iterator_category_convertible_to<_Tp, random_access_iterator_tag> {};\n\ntemplate<class _Category, class _Tp, class _Distance = ptrdiff_t,\n         class _Pointer = _Tp*, class _Reference = _Tp&>\nstruct _LIBCPP_TYPE_VIS_ONLY iterator\n{\n    typedef _Tp        value_type;\n    typedef _Distance  difference_type;\n    typedef _Pointer   pointer;\n    typedef _Reference reference;\n    typedef _Category  iterator_category;\n};\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n, input_iterator_tag)\n{\n    for (; __n > 0; --__n)\n        ++__i;\n}\n\ntemplate <class _BiDirIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_BiDirIter& __i,\n             typename iterator_traits<_BiDirIter>::difference_type __n, bidirectional_iterator_tag)\n{\n    if (__n >= 0)\n        for (; __n > 0; --__n)\n            ++__i;\n    else\n        for (; __n < 0; ++__n)\n            --__i;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __advance(_RandIter& __i,\n             typename iterator_traits<_RandIter>::difference_type __n, random_access_iterator_tag)\n{\n   __i += __n;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid advance(_InputIter& __i,\n             typename iterator_traits<_InputIter>::difference_type __n)\n{\n    __advance(__i, __n, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\n__distance(_InputIter __first, _InputIter __last, input_iterator_tag)\n{\n    typename iterator_traits<_InputIter>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        ++__r;\n    return __r;\n}\n\ntemplate <class _RandIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_RandIter>::difference_type\n__distance(_RandIter __first, _RandIter __last, random_access_iterator_tag)\n{\n    return __last - __first;\n}\n\ntemplate <class _InputIter>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIter>::difference_type\ndistance(_InputIter __first, _InputIter __last)\n{\n    return __distance(__first, __last, typename iterator_traits<_InputIter>::iterator_category());\n}\n\ntemplate <class _ForwardIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIter\nnext(_ForwardIter __x,\n     typename iterator_traits<_ForwardIter>::difference_type __n = 1,\n     typename enable_if<__is_forward_iterator<_ForwardIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, __n);\n    return __x;\n}\n\ntemplate <class _BidiretionalIter>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidiretionalIter\nprev(_BidiretionalIter __x,\n     typename iterator_traits<_BidiretionalIter>::difference_type __n = 1,\n     typename enable_if<__is_bidirectional_iterator<_BidiretionalIter>::value>::type* = 0)\n{\n    _VSTD::advance(__x, -__n);\n    return __x;\n}\n\ntemplate <class _Iter>\nclass _LIBCPP_TYPE_VIS_ONLY reverse_iterator\n    : public iterator<typename iterator_traits<_Iter>::iterator_category,\n                      typename iterator_traits<_Iter>::value_type,\n                      typename iterator_traits<_Iter>::difference_type,\n                      typename iterator_traits<_Iter>::pointer,\n                      typename iterator_traits<_Iter>::reference>\n{\nprivate:\n    mutable _Iter __t;  // no longer used as of LWG #2360, not removed due to ABI break\nprotected:\n    _Iter current;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<_Iter>::difference_type difference_type;\n    typedef typename iterator_traits<_Iter>::reference       reference;\n    typedef typename iterator_traits<_Iter>::pointer         pointer;\n\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator() : current() {}\n    _LIBCPP_INLINE_VISIBILITY explicit reverse_iterator(_Iter __x) : __t(__x), current(__x) {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY reverse_iterator(const reverse_iterator<_Up>& __u)\n        : __t(__u.base()), current(__u.base()) {}\n    _LIBCPP_INLINE_VISIBILITY _Iter base() const {return current;}\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {_Iter __tmp = current; return *--__tmp;}\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const {return _VSTD::addressof(operator*());}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator++() {--current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator++(int)\n        {reverse_iterator __tmp(*this); --current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator--() {++current; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator--(int)\n        {reverse_iterator __tmp(*this); ++current; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator+ (difference_type __n) const\n        {return reverse_iterator(current - __n);}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator+=(difference_type __n)\n        {current -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator  operator- (difference_type __n) const\n        {return reverse_iterator(current + __n);}\n    _LIBCPP_INLINE_VISIBILITY reverse_iterator& operator-=(difference_type __n)\n        {current += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference         operator[](difference_type __n) const\n        {return current[-__n-1];}\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename reverse_iterator<_Iter1>::difference_type\noperator-(const reverse_iterator<_Iter1>& __x, const reverse_iterator<_Iter2>& __y)\n{\n    return __y.base() - __x.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Iter>\noperator+(typename reverse_iterator<_Iter>::difference_type __n, const reverse_iterator<_Iter>& __x)\n{\n    return reverse_iterator<_Iter>(__x.base() - __n);\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Iter> make_reverse_iterator(_Iter __i)\n{\n    return reverse_iterator<_Iter>(__i);\n}\n#endif\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS_ONLY back_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      back_insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit back_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_back(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_back(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY back_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nback_insert_iterator<_Container>\nback_inserter(_Container& __x)\n{\n    return back_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS_ONLY front_insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      front_insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit front_insert_iterator(_Container& __x) : container(_VSTD::addressof(__x)) {}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {container->push_front(__value_); return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {container->push_front(_VSTD::move(__value_)); return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY front_insert_iterator  operator++(int) {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\nfront_insert_iterator<_Container>\nfront_inserter(_Container& __x)\n{\n    return front_insert_iterator<_Container>(__x);\n}\n\ntemplate <class _Container>\nclass _LIBCPP_TYPE_VIS_ONLY insert_iterator\n    : public iterator<output_iterator_tag,\n                      void,\n                      void,\n                      void,\n                      insert_iterator<_Container>&>\n{\nprotected:\n    _Container* container;\n    typename _Container::iterator iter;\npublic:\n    typedef _Container container_type;\n\n    _LIBCPP_INLINE_VISIBILITY insert_iterator(_Container& __x, typename _Container::iterator __i)\n        : container(_VSTD::addressof(__x)), iter(__i) {}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(const typename _Container::value_type& __value_)\n        {iter = container->insert(iter, __value_); ++iter; return *this;}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator=(typename _Container::value_type&& __value_)\n        {iter = container->insert(iter, _VSTD::move(__value_)); ++iter; return *this;}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator*()        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++()       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY insert_iterator& operator++(int)    {return *this;}\n};\n\ntemplate <class _Container>\ninline _LIBCPP_INLINE_VISIBILITY\ninsert_iterator<_Container>\ninserter(_Container& __x, typename _Container::iterator __i)\n{\n    return insert_iterator<_Container>(__x, __i);\n}\n\ntemplate <class _Tp, class _CharT = char,\n          class _Traits = char_traits<_CharT>, class _Distance = ptrdiff_t>\nclass _LIBCPP_TYPE_VIS_ONLY istream_iterator\n    : public iterator<input_iterator_tag, _Tp, _Distance, const _Tp*, const _Tp&>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_istream<_CharT,_Traits> istream_type;\nprivate:\n    istream_type* __in_stream_;\n    _Tp __value_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY istream_iterator() : __in_stream_(0) {}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator(istream_type& __s) : __in_stream_(&__s)\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY const _Tp& operator*() const {return __value_;}\n    _LIBCPP_INLINE_VISIBILITY const _Tp* operator->() const {return &(operator*());}\n    _LIBCPP_INLINE_VISIBILITY istream_iterator& operator++()\n        {\n            if (!(*__in_stream_ >> __value_))\n                __in_stream_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY istream_iterator  operator++(int)\n        {istream_iterator __t(*this); ++(*this); return __t;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const istream_iterator& __x, const istream_iterator& __y)\n        {return __x.__in_stream_ == __y.__in_stream_;}\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const istream_iterator& __x, const istream_iterator& __y)\n        {return !(__x == __y);}\n};\n\ntemplate <class _Tp, class _CharT = char, class _Traits = char_traits<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY ostream_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n    typedef basic_ostream<_CharT,_Traits> ostream_type;\nprivate:\n    ostream_type* __out_stream_;\n    const char_type* __delim_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s)\n        : __out_stream_(&__s), __delim_(0) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator(ostream_type& __s, const _CharT* __delimiter)\n        : __out_stream_(&__s), __delim_(__delimiter) {}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator=(const _Tp& __value_)\n        {\n            *__out_stream_ << __value_;\n            if (__delim_)\n                *__out_stream_ << __delim_;\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostream_iterator& operator++(int) {return *this;}\n};\n\ntemplate<class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY istreambuf_iterator\n    : public iterator<input_iterator_tag, _CharT,\n                      typename _Traits::off_type, _CharT*,\n                      _CharT>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef typename _Traits::int_type      int_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_istream<_CharT,_Traits>   istream_type;\nprivate:\n    mutable streambuf_type* __sbuf_;\n\n    class __proxy\n    {\n        char_type __keep_;\n        streambuf_type* __sbuf_;\n        _LIBCPP_INLINE_VISIBILITY __proxy(char_type __c, streambuf_type* __s)\n            : __keep_(__c), __sbuf_(__s) {}\n        friend class istreambuf_iterator;\n    public:\n        _LIBCPP_INLINE_VISIBILITY char_type operator*() const {return __keep_;}\n    };\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __test_for_eof() const\n    {\n        if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sgetc(), traits_type::eof()))\n            __sbuf_ = 0;\n        return __sbuf_ == 0;\n    }\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR istreambuf_iterator() _NOEXCEPT : __sbuf_(0) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(istream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator(const __proxy& __p) _NOEXCEPT\n        : __sbuf_(__p.__sbuf_) {}\n\n    _LIBCPP_INLINE_VISIBILITY char_type  operator*() const\n        {return static_cast<char_type>(__sbuf_->sgetc());}\n    _LIBCPP_INLINE_VISIBILITY char_type* operator->() const {return nullptr;}\n    _LIBCPP_INLINE_VISIBILITY istreambuf_iterator& operator++()\n        {\n            __sbuf_->sbumpc();\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY __proxy              operator++(int)\n        {\n            return __proxy(__sbuf_->sbumpc(), __sbuf_);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY bool equal(const istreambuf_iterator& __b) const\n        {return __test_for_eof() == __b.__test_for_eof();}\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return __a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const istreambuf_iterator<_CharT,_Traits>& __a,\n                const istreambuf_iterator<_CharT,_Traits>& __b)\n                {return !__a.equal(__b);}\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY ostreambuf_iterator\n    : public iterator<output_iterator_tag, void, void, void, void>\n{\npublic:\n    typedef _CharT                          char_type;\n    typedef _Traits                         traits_type;\n    typedef basic_streambuf<_CharT,_Traits> streambuf_type;\n    typedef basic_ostream<_CharT,_Traits>   ostream_type;\nprivate:\n    streambuf_type* __sbuf_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(ostream_type& __s) _NOEXCEPT\n        : __sbuf_(__s.rdbuf()) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator(streambuf_type* __s) _NOEXCEPT\n        : __sbuf_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator=(_CharT __c)\n        {\n            if (__sbuf_ && traits_type::eq_int_type(__sbuf_->sputc(__c), traits_type::eof()))\n                __sbuf_ = 0;\n            return *this;\n        }\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator*()     {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++()    {return *this;}\n    _LIBCPP_INLINE_VISIBILITY ostreambuf_iterator& operator++(int) {return *this;}\n    _LIBCPP_INLINE_VISIBILITY bool failed() const _NOEXCEPT {return __sbuf_ == 0;}\n\n#if !defined(__APPLE__) || \\\n    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \\\n    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)\n\n    template <class _Ch, class _Tr>\n    friend\n    _LIBCPP_HIDDEN\n    ostreambuf_iterator<_Ch, _Tr>\n    __pad_and_output(ostreambuf_iterator<_Ch, _Tr> __s,\n                     const _Ch* __ob, const _Ch* __op, const _Ch* __oe,\n                     ios_base& __iob, _Ch __fl);\n#endif\n};\n\ntemplate <class _Iter>\nclass _LIBCPP_TYPE_VIS_ONLY move_iterator\n{\nprivate:\n    _Iter __i;\npublic:\n    typedef _Iter                                            iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type difference_type;\n    typedef typename iterator_traits<iterator_type>::pointer pointer;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    typedef value_type&& reference;\n#else\n    typedef typename iterator_traits<iterator_type>::reference reference;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY move_iterator() : __i() {}\n    _LIBCPP_INLINE_VISIBILITY explicit move_iterator(_Iter __x) : __i(__x) {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY move_iterator(const move_iterator<_Up>& __u)\n        : __i(__u.base()) {}\n    _LIBCPP_INLINE_VISIBILITY _Iter base() const {return __i;}\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const {\n      return static_cast<reference>(*__i);\n    }\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const {\n      typename iterator_traits<iterator_type>::reference __ref = *__i;\n      return &__ref;\n    }\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator++() {++__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator++(int)\n        {move_iterator __tmp(*this); ++__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator--() {--__i; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator--(int)\n        {move_iterator __tmp(*this); --__i; return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator+ (difference_type __n) const\n        {return move_iterator(__i + __n);}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator+=(difference_type __n)\n        {__i += __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY move_iterator  operator- (difference_type __n) const\n        {return move_iterator(__i - __n);}\n    _LIBCPP_INLINE_VISIBILITY move_iterator& operator-=(difference_type __n)\n        {__i -= __n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference         operator[](difference_type __n) const\n    {\n      return static_cast<reference>(__i[__n]);\n    }\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() != __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() > __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() >= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() <= __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename move_iterator<_Iter1>::difference_type\noperator-(const move_iterator<_Iter1>& __x, const move_iterator<_Iter2>& __y)\n{\n    return __x.base() - __y.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nmove_iterator<_Iter>\noperator+(typename move_iterator<_Iter>::difference_type __n, const move_iterator<_Iter>& __x)\n{\n    return move_iterator<_Iter>(__x.base() + __n);\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\nmove_iterator<_Iter>\nmake_move_iterator(_Iter __i)\n{\n    return move_iterator<_Iter>(__i);\n}\n\n// __wrap_iter\n\ntemplate <class _Iter> class __wrap_iter;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter1, class _Iter2>\n_LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\ntemplate <class _Iter>\n_LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type, __wrap_iter<_Iter>) _NOEXCEPT;\n\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY copy(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY copy_backward(_B1, _B1, _B2);\ntemplate <class _Ip, class _Op> _Op _LIBCPP_INLINE_VISIBILITY move(_Ip, _Ip, _Op);\ntemplate <class _B1, class _B2> _B2 _LIBCPP_INLINE_VISIBILITY move_backward(_B1, _B1, _B2);\n\ntemplate <class _Tp>\n_LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*>);\n\ntemplate <class _Iter>\nclass __wrap_iter\n{\npublic:\n    typedef _Iter                                                      iterator_type;\n    typedef typename iterator_traits<iterator_type>::iterator_category iterator_category;\n    typedef typename iterator_traits<iterator_type>::value_type        value_type;\n    typedef typename iterator_traits<iterator_type>::difference_type   difference_type;\n    typedef typename iterator_traits<iterator_type>::pointer           pointer;\n    typedef typename iterator_traits<iterator_type>::reference         reference;\nprivate:\n    iterator_type __i;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n                : __i{}\n#endif\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY __wrap_iter(const __wrap_iter<_Up>& __u,\n        typename enable_if<is_convertible<_Up, iterator_type>::value>::type* = 0) _NOEXCEPT\n        : __i(__u.base())\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__iterator_copy(this, &__u);\n#endif\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter(const __wrap_iter& __x)\n        : __i(__x.base())\n    {\n        __get_db()->__iterator_copy(this, &__x);\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    __wrap_iter& operator=(const __wrap_iter& __x)\n    {\n        if (this != &__x)\n        {\n            __get_db()->__iterator_copy(this, &__x);\n            __i = __x.__i;\n        }\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY\n    ~__wrap_iter()\n    {\n        __get_db()->__erase_i(this);\n    }\n#endif\n    _LIBCPP_INLINE_VISIBILITY reference operator*() const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return *__i;\n    }\n    _LIBCPP_INLINE_VISIBILITY pointer  operator->() const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to dereference a non-dereferenceable iterator\");\n#endif\n        return (pointer)&reinterpret_cast<const volatile char&>(*__i);\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator++() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable iterator\");\n#endif\n        ++__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator++(int) _NOEXCEPT\n        {__wrap_iter __tmp(*this); ++(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator--() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__decrementable(this),\n                       \"Attempted to decrement non-decrementable iterator\");\n#endif\n        --__i;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator--(int) _NOEXCEPT\n        {__wrap_iter __tmp(*this); --(*this); return __tmp;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator+ (difference_type __n) const _NOEXCEPT\n        {__wrap_iter __w(*this); __w += __n; return __w;}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator+=(difference_type __n) _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__addable(this, __n),\n                   \"Attempted to add/subtract iterator outside of valid range\");\n#endif\n        __i += __n;\n        return *this;\n    }\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter  operator- (difference_type __n) const _NOEXCEPT\n        {return *this + (-__n);}\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter& operator-=(difference_type __n) _NOEXCEPT\n        {*this += -__n; return *this;}\n    _LIBCPP_INLINE_VISIBILITY reference        operator[](difference_type __n) const _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__subscriptable(this, __n),\n                   \"Attempted to subscript iterator outside of valid range\");\n#endif\n        return __i[__n];\n    }\n\n    _LIBCPP_INLINE_VISIBILITY iterator_type base() const _NOEXCEPT {return __i;}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(const void* __p, iterator_type __x) : __i(__x)\n    {\n        __get_db()->__insert_ic(this, __p);\n    }\n#else\n    _LIBCPP_INLINE_VISIBILITY __wrap_iter(iterator_type __x) _NOEXCEPT : __i(__x) {}\n#endif\n\n    template <class _Up> friend class __wrap_iter;\n    template <class _CharT, class _Traits, class _Alloc> friend class basic_string;\n    template <class _Tp, class _Alloc> friend class vector;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator==(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator!=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator>=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    bool\n    operator<=(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1, class _Iter2>\n    friend\n    typename __wrap_iter<_Iter1>::difference_type\n    operator-(const __wrap_iter<_Iter1>&, const __wrap_iter<_Iter2>&) _NOEXCEPT;\n\n    template <class _Iter1>\n    friend\n    __wrap_iter<_Iter1>\n    operator+(typename __wrap_iter<_Iter1>::difference_type, __wrap_iter<_Iter1>) _NOEXCEPT;\n\n    template <class _Ip, class _Op> friend _Op copy(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 copy_backward(_B1, _B1, _B2);\n    template <class _Ip, class _Op> friend _Op move(_Ip, _Ip, _Op);\n    template <class _B1, class _B2> friend _B2 move_backward(_B1, _B1, _B2);\n\n    template <class _Tp>\n    friend\n    typename enable_if\n    <\n        is_trivially_copy_assignable<_Tp>::value,\n        _Tp*\n    >::type\n    __unwrap_iter(__wrap_iter<_Tp*>);\n};\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return __x.base() == __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to compare incomparable iterators\");\n#endif\n    return __x.base() < __y.base();\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate <class _Iter1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter1>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate <class _Iter1, class _Iter2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __wrap_iter<_Iter1>::difference_type\noperator-(const __wrap_iter<_Iter1>& __x, const __wrap_iter<_Iter2>& __y) _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__less_than_comparable(&__x, &__y),\n                   \"Attempted to subtract incompatible iterators\");\n#endif\n    return __x.base() - __y.base();\n}\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n__wrap_iter<_Iter>\noperator+(typename __wrap_iter<_Iter>::difference_type __n,\n          __wrap_iter<_Iter> __x) _NOEXCEPT\n{\n    __x += __n;\n    return __x;\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp*\nbegin(_Tp (&__array)[_Np])\n{\n    return __array;\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp*\nend(_Tp (&__array)[_Np])\n{\n    return __array + _Np;\n}\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nbegin(_Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nbegin(const _Cp& __c) -> decltype(__c.begin())\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nend(_Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\nend(const _Cp& __c) -> decltype(__c.end())\n{\n    return __c.end();\n}\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Tp*> rbegin(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array + _Np);\n}\n\ntemplate <class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<_Tp*> rend(_Tp (&__array)[_Np])\n{\n    return reverse_iterator<_Tp*>(__array);\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<const _Ep*> rbegin(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.end());\n}\n\ntemplate <class _Ep>\ninline _LIBCPP_INLINE_VISIBILITY\nreverse_iterator<const _Ep*> rend(initializer_list<_Ep> __il)\n{\n    return reverse_iterator<const _Ep*>(__il.begin());\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nauto cbegin(const _Cp& __c) -> decltype(begin(__c))\n{\n    return begin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nauto cend(const _Cp& __c) -> decltype(end(__c))\n{\n    return end(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rbegin(_Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rbegin(const _Cp& __c) -> decltype(__c.rbegin())\n{\n    return __c.rbegin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rend(_Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto rend(const _Cp& __c) -> decltype(__c.rend())\n{\n    return __c.rend();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto crbegin(const _Cp& __c) -> decltype(rbegin(__c))\n{\n    return rbegin(__c);\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\nauto crend(const _Cp& __c) -> decltype(rend(__c))\n{\n    return rend(__c);\n}\n\n#endif\n\n\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nbegin(_Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nbegin(const _Cp& __c)\n{\n    return __c.begin();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::iterator\nend(_Cp& __c)\n{\n    return __c.end();\n}\n\ntemplate <class _Cp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename _Cp::const_iterator\nend(const _Cp& __c)\n{\n    return __c.end();\n}\n\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_TRAILING_RETURN)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ITERATOR\n","// -*- C++ -*-\n//===-------------------------- ostream -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_OSTREAM\n#define _LIBCPP_OSTREAM\n\n/*\n    ostream synopsis\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ostream\n    : virtual public basic_ios<charT,traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef charT                          char_type;\n    typedef traits                         traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.2.2 Constructor/destructor:\n    explicit basic_ostream(basic_streambuf<char_type,traits>* sb);\n    basic_ostream(basic_ostream&& rhs);\n    virtual ~basic_ostream();\n\n    // 27.7.2.3 Assign/swap\n    basic_ostream& operator=(const basic_ostream& rhs) = delete; // C++14\n    basic_ostream& operator=(basic_ostream&& rhs);\n    void swap(basic_ostream& rhs);\n\n    // 27.7.2.4 Prefix/suffix:\n    class sentry;\n\n    // 27.7.2.6 Formatted output:\n    basic_ostream& operator<<(basic_ostream& (*pf)(basic_ostream&));\n    basic_ostream& operator<<(basic_ios<charT, traits>& (*pf)(basic_ios<charT,traits>&));\n    basic_ostream& operator<<(ios_base& (*pf)(ios_base&));\n    basic_ostream& operator<<(bool n);\n    basic_ostream& operator<<(short n);\n    basic_ostream& operator<<(unsigned short n);\n    basic_ostream& operator<<(int n);\n    basic_ostream& operator<<(unsigned int n);\n    basic_ostream& operator<<(long n);\n    basic_ostream& operator<<(unsigned long n);\n    basic_ostream& operator<<(long long n);\n    basic_ostream& operator<<(unsigned long long n);\n    basic_ostream& operator<<(float f);\n    basic_ostream& operator<<(double f);\n    basic_ostream& operator<<(long double f);\n    basic_ostream& operator<<(const void* p);\n    basic_ostream& operator<<(basic_streambuf<char_type,traits>* sb);\n\n    // 27.7.2.7 Unformatted output:\n    basic_ostream& put(char_type c);\n    basic_ostream& write(const char_type* s, streamsize n);\n    basic_ostream& flush();\n\n    // 27.7.2.5 seeks:\n    pos_type tellp();\n    basic_ostream& seekp(pos_type);\n    basic_ostream& seekp(off_type, ios_base::seekdir);\nprotected:\n    basic_ostream(const basic_ostream& rhs) = delete;\n    basic_ostream(basic_ostream&& rhs);\n    // 27.7.3.3 Assign/swap\n    basic_ostream& operator=(basic_ostream& rhs) = delete;\n    basic_ostream& operator=(const basic_ostream&& rhs);\n    void swap(basic_ostream& rhs);\n};\n\n// 27.7.2.6.4 character inserters\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, charT);\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, char);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, char);\n\n// signed and unsigned\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, signed char);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, unsigned char);\n\n// NTBS\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const charT*);\n\ntemplate<class charT, class traits>\n  basic_ostream<charT,traits>& operator<<(basic_ostream<charT,traits>&, const char*);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const char*);\n\n// signed and unsigned\ntemplate<class traits>\nbasic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const signed char*);\n\ntemplate<class traits>\n  basic_ostream<char,traits>& operator<<(basic_ostream<char,traits>&, const unsigned char*);\n\n// swap:\ntemplate <class charT, class traits>\n  void swap(basic_ostream<charT, traits>& x, basic_ostream<charT, traits>& y);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& endl(basic_ostream<charT,traits>& os);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& ends(basic_ostream<charT,traits>& os);\n\ntemplate <class charT, class traits>\n  basic_ostream<charT,traits>& flush(basic_ostream<charT,traits>& os);\n\n// rvalue stream insertion\ntemplate <class charT, class traits, class T>\n  basic_ostream<charT, traits>&\n  operator<<(basic_ostream<charT, traits>&& os, const T& x);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <ios>\n#include <streambuf>\n#include <locale>\n#include <iterator>\n#include <bitset>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ostream\n    : virtual public basic_ios<_CharT, _Traits>\n{\npublic:\n    // types (inherited from basic_ios (27.5.4)):\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    // 27.7.2.2 Constructor/destructor:\n    explicit basic_ostream(basic_streambuf<char_type, traits_type>* __sb);\n    virtual ~basic_ostream();\nprotected:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream(basic_ostream&& __rhs);\n#endif\n\n    // 27.7.2.3 Assign/swap\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream& operator=(basic_ostream&& __rhs);\n#endif\n    void swap(basic_ostream& __rhs);\n\n#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n    basic_ostream           (const basic_ostream& __rhs) = delete;\n    basic_ostream& operator=(const basic_ostream& __rhs) = delete;\n#else\n    basic_ostream           (const basic_ostream& __rhs); // not defined\n    basic_ostream& operator=(const basic_ostream& __rhs); // not defined\n#endif\npublic:\n\n    // 27.7.2.4 Prefix/suffix:\n    class _LIBCPP_TYPE_VIS_ONLY sentry;\n\n    // 27.7.2.6 Formatted output:\n    basic_ostream& operator<<(basic_ostream& (*__pf)(basic_ostream&));\n    basic_ostream& operator<<(basic_ios<char_type, traits_type>&\n                              (*__pf)(basic_ios<char_type,traits_type>&));\n    basic_ostream& operator<<(ios_base& (*__pf)(ios_base&));\n    basic_ostream& operator<<(bool __n);\n    basic_ostream& operator<<(short __n);\n    basic_ostream& operator<<(unsigned short __n);\n    basic_ostream& operator<<(int __n);\n    basic_ostream& operator<<(unsigned int __n);\n    basic_ostream& operator<<(long __n);\n    basic_ostream& operator<<(unsigned long __n);\n    basic_ostream& operator<<(long long __n);\n    basic_ostream& operator<<(unsigned long long __n);\n    basic_ostream& operator<<(float __f);\n    basic_ostream& operator<<(double __f);\n    basic_ostream& operator<<(long double __f);\n    basic_ostream& operator<<(const void* __p);\n    basic_ostream& operator<<(basic_streambuf<char_type, traits_type>* __sb);\n\n    // 27.7.2.7 Unformatted output:\n    basic_ostream& put(char_type __c);\n    basic_ostream& write(const char_type* __s, streamsize __n);\n    basic_ostream& flush();\n\n    // 27.7.2.5 seeks:\n    pos_type tellp();\n    basic_ostream& seekp(pos_type __pos);\n    basic_ostream& seekp(off_type __off, ios_base::seekdir __dir);\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    basic_ostream() {}  // extension, intentially does not initialize\n};\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ostream<_CharT, _Traits>::sentry\n{\n    bool __ok_;\n    basic_ostream<_CharT, _Traits>& __os_;\n\n    sentry(const sentry&); // = delete;\n    sentry& operator=(const sentry&); // = delete;\n\npublic:\n    explicit sentry(basic_ostream<_CharT, _Traits>& __os);\n    ~sentry();\n\n    _LIBCPP_ALWAYS_INLINE\n        _LIBCPP_EXPLICIT\n        operator bool() const {return __ok_;}\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::sentry::sentry(basic_ostream<_CharT, _Traits>& __os)\n    : __ok_(false),\n      __os_(__os)\n{\n    if (__os.good())\n    {\n        if (__os.tie())\n            __os.tie()->flush();\n        __ok_ = true;\n    }\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::sentry::~sentry()\n{\n    if (__os_.rdbuf() && __os_.good() && (__os_.flags() & ios_base::unitbuf)\n                      && !uncaught_exception())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            if (__os_.rdbuf()->pubsync() == -1)\n                __os_.setstate(ios_base::badbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>::basic_ostream(basic_streambuf<char_type, traits_type>* __sb)\n{\n    this->init(__sb);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>::basic_ostream(basic_ostream&& __rhs)\n{\n    this->move(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator=(basic_ostream&& __rhs)\n{\n    swap(__rhs);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>::~basic_ostream()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ostream<_CharT, _Traits>::swap(basic_ostream& __rhs)\n{\n    basic_ios<char_type, traits_type>::swap(__rhs);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(basic_ostream& (*__pf)(basic_ostream&))\n{\n    return __pf(*this);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(basic_ios<char_type, traits_type>&\n                                           (*__pf)(basic_ios<char_type,traits_type>&))\n{\n    __pf(*this);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(ios_base& (*__pf)(ios_base&))\n{\n    __pf(*this);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(basic_streambuf<char_type, traits_type>* __sb)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            if (__sb)\n            {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                    typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n                    typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n                    _Ip __i(__sb);\n                    _Ip __eof;\n                    _Op __o(*this);\n                    size_t __c = 0;\n                    for (; __i != __eof; ++__i, ++__o, ++__c)\n                    {\n                        *__o = *__i;\n                        if (__o.failed())\n                            break;\n                    }\n                    if (__c == 0)\n                        this->setstate(ios_base::failbit);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    this->__set_failbit_and_consider_rethrow();\n                }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            else\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(bool __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(short __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(),\n                        __flags == ios_base::oct || __flags == ios_base::hex ?\n                        static_cast<long>(static_cast<unsigned short>(__n))  :\n                        static_cast<long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned short __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(int __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            ios_base::fmtflags __flags = ios_base::flags() & ios_base::basefield;\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(),\n                        __flags == ios_base::oct || __flags == ios_base::hex ?\n                        static_cast<long>(static_cast<unsigned int>(__n))  :\n                        static_cast<long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned int __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<unsigned long>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(unsigned long long __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(float __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), static_cast<double>(__n)).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(double __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(long double __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::operator<<(const void* __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef num_put<char_type, ostreambuf_iterator<char_type, traits_type> > _Fp;\n            const _Fp& __f = use_facet<_Fp>(this->getloc());\n            if (__f.put(*this, *this, this->fill(), __n).failed())\n                this->setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\n__put_character_sequence(basic_ostream<_CharT, _Traits>& __os,\n                          const _CharT* __str, size_t __len)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 __str,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __str + __len :\n                                     __str,\n                                 __str + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, _CharT __c)\n{\n    return _VSTD::__put_character_sequence(__os, &__c, 1);\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, char __cn)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            _CharT __c = __os.widen(__cn);\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            if (__pad_and_output(_Ip(__os),\n                                 &__c,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     &__c + 1 :\n                                     &__c,\n                                 &__c + 1,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, char __c)\n{\n    return _VSTD::__put_character_sequence(__os, &__c, 1);\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, signed char __c)\n{\n    return _VSTD::__put_character_sequence(__os, (char *) &__c, 1);\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, unsigned char __c)\n{\n    return _VSTD::__put_character_sequence(__os, (char *) &__c, 1);\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const _CharT* __str)\n{\n    return _VSTD::__put_character_sequence(__os, __str, _Traits::length(__str));\n}\n\ntemplate<class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const char* __strn)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Ip;\n            size_t __len = char_traits<char>::length(__strn);\n            const int __bs = 100;\n            _CharT __wbb[__bs];\n            _CharT* __wb = __wbb;\n            unique_ptr<_CharT, void(*)(void*)> __h(0, free);\n            if (__len > __bs)\n            {\n                __wb = (_CharT*)malloc(__len*sizeof(_CharT));\n                if (__wb == 0)\n                    __throw_bad_alloc();\n                __h.reset(__wb);\n            }\n            for (_CharT* __p = __wb; *__strn != '\\0'; ++__strn, ++__p)\n                *__p = __os.widen(*__strn);\n            if (__pad_and_output(_Ip(__os),\n                                 __wb,\n                                 (__os.flags() & ios_base::adjustfield) == ios_base::left ?\n                                     __wb + __len :\n                                     __wb,\n                                 __wb + __len,\n                                 __os,\n                                 __os.fill()).failed())\n                __os.setstate(ios_base::badbit | ios_base::failbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const char* __str)\n{\n    return _VSTD::__put_character_sequence(__os, __str, _Traits::length(__str));\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const signed char* __str)\n{\n    const char *__s = (const char *) __str;\n    return _VSTD::__put_character_sequence(__os, __s, _Traits::length(__s));\n}\n\ntemplate<class _Traits>\nbasic_ostream<char, _Traits>&\noperator<<(basic_ostream<char, _Traits>& __os, const unsigned char* __str)\n{\n    const char *__s = (const char *) __str;\n    return _VSTD::__put_character_sequence(__os, __s, _Traits::length(__s));\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::put(char_type __c)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __s(*this);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n            _Op __o(*this);\n            *__o = __c;\n            if (__o.failed())\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::write(const char_type* __s, streamsize __n)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        sentry __sen(*this);\n        if (__sen && __n)\n        {\n            if (this->rdbuf()->sputn(__s, __n) != __n)\n                this->setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::flush()\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        if (this->rdbuf())\n        {\n            sentry __s(*this);\n            if (__s)\n            {\n                if (this->rdbuf()->pubsync() == -1)\n                    this->setstate(ios_base::badbit);\n            }\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        this->__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_ostream<_CharT, _Traits>::pos_type\nbasic_ostream<_CharT, _Traits>::tellp()\n{\n    if (this->fail())\n        return pos_type(-1);\n    return this->rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::seekp(pos_type __pos)\n{\n    sentry __s(*this);\n    if (__s)\n    {\n        if (this->rdbuf()->pubseekpos(__pos, ios_base::out) == pos_type(-1))\n            this->setstate(ios_base::failbit);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nbasic_ostream<_CharT, _Traits>::seekp(off_type __off, ios_base::seekdir __dir)\n{\n    sentry __s(*this);\n    if (__s)\n    {\n        if (this->rdbuf()->pubseekoff(__off, __dir, ios_base::out) == pos_type(-1))\n            this->setstate(ios_base::failbit);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nendl(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.put(__os.widen('\\n'));\n    __os.flush();\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nends(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.put(_CharT());\n    return __os;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\nflush(basic_ostream<_CharT, _Traits>& __os)\n{\n    __os.flush();\n    return __os;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Stream, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_lvalue_reference<_Stream>::value &&\n    is_base_of<ios_base, _Stream>::value,\n    _Stream&&\n>::type\noperator<<(_Stream&& __os, const _Tp& __x)\n{\n    __os << __x;\n    return _VSTD::move(__os);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str)\n{\n    return _VSTD::__put_character_sequence(__os, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const error_code& __ec)\n{\n    return __os << __ec.category().name() << ':' << __ec.value();\n}\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p)\n{\n    return __os << __p.get();\n}\n\ntemplate <class _CharT, class _Traits, size_t _Size>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const bitset<_Size>& __x)\n{\n    return __os << __x.template to_string<_CharT, _Traits>\n                        (use_facet<ctype<_CharT> >(__os.getloc()).widen('0'),\n                         use_facet<ctype<_CharT> >(__os.getloc()).widen('1'));\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_ostream<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_ostream<wchar_t>)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_OSTREAM\n","// -*- C++ -*-\n//===-------------------------- memory ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_MEMORY\n#define _LIBCPP_MEMORY\n\n/*\n    memory synopsis\n\nnamespace std\n{\n\nstruct allocator_arg_t { };\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n\ntemplate <class T, class Alloc> struct uses_allocator;\n\ntemplate <class Ptr>\nstruct pointer_traits\n{\n    typedef Ptr pointer;\n    typedef <details> element_type;\n    typedef <details> difference_type;\n\n    template <class U> using rebind = <details>;\n\n    static pointer pointer_to(<details>);\n};\n\ntemplate <class T>\nstruct pointer_traits<T*>\n{\n    typedef T* pointer;\n    typedef T element_type;\n    typedef ptrdiff_t difference_type;\n\n    template <class U> using rebind = U*;\n\n    static pointer pointer_to(<details>) noexcept;\n};\n\ntemplate <class Alloc>\nstruct allocator_traits\n{\n    typedef Alloc                        allocator_type;\n    typedef typename allocator_type::value_type\n                                         value_type;\n\n    typedef Alloc::pointer | value_type* pointer;\n    typedef Alloc::const_pointer\n          | pointer_traits<pointer>::rebind<const value_type>\n                                         const_pointer;\n    typedef Alloc::void_pointer\n          | pointer_traits<pointer>::rebind<void>\n                                         void_pointer;\n    typedef Alloc::const_void_pointer\n          | pointer_traits<pointer>::rebind<const void>\n                                         const_void_pointer;\n    typedef Alloc::difference_type\n          | pointer_traits<pointer>::difference_type\n                                         difference_type;\n    typedef Alloc::size_type\n          | make_unsigned<difference_type>::type\n                                         size_type;\n    typedef Alloc::propagate_on_container_copy_assignment\n          | false_type                   propagate_on_container_copy_assignment;\n    typedef Alloc::propagate_on_container_move_assignment\n          | false_type                   propagate_on_container_move_assignment;\n    typedef Alloc::propagate_on_container_swap\n          | false_type                   propagate_on_container_swap;\n\n    template <class T> using rebind_alloc  = Alloc::rebind<U>::other | Alloc<T, Args...>;\n    template <class T> using rebind_traits = allocator_traits<rebind_alloc<T>>;\n\n    static pointer allocate(allocator_type& a, size_type n);\n    static pointer allocate(allocator_type& a, size_type n, const_void_pointer hint);\n\n    static void deallocate(allocator_type& a, pointer p, size_type n) noexcept;\n\n    template <class T, class... Args>\n        static void construct(allocator_type& a, T* p, Args&&... args);\n\n    template <class T>\n        static void destroy(allocator_type& a, T* p);\n\n    static size_type max_size(const allocator_type& a); // noexcept in C++14\n\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& a);\n};\n\ntemplate <>\nclass allocator<void>\n{\npublic:\n    typedef void*                                 pointer;\n    typedef const void*                           const_pointer;\n    typedef void                                  value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <class T>\nclass allocator\n{\npublic:\n    typedef size_t                                size_type;\n    typedef ptrdiff_t                             difference_type;\n    typedef T*                                    pointer;\n    typedef const T*                              const_pointer;\n    typedef typename add_lvalue_reference<T>::type       reference;\n    typedef typename add_lvalue_reference<const T>::type const_reference;\n    typedef T                                     value_type;\n\n    template <class U> struct rebind {typedef allocator<U> other;};\n\n    allocator() noexcept;\n    allocator(const allocator&) noexcept;\n    template <class U> allocator(const allocator<U>&) noexcept;\n    ~allocator();\n    pointer address(reference x) const noexcept;\n    const_pointer address(const_reference x) const noexcept;\n    pointer allocate(size_type, allocator<void>::const_pointer hint = 0);\n    void deallocate(pointer p, size_type n) noexcept;\n    size_type max_size() const noexcept;\n    template<class U, class... Args>\n        void construct(U* p, Args&&... args);\n    template <class U>\n        void destroy(U* p);\n};\n\ntemplate <class T, class U>\nbool operator==(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class T, class U>\nbool operator!=(const allocator<T>&, const allocator<U>&) noexcept;\n\ntemplate <class OutputIterator, class T>\nclass raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      T,                               // purposefully not C++03\n                      ptrdiff_t,                       // purposefully not C++03\n                      T*,                              // purposefully not C++03\n                      raw_storage_iterator&>           // purposefully not C++03\n{\npublic:\n    explicit raw_storage_iterator(OutputIterator x);\n    raw_storage_iterator& operator*();\n    raw_storage_iterator& operator=(const T& element);\n    raw_storage_iterator& operator++();\n    raw_storage_iterator  operator++(int);\n};\n\ntemplate <class T> pair<T*,ptrdiff_t> get_temporary_buffer(ptrdiff_t n) noexcept;\ntemplate <class T> void               return_temporary_buffer(T* p) noexcept;\n\ntemplate <class T> T* addressof(T& r) noexcept;\n\ntemplate <class InputIterator, class ForwardIterator>\nForwardIterator\nuninitialized_copy(InputIterator first, InputIterator last, ForwardIterator result);\n\ntemplate <class InputIterator, class Size, class ForwardIterator>\nForwardIterator\nuninitialized_copy_n(InputIterator first, Size n, ForwardIterator result);\n\ntemplate <class ForwardIterator, class T>\nvoid uninitialized_fill(ForwardIterator first, ForwardIterator last, const T& x);\n\ntemplate <class ForwardIterator, class Size, class T>\nForwardIterator\nuninitialized_fill_n(ForwardIterator first, Size n, const T& x);\n\ntemplate <class Y> struct auto_ptr_ref {};\n\ntemplate<class X>\nclass auto_ptr\n{\npublic:\n    typedef X element_type;\n\n    explicit auto_ptr(X* p =0) throw();\n    auto_ptr(auto_ptr&) throw();\n    template<class Y> auto_ptr(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr&) throw();\n    template<class Y> auto_ptr& operator=(auto_ptr<Y>&) throw();\n    auto_ptr& operator=(auto_ptr_ref<X> r) throw();\n    ~auto_ptr() throw();\n\n    typename add_lvalue_reference<X>::type operator*() const throw();\n    X* operator->() const throw();\n    X* get() const throw();\n    X* release() throw();\n    void reset(X* p =0) throw();\n\n    auto_ptr(auto_ptr_ref<X>) throw();\n    template<class Y> operator auto_ptr_ref<Y>() throw();\n    template<class Y> operator auto_ptr<Y>() throw();\n};\n\ntemplate <class T>\nstruct default_delete\n{\n    constexpr default_delete() noexcept = default;\n    template <class U> default_delete(const default_delete<U>&) noexcept;\n\n    void operator()(T*) const noexcept;\n};\n\ntemplate <class T>\nstruct default_delete<T[]>\n{\n    constexpr default_delete() noexcept = default;\n    void operator()(T*) const noexcept;\n    template <class U> void operator()(U*) const = delete;\n};\n\ntemplate <class T, class D = default_delete<T>>\nclass unique_ptr\n{\npublic:\n    typedef see below pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d1) noexcept;\n    unique_ptr(pointer p, see below d2) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n    template <class U, class E>\n        unique_ptr(unique_ptr<U, E>&& u) noexcept;\n    template <class U>\n        unique_ptr(auto_ptr<U>&& u) noexcept;\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    template <class U, class E> unique_ptr& operator=(unique_ptr<U, E>&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    typename add_lvalue_reference<T>::type operator*() const;\n    pointer operator->() const noexcept;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\nclass unique_ptr<T[], D>\n{\npublic:\n    typedef implementation-defined pointer;\n    typedef T element_type;\n    typedef D deleter_type;\n\n    // constructors\n    constexpr unique_ptr() noexcept;\n    explicit unique_ptr(pointer p) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(pointer p, see below d) noexcept;\n    unique_ptr(unique_ptr&& u) noexcept;\n    unique_ptr(nullptr_t) noexcept : unique_ptr() { }\n\n    // destructor\n    ~unique_ptr();\n\n    // assignment\n    unique_ptr& operator=(unique_ptr&& u) noexcept;\n    unique_ptr& operator=(nullptr_t) noexcept;\n\n    // observers\n    T& operator[](size_t i) const;\n    pointer get() const noexcept;\n    deleter_type& get_deleter() noexcept;\n    const deleter_type& get_deleter() const noexcept;\n    explicit operator bool() const noexcept;\n\n    // modifiers\n    pointer release() noexcept;\n    void reset(pointer p = pointer()) noexcept;\n    void reset(nullptr_t) noexcept;\n    template <class U> void reset(U) = delete;\n    void swap(unique_ptr& u) noexcept;\n};\n\ntemplate <class T, class D>\n    void swap(unique_ptr<T, D>& x, unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator==(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator!=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator<=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\ntemplate <class T1, class D1, class T2, class D2>\n    bool operator>=(const unique_ptr<T1, D1>& x, const unique_ptr<T2, D2>& y);\n\ntemplate <class T, class D>\n    bool operator==(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator==(nullptr_t, const unique_ptr<T, D>& y) noexcept;\ntemplate <class T, class D>\n    bool operator!=(const unique_ptr<T, D>& x, nullptr_t) noexcept;\ntemplate <class T, class D>\n    bool operator!=(nullptr_t, const unique_ptr<T, D>& y) noexcept;\n\ntemplate <class T, class D>\n    bool operator<(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator<=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator<=(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>(nullptr_t, const unique_ptr<T, D>& y);\ntemplate <class T, class D>\n    bool operator>=(const unique_ptr<T, D>& x, nullptr_t);\ntemplate <class T, class D>\n    bool operator>=(nullptr_t, const unique_ptr<T, D>& y);\n\nclass bad_weak_ptr\n    : public std::exception\n{\n    bad_weak_ptr() noexcept;\n};\n\ntemplate<class T, class... Args> unique_ptr<T> make_unique(Args&&... args);     // C++14\ntemplate<class T>                unique_ptr<T> make_unique(size_t n);           // C++14\ntemplate<class T, class... Args> unspecified   make_unique(Args&&...) = delete; // C++14, T == U[N]\n\ntemplate<class T>\nclass shared_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors:\n    constexpr shared_ptr() noexcept;\n    template<class Y> explicit shared_ptr(Y* p);\n    template<class Y, class D> shared_ptr(Y* p, D d);\n    template<class Y, class D, class A> shared_ptr(Y* p, D d, A a);\n    template <class D> shared_ptr(nullptr_t p, D d);\n    template <class D, class A> shared_ptr(nullptr_t p, D d, A a);\n    template<class Y> shared_ptr(const shared_ptr<Y>& r, T *p) noexcept;\n    shared_ptr(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr(const shared_ptr<Y>& r) noexcept;\n    shared_ptr(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr(shared_ptr<Y>&& r) noexcept;\n    template<class Y> explicit shared_ptr(const weak_ptr<Y>& r);\n    template<class Y> shared_ptr(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr(unique_ptr<Y, D>&& r);\n    shared_ptr(nullptr_t) : shared_ptr() { }\n\n    // destructor:\n    ~shared_ptr();\n\n    // assignment:\n    shared_ptr& operator=(const shared_ptr& r) noexcept;\n    template<class Y> shared_ptr& operator=(const shared_ptr<Y>& r) noexcept;\n    shared_ptr& operator=(shared_ptr&& r) noexcept;\n    template<class Y> shared_ptr& operator=(shared_ptr<Y>&& r);\n    template<class Y> shared_ptr& operator=(auto_ptr<Y>&& r);\n    template <class Y, class D> shared_ptr& operator=(unique_ptr<Y, D>&& r);\n\n    // modifiers:\n    void swap(shared_ptr& r) noexcept;\n    void reset() noexcept;\n    template<class Y> void reset(Y* p);\n    template<class Y, class D> void reset(Y* p, D d);\n    template<class Y, class D, class A> void reset(Y* p, D d, A a);\n\n    // observers:\n    T* get() const noexcept;\n    T& operator*() const noexcept;\n    T* operator->() const noexcept;\n    long use_count() const noexcept;\n    bool unique() const noexcept;\n    explicit operator bool() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// shared_ptr comparisons:\ntemplate<class T, class U>\n    bool operator==(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator!=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator<=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\ntemplate<class T, class U>\n    bool operator>=(shared_ptr<T> const& a, shared_ptr<U> const& b) noexcept;\n\ntemplate <class T>\n    bool operator==(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator==(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator!=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator!=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\nbool operator<(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator<=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator<=(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>(nullptr_t, const shared_ptr<T>& y) noexcept;\ntemplate <class T>\n    bool operator>=(const shared_ptr<T>& x, nullptr_t) noexcept;\ntemplate <class T>\n    bool operator>=(nullptr_t, const shared_ptr<T>& y) noexcept;\n\n// shared_ptr specialized algorithms:\ntemplate<class T> void swap(shared_ptr<T>& a, shared_ptr<T>& b) noexcept;\n\n// shared_ptr casts:\ntemplate<class T, class U>\n    shared_ptr<T> static_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> dynamic_pointer_cast(shared_ptr<U> const& r) noexcept;\ntemplate<class T, class U>\n    shared_ptr<T> const_pointer_cast(shared_ptr<U> const& r) noexcept;\n\n// shared_ptr I/O:\ntemplate<class E, class T, class Y>\n    basic_ostream<E, T>& operator<< (basic_ostream<E, T>& os, shared_ptr<Y> const& p);\n\n// shared_ptr get_deleter:\ntemplate<class D, class T> D* get_deleter(shared_ptr<T> const& p) noexcept;\n\ntemplate<class T, class... Args>\n    shared_ptr<T> make_shared(Args&&... args);\ntemplate<class T, class A, class... Args>\n    shared_ptr<T> allocate_shared(const A& a, Args&&... args);\n\ntemplate<class T>\nclass weak_ptr\n{\npublic:\n    typedef T element_type;\n\n    // constructors\n    constexpr weak_ptr() noexcept;\n    template<class Y> weak_ptr(shared_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr(weak_ptr<Y> const& r) noexcept;\n    weak_ptr(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // destructor\n    ~weak_ptr();\n\n    // assignment\n    weak_ptr& operator=(weak_ptr const& r) noexcept;\n    template<class Y> weak_ptr& operator=(weak_ptr<Y> const& r) noexcept;\n    template<class Y> weak_ptr& operator=(shared_ptr<Y> const& r) noexcept;\n    weak_ptr& operator=(weak_ptr&& r) noexcept;                      // C++14\n    template<class Y> weak_ptr& operator=(weak_ptr<Y>&& r) noexcept; // C++14\n\n    // modifiers\n    void swap(weak_ptr& r) noexcept;\n    void reset() noexcept;\n\n    // observers\n    long use_count() const noexcept;\n    bool expired() const noexcept;\n    shared_ptr<T> lock() const noexcept;\n    template<class U> bool owner_before(shared_ptr<U> const& b) const;\n    template<class U> bool owner_before(weak_ptr<U> const& b) const;\n};\n\n// weak_ptr specialized algorithms:\ntemplate<class T> void swap(weak_ptr<T>& a, weak_ptr<T>& b) noexcept;\n\n// class owner_less:\ntemplate<class T> struct owner_less;\n\ntemplate<class T>\nstruct owner_less<shared_ptr<T>>\n    : binary_function<shared_ptr<T>, shared_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(shared_ptr<T> const&, shared_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nstruct owner_less<weak_ptr<T>>\n    : binary_function<weak_ptr<T>, weak_ptr<T>, bool>\n{\n    typedef bool result_type;\n    bool operator()(weak_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(shared_ptr<T> const&, weak_ptr<T> const&) const;\n    bool operator()(weak_ptr<T> const&, shared_ptr<T> const&) const;\n};\n\ntemplate<class T>\nclass enable_shared_from_this\n{\nprotected:\n    constexpr enable_shared_from_this() noexcept;\n    enable_shared_from_this(enable_shared_from_this const&) noexcept;\n    enable_shared_from_this& operator=(enable_shared_from_this const&) noexcept;\n    ~enable_shared_from_this();\npublic:\n    shared_ptr<T> shared_from_this();\n    shared_ptr<T const> shared_from_this() const;\n};\n\ntemplate<class T>\n    bool atomic_is_lock_free(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load(const shared_ptr<T>* p);\ntemplate<class T>\n    shared_ptr<T> atomic_load_explicit(const shared_ptr<T>* p, memory_order mo);\ntemplate<class T>\n    void atomic_store(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    void atomic_store_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    shared_ptr<T> atomic_exchange(shared_ptr<T>* p, shared_ptr<T> r);\ntemplate<class T>\n    shared_ptr<T>\n    atomic_exchange_explicit(shared_ptr<T>* p, shared_ptr<T> r, memory_order mo);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak(shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong( shared_ptr<T>* p, shared_ptr<T>* v, shared_ptr<T> w);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_weak_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                          shared_ptr<T> w, memory_order success,\n                                          memory_order failure);\ntemplate<class T>\n    bool\n    atomic_compare_exchange_strong_explicit(shared_ptr<T>* p, shared_ptr<T>* v,\n                                            shared_ptr<T> w, memory_order success,\n                                            memory_order failure);\n// Hash support\ntemplate <class T> struct hash;\ntemplate <class T, class D> struct hash<unique_ptr<T, D> >;\ntemplate <class T> struct hash<shared_ptr<T> >;\n\n// Pointer safety\nenum class pointer_safety { relaxed, preferred, strict };\nvoid declare_reachable(void *p);\ntemplate <class T> T *undeclare_reachable(T *p);\nvoid declare_no_pointers(char *p, size_t n);\nvoid undeclare_no_pointers(char *p, size_t n);\npointer_safety get_pointer_safety() noexcept;\n\nvoid* align(size_t alignment, size_t size, void*& ptr, size_t& space);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <cstddef>\n#include <cstdint>\n#include <new>\n#include <utility>\n#include <limits>\n#include <iterator>\n#include <__functional_base>\n#include <iosfwd>\n#include <tuple>\n#include <cstring>\n#if defined(_LIBCPP_NO_EXCEPTIONS)\n    #include <cassert>\n#endif\n\n#if __has_feature(cxx_atomic) && !defined(_LIBCPP_HAS_NO_THREADS)\n#  include <atomic>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// addressof moved to <__functional_base>\n\ntemplate <class _Tp> class allocator;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<void>\n{\npublic:\n    typedef void*             pointer;\n    typedef const void*       const_pointer;\n    typedef void              value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<const void>\n{\npublic:\n    typedef const void*       pointer;\n    typedef const void*       const_pointer;\n    typedef const void        value_type;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n};\n\n// pointer_traits\n\ntemplate <class _Tp>\nstruct __has_element_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::element_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_element_type<_Ptr>::value>\nstruct __pointer_traits_element_type;\n\ntemplate <class _Ptr>\nstruct __pointer_traits_element_type<_Ptr, true>\n{\n    typedef typename _Ptr::element_type type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, true>\n{\n    typedef typename _Sp<_Tp, _Args...>::element_type type;\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args>\nstruct __pointer_traits_element_type<_Sp<_Tp, _Args...>, false>\n{\n    typedef _Tp type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, true>\n{\n    typedef typename _Sp<_Tp>::element_type type;\n};\n\ntemplate <template <class> class _Sp, class _Tp>\nstruct __pointer_traits_element_type<_Sp<_Tp>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, true>\n{\n    typedef typename _Sp<_Tp, _A0>::element_type type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1>::element_type type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0, class _A1>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1>, false>\n{\n    typedef _Tp type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, true>\n{\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::element_type type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                           class _A1, class _A2>\nstruct __pointer_traits_element_type<_Sp<_Tp, _A0, _A1, _A2>, false>\n{\n    typedef _Tp type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __has_difference_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::difference_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, bool = __has_difference_type<_Ptr>::value>\nstruct __pointer_traits_difference_type\n{\n    typedef ptrdiff_t type;\n};\n\ntemplate <class _Ptr>\nstruct __pointer_traits_difference_type<_Ptr, true>\n{\n    typedef typename _Ptr::difference_type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __pointer_traits_rebind\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Tp::template rebind<_Up> type;\n#else\n    typedef typename _Tp::template rebind<_Up>::other type;\n#endif\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _Args...>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class...> class _Sp, class _Tp, class ..._Args, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _Args...>, _Up, false>\n{\n    typedef _Sp<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class> class _Sp, class _Tp, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp>, _Up, false>\n{\n    typedef _Sp<_Up> type;\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class> class _Sp, class _Tp, class _A0, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0>, _Up, false>\n{\n    typedef _Sp<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class> class _Sp, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up> type;\n#else\n    typedef typename _Sp<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n#endif\n};\n\ntemplate <template <class, class, class, class> class _Sp, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __pointer_traits_rebind<_Sp<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Sp<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Ptr>\nstruct _LIBCPP_TYPE_VIS_ONLY pointer_traits\n{\n    typedef _Ptr                                                     pointer;\n    typedef typename __pointer_traits_element_type<pointer>::type    element_type;\n    typedef typename __pointer_traits_difference_type<pointer>::type difference_type;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Up> using rebind = typename __pointer_traits_rebind<pointer, _Up>::type;\n#else\n    template <class _Up> struct rebind\n        {typedef typename __pointer_traits_rebind<pointer, _Up>::type other;};\n#endif  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                           __nat, element_type>::type& __r)\n        {return pointer::pointer_to(__r);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY pointer_traits<_Tp*>\n{\n    typedef _Tp*      pointer;\n    typedef _Tp       element_type;\n    typedef ptrdiff_t difference_type;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Up> using rebind = _Up*;\n#else\n    template <class _Up> struct rebind {typedef _Up* other;};\n#endif\n\nprivate:\n    struct __nat {};\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer pointer_to(typename conditional<is_void<element_type>::value,\n                                      __nat, element_type>::type& __r) _NOEXCEPT\n        {return _VSTD::addressof(__r);}\n};\n\n// allocator_traits\n\nnamespace __has_pointer_type_imp\n{\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::pointer* = 0);\n}\n\ntemplate <class _Tp>\nstruct __has_pointer_type\n    : public integral_constant<bool, sizeof(__has_pointer_type_imp::__test<_Tp>(0)) == 1>\n{\n};\n\nnamespace __pointer_type_imp\n{\n\ntemplate <class _Tp, class _Dp, bool = __has_pointer_type<_Dp>::value>\nstruct __pointer_type\n{\n    typedef typename _Dp::pointer type;\n};\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type<_Tp, _Dp, false>\n{\n    typedef _Tp* type;\n};\n\n}  // __pointer_type_imp\n\ntemplate <class _Tp, class _Dp>\nstruct __pointer_type\n{\n    typedef typename __pointer_type_imp::__pointer_type<_Tp, typename remove_reference<_Dp>::type>::type type;\n};\n\ntemplate <class _Tp>\nstruct __has_const_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc, bool = __has_const_pointer<_Alloc>::value>\nstruct __const_pointer\n{\n    typedef typename _Alloc::const_pointer type;\n};\n\ntemplate <class _Tp, class _Ptr, class _Alloc>\nstruct __const_pointer<_Tp, _Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const _Tp>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_void_pointer<_Alloc>::value>\nstruct __void_pointer\n{\n    typedef typename _Alloc::void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __has_const_void_pointer\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::const_void_pointer* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Ptr, class _Alloc, bool = __has_const_void_pointer<_Alloc>::value>\nstruct __const_void_pointer\n{\n    typedef typename _Alloc::const_void_pointer type;\n};\n\ntemplate <class _Ptr, class _Alloc>\nstruct __const_void_pointer<_Ptr, _Alloc, false>\n{\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    typedef typename pointer_traits<_Ptr>::template rebind<const void> type;\n#else\n    typedef typename pointer_traits<_Ptr>::template rebind<const void>::other type;\n#endif\n};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\n__to_raw_pointer(_Tp* __p) _NOEXCEPT\n{\n    return __p;\n}\n\ntemplate <class _Pointer>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename pointer_traits<_Pointer>::element_type*\n__to_raw_pointer(_Pointer __p) _NOEXCEPT\n{\n    return _VSTD::__to_raw_pointer(__p.operator->());\n}\n\ntemplate <class _Tp>\nstruct __has_size_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::size_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, class _DiffType, bool = __has_size_type<_Alloc>::value>\nstruct __size_type\n{\n    typedef typename make_unsigned<_DiffType>::type type;\n};\n\ntemplate <class _Alloc, class _DiffType>\nstruct __size_type<_Alloc, _DiffType, true>\n{\n    typedef typename _Alloc::size_type type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_copy_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_copy_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_copy_assignment<_Alloc>::value>\nstruct __propagate_on_container_copy_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_copy_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_copy_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_move_assignment\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_move_assignment* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_move_assignment<_Alloc>::value>\nstruct __propagate_on_container_move_assignment\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_move_assignment<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_move_assignment type;\n};\n\ntemplate <class _Tp>\nstruct __has_propagate_on_container_swap\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::propagate_on_container_swap* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Alloc, bool = __has_propagate_on_container_swap<_Alloc>::value>\nstruct __propagate_on_container_swap\n{\n    typedef false_type type;\n};\n\ntemplate <class _Alloc>\nstruct __propagate_on_container_swap<_Alloc, true>\n{\n    typedef typename _Alloc::propagate_on_container_swap type;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind<_Tp, _Up>::value>\nstruct __has_rebind_other\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Xp> static __two __test(...);\n    template <class _Xp> static char __test(typename _Xp::template rebind<_Up>::other* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __has_rebind_other<_Tp, _Up, false>\n{\n    static const bool value = false;\n};\n\ntemplate <class _Tp, class _Up, bool = __has_rebind_other<_Tp, _Up>::value>\nstruct __allocator_traits_rebind\n{\n    typedef typename _Tp::template rebind<_Up>::other type;\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _Args...>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class...> class _Alloc, class _Tp, class ..._Args, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _Args...>, _Up, false>\n{\n    typedef _Alloc<_Up, _Args...> type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, true>\n{\n    typedef typename _Alloc<_Tp>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class> class _Alloc, class _Tp, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp>, _Up, false>\n{\n    typedef _Alloc<_Up> type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class> class _Alloc, class _Tp, class _A0, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0> type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class> class _Alloc, class _Tp, class _A0,\n                                         class _A1, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1> type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, true>\n{\n    typedef typename _Alloc<_Tp, _A0, _A1, _A2>::template rebind<_Up>::other type;\n};\n\ntemplate <template <class, class, class, class> class _Alloc, class _Tp, class _A0,\n                                                class _A1, class _A2, class _Up>\nstruct __allocator_traits_rebind<_Alloc<_Tp, _A0, _A1, _A2>, _Up, false>\n{\n    typedef _Alloc<_Up, _A0, _A1, _A2> type;\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(_Alloc&& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> decltype(__a.allocate(__sz, __p), true_type());\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nauto\n__has_allocate_hint_test(const _Alloc& __a, _SizeType&& __sz, _ConstVoidPtr&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_allocate_hint_test(declval<_Alloc>(),\n                                          declval<_SizeType>(),\n                                          declval<_ConstVoidPtr>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _SizeType, class _ConstVoidPtr>\nstruct __has_allocate_hint\n    : true_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n#if !defined(_LIBCPP_HAS_NO_ADVANCED_SFINAE) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\ntemplate <class _Alloc, class _Tp, class ..._Args>\ndecltype(_VSTD::declval<_Alloc>().construct(_VSTD::declval<_Tp*>(),\n                                           _VSTD::declval<_Args>()...),\n                                           true_type())\n__has_construct_test(_Alloc&& __a, _Tp* __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nfalse_type\n__has_construct_test(const _Alloc& __a, _Pointer&& __p, _Args&& ...__args);\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_construct_test(declval<_Alloc>(),\n                                          declval<_Pointer>(),\n                                          declval<_Args>()...)),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(_Alloc&& __a, _Pointer&& __p)\n    -> decltype(__a.destroy(__p), true_type());\n\ntemplate <class _Alloc, class _Pointer>\nauto\n__has_destroy_test(const _Alloc& __a, _Pointer&& __p)\n    -> false_type;\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_destroy_test(declval<_Alloc>(),\n                                        declval<_Pointer>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(_Alloc&& __a)\n    -> decltype(__a.max_size(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_max_size_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_max_size_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(_Alloc&& __a)\n    -> decltype(__a.select_on_container_copy_construction(), true_type());\n\ntemplate <class _Alloc>\nauto\n__has_select_on_container_copy_construction_test(const volatile _Alloc& __a)\n    -> false_type;\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : integral_constant<bool,\n        is_same<\n            decltype(__has_select_on_container_copy_construction_test(declval<_Alloc&>())),\n            true_type>::value>\n{\n};\n\n#else  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class ..._Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer, class _Args>\nstruct __has_construct\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Alloc, class _Pointer>\nstruct __has_destroy\n    : false_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_max_size\n    : true_type\n{\n};\n\ntemplate <class _Alloc>\nstruct __has_select_on_container_copy_construction\n    : false_type\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Alloc, class _Ptr, bool = __has_difference_type<_Alloc>::value>\nstruct __alloc_traits_difference_type\n{\n    typedef typename pointer_traits<_Ptr>::difference_type type;\n};\n\ntemplate <class _Alloc, class _Ptr>\nstruct __alloc_traits_difference_type<_Alloc, _Ptr, true>\n{\n    typedef typename _Alloc::difference_type type;\n};\n\ntemplate <class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY allocator_traits\n{\n    typedef _Alloc                              allocator_type;\n    typedef typename allocator_type::value_type value_type;\n\n    typedef typename __pointer_type<value_type, allocator_type>::type pointer;\n    typedef typename __const_pointer<value_type, pointer, allocator_type>::type const_pointer;\n    typedef typename __void_pointer<pointer, allocator_type>::type void_pointer;\n    typedef typename __const_void_pointer<pointer, allocator_type>::type const_void_pointer;\n\n    typedef typename __alloc_traits_difference_type<allocator_type, pointer>::type difference_type;\n    typedef typename __size_type<allocator_type, difference_type>::type size_type;\n\n    typedef typename __propagate_on_container_copy_assignment<allocator_type>::type\n                     propagate_on_container_copy_assignment;\n    typedef typename __propagate_on_container_move_assignment<allocator_type>::type\n                     propagate_on_container_move_assignment;\n    typedef typename __propagate_on_container_swap<allocator_type>::type\n                     propagate_on_container_swap;\n\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Tp> using rebind_alloc =\n                  typename __allocator_traits_rebind<allocator_type, _Tp>::type;\n    template <class _Tp> using rebind_traits = allocator_traits<rebind_alloc<_Tp>>;\n#else  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n    template <class _Tp> struct rebind_alloc\n        {typedef typename __allocator_traits_rebind<allocator_type, _Tp>::type other;};\n    template <class _Tp> struct rebind_traits\n        {typedef allocator_traits<typename rebind_alloc<_Tp>::other> other;};\n#endif  // _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n)\n        {return __a.allocate(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n, const_void_pointer __hint)\n        {return allocate(__a, __n, __hint,\n            __has_allocate_hint<allocator_type, size_type, const_void_pointer>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void deallocate(allocator_type& __a, pointer __p, size_type __n) _NOEXCEPT\n        {__a.deallocate(__p, __n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__construct(__has_construct<allocator_type, pointer, _Args...>(),\n                         __a, __p, _VSTD::forward<_Args>(__args)...);}\n#else  // _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p)\n            {\n                ::new ((void*)__p) _Tp();\n            }\n    template <class _Tp, class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0)\n            {\n                ::new ((void*)__p) _Tp(__a0);\n            }\n    template <class _Tp, class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1);\n            }\n    template <class _Tp, class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        static void construct(allocator_type& __a, _Tp* __p, const _A0& __a0,\n                              const _A1& __a1, const _A2& __a2)\n            {\n                ::new ((void*)__p) _Tp(__a0, __a1, __a2);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void destroy(allocator_type& __a, _Tp* __p)\n            {__destroy(__has_destroy<allocator_type, _Tp*>(), __a, __p);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type max_size(const allocator_type& __a) _NOEXCEPT\n        {return __max_size(__has_max_size<const allocator_type>(), __a);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(const allocator_type& __a)\n            {return select_on_container_copy_construction(\n                __has_select_on_container_copy_construction<const allocator_type>(),\n                __a);}\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_forward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __begin2)\n        {\n            for (; __begin1 != __end1; ++__begin1, ++__begin2)\n                construct(__a, _VSTD::__to_raw_pointer(__begin2), _VSTD::move_if_noexcept(*__begin1));\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_forward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __begin2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            _VSTD::memcpy(__begin2, __begin1, _Np * sizeof(_Tp));\n            __begin2 += _Np;\n        }\n\n    template <class _Ptr>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        void\n        __construct_backward(allocator_type& __a, _Ptr __begin1, _Ptr __end1, _Ptr& __end2)\n        {\n            while (__end1 != __begin1)\n            {\n                construct(__a, _VSTD::__to_raw_pointer(__end2-1), _VSTD::move_if_noexcept(*--__end1));\n                --__end2;\n            }\n        }\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static\n        typename enable_if\n        <\n            (is_same<allocator_type, allocator<_Tp> >::value\n                || !__has_construct<allocator_type, _Tp*, _Tp>::value) &&\n             is_trivially_move_constructible<_Tp>::value,\n            void\n        >::type\n        __construct_backward(allocator_type& __a, _Tp* __begin1, _Tp* __end1, _Tp*& __end2)\n        {\n            ptrdiff_t _Np = __end1 - __begin1;\n            __end2 -= _Np;\n            _VSTD::memcpy(__end2, __begin1, _Np * sizeof(_Tp));\n        }\n\nprivate:\n\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer __hint, true_type)\n        {return __a.allocate(__n, __hint);}\n    _LIBCPP_INLINE_VISIBILITY\n    static pointer allocate(allocator_type& __a, size_type __n,\n        const_void_pointer, false_type)\n        {return __a.allocate(__n);}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(true_type, allocator_type& __a, _Tp* __p, _Args&&... __args)\n            {__a.construct(__p, _VSTD::forward<_Args>(__args)...);}\n    template <class _Tp, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __construct(false_type, allocator_type&, _Tp* __p, _Args&&... __args)\n            {\n                ::new ((void*)__p) _Tp(_VSTD::forward<_Args>(__args)...);\n            }\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(true_type, allocator_type& __a, _Tp* __p)\n            {__a.destroy(__p);}\n    template <class _Tp>\n        _LIBCPP_INLINE_VISIBILITY\n        static void __destroy(false_type, allocator_type&, _Tp* __p)\n            {\n                __p->~_Tp();\n            }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(true_type, const allocator_type& __a)\n            {return __a.max_size();}\n    _LIBCPP_INLINE_VISIBILITY\n    static size_type __max_size(false_type, const allocator_type&)\n            {return numeric_limits<size_type>::max();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(true_type, const allocator_type& __a)\n            {return __a.select_on_container_copy_construction();}\n    _LIBCPP_INLINE_VISIBILITY\n    static allocator_type\n        select_on_container_copy_construction(false_type, const allocator_type& __a)\n            {return __a;}\n};\n\n// allocator\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY allocator\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef _Tp*              pointer;\n    typedef const _Tp*        const_pointer;\n    typedef _Tp&              reference;\n    typedef const _Tp&        const_reference;\n    typedef _Tp               value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY pointer address(reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));}\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY allocator<const _Tp>\n{\npublic:\n    typedef size_t            size_type;\n    typedef ptrdiff_t         difference_type;\n    typedef const _Tp*        pointer;\n    typedef const _Tp*        const_pointer;\n    typedef const _Tp&        reference;\n    typedef const _Tp&        const_reference;\n    typedef const _Tp         value_type;\n\n    typedef true_type propagate_on_container_move_assignment;\n\n    template <class _Up> struct rebind {typedef allocator<_Up> other;};\n\n    _LIBCPP_INLINE_VISIBILITY allocator() _NOEXCEPT {}\n    template <class _Up> _LIBCPP_INLINE_VISIBILITY allocator(const allocator<_Up>&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY const_pointer address(const_reference __x) const _NOEXCEPT\n        {return _VSTD::addressof(__x);}\n    _LIBCPP_INLINE_VISIBILITY pointer allocate(size_type __n, allocator<void>::const_pointer = 0)\n        {return static_cast<pointer>(_VSTD::__allocate(__n * sizeof(_Tp)));}\n    _LIBCPP_INLINE_VISIBILITY void deallocate(pointer __p, size_type) _NOEXCEPT\n        {_VSTD::__deallocate((void*)__p);}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT\n        {return size_type(~0) / sizeof(_Tp);}\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class _Up, class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(_Up* __p, _Args&&... __args)\n        {\n            ::new((void*)__p) _Up(_VSTD::forward<_Args>(__args)...);\n        }\n#else  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p)\n        {\n            ::new((void*)__p) _Tp();\n        }\n# if defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0)\n        {\n            ::new((void*)__p) _Tp(__a0);\n        }\n# endif  // defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        construct(pointer __p, const _A0& __a0, const _A1& __a1)\n        {\n            ::new((void*)__p) _Tp(__a0, __a1);\n        }\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY void destroy(pointer __p) {__p->~_Tp();}\n};\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return true;}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const allocator<_Tp>&, const allocator<_Up>&) _NOEXCEPT {return false;}\n\ntemplate <class _OutputIterator, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY raw_storage_iterator\n    : public iterator<output_iterator_tag,\n                      _Tp,                                         // purposefully not C++03\n                      ptrdiff_t,                                   // purposefully not C++03\n                      _Tp*,                                        // purposefully not C++03\n                      raw_storage_iterator<_OutputIterator, _Tp>&> // purposefully not C++03\n{\nprivate:\n    _OutputIterator __x_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit raw_storage_iterator(_OutputIterator __x) : __x_(__x) {}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator*() {return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator=(const _Tp& __element)\n        {::new(&*__x_) _Tp(__element); return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator& operator++() {++__x_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY raw_storage_iterator  operator++(int)\n        {raw_storage_iterator __t(*this); ++__x_; return __t;}\n};\n\ntemplate <class _Tp>\npair<_Tp*, ptrdiff_t>\nget_temporary_buffer(ptrdiff_t __n) _NOEXCEPT\n{\n    pair<_Tp*, ptrdiff_t> __r(0, 0);\n    const ptrdiff_t __m = (~ptrdiff_t(0) ^\n                           ptrdiff_t(ptrdiff_t(1) << (sizeof(ptrdiff_t) * __CHAR_BIT__ - 1)))\n                           / sizeof(_Tp);\n    if (__n > __m)\n        __n = __m;\n    while (__n > 0)\n    {\n        __r.first = static_cast<_Tp*>(::operator new(__n * sizeof(_Tp), nothrow));\n        if (__r.first)\n        {\n            __r.second = __n;\n            break;\n        }\n        __n /= 2;\n    }\n    return __r;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid return_temporary_buffer(_Tp* __p) _NOEXCEPT {::operator delete(__p);}\n\ntemplate <class _Tp>\nstruct auto_ptr_ref\n{\n    _Tp* __ptr_;\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY auto_ptr\n{\nprivate:\n    _Tp* __ptr_;\npublic:\n    typedef _Tp element_type;\n\n    _LIBCPP_INLINE_VISIBILITY explicit auto_ptr(_Tp* __p = 0) throw() : __ptr_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr& __p) throw() : __ptr_(__p.release()) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr<_Up>& __p) throw()\n        : __ptr_(__p.release()) {}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr& __p) throw()\n        {reset(__p.release()); return *this;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr<_Up>& __p) throw()\n        {reset(__p.release()); return *this;}\n    _LIBCPP_INLINE_VISIBILITY auto_ptr& operator=(auto_ptr_ref<_Tp> __p) throw()\n        {reset(__p.__ptr_); return *this;}\n    _LIBCPP_INLINE_VISIBILITY ~auto_ptr() throw() {delete __ptr_;}\n\n    _LIBCPP_INLINE_VISIBILITY _Tp& operator*() const throw()\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* operator->() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* get() const throw() {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY _Tp* release() throw()\n    {\n        _Tp* __t = __ptr_;\n        __ptr_ = 0;\n        return __t;\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(_Tp* __p = 0) throw()\n    {\n        if (__ptr_ != __p)\n            delete __ptr_;\n        __ptr_ = __p;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY auto_ptr(auto_ptr_ref<_Tp> __p) throw() : __ptr_(__p.__ptr_) {}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr_ref<_Up>() throw()\n        {auto_ptr_ref<_Up> __t; __t.__ptr_ = release(); return __t;}\n    template<class _Up> _LIBCPP_INLINE_VISIBILITY operator auto_ptr<_Up>() throw()\n        {return auto_ptr<_Up>(release());}\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS_ONLY auto_ptr<void>\n{\npublic:\n    typedef void element_type;\n};\n\ntemplate <class _T1, class _T2, bool = is_same<typename remove_cv<_T1>::type,\n                                                     typename remove_cv<_T2>::type>::value,\n                                bool = is_empty<_T1>::value\n#if __has_feature(is_final)\n                                       && !__is_final(_T1)\n#endif\n                                ,\n                                bool = is_empty<_T2>::value\n#if __has_feature(is_final)\n                                       && !__is_final(_T2)\n#endif\n         >\nstruct __libcpp_compressed_pair_switch;\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, false> {enum {value = 0};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, true, false>  {enum {value = 1};};\n\ntemplate <class _T1, class _T2, bool IsSame>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, IsSame, false, true>  {enum {value = 2};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, false, true, true>    {enum {value = 3};};\n\ntemplate <class _T1, class _T2>\nstruct __libcpp_compressed_pair_switch<_T1, _T2, true, true, true>     {enum {value = 1};};\n\ntemplate <class _T1, class _T2, unsigned = __libcpp_compressed_pair_switch<_T1, _T2>::value>\nclass __libcpp_compressed_pair_imp;\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 0>\n{\nprivate:\n    _T1 __first_;\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : __first_(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : __first_(__p.first()),\n          __second_(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            __first_ = __p.first();\n            __second_ = __p.second();\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : __first_(_VSTD::forward<_T1>(__p.first())),\n          __second_(_VSTD::forward<_T2>(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            __first_ = _VSTD::forward<_T1>(__p.first());\n            __second_ = _VSTD::forward<_T2>(__p.second());\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 1>\n    : private _T1\n{\nprivate:\n    _T2 __second_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1&                                        _T1_reference;\n    typedef typename remove_reference<_T2>::type& _T2_reference;\n\n    typedef const _T1&                                        _T1_const_reference;\n    typedef const typename remove_reference<_T2>::type& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : __second_(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), __second_(_VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T1(__p.first()), __second_(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T1::operator=(__p.first());\n            __second_ = __p.second();\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T1(_VSTD::move(__p.first())), __second_(_VSTD::forward<_T2>(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T1::operator=(_VSTD::move(__p.first()));\n            __second_ = _VSTD::forward<_T2>(__p.second());\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              __second_(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return __second_;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return __second_;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__second_, __x.__second_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 2>\n    : private _T2\n{\nprivate:\n    _T1 __first_;\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef typename remove_reference<_T1>::type& _T1_reference;\n    typedef _T2&                                        _T2_reference;\n\n    typedef const typename remove_reference<_T1>::type& _T1_const_reference;\n    typedef const _T2&                                        _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : __first_(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2_param>(__t2)), __first_(_VSTD::forward<_T1_param>(__t1)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T2(__p.second()), __first_(__p.first()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T2::operator=(__p.second());\n            __first_ = __p.first();\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T2(_VSTD::forward<_T2>(__p.second())), __first_(_VSTD::move(__p.first())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T2::operator=(_VSTD::forward<_T2>(__p.second()));\n            __first_ = _VSTD::move(__p.first());\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...),\n              __first_(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...)\n              \n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return __first_;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return __first_;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n        using _VSTD::swap;\n        swap(__first_, __x.__first_);\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __libcpp_compressed_pair_imp<_T1, _T2, 3>\n    : private _T1,\n      private _T2\n{\npublic:\n    typedef _T1 _T1_param;\n    typedef _T2 _T2_param;\n\n    typedef _T1& _T1_reference;\n    typedef _T2& _T2_reference;\n\n    typedef const _T1& _T1_const_reference;\n    typedef const _T2& _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T1_param __t1)\n        : _T1(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __libcpp_compressed_pair_imp(_T2_param __t2)\n        : _T2(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __libcpp_compressed_pair_imp(_T1_param __t1, _T2_param __t2)\n        : _T1(_VSTD::forward<_T1_param>(__t1)), _T2(_VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : _T1(__p.first()), _T2(__p.second()) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(const __libcpp_compressed_pair_imp& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            _T1::operator=(__p.first());\n            _T2::operator=(__p.second());\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : _T1(_VSTD::move(__p.first())), _T2(_VSTD::move(__p.second())) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __libcpp_compressed_pair_imp& operator=(__libcpp_compressed_pair_imp&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            _T1::operator=(_VSTD::move(__p.first()));\n            _T2::operator=(_VSTD::move(__p.second()));\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        __libcpp_compressed_pair_imp(piecewise_construct_t __pc,\n                                     tuple<_Args1...> __first_args,\n                                     tuple<_Args2...> __second_args,\n                                     __tuple_indices<_I1...>,\n                                     __tuple_indices<_I2...>)\n            : _T1(_VSTD::forward<_Args1>(_VSTD::get<_I1>(__first_args))...),\n              _T2(_VSTD::forward<_Args2>(_VSTD::get<_I2>(__second_args))...)\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return *this;}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__libcpp_compressed_pair_imp&)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {\n    }\n};\n\ntemplate <class _T1, class _T2>\nclass __compressed_pair\n    : private __libcpp_compressed_pair_imp<_T1, _T2>\n{\n    typedef __libcpp_compressed_pair_imp<_T1, _T2> base;\npublic:\n    typedef typename base::_T1_param _T1_param;\n    typedef typename base::_T2_param _T2_param;\n\n    typedef typename base::_T1_reference _T1_reference;\n    typedef typename base::_T2_reference _T2_reference;\n\n    typedef typename base::_T1_const_reference _T1_const_reference;\n    typedef typename base::_T2_const_reference _T2_const_reference;\n\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair() {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T1_param __t1)\n        : base(_VSTD::forward<_T1_param>(__t1)) {}\n    _LIBCPP_INLINE_VISIBILITY explicit __compressed_pair(_T2_param __t2)\n        : base(_VSTD::forward<_T2_param>(__t2)) {}\n    _LIBCPP_INLINE_VISIBILITY __compressed_pair(_T1_param __t1, _T2_param __t2)\n        : base(_VSTD::forward<_T1_param>(__t1), _VSTD::forward<_T2_param>(__t2)) {}\n\n#if defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair(const __compressed_pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_T1>::value &&\n                   is_nothrow_copy_constructible<_T2>::value)\n        : base(__p) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair& operator=(const __compressed_pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<_T1>::value &&\n                   is_nothrow_copy_assignable<_T2>::value)\n        {\n            base::operator=(__p);\n            return *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair(__compressed_pair&& __p)\n        _NOEXCEPT_(is_nothrow_move_constructible<_T1>::value &&\n                   is_nothrow_move_constructible<_T2>::value)\n        : base(_VSTD::move(__p)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __compressed_pair& operator=(__compressed_pair&& __p)\n        _NOEXCEPT_(is_nothrow_move_assignable<_T1>::value &&\n                   is_nothrow_move_assignable<_T2>::value)\n        {\n            base::operator=(_VSTD::move(__p));\n            return *this;\n        }\n\n#endif  // defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        __compressed_pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                                      tuple<_Args2...> __second_args)\n            : base(__pc, _VSTD::move(__first_args), _VSTD::move(__second_args),\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY _T1_reference       first() _NOEXCEPT       {return base::first();}\n    _LIBCPP_INLINE_VISIBILITY _T1_const_reference first() const _NOEXCEPT {return base::first();}\n\n    _LIBCPP_INLINE_VISIBILITY _T2_reference       second() _NOEXCEPT       {return base::second();}\n    _LIBCPP_INLINE_VISIBILITY _T2_const_reference second() const _NOEXCEPT {return base::second();}\n\n    _LIBCPP_INLINE_VISIBILITY void swap(__compressed_pair& __x)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n        {base::swap(__x);}\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__compressed_pair<_T1, _T2>& __x, __compressed_pair<_T1, _T2>& __y)\n        _NOEXCEPT_(__is_nothrow_swappable<_T1>::value &&\n                   __is_nothrow_swappable<_T2>::value)\n    {__x.swap(__y);}\n\n// __same_or_less_cv_qualified\n\ntemplate <class _Ptr1, class _Ptr2,\n          bool = is_same<typename remove_cv<typename pointer_traits<_Ptr1>::element_type>::type,\n                         typename remove_cv<typename pointer_traits<_Ptr2>::element_type>::type\n                        >::value\n         >\nstruct __same_or_less_cv_qualified_imp\n    : is_convertible<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2, false>\n    : false_type {};\n\ntemplate <class _Ptr1, class _Ptr2, bool = is_pointer<_Ptr1>::value ||\n                                           is_same<_Ptr1, _Ptr2>::value ||\n                                           __has_element_type<_Ptr1>::value>\nstruct __same_or_less_cv_qualified\n    : __same_or_less_cv_qualified_imp<_Ptr1, _Ptr2> {};\n\ntemplate <class _Ptr1, class _Ptr2>\nstruct __same_or_less_cv_qualified<_Ptr1, _Ptr2, false>\n    : false_type {};\n\n// default_delete\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY default_delete\n{\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up>&,\n             typename enable_if<is_convertible<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY void operator() (_Tp* __ptr) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete incomplete type\");\n            delete __ptr;\n        }\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY default_delete<_Tp[]>\n{\npublic:\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR default_delete() _NOEXCEPT {}\n#endif\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY default_delete(const default_delete<_Up[]>&,\n             typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) _NOEXCEPT {}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        void operator() (_Up* __ptr,\n                         typename enable_if<__same_or_less_cv_qualified<_Up*, _Tp*>::value>::type* = 0) const _NOEXCEPT\n        {\n            static_assert(sizeof(_Tp) > 0, \"default_delete can not delete incomplete type\");\n            static_assert(!is_void<_Tp>::value, \"default_delete can not delete incomplete type\");\n            delete [] __ptr;\n        }\n};\n\ntemplate <class _Tp, class _Dp = default_delete<_Tp> >\nclass _LIBCPP_TYPE_VIS_ONLY unique_ptr\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr(unique_ptr<_Up, _Ep>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up, class _Ep>\n        unique_ptr& operator=(unique_ptr<_Up, _Ep>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p) _NOEXCEPT\n        : __ptr_(_VSTD::move(__p))\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename conditional<\n                                        is_reference<deleter_type>::value,\n                                        deleter_type,\n                                        typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                      <\n                        !is_array<_Up>::value &&\n                         is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                         is_convertible<_Ep, deleter_type>::value &&\n                         (\n                            !is_reference<deleter_type>::value ||\n                            is_same<deleter_type, _Ep>::value\n                         ),\n                         __nat\n                      >::type = __nat()) _NOEXCEPT\n            : __ptr_(__u.release(), _VSTD::forward<_Ep>(__u.get_deleter())) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY unique_ptr(auto_ptr<_Up>&& __p,\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      __nat\n                                  >::type = __nat()) _NOEXCEPT\n            : __ptr_(__p.release())\n            {\n            }\n\n        _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n                return *this;\n            }\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                !is_array<_Up>::value &&\n                is_convertible<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    template <class _Up, class _Ep>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr<_Up, _Ep> __u)\n    {\n        reset(__u.release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(_VSTD::move(__p), _VSTD::move(__d)) {}\n\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n                typename enable_if<\n                                      is_convertible<_Up*, _Tp*>::value &&\n                                      is_same<_Dp, default_delete<_Tp> >::value,\n                                      unique_ptr&\n                                  >::type\n        operator=(auto_ptr<_Up> __p)\n            {reset(__p.release()); return *this;}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator*() const\n        {return *__ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer operator->() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer()) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) _NOEXCEPT\n        {__ptr_.swap(__u.__ptr_);}\n};\n\ntemplate <class _Tp, class _Dp>\nclass _LIBCPP_TYPE_VIS_ONLY unique_ptr<_Tp[], _Dp>\n{\npublic:\n    typedef _Tp element_type;\n    typedef _Dp deleter_type;\n    typedef typename __pointer_type<_Tp, deleter_type>::type pointer;\nprivate:\n    __compressed_pair<pointer, deleter_type> __ptr_;\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unique_ptr(unique_ptr&);\n    template <class _Up>\n        unique_ptr(unique_ptr<_Up>&);\n    unique_ptr& operator=(unique_ptr&);\n    template <class _Up>\n        unique_ptr& operator=(unique_ptr<_Up>&);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    struct __nat {int __for_bool_;};\n\n    typedef       typename remove_reference<deleter_type>::type& _Dp_reference;\n    typedef const typename remove_reference<deleter_type>::type& _Dp_const_reference;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr() _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR unique_ptr(nullptr_t) _NOEXCEPT\n        : __ptr_(pointer())\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(_Pp __p,\n            typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat()) _NOEXCEPT\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d,\n                                       typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, __d) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), __d) {}\n\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(_Pp __p,\n                                         typename remove_reference<deleter_type>::type&& __d,\n                                         typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, __nat>::type = __nat())\n             _NOEXCEPT\n        : __ptr_(__p, _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, typename remove_reference<deleter_type>::type&& __d)\n             _NOEXCEPT\n        : __ptr_(pointer(), _VSTD::move(__d))\n        {\n            static_assert(!is_reference<deleter_type>::value, \"rvalue deleter bound to reference\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(unique_ptr&& __u) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(unique_ptr&& __u) _NOEXCEPT\n        {\n            reset(__u.release());\n            __ptr_.second() = _VSTD::forward<deleter_type>(__u.get_deleter());\n            return *this;\n        }\n\n    template <class _Up, class _Ep>\n        _LIBCPP_INLINE_VISIBILITY\n        unique_ptr(unique_ptr<_Up, _Ep>&& __u,\n                   typename enable_if\n                            <\n                                is_array<_Up>::value &&\n                                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value\n                                && is_convertible<_Ep, deleter_type>::value &&\n                                (\n                                    !is_reference<deleter_type>::value ||\n                                    is_same<deleter_type, _Ep>::value\n                                ),\n                                __nat\n                            >::type = __nat()\n                  ) _NOEXCEPT\n        : __ptr_(__u.release(), _VSTD::forward<deleter_type>(__u.get_deleter())) {}\n\n\n        template <class _Up, class _Ep>\n            _LIBCPP_INLINE_VISIBILITY\n            typename enable_if\n            <\n                is_array<_Up>::value &&\n                __same_or_less_cv_qualified<typename unique_ptr<_Up, _Ep>::pointer, pointer>::value &&\n                is_assignable<deleter_type&, _Ep&&>::value,\n                unique_ptr&\n            >::type\n            operator=(unique_ptr<_Up, _Ep>&& __u) _NOEXCEPT\n            {\n                reset(__u.release());\n                __ptr_.second() = _VSTD::forward<_Ep>(__u.get_deleter());\n                return *this;\n            }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY explicit unique_ptr(pointer __p)\n        : __ptr_(__p)\n        {\n            static_assert(!is_pointer<deleter_type>::value,\n                \"unique_ptr constructed with null function pointer deleter\");\n        }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(pointer __p, deleter_type __d)\n        : __ptr_(__p, _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(nullptr_t, deleter_type __d)\n        : __ptr_(pointer(), _VSTD::forward<deleter_type>(__d)) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator __rv<unique_ptr>()\n    {\n        return __rv<unique_ptr>(*this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr(__rv<unique_ptr> __u)\n        : __ptr_(__u->release(), _VSTD::forward<deleter_type>(__u->get_deleter())) {}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(__rv<unique_ptr> __u)\n    {\n        reset(__u->release());\n        __ptr_.second() = _VSTD::forward<deleter_type>(__u->get_deleter());\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY ~unique_ptr() {reset();}\n\n    _LIBCPP_INLINE_VISIBILITY unique_ptr& operator=(nullptr_t) _NOEXCEPT\n    {\n        reset();\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY typename add_lvalue_reference<_Tp>::type operator[](size_t __i) const\n        {return __ptr_.first()[__i];}\n    _LIBCPP_INLINE_VISIBILITY pointer get() const _NOEXCEPT {return __ptr_.first();}\n    _LIBCPP_INLINE_VISIBILITY       _Dp_reference get_deleter() _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY _Dp_const_reference get_deleter() const _NOEXCEPT\n        {return __ptr_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT\n        {return __ptr_.first() != nullptr;}\n\n    _LIBCPP_INLINE_VISIBILITY pointer release() _NOEXCEPT\n    {\n        pointer __t = __ptr_.first();\n        __ptr_.first() = pointer();\n        return __t;\n    }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp>\n    _LIBCPP_INLINE_VISIBILITY\n    typename enable_if<__same_or_less_cv_qualified<_Pp, pointer>::value, void>::type\n    reset(_Pp __p) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset(nullptr_t) _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n    _LIBCPP_INLINE_VISIBILITY void reset() _NOEXCEPT\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = nullptr;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY void reset(pointer __p = pointer())\n    {\n        pointer __tmp = __ptr_.first();\n        __ptr_.first() = __p;\n        if (__tmp)\n            __ptr_.second()(__tmp);\n    }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY void swap(unique_ptr& __u) {__ptr_.swap(__u.__ptr_);}\nprivate:\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Up>\n        explicit unique_ptr(_Up);\n    template <class _Up>\n        unique_ptr(_Up __u,\n                   typename conditional<\n                                       is_reference<deleter_type>::value,\n                                       deleter_type,\n                                       typename add_lvalue_reference<const deleter_type>::type>::type,\n                   typename enable_if\n                      <\n                         is_convertible<_Up, pointer>::value,\n                         __nat\n                      >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(unique_ptr<_Tp, _Dp>& __x, unique_ptr<_Tp, _Dp>& __y) _NOEXCEPT {__x.swap(__y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __x.get() == __y.get();}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x == __y);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    typedef typename unique_ptr<_T2, _D2>::pointer _P2;\n    typedef typename common_type<_P1, _P2>::type _V;\n    return less<_V>()(__x.get(), __y.get());\n}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return __y < __x;}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__y < __x);}\n\ntemplate <class _T1, class _D1, class _T2, class _D2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, const unique_ptr<_T2, _D2>& __y) {return !(__x < __y);}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unique_ptr<_T1, _D1>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const unique_ptr<_T1, _D1>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(__x.get(), nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    typedef typename unique_ptr<_T1, _D1>::pointer _P1;\n    return less<_P1>()(nullptr, __x.get());\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return nullptr < __x;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return __x < nullptr;\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(nullptr < __x);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const unique_ptr<_T1, _D1>& __x, nullptr_t)\n{\n    return !(__x < nullptr);\n}\n\ntemplate <class _T1, class _D1>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const unique_ptr<_T1, _D1>& __x)\n{\n    return !(nullptr < __x);\n}\n\n#ifdef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\nunique_ptr<_Tp, _Dp>\nmove(unique_ptr<_Tp, _Dp>& __t)\n{\n    return unique_ptr<_Tp, _Dp>(__rv<unique_ptr<_Tp, _Dp> >(__t));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp>\nstruct __unique_if\n{\n    typedef unique_ptr<_Tp> __unique_single;\n};\n\ntemplate<class _Tp>\nstruct __unique_if<_Tp[]>\n{\n    typedef unique_ptr<_Tp[]> __unique_array_unknown_bound;\n};\n\ntemplate<class _Tp, size_t _Np>\nstruct __unique_if<_Tp[_Np]>\n{\n    typedef void __unique_array_known_bound;\n};\n\ntemplate<class _Tp, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_single\nmake_unique(_Args&&... __args)\n{\n    return unique_ptr<_Tp>(new _Tp(_VSTD::forward<_Args>(__args)...));\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __unique_if<_Tp>::__unique_array_unknown_bound\nmake_unique(size_t __n)\n{\n    typedef typename remove_extent<_Tp>::type _Up;\n    return unique_ptr<_Tp>(new _Up[__n]());\n}\n\ntemplate<class _Tp, class... _Args>\n    typename __unique_if<_Tp>::__unique_array_known_bound\n    make_unique(_Args&&...) = delete;\n\n#endif  // _LIBCPP_STD_VER > 11\n\ntemplate <class _Tp> struct hash;\n\ntemplate <class _Size>\ninline _LIBCPP_INLINE_VISIBILITY\n_Size\n__loadword(const void* __p)\n{\n    _Size __r;\n    std::memcpy(&__r, __p, sizeof(__r));\n    return __r;\n}\n\n// We use murmur2 when size_t is 32 bits, and cityhash64 when size_t\n// is 64 bits.  This is because cityhash64 uses 64bit x 64bit\n// multiplication, which can be very slow on 32-bit systems.\ntemplate <class _Size, size_t = sizeof(_Size)*__CHAR_BIT__>\nstruct __murmur2_or_cityhash;\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 32>\n{\n    _Size operator()(const void* __key, _Size __len);\n};\n\n// murmur2\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 32>::operator()(const void* __key, _Size __len)\n{\n    const _Size __m = 0x5bd1e995;\n    const _Size __r = 24;\n    _Size __h = __len;\n    const unsigned char* __data = static_cast<const unsigned char*>(__key);\n    for (; __len >= 4; __data += 4, __len -= 4)\n    {\n        _Size __k = __loadword<_Size>(__data);\n        __k *= __m;\n        __k ^= __k >> __r;\n        __k *= __m;\n        __h *= __m;\n        __h ^= __k;\n    }\n    switch (__len)\n    {\n    case 3:\n        __h ^= __data[2] << 16;\n    case 2:\n        __h ^= __data[1] << 8;\n    case 1:\n        __h ^= __data[0];\n        __h *= __m;\n    }\n    __h ^= __h >> 13;\n    __h *= __m;\n    __h ^= __h >> 15;\n    return __h;\n}\n\ntemplate <class _Size>\nstruct __murmur2_or_cityhash<_Size, 64>\n{\n    _Size operator()(const void* __key, _Size __len);\n\n private:\n  // Some primes between 2^63 and 2^64.\n  static const _Size __k0 = 0xc3a5c85c97cb3127ULL;\n  static const _Size __k1 = 0xb492b66fbe98f273ULL;\n  static const _Size __k2 = 0x9ae16a3b2f90404fULL;\n  static const _Size __k3 = 0xc949d7c7509e6557ULL;\n\n  static _Size __rotate(_Size __val, int __shift) {\n    return __shift == 0 ? __val : ((__val >> __shift) | (__val << (64 - __shift)));\n  }\n\n  static _Size __rotate_by_at_least_1(_Size __val, int __shift) {\n    return (__val >> __shift) | (__val << (64 - __shift));\n  }\n\n  static _Size __shift_mix(_Size __val) {\n    return __val ^ (__val >> 47);\n  }\n\n  static _Size __hash_len_16(_Size __u, _Size __v) {\n    const _Size __mul = 0x9ddfea08eb382d69ULL;\n    _Size __a = (__u ^ __v) * __mul;\n    __a ^= (__a >> 47);\n    _Size __b = (__v ^ __a) * __mul;\n    __b ^= (__b >> 47);\n    __b *= __mul;\n    return __b;\n  }\n\n  static _Size __hash_len_0_to_16(const char* __s, _Size __len) {\n    if (__len > 8) {\n      const _Size __a = __loadword<_Size>(__s);\n      const _Size __b = __loadword<_Size>(__s + __len - 8);\n      return __hash_len_16(__a, __rotate_by_at_least_1(__b + __len, __len)) ^ __b;\n    }\n    if (__len >= 4) {\n      const uint32_t __a = __loadword<uint32_t>(__s);\n      const uint32_t __b = __loadword<uint32_t>(__s + __len - 4);\n      return __hash_len_16(__len + (__a << 3), __b);\n    }\n    if (__len > 0) {\n      const unsigned char __a = __s[0];\n      const unsigned char __b = __s[__len >> 1];\n      const unsigned char __c = __s[__len - 1];\n      const uint32_t __y = static_cast<uint32_t>(__a) +\n                           (static_cast<uint32_t>(__b) << 8);\n      const uint32_t __z = __len + (static_cast<uint32_t>(__c) << 2);\n      return __shift_mix(__y * __k2 ^ __z * __k3) * __k2;\n    }\n    return __k2;\n  }\n\n  static _Size __hash_len_17_to_32(const char *__s, _Size __len) {\n    const _Size __a = __loadword<_Size>(__s) * __k1;\n    const _Size __b = __loadword<_Size>(__s + 8);\n    const _Size __c = __loadword<_Size>(__s + __len - 8) * __k2;\n    const _Size __d = __loadword<_Size>(__s + __len - 16) * __k0;\n    return __hash_len_16(__rotate(__a - __b, 43) + __rotate(__c, 30) + __d,\n                         __a + __rotate(__b ^ __k3, 20) - __c + __len);\n  }\n\n  // Return a 16-byte hash for 48 bytes.  Quick and dirty.\n  // Callers do best to use \"random-looking\" values for a and b.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      _Size __w, _Size __x, _Size __y, _Size __z, _Size __a, _Size __b) {\n    __a += __w;\n    __b = __rotate(__b + __a + __z, 21);\n    const _Size __c = __a;\n    __a += __x;\n    __a += __y;\n    __b += __rotate(__a, 44);\n    return pair<_Size, _Size>(__a + __z, __b + __c);\n  }\n\n  // Return a 16-byte hash for s[0] ... s[31], a, and b.  Quick and dirty.\n  static pair<_Size, _Size> __weak_hash_len_32_with_seeds(\n      const char* __s, _Size __a, _Size __b) {\n    return __weak_hash_len_32_with_seeds(__loadword<_Size>(__s),\n                                         __loadword<_Size>(__s + 8),\n                                         __loadword<_Size>(__s + 16),\n                                         __loadword<_Size>(__s + 24),\n                                         __a,\n                                         __b);\n  }\n\n  // Return an 8-byte hash for 33 to 64 bytes.\n  static _Size __hash_len_33_to_64(const char *__s, size_t __len) {\n    _Size __z = __loadword<_Size>(__s + 24);\n    _Size __a = __loadword<_Size>(__s) +\n                (__len + __loadword<_Size>(__s + __len - 16)) * __k0;\n    _Size __b = __rotate(__a + __z, 52);\n    _Size __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + 8);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + 16);\n    _Size __vf = __a + __z;\n    _Size __vs = __b + __rotate(__a, 31) + __c;\n    __a = __loadword<_Size>(__s + 16) + __loadword<_Size>(__s + __len - 32);\n    __z += __loadword<_Size>(__s + __len - 8);\n    __b = __rotate(__a + __z, 52);\n    __c = __rotate(__a, 37);\n    __a += __loadword<_Size>(__s + __len - 24);\n    __c += __rotate(__a, 7);\n    __a += __loadword<_Size>(__s + __len - 16);\n    _Size __wf = __a + __z;\n    _Size __ws = __b + __rotate(__a, 31) + __c;\n    _Size __r = __shift_mix((__vf + __ws) * __k2 + (__wf + __vs) * __k0);\n    return __shift_mix(__r * __k0 + __vs) * __k2;\n  }\n};\n\n// cityhash64\ntemplate <class _Size>\n_Size\n__murmur2_or_cityhash<_Size, 64>::operator()(const void* __key, _Size __len)\n{\n  const char* __s = static_cast<const char*>(__key);\n  if (__len <= 32) {\n    if (__len <= 16) {\n      return __hash_len_0_to_16(__s, __len);\n    } else {\n      return __hash_len_17_to_32(__s, __len);\n    }\n  } else if (__len <= 64) {\n    return __hash_len_33_to_64(__s, __len);\n  }\n\n  // For strings over 64 bytes we hash the end first, and then as we\n  // loop we keep 56 bytes of state: v, w, x, y, and z.\n  _Size __x = __loadword<_Size>(__s + __len - 40);\n  _Size __y = __loadword<_Size>(__s + __len - 16) +\n              __loadword<_Size>(__s + __len - 56);\n  _Size __z = __hash_len_16(__loadword<_Size>(__s + __len - 48) + __len,\n                          __loadword<_Size>(__s + __len - 24));\n  pair<_Size, _Size> __v = __weak_hash_len_32_with_seeds(__s + __len - 64, __len, __z);\n  pair<_Size, _Size> __w = __weak_hash_len_32_with_seeds(__s + __len - 32, __y + __k1, __x);\n  __x = __x * __k1 + __loadword<_Size>(__s);\n\n  // Decrease len to the nearest multiple of 64, and operate on 64-byte chunks.\n  __len = (__len - 1) & ~static_cast<_Size>(63);\n  do {\n    __x = __rotate(__x + __y + __v.first + __loadword<_Size>(__s + 8), 37) * __k1;\n    __y = __rotate(__y + __v.second + __loadword<_Size>(__s + 48), 42) * __k1;\n    __x ^= __w.second;\n    __y += __v.first + __loadword<_Size>(__s + 40);\n    __z = __rotate(__z + __w.first, 33) * __k1;\n    __v = __weak_hash_len_32_with_seeds(__s, __v.second * __k1, __x + __w.first);\n    __w = __weak_hash_len_32_with_seeds(__s + 32, __z + __w.second,\n                                        __y + __loadword<_Size>(__s + 16));\n    std::swap(__z, __x);\n    __s += 64;\n    __len -= 64;\n  } while (__len != 0);\n  return __hash_len_16(\n      __hash_len_16(__v.first, __w.first) + __shift_mix(__y) * __k1 + __z,\n      __hash_len_16(__v.second, __w.second) + __x);\n}\n\ntemplate <class _Tp, size_t = sizeof(_Tp) / sizeof(size_t)>\nstruct __scalar_hash;\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 0>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__a = 0;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 1>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp    __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __u.__a;\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 2>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            };\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 3>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n            };\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp>\nstruct __scalar_hash<_Tp, 4>\n    : public unary_function<_Tp, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            };\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate<class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<_Tp*>\n    : public unary_function<_Tp*, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp* __v) const _NOEXCEPT\n    {\n        union\n        {\n            _Tp* __t;\n            size_t __a;\n        } __u;\n        __u.__t = __v;\n        return __murmur2_or_cityhash<size_t>()(&__u, sizeof(__u));\n    }\n};\n\ntemplate <class _Tp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unique_ptr<_Tp, _Dp> >\n{\n    typedef unique_ptr<_Tp, _Dp> argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        typedef typename argument_type::pointer pointer;\n        return hash<pointer>()(__ptr.get());\n    }\n};\n\nstruct __destruct_n\n{\nprivate:\n    size_t size;\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp* __p, false_type) _NOEXCEPT\n        {for (size_t __i = 0; __i < size; ++__i, ++__p) __p->~_Tp();}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __process(_Tp*, true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __incr(false_type) _NOEXCEPT\n        {++size;}\n    _LIBCPP_INLINE_VISIBILITY void __incr(true_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, false_type) _NOEXCEPT\n        {size = __s;}\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t, true_type) _NOEXCEPT\n        {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit __destruct_n(size_t __s) _NOEXCEPT\n        : size(__s) {}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __incr(_Tp*) _NOEXCEPT\n        {__incr(integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void __set(size_t __s, _Tp*) _NOEXCEPT\n        {__set(__s, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) _NOEXCEPT\n        {__process(__p, integral_constant<bool, is_trivially_destructible<_Tp>::value>());}\n};\n\ntemplate <class _Alloc>\nclass __allocator_destructor\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\npublic:\n    typedef typename __alloc_traits::pointer pointer;\n    typedef typename __alloc_traits::size_type size_type;\nprivate:\n    _Alloc& __alloc_;\n    size_type __s_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __allocator_destructor(_Alloc& __a, size_type __s)\n             _NOEXCEPT\n        : __alloc_(__a), __s_(__s) {}\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n        {__alloc_traits::deallocate(__alloc_, __p, __s_);}\n};\n\ntemplate <class _InputIterator, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy(_InputIterator __f, _InputIterator __l, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f, ++__r)\n            ::new(&*__r) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _InputIterator, class _Size, class _ForwardIterator>\n_ForwardIterator\nuninitialized_copy_n(_InputIterator __f, _Size __n, _ForwardIterator __r)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __r;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, ++__r, --__n)\n            ::new(&*__r) value_type(*__f);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __r; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __r;\n}\n\ntemplate <class _ForwardIterator, class _Tp>\nvoid\nuninitialized_fill(_ForwardIterator __f, _ForwardIterator __l, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __f != __l; ++__f)\n            ::new(&*__f) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\nuninitialized_fill_n(_ForwardIterator __f, _Size __n, const _Tp& __x)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    _ForwardIterator __s = __f;\n    try\n    {\n#endif\n        for (; __n > 0; ++__f, --__n)\n            ::new(&*__f) value_type(__x);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        for (; __s != __f; ++__s)\n            __s->~value_type();\n        throw;\n    }\n#endif\n    return __f;\n}\n\nclass _LIBCPP_EXCEPTION_ABI bad_weak_ptr\n    : public std::exception\n{\npublic:\n    virtual ~bad_weak_ptr() _NOEXCEPT;\n    virtual const char* what() const  _NOEXCEPT;\n};\n\ntemplate<class _Tp> class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n\nclass _LIBCPP_TYPE_VIS __shared_count\n{\n    __shared_count(const __shared_count&);\n    __shared_count& operator=(const __shared_count&);\n\nprotected:\n    long __shared_owners_;\n    virtual ~__shared_count();\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT = 0;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_count(long __refs = 0) _NOEXCEPT\n        : __shared_owners_(__refs) {}\n\n    void __add_shared() _NOEXCEPT;\n    bool __release_shared() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_owners_ + 1;}\n};\n\nclass _LIBCPP_TYPE_VIS __shared_weak_count\n    : private __shared_count\n{\n    long __shared_weak_owners_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __shared_weak_count(long __refs = 0) _NOEXCEPT\n        : __shared_count(__refs),\n          __shared_weak_owners_(__refs) {}\nprotected:\n    virtual ~__shared_weak_count();\n\npublic:\n    void __add_shared() _NOEXCEPT;\n    void __add_weak() _NOEXCEPT;\n    void __release_shared() _NOEXCEPT;\n    void __release_weak() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __shared_count::use_count();}\n    __shared_weak_count* lock() _NOEXCEPT;\n\n    // Define the function out only if we build static libc++ without RTTI.\n    // Otherwise we may break clients who need to compile their projects with\n    // -fno-rtti and yet link against a libc++.dylib compiled\n    // without -fno-rtti.\n#if !defined(_LIBCPP_NO_RTTI) || !defined(_LIBCPP_BUILD_STATIC)\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\nprivate:\n    virtual void __on_zero_shared_weak() _NOEXCEPT = 0;\n};\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nclass __shared_ptr_pointer\n    : public __shared_weak_count\n{\n    __compressed_pair<__compressed_pair<_Tp, _Dp>, _Alloc> __data_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_pointer(_Tp __p, _Dp __d, _Alloc __a)\n        :  __data_(__compressed_pair<_Tp, _Dp>(__p, _VSTD::move(__d)), _VSTD::move(__a)) {}\n\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* __get_deleter(const type_info&) const _NOEXCEPT;\n#endif\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\n};\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nconst void*\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__get_deleter(const type_info& __t) const _NOEXCEPT\n{\n    return __t == typeid(_Dp) ? &__data_.first().second() : 0;\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.first().second()(__data_.first().first());\n    __data_.first().second().~_Dp();\n}\n\ntemplate <class _Tp, class _Dp, class _Alloc>\nvoid\n__shared_ptr_pointer<_Tp, _Dp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typename _Alloc::template rebind<__shared_ptr_pointer>::other __a(__data_.second());\n    __data_.second().~_Alloc();\n    __a.deallocate(this, 1);\n}\n\ntemplate <class _Tp, class _Alloc>\nclass __shared_ptr_emplace\n    : public __shared_weak_count\n{\n    __compressed_pair<_Alloc, _Tp> __data_;\npublic:\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(_VSTD::move(__a)) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _Args&& ...__args)\n            :  __data_(piecewise_construct, _VSTD::forward_as_tuple(__a),\n                   _VSTD::forward_as_tuple(_VSTD::forward<_Args>(__args)...)) {}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __shared_ptr_emplace(_Alloc __a)\n        :  __data_(__a) {}\n\n    template <class _A0>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0)\n            :  __data_(__a, _Tp(__a0)) {}\n\n    template <class _A0, class _A1>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1)\n            :  __data_(__a, _Tp(__a0, __a1)) {}\n\n    template <class _A0, class _A1, class _A2>\n        _LIBCPP_INLINE_VISIBILITY\n        __shared_ptr_emplace(_Alloc __a, _A0& __a0, _A1& __a1, _A2& __a2)\n            :  __data_(__a, _Tp(__a0, __a1, __a2)) {}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n    virtual void __on_zero_shared_weak() _NOEXCEPT;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Tp* get() _NOEXCEPT {return &__data_.second();}\n};\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared() _NOEXCEPT\n{\n    __data_.second().~_Tp();\n}\n\ntemplate <class _Tp, class _Alloc>\nvoid\n__shared_ptr_emplace<_Tp, _Alloc>::__on_zero_shared_weak() _NOEXCEPT\n{\n    typename _Alloc::template rebind<__shared_ptr_emplace>::other __a(__data_.first());\n    __data_.first().~_Alloc();\n    __a.deallocate(this, 1);\n}\n\ntemplate<class _Tp> class _LIBCPP_TYPE_VIS_ONLY enable_shared_from_this;\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY shared_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*      __ptr_;\n    __shared_weak_count* __cntrl_;\n\n    struct __nat {int __for_bool_;};\npublic:\n    _LIBCPP_CONSTEXPR shared_ptr() _NOEXCEPT;\n    _LIBCPP_CONSTEXPR shared_ptr(nullptr_t) _NOEXCEPT;\n    template<class _Yp>\n        explicit shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp>\n        shared_ptr(_Yp* __p, _Dp __d,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template<class _Yp, class _Dp, class _Alloc>\n        shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n    template <class _Dp> shared_ptr(nullptr_t __p, _Dp __d);\n    template <class _Dp, class _Alloc> shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a);\n    template<class _Yp> shared_ptr(const shared_ptr<_Yp>& __r, element_type* __p) _NOEXCEPT;\n    shared_ptr(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        shared_ptr(const shared_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    shared_ptr(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> shared_ptr(shared_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type = __nat())\n                       _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp> explicit shared_ptr(const weak_ptr<_Yp>& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type= __nat());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#else\n    template<class _Yp>\n        shared_ptr(auto_ptr<_Yp> __r,\n                   typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type = __nat());\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>&&,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       !is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n    template <class _Yp, class _Dp>\n        shared_ptr(unique_ptr<_Yp, _Dp>,\n                   typename enable_if\n                   <\n                       is_lvalue_reference<_Dp>::value &&\n                       !is_array<_Yp>::value &&\n                       is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                       __nat\n                   >::type = __nat());\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    ~shared_ptr();\n\n    shared_ptr& operator=(const shared_ptr& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT;\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    shared_ptr& operator=(shared_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr<_Tp>&\n        >::type\n        operator=(shared_ptr<_Yp>&& __r);\n    template<class _Yp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr\n        >::type&\n        operator=(auto_ptr<_Yp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template<class _Yp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<_Yp*, element_type*>::value,\n            shared_ptr&\n        >::type\n        operator=(auto_ptr<_Yp> __r);\n#endif\n    template <class _Yp, class _Dp>\n        typename enable_if\n        <\n            !is_array<_Yp>::value &&\n            is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n            shared_ptr&\n        >::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        operator=(unique_ptr<_Yp, _Dp>&& __r);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        operator=(unique_ptr<_Yp, _Dp> __r);\n#endif\n\n    void swap(shared_ptr& __r) _NOEXCEPT;\n    void reset() _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        reset(_Yp* __p);\n    template<class _Yp, class _Dp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        reset(_Yp* __p, _Dp __d);\n    template<class _Yp, class _Dp, class _Alloc>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            void\n        >::type\n        reset(_Yp* __p, _Dp __d, _Alloc __a);\n\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* get() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    typename add_lvalue_reference<element_type>::type operator*() const _NOEXCEPT\n        {return *__ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    element_type* operator->() const _NOEXCEPT {return __ptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool unique() const _NOEXCEPT {return use_count() == 1;}\n    _LIBCPP_INLINE_VISIBILITY\n    _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return get() != 0;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(shared_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    template <class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(weak_ptr<_Up> const& __p) const\n        {return __cntrl_ < __p.__cntrl_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool\n    __owner_equivalent(const shared_ptr& __p) const\n        {return __cntrl_ == __p.__cntrl_;}\n\n#ifndef _LIBCPP_NO_RTTI\n    template <class _Dp>\n        _LIBCPP_INLINE_VISIBILITY\n        _Dp* __get_deleter() const _NOEXCEPT\n            {return (_Dp*)(__cntrl_ ? __cntrl_->__get_deleter(typeid(_Dp)) : 0);}\n#endif  // _LIBCPP_NO_RTTI\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class ..._Args>\n        static\n        shared_ptr<_Tp>\n        make_shared(_Args&& ...__args);\n\n    template<class _Alloc, class ..._Args>\n        static\n        shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _Args&& ...__args);\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n    static shared_ptr<_Tp> make_shared();\n\n    template<class _A0>\n        static shared_ptr<_Tp> make_shared(_A0&);\n\n    template<class _A0, class _A1>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&);\n\n    template<class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp> make_shared(_A0&, _A1&, _A2&);\n\n    template<class _Alloc>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a);\n\n    template<class _Alloc, class _A0>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0);\n\n    template<class _Alloc, class _A0, class _A1>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1);\n\n    template<class _Alloc, class _A0, class _A1, class _A2>\n        static shared_ptr<_Tp>\n        allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2);\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\nprivate:\n\n    template <class _Yp>\n        _LIBCPP_INLINE_VISIBILITY\n        void\n        __enable_weak_this(const enable_shared_from_this<_Yp>* __e) _NOEXCEPT\n        {\n            if (__e)\n                __e->__weak_this_ = *this;\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __enable_weak_this(const void*) _NOEXCEPT {}\n\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY shared_ptr;\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n};\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nshared_ptr<_Tp>::shared_ptr(nullptr_t) _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n    unique_ptr<_Yp> __hold(__p);\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__p, default_delete<_Yp>(), allocator<_Yp>());\n    __hold.release();\n    __enable_weak_this(__p);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Yp>());\n        __enable_weak_this(__p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, allocator<_Tp> > _CntrlBlk;\n        __cntrl_ = new _CntrlBlk(__p, __d, allocator<_Tp>());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(_Yp* __p, _Dp __d, _Alloc __a,\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__p)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<_Yp*, _Dp, _Alloc> _CntrlBlk;\n        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);\n        __cntrl_ = __hold2.release();\n        __enable_weak_this(__p);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Dp, class _Alloc>\nshared_ptr<_Tp>::shared_ptr(nullptr_t __p, _Dp __d, _Alloc __a)\n    : __ptr_(0)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typedef __shared_ptr_pointer<nullptr_t, _Dp, _Alloc> _CntrlBlk;\n        typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;\n        typedef __allocator_destructor<_A2> _D2;\n        _A2 __a2(__a);\n        unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n        ::new(__hold2.get()) _CntrlBlk(__p, __d, __a);\n        __cntrl_ = __hold2.release();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __d(__p);\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r, element_type *__p) _NOEXCEPT\n    : __ptr_(__p),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(const shared_ptr& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(const shared_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_shared();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(shared_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>::shared_ptr(shared_ptr<_Yp>&& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(auto_ptr<_Yp> __r,\n#endif\n                            typename enable_if<is_convertible<_Yp*, element_type*>::value, __nat>::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, default_delete<_Yp>, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), default_delete<_Yp>(), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                !is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*, _Dp, allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), __r.get_deleter(), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp>&& __r,\n#else\nshared_ptr<_Tp>::shared_ptr(unique_ptr<_Yp, _Dp> __r,\n#endif\n                            typename enable_if\n                            <\n                                is_lvalue_reference<_Dp>::value &&\n                                !is_array<_Yp>::value &&\n                                is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, element_type*>::value,\n                                __nat\n                            >::type)\n    : __ptr_(__r.get())\n{\n    typedef __shared_ptr_pointer<_Yp*,\n                                 reference_wrapper<typename remove_reference<_Dp>::type>,\n                                 allocator<_Yp> > _CntrlBlk;\n    __cntrl_ = new _CntrlBlk(__r.get(), ref(__r.get_deleter()), allocator<_Yp>());\n    __enable_weak_this(__r.get());\n    __r.release();\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ntemplate<class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a2, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class ..._Args>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _A2;\n    typedef __allocator_destructor<_A2> _D2;\n    _A2 __a2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__a2.allocate(1), _D2(__a2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, _VSTD::forward<_Args>(__args)...);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared()\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::make_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, allocator<_Tp> > _CntrlBlk;\n    typedef allocator<_CntrlBlk> _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2;\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__alloc2, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, __a0);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, __a0, __a1);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\ntemplate<class _Tp>\ntemplate<class _Alloc, class _A0, class _A1, class _A2>\nshared_ptr<_Tp>\nshared_ptr<_Tp>::allocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    typedef __shared_ptr_emplace<_Tp, _Alloc> _CntrlBlk;\n    typedef typename _Alloc::template rebind<_CntrlBlk>::other _Alloc2;\n    typedef __allocator_destructor<_Alloc2> _D2;\n    _Alloc2 __alloc2(__a);\n    unique_ptr<_CntrlBlk, _D2> __hold2(__alloc2.allocate(1), _D2(__alloc2, 1));\n    ::new(__hold2.get()) _CntrlBlk(__a, __a0, __a1, __a2);\n    shared_ptr<_Tp> __r;\n    __r.__ptr_ = __hold2.get()->get();\n    __r.__cntrl_ = __hold2.release();\n    __r.__enable_weak_this(__r.__ptr_);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\nshared_ptr<_Tp>::~shared_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_shared();\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(const shared_ptr& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(const shared_ptr<_Yp>& __r) _NOEXCEPT\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>&\nshared_ptr<_Tp>::operator=(shared_ptr&& __r) _NOEXCEPT\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(shared_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>\n>::type&\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp>&& __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<_Yp*, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(auto_ptr<_Yp> __r)\n{\n    shared_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate <class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Yp>::value &&\n    is_convertible<typename unique_ptr<_Yp, _Dp>::pointer, _Tp*>::value,\n    shared_ptr<_Tp>&\n>::type\nshared_ptr<_Tp>::operator=(unique_ptr<_Yp, _Dp> __r)\n{\n    shared_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nshared_ptr<_Tp>::swap(shared_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nshared_ptr<_Tp>::reset() _NOEXCEPT\n{\n    shared_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p)\n{\n    shared_ptr(__p).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d)\n{\n    shared_ptr(__p, __d).swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp, class _Dp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    void\n>::type\nshared_ptr<_Tp>::reset(_Yp* __p, _Dp __d, _Alloc __a)\n{\n    shared_ptr(__p, __d, __a).swap(*this);\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nmake_shared(_Args&& ...__args)\n{\n    return shared_ptr<_Tp>::make_shared(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate<class _Tp, class _Alloc, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value,\n    shared_ptr<_Tp>\n>::type\nallocate_shared(const _Alloc& __a, _Args&& ...__args)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, _VSTD::forward<_Args>(__args)...);\n}\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared()\n{\n    return shared_ptr<_Tp>::make_shared();\n}\n\ntemplate<class _Tp, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0)\n{\n    return shared_ptr<_Tp>::make_shared(__a0);\n}\n\ntemplate<class _Tp, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1);\n}\n\ntemplate<class _Tp, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nmake_shared(_A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::make_shared(__a0, __a1, __a2);\n}\n\ntemplate<class _Tp, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1);\n}\n\ntemplate<class _Tp, class _Alloc, class _A0, class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\nallocate_shared(const _Alloc& __a, _A0& __a0, _A1& __a1, _A2& __a2)\n{\n    return shared_ptr<_Tp>::allocate_shared(__a, __a0, __a1, __a2);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __x.get() == __y.get();\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    typedef typename common_type<_Tp*, _Up*>::type _V;\n    return less<_V>()(__x.get(), __y.get());\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, const shared_ptr<_Up>& __y) _NOEXCEPT\n{\n    return !(__x < __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !__x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return static_cast<bool>(__x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return less<_Tp*>()(__x.get(), nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return less<_Tp*>()(nullptr, __x.get());\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return nullptr < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return __x < nullptr;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const shared_ptr<_Tp>& __x, nullptr_t) _NOEXCEPT\n{\n    return !(__x < nullptr);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(nullptr_t, const shared_ptr<_Tp>& __x) _NOEXCEPT\n{\n    return !(nullptr < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(shared_ptr<_Tp>& __x, shared_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nstatic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    return shared_ptr<_Tp>(__r, static_cast<_Tp*>(__r.get()));\n}\n\ntemplate<class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_array<_Tp>::value && !is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\ndynamic_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    _Tp* __p = dynamic_cast<_Tp*>(__r.get());\n    return __p ? shared_ptr<_Tp>(__r, __p) : shared_ptr<_Tp>();\n}\n\ntemplate<class _Tp, class _Up>\ntypename enable_if\n<\n    is_array<_Tp>::value == is_array<_Up>::value,\n    shared_ptr<_Tp>\n>::type\nconst_pointer_cast(const shared_ptr<_Up>& __r) _NOEXCEPT\n{\n    typedef typename remove_extent<_Tp>::type _RTp;\n    return shared_ptr<_Tp>(__r, const_cast<_RTp*>(__r.get()));\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Dp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Dp*\nget_deleter(const shared_ptr<_Tp>& __p) _NOEXCEPT\n{\n    return __p.template __get_deleter<_Dp>();\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY weak_ptr\n{\npublic:\n    typedef _Tp element_type;\nprivate:\n    element_type*        __ptr_;\n    __shared_weak_count* __cntrl_;\n\npublic:\n    _LIBCPP_CONSTEXPR weak_ptr() _NOEXCEPT;\n    template<class _Yp> weak_ptr(shared_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                        _NOEXCEPT;\n    weak_ptr(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp> weak_ptr(weak_ptr<_Yp> const& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    weak_ptr(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp> weak_ptr(weak_ptr<_Yp>&& __r,\n                   typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type = 0)\n                         _NOEXCEPT;\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    ~weak_ptr();\n\n    weak_ptr& operator=(weak_ptr const& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT;\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    weak_ptr& operator=(weak_ptr&& __r) _NOEXCEPT;\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT;\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template<class _Yp>\n        typename enable_if\n        <\n            is_convertible<_Yp*, element_type*>::value,\n            weak_ptr&\n        >::type\n        operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT;\n\n    void swap(weak_ptr& __r) _NOEXCEPT;\n    void reset() _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    long use_count() const _NOEXCEPT\n        {return __cntrl_ ? __cntrl_->use_count() : 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool expired() const _NOEXCEPT\n        {return __cntrl_ == 0 || __cntrl_->use_count() == 0;}\n    shared_ptr<_Tp> lock() const _NOEXCEPT;\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const shared_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n    template<class _Up>\n        _LIBCPP_INLINE_VISIBILITY\n        bool owner_before(const weak_ptr<_Up>& __r) const\n        {return __cntrl_ < __r.__cntrl_;}\n\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY weak_ptr;\n    template <class _Up> friend class _LIBCPP_TYPE_VIS_ONLY shared_ptr;\n};\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_LIBCPP_CONSTEXPR\nweak_ptr<_Tp>::weak_ptr() _NOEXCEPT\n    : __ptr_(0),\n      __cntrl_(0)\n{\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr const& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(shared_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n                         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp> const& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    if (__cntrl_)\n        __cntrl_->__add_weak();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr&& __r) _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>::weak_ptr(weak_ptr<_Yp>&& __r,\n                        typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat*>::type)\n         _NOEXCEPT\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_)\n{\n    __r.__ptr_ = 0;\n    __r.__cntrl_ = 0;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\nweak_ptr<_Tp>::~weak_ptr()\n{\n    if (__cntrl_)\n        __cntrl_->__release_weak();\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nweak_ptr<_Tp>&\nweak_ptr<_Tp>::operator=(weak_ptr&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(weak_ptr<_Yp>&& __r) _NOEXCEPT\n{\n    weak_ptr(_VSTD::move(__r)).swap(*this);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Tp>\ntemplate<class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_convertible<_Yp*, _Tp*>::value,\n    weak_ptr<_Tp>&\n>::type\nweak_ptr<_Tp>::operator=(shared_ptr<_Yp> const& __r) _NOEXCEPT\n{\n    weak_ptr(__r).swap(*this);\n    return *this;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nweak_ptr<_Tp>::swap(weak_ptr& __r) _NOEXCEPT\n{\n    _VSTD::swap(__ptr_, __r.__ptr_);\n    _VSTD::swap(__cntrl_, __r.__cntrl_);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(weak_ptr<_Tp>& __x, weak_ptr<_Tp>& __y) _NOEXCEPT\n{\n    __x.swap(__y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nweak_ptr<_Tp>::reset() _NOEXCEPT\n{\n    weak_ptr().swap(*this);\n}\n\ntemplate<class _Tp>\ntemplate<class _Yp>\nshared_ptr<_Tp>::shared_ptr(const weak_ptr<_Yp>& __r,\n                            typename enable_if<is_convertible<_Yp*, _Tp*>::value, __nat>::type)\n    : __ptr_(__r.__ptr_),\n      __cntrl_(__r.__cntrl_ ? __r.__cntrl_->lock() : __r.__cntrl_)\n{\n    if (__cntrl_ == 0)\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        throw bad_weak_ptr();\n#else\n        assert(!\"bad_weak_ptr\");\n#endif\n}\n\ntemplate<class _Tp>\nshared_ptr<_Tp>\nweak_ptr<_Tp>::lock() const _NOEXCEPT\n{\n    shared_ptr<_Tp> __r;\n    __r.__cntrl_ = __cntrl_ ? __cntrl_->lock() : __cntrl_;\n    if (__r.__cntrl_)\n        __r.__ptr_ = __ptr_;\n    return __r;\n}\n\ntemplate <class _Tp> struct owner_less;\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY owner_less<shared_ptr<_Tp> >\n    : binary_function<shared_ptr<_Tp>, shared_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY owner_less<weak_ptr<_Tp> >\n    : binary_function<weak_ptr<_Tp>, weak_ptr<_Tp>, bool>\n{\n    typedef bool result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(shared_ptr<_Tp> const& __x,   weak_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(  weak_ptr<_Tp> const& __x, shared_ptr<_Tp> const& __y) const\n        {return __x.owner_before(__y);}\n};\n\ntemplate<class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY enable_shared_from_this\n{\n    mutable weak_ptr<_Tp> __weak_this_;\nprotected:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR\n    enable_shared_from_this() _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this(enable_shared_from_this const&) _NOEXCEPT {}\n    _LIBCPP_INLINE_VISIBILITY\n    enable_shared_from_this& operator=(enable_shared_from_this const&) _NOEXCEPT\n        {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    ~enable_shared_from_this() {}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp> shared_from_this()\n        {return shared_ptr<_Tp>(__weak_this_);}\n    _LIBCPP_INLINE_VISIBILITY\n    shared_ptr<_Tp const> shared_from_this() const\n        {return shared_ptr<const _Tp>(__weak_this_);}\n\n    template <class _Up> friend class shared_ptr;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<shared_ptr<_Tp> >\n{\n    typedef shared_ptr<_Tp>      argument_type;\n    typedef size_t               result_type;\n    _LIBCPP_INLINE_VISIBILITY\n    result_type operator()(const argument_type& __ptr) const _NOEXCEPT\n    {\n        return hash<_Tp*>()(__ptr.get());\n    }\n};\n\ntemplate<class _CharT, class _Traits, class _Yp>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, shared_ptr<_Yp> const& __p);\n\n#if __has_feature(cxx_atomic) && !defined(_LIBCPP_HAS_NO_THREADS)\n\nclass _LIBCPP_TYPE_VIS __sp_mut\n{\n    void* __lx;\npublic:\n    void lock() _NOEXCEPT;\n    void unlock() _NOEXCEPT;\n\nprivate:\n    _LIBCPP_CONSTEXPR __sp_mut(void*) _NOEXCEPT;\n    __sp_mut(const __sp_mut&);\n    __sp_mut& operator=(const __sp_mut&);\n\n    friend _LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n};\n\n_LIBCPP_FUNC_VIS __sp_mut& __get_sp_mut(const void*);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_is_lock_free(const shared_ptr<_Tp>*)\n{\n    return false;\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_load(const shared_ptr<_Tp>* __p)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    shared_ptr<_Tp> __q = *__p;\n    __m.unlock();\n    return __q;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_load_explicit(const shared_ptr<_Tp>* __p, memory_order)\n{\n    return atomic_load(__p);\n}\n\ntemplate <class _Tp>\nvoid\natomic_store(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\natomic_store_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    atomic_store(__p, __r);\n}\n\ntemplate <class _Tp>\nshared_ptr<_Tp>\natomic_exchange(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    __p->swap(__r);\n    __m.unlock();\n    return __r;\n}\n  \ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nshared_ptr<_Tp>\natomic_exchange_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp> __r, memory_order)\n{\n    return atomic_exchange(__p, __r);\n}\n\ntemplate <class _Tp>\nbool\natomic_compare_exchange_strong(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    __sp_mut& __m = __get_sp_mut(__p);\n    __m.lock();\n    if (__p->__owner_equivalent(*__v))\n    {\n        *__p = __w;\n        __m.unlock();\n        return true;\n    }\n    *__v = *__p;\n    __m.unlock();\n    return false;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v, shared_ptr<_Tp> __w)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_strong_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                        shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_strong(__p, __v, __w);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\natomic_compare_exchange_weak_explicit(shared_ptr<_Tp>* __p, shared_ptr<_Tp>* __v,\n                                      shared_ptr<_Tp> __w, memory_order, memory_order)\n{\n    return atomic_compare_exchange_weak(__p, __v, __w);\n}\n\n#endif  // __has_feature(cxx_atomic) && !defined(_LIBCPP_HAS_NO_THREADS)\n\n//enum class\nstruct _LIBCPP_TYPE_VIS pointer_safety\n{\n    enum __lx\n    {\n        relaxed,\n        preferred,\n        strict\n    };\n\n    __lx __v_;\n\n    _LIBCPP_INLINE_VISIBILITY\n    pointer_safety(__lx __v) : __v_(__v) {}\n    _LIBCPP_INLINE_VISIBILITY\n    operator int() const {return __v_;}\n};\n\n_LIBCPP_FUNC_VIS void declare_reachable(void* __p);\n_LIBCPP_FUNC_VIS void declare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS void undeclare_no_pointers(char* __p, size_t __n);\n_LIBCPP_FUNC_VIS pointer_safety get_pointer_safety() _NOEXCEPT;\n_LIBCPP_FUNC_VIS void* __undeclare_reachable(void* __p);\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\nundeclare_reachable(_Tp* __p)\n{\n    return static_cast<_Tp*>(__undeclare_reachable(__p));\n}\n\n_LIBCPP_FUNC_VIS void* align(size_t __align, size_t __sz, void*& __ptr, size_t& __space);\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_MEMORY\n","// -*- C++ -*-\n//===------------------------ type_traits ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_TYPE_TRAITS\n#define _LIBCPP_TYPE_TRAITS\n\n/*\n    type_traits synopsis\n\nnamespace std\n{\n\n    // helper class:\n    template <class T, T v> struct integral_constant;\n    typedef integral_constant<bool, true>  true_type;\n    typedef integral_constant<bool, false> false_type;\n\n    // helper traits\n    template <bool, class T = void> struct enable_if;\n    template <bool, class T, class F> struct conditional;\n\n    // Primary classification traits:\n    template <class T> struct is_void;\n    template <class T> struct is_null_pointer;  // C++14\n    template <class T> struct is_integral;\n    template <class T> struct is_floating_point;\n    template <class T> struct is_array;\n    template <class T> struct is_pointer;\n    template <class T> struct is_lvalue_reference;\n    template <class T> struct is_rvalue_reference;\n    template <class T> struct is_member_object_pointer;\n    template <class T> struct is_member_function_pointer;\n    template <class T> struct is_enum;\n    template <class T> struct is_union;\n    template <class T> struct is_class;\n    template <class T> struct is_function;\n\n    // Secondary classification traits:\n    template <class T> struct is_reference;\n    template <class T> struct is_arithmetic;\n    template <class T> struct is_fundamental;\n    template <class T> struct is_member_pointer;\n    template <class T> struct is_scalar;\n    template <class T> struct is_object;\n    template <class T> struct is_compound;\n\n    // Const-volatile properties and transformations:\n    template <class T> struct is_const;\n    template <class T> struct is_volatile;\n    template <class T> struct remove_const;\n    template <class T> struct remove_volatile;\n    template <class T> struct remove_cv;\n    template <class T> struct add_const;\n    template <class T> struct add_volatile;\n    template <class T> struct add_cv;\n\n    // Reference transformations:\n    template <class T> struct remove_reference;\n    template <class T> struct add_lvalue_reference;\n    template <class T> struct add_rvalue_reference;\n\n    // Pointer transformations:\n    template <class T> struct remove_pointer;\n    template <class T> struct add_pointer;\n\n    // Integral properties:\n    template <class T> struct is_signed;\n    template <class T> struct is_unsigned;\n    template <class T> struct make_signed;\n    template <class T> struct make_unsigned;\n\n    // Array properties and transformations:\n    template <class T> struct rank;\n    template <class T, unsigned I = 0> struct extent;\n    template <class T> struct remove_extent;\n    template <class T> struct remove_all_extents;\n\n    // Member introspection:\n    template <class T> struct is_pod;\n    template <class T> struct is_trivial;\n    template <class T> struct is_trivially_copyable;\n    template <class T> struct is_standard_layout;\n    template <class T> struct is_literal_type;\n    template <class T> struct is_empty;\n    template <class T> struct is_polymorphic;\n    template <class T> struct is_abstract;\n    template <class T> struct is_final; // C++14\n\n    template <class T, class... Args> struct is_constructible;\n    template <class T>                struct is_default_constructible;\n    template <class T>                struct is_copy_constructible;\n    template <class T>                struct is_move_constructible;\n    template <class T, class U>       struct is_assignable;\n    template <class T>                struct is_copy_assignable;\n    template <class T>                struct is_move_assignable;\n    template <class T>                struct is_destructible;\n\n    template <class T, class... Args> struct is_trivially_constructible;\n    template <class T>                struct is_trivially_default_constructible;\n    template <class T>                struct is_trivially_copy_constructible;\n    template <class T>                struct is_trivially_move_constructible;\n    template <class T, class U>       struct is_trivially_assignable;\n    template <class T>                struct is_trivially_copy_assignable;\n    template <class T>                struct is_trivially_move_assignable;\n    template <class T>                struct is_trivially_destructible;\n\n    template <class T, class... Args> struct is_nothrow_constructible;\n    template <class T>                struct is_nothrow_default_constructible;\n    template <class T>                struct is_nothrow_copy_constructible;\n    template <class T>                struct is_nothrow_move_constructible;\n    template <class T, class U>       struct is_nothrow_assignable;\n    template <class T>                struct is_nothrow_copy_assignable;\n    template <class T>                struct is_nothrow_move_assignable;\n    template <class T>                struct is_nothrow_destructible;\n\n    template <class T> struct has_virtual_destructor;\n\n    // Relationships between types:\n    template <class T, class U> struct is_same;\n    template <class Base, class Derived> struct is_base_of;\n    template <class From, class To> struct is_convertible;\n\n    // Alignment properties and transformations:\n    template <class T> struct alignment_of;\n    template <size_t Len, size_t Align = most_stringent_alignment_requirement>\n        struct aligned_storage;\n    template <size_t Len, class... Types> struct aligned_union;\n\n    template <class T> struct decay;\n    template <class... T> struct common_type;\n    template <class T> struct underlying_type;\n    template <class> class result_of; // undefined\n    template <class Fn, class... ArgTypes> class result_of<Fn(ArgTypes...)>;\n\n    // const-volatile modifications:\n    template <class T>\n      using remove_const_t    = typename remove_const<T>::type;  // C++14\n    template <class T>\n      using remove_volatile_t = typename remove_volatile<T>::type;  // C++14\n    template <class T>\n      using remove_cv_t       = typename remove_cv<T>::type;  // C++14\n    template <class T>\n      using add_const_t       = typename add_const<T>::type;  // C++14\n    template <class T>\n      using add_volatile_t    = typename add_volatile<T>::type;  // C++14\n    template <class T>\n      using add_cv_t          = typename add_cv<T>::type;  // C++14\n  \n    // reference modifications:\n    template <class T>\n      using remove_reference_t     = typename remove_reference<T>::type;  // C++14\n    template <class T>\n      using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;  // C++14\n    template <class T>\n      using add_rvalue_reference_t = typename add_rvalue_reference<T>::type;  // C++14\n  \n    // sign modifications:\n    template <class T>\n      using make_signed_t   = typename make_signed<T>::type;  // C++14\n    template <class T>\n      using make_unsigned_t = typename make_unsigned<T>::type;  // C++14\n  \n    // array modifications:\n    template <class T>\n      using remove_extent_t      = typename remove_extent<T>::type;  // C++14\n    template <class T>\n      using remove_all_extents_t = typename remove_all_extents<T>::type;  // C++14\n\n    // pointer modifications:\n    template <class T>\n      using remove_pointer_t = typename remove_pointer<T>::type;  // C++14\n    template <class T>\n      using add_pointer_t    = typename add_pointer<T>::type;  // C++14\n\n    // other transformations:\n    template <size_t Len, std::size_t Align=default-alignment>\n      using aligned_storage_t = typename aligned_storage<Len,Align>::type;  // C++14\n    template <std::size_t Len, class... Types>\n      using aligned_union_t   = typename aligned_union<Len,Types...>::type;  // C++14\n    template <class T>\n      using decay_t           = typename decay<T>::type;  // C++14\n    template <bool b, class T=void>\n      using enable_if_t       = typename enable_if<b,T>::type;  // C++14\n    template <bool b, class T, class F>\n      using conditional_t     = typename conditional<b,T,F>::type;  // C++14\n    template <class... T>\n      using common_type_t     = typename common_type<T...>::type;  // C++14\n    template <class T>\n      using underlying_type_t = typename underlying_type<T>::type;  // C++14\n    template <class F, class... ArgTypes>\n      using result_of_t       = typename result_of<F(ArgTypes...)>::type;  // C++14\n\n}  // std\n\n*/\n#include <__config>\n#include <cstddef>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool _Bp, class _If, class _Then>\n    struct _LIBCPP_TYPE_VIS_ONLY conditional {typedef _If type;};\ntemplate <class _If, class _Then>\n    struct _LIBCPP_TYPE_VIS_ONLY conditional<false, _If, _Then> {typedef _Then type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;\n#endif\n\ntemplate <bool, class _Tp = void> struct _LIBCPP_TYPE_VIS_ONLY enable_if {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY enable_if<true, _Tp> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <bool _Bp, class _Tp = void> using enable_if_t = typename enable_if<_Bp, _Tp>::type;\n#endif\n\n\nstruct __two {char __lx[2];};\n\n// helper class:\n\ntemplate <class _Tp, _Tp __v>\nstruct _LIBCPP_TYPE_VIS_ONLY integral_constant\n{\n    static _LIBCPP_CONSTEXPR const _Tp      value = __v;\n    typedef _Tp               value_type;\n    typedef integral_constant type;\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_CONSTEXPR operator value_type() const _NOEXCEPT {return value;}\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n         constexpr value_type operator ()() const _NOEXCEPT {return value;}\n#endif\n};\n\ntemplate <class _Tp, _Tp __v>\n_LIBCPP_CONSTEXPR const _Tp integral_constant<_Tp, __v>::value;\n\ntypedef integral_constant<bool, true>  true_type;\ntypedef integral_constant<bool, false> false_type;\n\n// is_const\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_const            : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_const<_Tp const> : public true_type {};\n\n// is_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_volatile               : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_volatile<_Tp volatile> : public true_type {};\n\n// remove_const\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_const            {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_const<const _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;\n#endif\n\n// remove_volatile\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_volatile               {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_volatile<volatile _Tp> {typedef _Tp type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;\n#endif\n\n// remove_cv\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_cv\n{typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;};\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;\n#endif\n\n// is_void\n\ntemplate <class _Tp> struct __libcpp_is_void       : public false_type {};\ntemplate <>          struct __libcpp_is_void<void> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_void\n    : public __libcpp_is_void<typename remove_cv<_Tp>::type> {};\n\n// __is_nullptr_t\n\ntemplate <class _Tp> struct __is_nullptr_t_impl       : public false_type {};\ntemplate <>          struct __is_nullptr_t_impl<nullptr_t> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY __is_nullptr_t\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_null_pointer\n    : public __is_nullptr_t_impl<typename remove_cv<_Tp>::type> {};\n#endif\n\n// is_integral\n\ntemplate <class _Tp> struct __libcpp_is_integral                     : public false_type {};\ntemplate <>          struct __libcpp_is_integral<bool>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<signed char>        : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned char>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<wchar_t>            : public true_type {};\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<char16_t>           : public true_type {};\ntemplate <>          struct __libcpp_is_integral<char32_t>           : public true_type {};\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\ntemplate <>          struct __libcpp_is_integral<short>              : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned short>     : public true_type {};\ntemplate <>          struct __libcpp_is_integral<int>                : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned int>       : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long>               : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long>      : public true_type {};\ntemplate <>          struct __libcpp_is_integral<long long>          : public true_type {};\ntemplate <>          struct __libcpp_is_integral<unsigned long long> : public true_type {};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <>          struct __libcpp_is_integral<__int128_t>         : public true_type {};\ntemplate <>          struct __libcpp_is_integral<__uint128_t>        : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_integral\n    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};\n\n// is_floating_point\n\ntemplate <class _Tp> struct __libcpp_is_floating_point              : public false_type {};\ntemplate <>          struct __libcpp_is_floating_point<float>       : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<double>      : public true_type {};\ntemplate <>          struct __libcpp_is_floating_point<long double> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_floating_point\n    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};\n\n// is_array\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_array\n    : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_array<_Tp[]>\n    : public true_type {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY is_array<_Tp[_Np]>\n    : public true_type {};\n\n// is_pointer\n\ntemplate <class _Tp> struct __libcpp_is_pointer       : public false_type {};\ntemplate <class _Tp> struct __libcpp_is_pointer<_Tp*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pointer\n    : public __libcpp_is_pointer<typename remove_cv<_Tp>::type> {};\n\n// is_reference\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_lvalue_reference       : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_lvalue_reference<_Tp&> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_rvalue_reference        : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_rvalue_reference<_Tp&&> : public true_type {};\n#endif\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference        : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference<_Tp&>  : public true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_reference<_Tp&&> : public true_type {};\n#endif\n\n// is_union\n\n#if __has_feature(is_union) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_union\n    : public integral_constant<bool, __is_union(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_union : public false_type {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_union\n    : public __libcpp_union<typename remove_cv<_Tp>::type> {};\n\n#endif\n\n// is_class\n\n#if __has_feature(is_class) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_class\n    : public integral_constant<bool, __is_class(_Tp)> {};\n\n#else\n\nnamespace __is_class_imp\n{\ntemplate <class _Tp> char  __test(int _Tp::*);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_class\n    : public integral_constant<bool, sizeof(__is_class_imp::__test<_Tp>(0)) == 1 && !is_union<_Tp>::value> {};\n\n#endif\n\n// is_same\n\ntemplate <class _Tp, class _Up> struct _LIBCPP_TYPE_VIS_ONLY is_same           : public false_type {};\ntemplate <class _Tp>            struct _LIBCPP_TYPE_VIS_ONLY is_same<_Tp, _Tp> : public true_type {};\n\n// is_function\n\nnamespace __libcpp_is_function_imp\n{\nstruct __dummy_type {};\ntemplate <class _Tp> char  __test(_Tp*);\ntemplate <class _Tp> char __test(__dummy_type);\ntemplate <class _Tp> __two __test(...);\ntemplate <class _Tp> _Tp&  __source(int);\ntemplate <class _Tp> __dummy_type __source(long);\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value ||\n                            is_union<_Tp>::value ||\n                            is_void<_Tp>::value  ||\n                            is_reference<_Tp>::value ||\n                            __is_nullptr_t<_Tp>::value >\nstruct __libcpp_is_function\n    : public integral_constant<bool, sizeof(__libcpp_is_function_imp::__test<_Tp>(__libcpp_is_function_imp::__source<_Tp>(0))) == 1>\n    {};\ntemplate <class _Tp> struct __libcpp_is_function<_Tp, true> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_function\n    : public __libcpp_is_function<_Tp> {};\n\n// is_member_function_pointer\n\n// template <class _Tp> struct            __libcpp_is_member_function_pointer             : public false_type {};\n// template <class _Tp, class _Up> struct __libcpp_is_member_function_pointer<_Tp _Up::*> : public is_function<_Tp> {};\n// \n\ntemplate <class _MP, bool _IsMemberFuctionPtr, bool _IsMemberObjectPtr>\nstruct __member_pointer_traits_imp\n{  // forward declaration; specializations later\n};\n\n\nnamespace __libcpp_is_member_function_pointer_imp {\n    template <typename _Tp>\n    char __test(typename std::__member_pointer_traits_imp<_Tp, true, false>::_FnType *);\n\n    template <typename>\n    std::__two __test(...);\n};\n    \ntemplate <class _Tp> struct __libcpp_is_member_function_pointer\n    : public integral_constant<bool, sizeof(__libcpp_is_member_function_pointer_imp::__test<_Tp>(nullptr)) == 1> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_function_pointer\n    : public __libcpp_is_member_function_pointer<typename remove_cv<_Tp>::type> {};\n\n// is_member_pointer\n\ntemplate <class _Tp>            struct __libcpp_is_member_pointer             : public false_type {};\ntemplate <class _Tp, class _Up> struct __libcpp_is_member_pointer<_Tp _Up::*> : public true_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_pointer\n    : public __libcpp_is_member_pointer<typename remove_cv<_Tp>::type> {};\n\n// is_member_object_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_member_object_pointer\n    : public integral_constant<bool, is_member_pointer<_Tp>::value &&\n                                    !is_member_function_pointer<_Tp>::value> {};\n\n// is_enum\n\n#if __has_feature(is_enum) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_enum\n    : public integral_constant<bool, __is_enum(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_enum\n    : public integral_constant<bool, !is_void<_Tp>::value             &&\n                                     !is_integral<_Tp>::value         &&\n                                     !is_floating_point<_Tp>::value   &&\n                                     !is_array<_Tp>::value            &&\n                                     !is_pointer<_Tp>::value          &&\n                                     !is_reference<_Tp>::value        &&\n                                     !is_member_pointer<_Tp>::value   &&\n                                     !is_union<_Tp>::value            &&\n                                     !is_class<_Tp>::value            &&\n                                     !is_function<_Tp>::value         > {};\n\n#endif\n\n// is_arithmetic\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_arithmetic\n    : public integral_constant<bool, is_integral<_Tp>::value      ||\n                                     is_floating_point<_Tp>::value> {};\n\n// is_fundamental\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_fundamental\n    : public integral_constant<bool, is_void<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value ||\n                                     is_arithmetic<_Tp>::value> {};\n\n// is_scalar\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_scalar\n    : public integral_constant<bool, is_arithmetic<_Tp>::value     ||\n                                     is_member_pointer<_Tp>::value ||\n                                     is_pointer<_Tp>::value        ||\n                                     __is_nullptr_t<_Tp>::value    ||\n                                     is_enum<_Tp>::value           > {};\n\ntemplate <> struct _LIBCPP_TYPE_VIS_ONLY is_scalar<nullptr_t> : public true_type {};\n\n// is_object\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_object\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_array<_Tp>::value  ||\n                                     is_union<_Tp>::value  ||\n                                     is_class<_Tp>::value  > {};\n\n// is_compound\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_compound\n    : public integral_constant<bool, !is_fundamental<_Tp>::value> {};\n\n// add_const\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_const<_Tp>::value     >\nstruct __add_const             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_const<_Tp, false> {typedef const _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_const\n    {typedef typename __add_const<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_const_t = typename add_const<_Tp>::type;\n#endif\n\n// add_volatile\n\ntemplate <class _Tp, bool = is_reference<_Tp>::value ||\n                            is_function<_Tp>::value  ||\n                            is_volatile<_Tp>::value  >\nstruct __add_volatile             {typedef _Tp type;};\n\ntemplate <class _Tp>\nstruct __add_volatile<_Tp, false> {typedef volatile _Tp type;};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_volatile\n    {typedef typename __add_volatile<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_volatile_t = typename add_volatile<_Tp>::type;\n#endif\n\n// add_cv\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_cv\n    {typedef typename add_const<typename add_volatile<_Tp>::type>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_cv_t = typename add_cv<_Tp>::type;\n#endif\n\n// remove_reference\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference        {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference<_Tp&>  {typedef _Tp type;};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_reference<_Tp&&> {typedef _Tp type;};\n#endif\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;\n#endif\n\n// add_lvalue_reference\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference                      {typedef _Tp& type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<_Tp&>                {typedef _Tp& type;};  // for older compiler\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<void>                {typedef void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<const void>          {typedef const void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<volatile void>       {typedef volatile void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_lvalue_reference<const volatile void> {typedef const volatile void type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_lvalue_reference_t = typename add_lvalue_reference<_Tp>::type;\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY  add_rvalue_reference                     {typedef _Tp&& type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<void>                {typedef void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<const void>          {typedef const void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<volatile void>       {typedef volatile void type;};\ntemplate <>          struct _LIBCPP_TYPE_VIS_ONLY add_rvalue_reference<const volatile void> {typedef const volatile void type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_rvalue_reference_t = typename add_rvalue_reference<_Tp>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_rvalue_reference<_Tp>::type\ndeclval() _NOEXCEPT;\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ntypename add_lvalue_reference<_Tp>::type\ndeclval();\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\nstruct __any\n{\n    __any(...);\n};\n\n// remove_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer                      {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp*>                {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* const>          {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* volatile>       {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_pointer<_Tp* const volatile> {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_pointer_t = typename remove_pointer<_Tp>::type;\n#endif\n\n// add_pointer\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY add_pointer\n    {typedef typename remove_reference<_Tp>::type* type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using add_pointer_t = typename add_pointer<_Tp>::type;\n#endif\n\n// is_signed\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_signed_impl : public integral_constant<bool, _Tp(-1) < _Tp(0)> {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_signed_impl<_Tp, false> : public true_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_signed : public __libcpp_is_signed<_Tp> {};\n\n// is_unsigned\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value>\nstruct __libcpp_is_unsigned_impl : public integral_constant<bool, _Tp(0) < _Tp(-1)> {};\n\ntemplate <class _Tp>\nstruct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {};  // floating point\n\ntemplate <class _Tp, bool = is_arithmetic<_Tp>::value>\nstruct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};\n\ntemplate <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_unsigned : public __libcpp_is_unsigned<_Tp> {};\n\n// rank\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY rank\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY rank<_Tp[]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY rank<_Tp[_Np]>\n    : public integral_constant<size_t, rank<_Tp>::value + 1> {};\n\n// extent\n\ntemplate <class _Tp, unsigned _Ip = 0> struct _LIBCPP_TYPE_VIS_ONLY extent\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[], 0>\n    : public integral_constant<size_t, 0> {};\ntemplate <class _Tp, unsigned _Ip> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[_Np], 0>\n    : public integral_constant<size_t, _Np> {};\ntemplate <class _Tp, size_t _Np, unsigned _Ip> struct _LIBCPP_TYPE_VIS_ONLY extent<_Tp[_Np], _Ip>\n    : public integral_constant<size_t, extent<_Tp, _Ip-1>::value> {};\n\n// remove_extent\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_extent\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_extent<_Tp[]>\n    {typedef _Tp type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY remove_extent<_Tp[_Np]>\n    {typedef _Tp type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_extent_t = typename remove_extent<_Tp>::type;\n#endif\n\n// remove_all_extents\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents\n    {typedef _Tp type;};\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents<_Tp[]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\ntemplate <class _Tp, size_t _Np> struct _LIBCPP_TYPE_VIS_ONLY remove_all_extents<_Tp[_Np]>\n    {typedef typename remove_all_extents<_Tp>::type type;};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using remove_all_extents_t = typename remove_all_extents<_Tp>::type;\n#endif\n\n// decay\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY decay\n{\nprivate:\n    typedef typename remove_reference<_Tp>::type _Up;\npublic:\n    typedef typename conditional\n                     <\n                         is_array<_Up>::value,\n                         typename remove_extent<_Up>::type*,\n                         typename conditional\n                         <\n                              is_function<_Up>::value,\n                              typename add_pointer<_Up>::type,\n                              typename remove_cv<_Up>::type\n                         >::type\n                     >::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using decay_t = typename decay<_Tp>::type;\n#endif\n\n// is_abstract\n\nnamespace __is_abstract_imp\n{\ntemplate <class _Tp> char  __test(_Tp (*)[1]);\ntemplate <class _Tp> __two __test(...);\n}\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_abstract : public integral_constant<bool, sizeof(__is_abstract_imp::__test<_Tp>(0)) != 1> {};\n\ntemplate <class _Tp> struct __libcpp_abstract<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_abstract : public __libcpp_abstract<_Tp> {};\n\n// is_final\n\n#if _LIBCPP_STD_VER > 11 && __has_feature(is_final)\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY \nis_final : public integral_constant<bool, __is_final(_Tp)> {};\n#endif\n\n// is_base_of\n\n#ifdef _LIBCPP_HAS_IS_BASE_OF\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_base_of\n    : public integral_constant<bool, __is_base_of(_Bp, _Dp)> {};\n\n#else  // _LIBCPP_HAS_IS_BASE_OF\n\nnamespace __is_base_of_imp\n{\ntemplate <class _Tp>\nstruct _Dst\n{\n    _Dst(const volatile _Tp &);\n};\ntemplate <class _Tp>\nstruct _Src\n{\n    operator const volatile _Tp &();\n    template <class _Up> operator const _Dst<_Up> &();\n};\ntemplate <size_t> struct __one { typedef char type; };\ntemplate <class _Bp, class _Dp> typename __one<sizeof(_Dst<_Bp>(declval<_Src<_Dp> >()))>::type __test(int);\ntemplate <class _Bp, class _Dp> __two __test(...);\n}\n\ntemplate <class _Bp, class _Dp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_base_of\n    : public integral_constant<bool, is_class<_Bp>::value &&\n                                     sizeof(__is_base_of_imp::__test<_Bp, _Dp>(0)) == 2> {};\n\n#endif  // _LIBCPP_HAS_IS_BASE_OF\n\n// is_convertible\n\n#if __has_feature(is_convertible_to)\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY is_convertible\n    : public integral_constant<bool, __is_convertible_to(_T1, _T2) &&\n                                     !is_abstract<_T2>::value> {};\n\n#else  // __has_feature(is_convertible_to)\n\nnamespace __is_convertible_imp\n{\ntemplate <class _Tp> char  __test(_Tp);\ntemplate <class _Tp> __two __test(...);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _Tp> _Tp&& __source();\n#else\ntemplate <class _Tp> typename remove_reference<_Tp>::type& __source();\n#endif\n\ntemplate <class _Tp, bool _IsArray =    is_array<_Tp>::value,\n                     bool _IsFunction = is_function<_Tp>::value,\n                     bool _IsVoid =     is_void<_Tp>::value>\n                     struct __is_array_function_or_void                          {enum {value = 0};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, true, false, false> {enum {value = 1};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, true, false> {enum {value = 2};};\ntemplate <class _Tp> struct __is_array_function_or_void<_Tp, false, false, true> {enum {value = 3};};\n}\n\ntemplate <class _Tp,\n    unsigned = __is_convertible_imp::__is_array_function_or_void<typename remove_reference<_Tp>::type>::value>\nstruct __is_convertible_check\n{\n    static const size_t __v = 0;\n};\n\ntemplate <class _Tp>\nstruct __is_convertible_check<_Tp, 0>\n{\n    static const size_t __v = sizeof(_Tp);\n};\n\ntemplate <class _T1, class _T2,\n    unsigned _T1_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T1>::value,\n    unsigned _T2_is_array_function_or_void = __is_convertible_imp::__is_array_function_or_void<_T2>::value>\nstruct __is_convertible\n    : public integral_constant<bool,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n        sizeof(__is_convertible_imp::__test<_T2>(__is_convertible_imp::__source<_T1>())) == 1\n#else\n        sizeof(__is_convertible_imp::__test<_T2>(__is_convertible_imp::__source<_T1>())) == 1\n         && !(!is_function<_T1>::value && !is_reference<_T1>::value && is_reference<_T2>::value\n              && (!is_const<typename remove_reference<_T2>::type>::value\n                  || is_volatile<typename remove_reference<_T2>::type>::value)\n                  && (is_same<typename remove_cv<_T1>::type,\n                              typename remove_cv<typename remove_reference<_T2>::type>::type>::value\n                      || is_base_of<typename remove_reference<_T2>::type, _T1>::value))\n#endif\n    >\n{};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 0> : false_type {};\n\ntemplate <class _T1> struct __is_convertible<_T1, const _T1&, 1, 0> : true_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _T1> struct __is_convertible<_T1, _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, const _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, volatile _T1&&, 1, 0> : true_type {};\ntemplate <class _T1> struct __is_convertible<_T1, const volatile _T1&&, 1, 0> : true_type {};\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2*, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* const, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* volatile, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*volatile>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2* const volatile, 1, 0>\n    : public integral_constant<bool, __is_convertible<typename remove_all_extents<_T1>::type*, _T2*const volatile>::value> {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 0>                : public false_type {};\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntemplate <class _T1>            struct __is_convertible<_T1, _T1&&, 2, 0>               : public true_type {};\n#endif\ntemplate <class _T1>            struct __is_convertible<_T1, _T1&, 2, 0>               : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*, 2, 0>               : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*const, 2, 0>          : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*volatile, 2, 0>       : public true_type {};\ntemplate <class _T1>            struct __is_convertible<_T1, _T1*const volatile, 2, 0> : public true_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 0> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 1> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 1> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 2> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 2> : public false_type {};\n\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 0, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 1, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 2, 3> : public false_type {};\ntemplate <class _T1, class _T2> struct __is_convertible<_T1, _T2, 3, 3> : public true_type {};\n\ntemplate <class _T1, class _T2> struct _LIBCPP_TYPE_VIS_ONLY is_convertible\n    : public __is_convertible<_T1, _T2>\n{\n    static const size_t __complete_check1 = __is_convertible_check<_T1>::__v;\n    static const size_t __complete_check2 = __is_convertible_check<_T2>::__v;\n};\n\n#endif  // __has_feature(is_convertible_to)\n\n// is_empty\n\n#if __has_feature(is_empty) || (_GNUC_VER >= 407)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_empty\n    : public integral_constant<bool, __is_empty(_Tp)> {};\n\n#else  // __has_feature(is_empty)\n\ntemplate <class _Tp>\nstruct __is_empty1\n    : public _Tp\n{\n    double __lx;\n};\n\nstruct __is_empty2\n{\n    double __lx;\n};\n\ntemplate <class _Tp, bool = is_class<_Tp>::value>\nstruct __libcpp_empty : public integral_constant<bool, sizeof(__is_empty1<_Tp>) == sizeof(__is_empty2)> {};\n\ntemplate <class _Tp> struct __libcpp_empty<_Tp, false> : public false_type {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_empty : public __libcpp_empty<_Tp> {};\n\n#endif  // __has_feature(is_empty)\n\n// is_polymorphic\n\n#if __has_feature(is_polymorphic) || defined(_LIBCPP_MSVC)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_polymorphic\n    : public integral_constant<bool, __is_polymorphic(_Tp)> {};\n\n#else\n\ntemplate<typename _Tp> char &__is_polymorphic_impl(\n    typename enable_if<sizeof((_Tp*)dynamic_cast<const volatile void*>(declval<_Tp*>())) != 0,\n                       int>::type);\ntemplate<typename _Tp> __two &__is_polymorphic_impl(...);\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_polymorphic\n    : public integral_constant<bool, sizeof(__is_polymorphic_impl<_Tp>(0)) == 1> {};\n\n#endif // __has_feature(is_polymorphic)\n\n// has_virtual_destructor\n\n#if __has_feature(has_virtual_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY has_virtual_destructor\n    : public integral_constant<bool, __has_virtual_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY has_virtual_destructor\n    : public false_type {};\n\n#endif\n\n// alignment_of\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY alignment_of\n    : public integral_constant<size_t, __alignof__(_Tp)> {};\n\n// aligned_storage\n\ntemplate <class _Hp, class _Tp>\nstruct __type_list\n{\n    typedef _Hp _Head;\n    typedef _Tp _Tail;\n};\n\nstruct __nat\n{\n#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n    __nat() = delete;\n    __nat(const __nat&) = delete;\n    __nat& operator=(const __nat&) = delete;\n    ~__nat() = delete;\n#endif\n};\n\ntemplate <class _Tp>\nstruct __align_type\n{\n    static const size_t value = alignment_of<_Tp>::value;\n    typedef _Tp type;\n};\n\nstruct __struct_double {long double __lx;};\nstruct __struct_double4 {double __lx[4];};\n\ntypedef\n    __type_list<__align_type<unsigned char>,\n    __type_list<__align_type<unsigned short>,\n    __type_list<__align_type<unsigned int>,\n    __type_list<__align_type<unsigned long>,\n    __type_list<__align_type<unsigned long long>,\n    __type_list<__align_type<double>,\n    __type_list<__align_type<long double>,\n    __type_list<__align_type<__struct_double>,\n    __type_list<__align_type<__struct_double4>,\n    __type_list<__align_type<int*>,\n    __nat\n    > > > > > > > > > > __all_types;\n\ntemplate <class _TL, size_t _Align> struct __find_pod;\n\ntemplate <class _Hp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, __nat>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             void\n                         >::type type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Align>\nstruct __find_pod<__type_list<_Hp, _Tp>, _Align>\n{\n    typedef typename conditional<\n                             _Align == _Hp::value,\n                             typename _Hp::type,\n                             typename __find_pod<_Tp, _Align>::type\n                         >::type type;\n};\n\ntemplate <class _TL, size_t _Len> struct __find_max_align;\n\ntemplate <class _Hp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, __nat>, _Len> : public integral_constant<size_t, _Hp::value> {};\n\ntemplate <size_t _Len, size_t _A1, size_t _A2>\nstruct __select_align\n{\nprivate:\n    static const size_t __min = _A2 < _A1 ? _A2 : _A1;\n    static const size_t __max = _A1 < _A2 ? _A2 : _A1;\npublic:\n    static const size_t value = _Len < __max ? __min : __max;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Len>\nstruct __find_max_align<__type_list<_Hp, _Tp>, _Len>\n    : public integral_constant<size_t, __select_align<_Len, _Hp::value, __find_max_align<_Tp, _Len>::value>::value> {};\n\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\nstruct _LIBCPP_TYPE_VIS_ONLY aligned_storage\n{\n    typedef typename __find_pod<__all_types, _Align>::type _Aligner;\n    static_assert(!is_void<_Aligner>::value, \"\");\n    union type\n    {\n        _Aligner __align;\n        unsigned char __data[_Len];\n    };\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, size_t _Align = __find_max_align<__all_types, _Len>::value>\n    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;\n#endif\n\n#define _CREATE_ALIGNED_STORAGE_SPECIALIZATION(n) \\\ntemplate <size_t _Len>\\\nstruct _LIBCPP_TYPE_VIS_ONLY aligned_storage<_Len, n>\\\n{\\\n    struct _ALIGNAS(n) type\\\n    {\\\n        unsigned char __lx[_Len];\\\n    };\\\n}\n\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x8);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x10);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x20);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x40);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x80);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x100);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x200);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x400);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x800);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x1000);\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x2000);\n// MSDN says that MSVC does not support alignment beyond 8192 (=0x2000)\n#if !defined(_LIBCPP_MSVC)\n_CREATE_ALIGNED_STORAGE_SPECIALIZATION(0x4000);\n#endif // !_LIBCPP_MSVC\n\n#undef _CREATE_ALIGNED_STORAGE_SPECIALIZATION\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// aligned_union\n\ntemplate <size_t _I0, size_t ..._In>\nstruct __static_max;\n\ntemplate <size_t _I0>\nstruct __static_max<_I0>\n{\n    static const size_t value = _I0;\n};\n\ntemplate <size_t _I0, size_t _I1, size_t ..._In>\nstruct __static_max<_I0, _I1, _In...>\n{\n    static const size_t value = _I0 >= _I1 ? __static_max<_I0, _In...>::value :\n                                             __static_max<_I1, _In...>::value;\n};\n\ntemplate <size_t _Len, class _Type0, class ..._Types>\nstruct aligned_union\n{\n    static const size_t alignment_value = __static_max<__alignof__(_Type0),\n                                                       __alignof__(_Types)...>::value;\n    static const size_t __len = __static_max<_Len, sizeof(_Type0),\n                                             sizeof(_Types)...>::value;\n    typedef typename aligned_storage<__len, alignment_value>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <size_t _Len, class ..._Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nstruct __numeric_type\n{\n   static void __test(...);\n   static float __test(float);\n   static double __test(char);\n   static double __test(int);\n   static double __test(unsigned);\n   static double __test(long);\n   static double __test(unsigned long);\n   static double __test(long long);\n   static double __test(unsigned long long);\n   static double __test(double);\n   static long double __test(long double);\n\n   typedef decltype(__test(declval<_Tp>())) type;\n   static const bool value = !is_same<type, void>::value;\n};\n\ntemplate <>\nstruct __numeric_type<void>\n{\n   static const bool value = true;\n};\n\n// __promote\n\ntemplate <class _A1, class _A2 = void, class _A3 = void,\n          bool = __numeric_type<_A1>::value &&\n                 __numeric_type<_A2>::value &&\n                 __numeric_type<_A3>::value>\nclass __promote\n{\n    static const bool value = false;\n};\n\ntemplate <class _A1, class _A2, class _A3>\nclass __promote<_A1, _A2, _A3, true>\n{\nprivate:\n    typedef typename __promote<_A1>::type __type1;\n    typedef typename __promote<_A2>::type __type2;\n    typedef typename __promote<_A3>::type __type3;\npublic:\n    typedef decltype(__type1() + __type2() + __type3()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1, class _A2>\nclass __promote<_A1, _A2, void, true>\n{\nprivate:\n    typedef typename __promote<_A1>::type __type1;\n    typedef typename __promote<_A2>::type __type2;\npublic:\n    typedef decltype(__type1() + __type2()) type;\n    static const bool value = true;\n};\n\ntemplate <class _A1>\nclass __promote<_A1, void, void, true>\n{\npublic:\n    typedef typename __numeric_type<_A1>::type type;\n    static const bool value = true;\n    static const bool __does_not_throw = _NOEXCEPT_OR_FALSE(static_cast<type>(declval<_A1>()));\n};\n\n#ifdef _LIBCPP_STORE_AS_OPTIMIZATION\n\n// __transform\n\ntemplate <class _Tp, size_t = sizeof(_Tp), bool = is_scalar<_Tp>::value> struct __transform {typedef _Tp type;};\ntemplate <class _Tp> struct __transform<_Tp, 1, true> {typedef unsigned char      type;};\ntemplate <class _Tp> struct __transform<_Tp, 2, true> {typedef unsigned short     type;};\ntemplate <class _Tp> struct __transform<_Tp, 4, true> {typedef unsigned int       type;};\ntemplate <class _Tp> struct __transform<_Tp, 8, true> {typedef unsigned long long type;};\n\n#endif  // _LIBCPP_STORE_AS_OPTIMIZATION\n\n// make_signed / make_unsigned\n\ntypedef\n    __type_list<signed char,\n    __type_list<signed short,\n    __type_list<signed int,\n    __type_list<signed long,\n    __type_list<signed long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__int128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __signed_types;\n\ntypedef\n    __type_list<unsigned char,\n    __type_list<unsigned short,\n    __type_list<unsigned int,\n    __type_list<unsigned long,\n    __type_list<unsigned long long,\n#ifndef _LIBCPP_HAS_NO_INT128\n    __type_list<__uint128_t,\n#endif\n    __nat\n#ifndef _LIBCPP_HAS_NO_INT128\n    >\n#endif\n    > > > > > __unsigned_types;\n\ntemplate <class _TypeList, size_t _Size, bool = _Size <= sizeof(typename _TypeList::_Head)> struct __find_first;\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, true>\n{\n    typedef _Hp type;\n};\n\ntemplate <class _Hp, class _Tp, size_t _Size>\nstruct __find_first<__type_list<_Hp, _Tp>, _Size, false>\n{\n    typedef typename __find_first<_Tp, _Size>::type type;\n};\n\ntemplate <class _Tp, class _Up, bool = is_const<typename remove_reference<_Tp>::type>::value,\n                             bool = is_volatile<typename remove_reference<_Tp>::type>::value>\nstruct __apply_cv\n{\n    typedef _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, false>\n{\n    typedef const _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, false, true>\n{\n    typedef volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp, _Up, true, true>\n{\n    typedef const volatile _Up type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, false>\n{\n    typedef _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, false>\n{\n    typedef const _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, false, true>\n{\n    typedef volatile _Up& type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct __apply_cv<_Tp&, _Up, true, true>\n{\n    typedef const volatile _Up& type;\n};\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_signed {};\n\ntemplate <class _Tp>\nstruct __make_signed<_Tp, true>\n{\n    typedef typename __find_first<__signed_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_signed<bool,               true> {};\ntemplate <> struct __make_signed<  signed short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<unsigned short,     true> {typedef short     type;};\ntemplate <> struct __make_signed<  signed int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<unsigned int,       true> {typedef int       type;};\ntemplate <> struct __make_signed<  signed long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<unsigned long,      true> {typedef long      type;};\ntemplate <> struct __make_signed<  signed long long, true> {typedef long long type;};\ntemplate <> struct __make_signed<unsigned long long, true> {typedef long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_signed<__int128_t,         true> {typedef __int128_t type;};\ntemplate <> struct __make_signed<__uint128_t,        true> {typedef __int128_t type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY make_signed\n{\n    typedef typename __apply_cv<_Tp, typename __make_signed<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_signed_t = typename make_signed<_Tp>::type;\n#endif\n\ntemplate <class _Tp, bool = is_integral<_Tp>::value || is_enum<_Tp>::value>\nstruct __make_unsigned {};\n\ntemplate <class _Tp>\nstruct __make_unsigned<_Tp, true>\n{\n    typedef typename __find_first<__unsigned_types, sizeof(_Tp)>::type type;\n};\n\ntemplate <> struct __make_unsigned<bool,               true> {};\ntemplate <> struct __make_unsigned<  signed short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<unsigned short,     true> {typedef unsigned short     type;};\ntemplate <> struct __make_unsigned<  signed int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<unsigned int,       true> {typedef unsigned int       type;};\ntemplate <> struct __make_unsigned<  signed long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<unsigned long,      true> {typedef unsigned long      type;};\ntemplate <> struct __make_unsigned<  signed long long, true> {typedef unsigned long long type;};\ntemplate <> struct __make_unsigned<unsigned long long, true> {typedef unsigned long long type;};\n#ifndef _LIBCPP_HAS_NO_INT128\ntemplate <> struct __make_unsigned<__int128_t,         true> {typedef __uint128_t        type;};\ntemplate <> struct __make_unsigned<__uint128_t,        true> {typedef __uint128_t        type;};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY make_unsigned\n{\n    typedef typename __apply_cv<_Tp, typename __make_unsigned<typename remove_cv<_Tp>::type>::type>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using make_unsigned_t = typename make_unsigned<_Tp>::type;\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Up = void, class V = void>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type\n{\npublic:\n    typedef typename common_type<typename common_type<_Tp, _Up>::type, V>::type type;\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, void, void>\n{\npublic:\n    typedef typename decay<_Tp>::type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up, void>\n{\nprivate:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    static _Tp&& __t();\n    static _Up&& __u();\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    static _Tp __t();\n    static _Up __u();\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\npublic:\n    typedef typename remove_reference<decltype(true ? __t() : __u())>::type type;\n};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class ..._Tp> struct common_type;\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp>\n{\n    typedef typename decay<_Tp>::type type;\n};\n\ntemplate <class _Tp, class _Up>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up>\n{\nprivate:\n    static _Tp&& __t();\n    static _Up&& __u();\n    static bool __f();\npublic:\n    typedef typename decay<decltype(__f() ? __t() : __u())>::type type;\n};\n\ntemplate <class _Tp, class _Up, class ..._Vp>\nstruct _LIBCPP_TYPE_VIS_ONLY common_type<_Tp, _Up, _Vp...>\n{\n    typedef typename common_type<typename common_type<_Tp, _Up>::type, _Vp...>::type type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class ..._Tp> using common_type_t = typename common_type<_Tp...>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_assignable\n\ntemplate<typename, typename _Tp> struct __select_2nd { typedef _Tp type; };\n\ntemplate <class _Tp, class _Arg>\ntypename __select_2nd<decltype((_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>())), true_type>::type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n__is_assignable_test(_Tp&&, _Arg&&);\n#else\n__is_assignable_test(_Tp, _Arg&);\n#endif\n\ntemplate <class _Arg>\nfalse_type\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n__is_assignable_test(__any, _Arg&&);\n#else\n__is_assignable_test(__any, _Arg&);\n#endif\n\ntemplate <class _Tp, class _Arg, bool = is_void<_Tp>::value || is_void<_Arg>::value>\nstruct __is_assignable_imp\n    : public common_type\n        <\n            decltype(__is_assignable_test(declval<_Tp>(), declval<_Arg>()))\n        >::type {};\n\ntemplate <class _Tp, class _Arg>\nstruct __is_assignable_imp<_Tp, _Arg, true>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct is_assignable\n    : public __is_assignable_imp<_Tp, _Arg> {};\n\n// is_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_copy_assignable\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n// is_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_move_assignable\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_assignable<typename add_lvalue_reference<_Tp>::type,\n                     const typename add_rvalue_reference<_Tp>::type> {};\n#else\n    : public is_copy_assignable<_Tp> {};\n#endif\n\n// is_destructible\n\n//\tif it's a reference, return true\n//\tif it's a function, return false\n//\tif it's   void,     return false\n//\tif it's an array of unknown bound, return false\n//\tOtherwise, return \"std::declval<_Up&>().~_Up()\" is well-formed\n//    where _Up is remove_all_extents<_Tp>::type\n\ntemplate <class>\nstruct __is_destructible_apply { typedef int type; };\n\ntemplate <typename _Tp>\nstruct __is_destructor_wellformed {\n\ttemplate <typename _Tp1>\n\tstatic char  __test (\n        typename __is_destructible_apply<decltype(_VSTD::declval<_Tp1&>().~_Tp1())>::type\n    );\n\n\ttemplate <typename _Tp1>\n\tstatic __two __test (...);\n\t\n\tstatic const bool value = sizeof(__test<_Tp>(12)) == sizeof(char);\n};\n\ntemplate <class _Tp, bool>\nstruct __destructible_imp;\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, false> \n   : public _VSTD::integral_constant<bool, \n        __is_destructor_wellformed<typename _VSTD::remove_all_extents<_Tp>::type>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_imp<_Tp, true>\n    : public _VSTD::true_type {};\n\ntemplate <class _Tp, bool>\nstruct __destructible_false;\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, false> : public __destructible_imp<_Tp, _VSTD::is_reference<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct __destructible_false<_Tp, true> : public _VSTD::false_type {};\n\ntemplate <class _Tp>\nstruct is_destructible\n    : public __destructible_false<_Tp, _VSTD::is_function<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_destructible<_Tp[]>\n    : public _VSTD::false_type {};\n\ntemplate <>\nstruct is_destructible<void>\n    : public _VSTD::false_type {};\n\n// move\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename remove_reference<_Tp>::type&&\nmove(_Tp&& __t) _NOEXCEPT\n{\n    typedef typename remove_reference<_Tp>::type _Up;\n    return static_cast<_Up&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp&&\nforward(typename std::remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return static_cast<_Tp&&>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp&&\nforward(typename std::remove_reference<_Tp>::type&& __t) _NOEXCEPT\n{\n    static_assert(!std::is_lvalue_reference<_Tp>::value,\n                  \"Can not forward an rvalue as an lvalue.\");\n    return static_cast<_Tp&&>(__t);\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nmove(_Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Tp&\nmove(const _Tp& __t)\n{\n    return __t;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\nforward(typename std::remove_reference<_Tp>::type& __t) _NOEXCEPT\n{\n    return __t;\n}\n\n\ntemplate <class _Tp>\nclass __rv\n{\n    typedef typename remove_reference<_Tp>::type _Trr;\n    _Trr& t_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    _Trr* operator->() {return &t_;}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __rv(_Trr& __t) : t_(__t) {}\n};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(_Tp&& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#else\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename decay<_Tp>::type\n__decay_copy(const _Tp& __t)\n{\n    return _VSTD::forward<_Tp>(__t);\n}\n\n#endif\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#if __has_feature(cxx_reference_qualified_functions)\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &, true, false>\n{\n    typedef _Class& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&, true, false>\n{\n    typedef _Class const& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&, true, false>\n{\n    typedef _Class volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&, true, false>\n{\n    typedef _Class const volatile& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) &&, true, false>\n{\n    typedef _Class&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const&&, true, false>\n{\n    typedef _Class const&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) volatile&&, true, false>\n{\n    typedef _Class volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param...);\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_Param..., ...) const volatile&&, true, false>\n{\n    typedef _Class const volatile&& _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_Param..., ...);\n};\n\n#endif  // __has_feature(cxx_reference_qualified_functions)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...), true, false>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const, true, false>\n{\n    typedef _Class const _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) volatile, true, false>\n{\n    typedef _Class volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)() const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) ();\n};\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (...);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0);\n};\n\ntemplate <class _Rp, class _Class, class _P0>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, ...);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2);\n};\n\ntemplate <class _Rp, class _Class, class _P0, class _P1, class _P2>\nstruct __member_pointer_traits_imp<_Rp (_Class::*)(_P0, _P1, _P2, ...) const volatile, true, false>\n{\n    typedef _Class const volatile _ClassType;\n    typedef _Rp _ReturnType;\n    typedef _Rp (_FnType) (_P0, _P1, _P2, ...);\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Rp, class _Class>\nstruct __member_pointer_traits_imp<_Rp _Class::*, false, true>\n{\n    typedef _Class _ClassType;\n    typedef _Rp _ReturnType;\n};\n\ntemplate <class _MP>\nstruct __member_pointer_traits\n    : public __member_pointer_traits_imp<typename remove_cv<_MP>::type,\n                    is_member_function_pointer<_MP>::value,\n                    is_member_object_pointer<_MP>::value>\n{\n//     typedef ... _ClassType;\n//     typedef ... _ReturnType;\n//     typedef ... _FnType;\n};\n\n// result_of\n\ntemplate <class _Callable> class result_of;\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Fn, bool, bool>\nclass __result_of\n{\n};\n\ntemplate <class _Fn>\nclass __result_of<_Fn(), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()()) type;\n};\n\ntemplate <class _Fn, class _A0>\nclass __result_of<_Fn(_A0), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass __result_of<_Fn(_A0, _A1), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>())) type;\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_A0, _A1, _A2), true, false>\n{\npublic:\n    typedef decltype(declval<_Fn>()(declval<_A0>(), declval<_A1>(), declval<_A2>())) type;\n};\n\ntemplate <class _MP, class _Tp, bool _IsMemberFunctionPtr>\nstruct __result_of_mp;\n\n// member function pointer\n\ntemplate <class _MP, class _Tp>\nstruct __result_of_mp<_MP, _Tp, true>\n    : public common_type<typename __member_pointer_traits<_MP>::_ReturnType>\n{\n};\n\n// member data pointer\n\ntemplate <class _MP, class _Tp, bool>\nstruct __result_of_mdp;\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, false>\n{\n    typedef typename __apply_cv<decltype(*_VSTD::declval<_Tp>()), _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mdp<_Rp _Class::*, _Tp, true>\n{\n    typedef typename __apply_cv<_Tp, _Rp>::type& type;\n};\n\ntemplate <class _Rp, class _Class, class _Tp>\nstruct __result_of_mp<_Rp _Class::*, _Tp, false>\n    : public __result_of_mdp<_Rp _Class::*, _Tp,\n            is_base_of<_Class, typename remove_reference<_Tp>::type>::value>\n{\n};\n\n\n\ntemplate <class _Fn, class _Tp>\nclass __result_of<_Fn(_Tp), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0>\nclass __result_of<_Fn(_Tp, _A0), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1>\nclass __result_of<_Fn(_Tp, _A0, _A1), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\ntemplate <class _Fn, class _Tp, class _A0, class _A1, class _A2>\nclass __result_of<_Fn(_Tp, _A0, _A1, _A2), false, true>  // _Fn must be member pointer\n    : public __result_of_mp<typename remove_reference<_Fn>::type,\n                            _Tp,\n                            is_member_function_pointer<typename remove_reference<_Fn>::type>::value>\n{\n};\n\n// result_of\n\ntemplate <class _Fn>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn()>\n    : public __result_of<_Fn(),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0)>\n    : public __result_of<_Fn(_A0),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0, _A1)>\n    : public __result_of<_Fn(_A0, _A1),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\ntemplate <class _Fn, class _A0, class _A1, class _A2>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fn(_A0, _A1, _A2)>\n    : public __result_of<_Fn(_A0, _A1, _A2),\n                         is_class<typename remove_reference<_Fn>::type>::value ||\n                         is_function<typename remove_reference<_Fn>::type>::value,\n                         is_member_pointer<typename remove_reference<_Fn>::type>::value\n                        >\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T, class... Args> struct is_constructible;\n\nnamespace __is_construct\n{\nstruct __nat {};\n}\n\n#if __has_feature(is_constructible)\n\ntemplate <class _Tp, class ..._Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public integral_constant<bool, __is_constructible(_Tp, _Args...)>\n    {};\n\n#else\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n//      main is_constructible test\n\ntemplate <class _Tp, class ..._Args>\ntypename __select_2nd<decltype(_VSTD::move(_Tp(_VSTD::declval<_Args>()...))), true_type>::type\n__is_constructible_test(_Tp&&, _Args&& ...);\n\ntemplate <class ..._Args>\nfalse_type\n__is_constructible_test(__any, _Args&& ...);\n\ntemplate <bool, class _Tp, class... _Args>\nstruct __libcpp_is_constructible // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible_test(declval<_Tp>(), declval<_Args>()...))\n             >::type\n    {};\n\n//      function types are not constructible\n\ntemplate <class _Rp, class... _A1, class... _A2>\nstruct __libcpp_is_constructible<false, _Rp(_A1...), _A2...>\n    : public false_type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __libcpp_is_constructible<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\n//      Scalars and references are constructible from one arg if that arg is\n//          implicitly convertible to the scalar or reference.\n\ntemplate <class _Tp>\nstruct __is_constructible_ref\n{\n    true_type static __lxx(_Tp);\n    false_type static __lxx(...);\n};\n\ntemplate <class _Tp, class _A0>\nstruct __libcpp_is_constructible<true, _Tp, _A0>\n    : public common_type\n             <\n                 decltype(__is_constructible_ref<_Tp>::__lxx(declval<_A0>()))\n             >::type\n    {};\n\n//      Scalars and references are not constructible from multiple args.\n\ntemplate <class _Tp, class _A0, class ..._Args>\nstruct __libcpp_is_constructible<true, _Tp, _A0, _Args...>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp, class... _Args>\nstruct __is_constructible_void_check\n    : public __libcpp_is_constructible<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _Args...>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp, class... _Args>\nstruct __is_constructible_void_check<true, _Tp, _Args...>\n    : public false_type\n    {};\n\ntemplate <class ..._Args> struct __contains_void;\n\ntemplate <> struct __contains_void<> : false_type {};\n\ntemplate <class _A0, class ..._Args>\nstruct __contains_void<_A0, _Args...>\n{\n    static const bool value = is_void<_A0>::value ||\n                              __contains_void<_Args...>::value;\n};\n\n//      is_constructible entry point\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public __is_constructible_void_check<__contains_void<_Tp, _Args...>::value\n                                        || is_abstract<_Tp>::value,\n                                           _Tp, _Args...>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __libcpp_is_constructible<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\n//      Otherwise array types are not constructible by this syntax\n\ntemplate <class _Ap, size_t _Np, class ..._Args>\nstruct __libcpp_is_constructible<false, _Ap[_Np], _Args...>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap, class ..._Args>\nstruct __libcpp_is_constructible<false, _Ap[], _Args...>\n    : public false_type\n    {};\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// template <class T> struct is_constructible0;\n\n//      main is_constructible0 test\n\ntemplate <class _Tp>\ndecltype((_Tp(), true_type()))\n__is_constructible0_test(_Tp&);\n\nfalse_type\n__is_constructible0_test(__any);\n\ntemplate <class _Tp, class _A0>\ndecltype((_Tp(_VSTD::declval<_A0>()), true_type()))\n__is_constructible1_test(_Tp&, _A0&);\n\ntemplate <class _A0>\nfalse_type\n__is_constructible1_test(__any, _A0&);\n\ntemplate <class _Tp, class _A0, class _A1>\ndecltype((_Tp(_VSTD::declval<_A0>(), _VSTD::declval<_A1>()), true_type()))\n__is_constructible2_test(_Tp&, _A0&, _A1&);\n\ntemplate <class _A0, class _A1>\nfalse_type\n__is_constructible2_test(__any, _A0&, _A1&);\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible0_test(declval<_Tp&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible1_test(declval<_Tp&>(), declval<_A0&>()))\n             >::type\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp // false, _Tp is not a scalar\n    : public common_type\n             <\n                 decltype(__is_constructible2_test(declval<_Tp&>(), declval<_A0>(), declval<_A1>()))\n             >::type\n    {};\n\n//      handle scalars and reference types\n\n//      Scalars are default constructible, references are not\n\ntemplate <class _Tp>\nstruct __is_constructible0_imp<true, _Tp>\n    : public is_scalar<_Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_imp<true, _Tp, _A0>\n    : public is_convertible<_A0, _Tp>\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_imp<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      Treat scalars and reference types separately\n\ntemplate <bool, class _Tp>\nstruct __is_constructible0_void_check\n    : public __is_constructible0_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp>\n    {};\n\ntemplate <bool, class _Tp, class _A0>\nstruct __is_constructible1_void_check\n    : public __is_constructible1_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0>\n    {};\n\ntemplate <bool, class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check\n    : public __is_constructible2_imp<is_scalar<_Tp>::value || is_reference<_Tp>::value,\n                                _Tp, _A0, _A1>\n    {};\n\n//      If any of T or Args is void, is_constructible should be false\n\ntemplate <class _Tp>\nstruct __is_constructible0_void_check<true, _Tp>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct __is_constructible1_void_check<true, _Tp, _A0>\n    : public false_type\n    {};\n\ntemplate <class _Tp, class _A0, class _A1>\nstruct __is_constructible2_void_check<true, _Tp, _A0, _A1>\n    : public false_type\n    {};\n\n//      is_constructible entry point\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible\n    : public __is_constructible2_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value\n                                        || is_void<_A1>::value,\n                                           _Tp, _A0, _A1>\n    {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible<_Tp, __is_construct::__nat, __is_construct::__nat>\n    : public __is_constructible0_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value,\n                                           _Tp>\n    {};\n\ntemplate <class _Tp, class _A0>\nstruct _LIBCPP_TYPE_VIS_ONLY is_constructible<_Tp, _A0, __is_construct::__nat>\n    : public __is_constructible1_void_check<is_void<_Tp>::value\n                                        || is_abstract<_Tp>::value\n                                        || is_function<_Tp>::value\n                                        || is_void<_A0>::value,\n                                           _Tp, _A0>\n    {};\n\n//      Array types are default constructible if their element type\n//      is default constructible\n\ntemplate <class _Ap, size_t _Np>\nstruct __is_constructible0_imp<false, _Ap[_Np]>\n    : public is_constructible<typename remove_all_extents<_Ap>::type>\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0>\nstruct __is_constructible1_imp<false, _Ap[_Np], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, size_t _Np, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[_Np], _A0, _A1>\n    : public false_type\n    {};\n\n//      Incomplete array types are not constructible\n\ntemplate <class _Ap>\nstruct __is_constructible0_imp<false, _Ap[]>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0>\nstruct __is_constructible1_imp<false, _Ap[], _A0>\n    : public false_type\n    {};\n\ntemplate <class _Ap, class _A0, class _A1>\nstruct __is_constructible2_imp<false, _Ap[], _A0, _A1>\n    : public false_type\n    {};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // __has_feature(is_constructible)\n\n// is_default_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_default_constructible\n    : public is_constructible<_Tp>\n    {};\n\n// is_copy_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_copy_constructible\n    : public is_constructible<_Tp, \n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n// is_move_constructible\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_copy_constructible<_Tp>\n#endif\n    {};\n\n// is_trivially_constructible\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Args...)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp>\n#if __has_feature(has_trivial_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_trivial_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp>\n#endif\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible\n    : false_type\n{\n};\n\n#if __has_feature(is_trivially_constructible)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, const _Tp&)>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, __is_trivially_constructible(_Tp, _Tp&)>\n{\n};\n\n#else  // !__has_feature(is_trivially_constructible)\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_trivially_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n    : integral_constant<bool, is_scalar<_Tp>::value>\n{\n};\n\n#endif  // !__has_feature(is_trivially_constructible)\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n// is_trivially_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_default_constructible\n    : public is_trivially_constructible<_Tp>\n    {};\n\n// is_trivially_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copy_constructible\n    : public is_trivially_constructible<_Tp, typename add_lvalue_reference<const _Tp>::type>\n    {};\n\n// is_trivially_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_trivially_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_trivially_copy_constructible<_Tp>\n#endif\n    {};\n\n// is_trivially_assignable\n\n#if __has_feature(is_trivially_assignable)\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : integral_constant<bool, __is_trivially_assignable(_Tp, _Arg)>\n{\n};\n\n#else  // !__has_feature(is_trivially_assignable)\n\ntemplate <class _Tp, class _Arg>\nstruct is_trivially_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, const _Tp&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_trivially_assignable<_Tp&, _Tp&&>\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // !__has_feature(is_trivially_assignable)\n\n// is_trivially_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copy_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n// is_trivially_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_move_assignable\n    : public is_trivially_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n// is_trivially_destructible\n\n#if __has_feature(has_trivial_destructor) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible\n    : public integral_constant<bool, is_destructible<_Tp>::value && __has_trivial_destructor(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct __libcpp_trivial_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_destructible\n    : public __libcpp_trivial_destructor<typename remove_all_extents<_Tp>::type> {};\n\n#endif\n\n// is_nothrow_constructible\n\n#if 0\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : public integral_constant<bool, __is_nothrow_constructible(_Tp(_Args...))>\n{\n};\n\n#else\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp, class... _Args> struct __libcpp_is_nothrow_constructible;\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_nothrow_constructible<true, _Tp, _Args...>\n    : public integral_constant<bool, noexcept(_Tp(declval<_Args>()...))>\n{\n};\n\ntemplate <class _Tp, class... _Args>\nstruct __libcpp_is_nothrow_constructible<false, _Tp, _Args...>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp, _Args...>::value, _Tp, _Args...>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp[_Ns]>\n    : __libcpp_is_nothrow_constructible<is_constructible<_Tp>::value, _Tp>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class... _Args>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&&>\n#else\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp>\n#endif\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, const _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // __has_feature(cxx_noexcept)\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _A0 = __is_construct::__nat,\n                     class _A1 = __is_construct::__nat>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible\n    : false_type\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, __is_construct::__nat,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_constructor) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_constructor(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, const _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_constructible<_Tp, _Tp&,\n                                                       __is_construct::__nat>\n#if __has_feature(has_nothrow_copy) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_copy(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value>\n#endif\n{\n};\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // __has_feature(is_nothrow_constructible)\n\n// is_nothrow_default_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_default_constructible\n    : public is_nothrow_constructible<_Tp>\n    {};\n\n// is_nothrow_copy_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_copy_constructible\n    : public is_nothrow_constructible<_Tp,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n// is_nothrow_move_constructible\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_move_constructible\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    : public is_nothrow_constructible<_Tp, typename add_rvalue_reference<_Tp>::type>\n#else\n    : public is_nothrow_copy_constructible<_Tp>\n#endif\n    {};\n\n// is_nothrow_assignable\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp, class _Arg> struct __libcpp_is_nothrow_assignable;\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<false, _Tp, _Arg>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct __libcpp_is_nothrow_assignable<true, _Tp, _Arg>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>() = _VSTD::declval<_Arg>()) >\n{\n};\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable\n    : public __libcpp_is_nothrow_assignable<is_assignable<_Tp, _Arg>::value, _Tp, _Arg>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp, class _Arg>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable\n    : public false_type {};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, _Tp>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_assignable<_Tp&, const _Tp&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct is_nothrow_assignable<_Tp&, _Tp&&>\n#if __has_feature(has_nothrow_assign) || (_GNUC_VER >= 403)\n    : integral_constant<bool, __has_nothrow_assign(_Tp)> {};\n#else\n    : integral_constant<bool, is_scalar<_Tp>::value> {};\n#endif\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // __has_feature(cxx_noexcept)\n\n// is_nothrow_copy_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_copy_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n                  typename add_lvalue_reference<typename add_const<_Tp>::type>::type> {};\n\n// is_nothrow_move_assignable\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_move_assignable\n    : public is_nothrow_assignable<typename add_lvalue_reference<_Tp>::type,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                                     typename add_rvalue_reference<_Tp>::type>\n#else\n                                     typename add_lvalue_reference<_Tp>::type>\n#endif\n    {};\n\n// is_nothrow_destructible\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp> struct __libcpp_is_nothrow_destructible;\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<false, _Tp>\n    : public false_type\n{\n};\n\ntemplate <class _Tp>\nstruct __libcpp_is_nothrow_destructible<true, _Tp>\n    : public integral_constant<bool, noexcept(_VSTD::declval<_Tp>().~_Tp()) >\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible\n    : public __libcpp_is_nothrow_destructible<is_destructible<_Tp>::value, _Tp>\n{\n};\n\ntemplate <class _Tp, size_t _Ns>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp[_Ns]>\n    : public is_nothrow_destructible<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp&>\n    : public true_type\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible<_Tp&&>\n    : public true_type\n{\n};\n\n#endif\n\n#else\n\ntemplate <class _Tp> struct __libcpp_nothrow_destructor\n    : public integral_constant<bool, is_scalar<_Tp>::value ||\n                                     is_reference<_Tp>::value> {};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_nothrow_destructible\n    : public __libcpp_nothrow_destructor<typename remove_all_extents<_Tp>::type> {};\n\n#endif\n\n// is_pod\n\n#if __has_feature(is_pod) || (_GNUC_VER >= 403)\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pod\n    : public integral_constant<bool, __is_pod(_Tp)> {};\n\n#else\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_pod\n    : public integral_constant<bool, is_trivially_default_constructible<_Tp>::value   &&\n                                     is_trivially_copy_constructible<_Tp>::value      &&\n                                     is_trivially_copy_assignable<_Tp>::value    &&\n                                     is_trivially_destructible<_Tp>::value> {};\n\n#endif\n\n// is_literal_type;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_literal_type\n#ifdef _LIBCPP_IS_LITERAL\n    : public integral_constant<bool, _LIBCPP_IS_LITERAL(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value ||\n                              is_reference<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n// is_standard_layout;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_standard_layout\n#if __has_feature(is_standard_layout) || (_GNUC_VER >= 407)\n    : public integral_constant<bool, __is_standard_layout(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n// is_trivially_copyable;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivially_copyable\n#if __has_feature(is_trivially_copyable)\n    : public integral_constant<bool, __is_trivially_copyable(_Tp)>\n#else\n    : integral_constant<bool, is_scalar<typename remove_all_extents<_Tp>::type>::value>\n#endif\n    {};\n    \n// is_trivial;\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_trivial\n#if __has_feature(is_trivial) || (_GNUC_VER >= 407)\n    : public integral_constant<bool, __is_trivial(_Tp)>\n#else\n    : integral_constant<bool, is_trivially_copyable<_Tp>::value &&\n                                 is_trivially_default_constructible<_Tp>::value>\n#endif\n    {};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// Check for complete types\n\ntemplate <class ..._Tp> struct __check_complete;\n\ntemplate <>\nstruct __check_complete<>\n{\n};\n\ntemplate <class _Hp, class _T0, class ..._Tp>\nstruct __check_complete<_Hp, _T0, _Tp...>\n    : private __check_complete<_Hp>,\n      private __check_complete<_T0, _Tp...>\n{\n};\n\ntemplate <class _Hp>\nstruct __check_complete<_Hp, _Hp>\n    : private __check_complete<_Hp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp>\n{\n    static_assert(sizeof(_Tp) > 0, \"Type must be complete.\");\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __check_complete<_Tp&&>\n    : private __check_complete<_Tp>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (*)(_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (*)(_Param...)>\n{\n};\n\ntemplate <class _Rp, class ..._Param>\nstruct __check_complete<_Rp (_Param...)>\n    : private __check_complete<_Rp>\n{\n};\n\ntemplate <class ..._Param>\nstruct __check_complete<void (_Param...)>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...)>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile>\n    : private __check_complete<_Class>\n{\n};\n\n#if __has_feature(cxx_reference_qualified_functions)\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) &&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\ntemplate <class _Rp, class _Class, class ..._Param>\nstruct __check_complete<_Rp (_Class::*)(_Param...) const volatile&&>\n    : private __check_complete<_Class>\n{\n};\n\n#endif\n\ntemplate <class _Rp, class _Class>\nstruct __check_complete<_Rp _Class::*>\n    : private __check_complete<_Class>\n{\n};\n\n// __invoke forward declarations\n\n// fall back - none of the bullets\n\ntemplate <class ..._Args>\nauto\n__invoke(__any, _Args&& ...__args)\n    -> __nat;\n\n// bullets 1 and 2\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class = typename enable_if\n            <\n                is_member_function_pointer<typename remove_reference<_Fp>::type>::value &&\n                is_base_of<typename remove_reference<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType>::type,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...));\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class = typename enable_if\n            <\n                is_member_function_pointer<typename remove_reference<_Fp>::type>::value &&\n                !is_base_of<typename remove_reference<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType>::type,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...));\n\n// bullets 3 and 4\n\ntemplate <class _Fp, class _A0,\n            class = typename enable_if\n            <\n                is_member_object_pointer<typename remove_reference<_Fp>::type>::value &&\n                is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype(_VSTD::forward<_A0>(__a0).*__f);\n\ntemplate <class _Fp, class _A0,\n            class = typename enable_if\n            <\n                is_member_object_pointer<typename remove_reference<_Fp>::type>::value &&\n                !is_base_of<typename __member_pointer_traits<typename remove_reference<_Fp>::type>::_ClassType,\n                           typename remove_reference<_A0>::type>::value\n            >::type\n         >\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype((*_VSTD::forward<_A0>(__a0)).*__f);\n\n// bullet 5\n\ntemplate <class _Fp, class ..._Args>\n_LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _Args&& ...__args)\n    -> decltype(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...));\n\n// __invokable\n\ntemplate <class _Fp, class ..._Args>\nstruct __invokable_imp\n    : private __check_complete<_Fp>\n{\n    typedef decltype(\n            __invoke(_VSTD::declval<_Fp>(), _VSTD::declval<_Args>()...)\n                    ) type;\n    static const bool value = !is_same<type, __nat>::value;\n};\n\ntemplate <class _Fp, class ..._Args>\nstruct __invokable\n    : public integral_constant<bool,\n          __invokable_imp<_Fp, _Args...>::value>\n{\n};\n\n// __invoke_of\n\ntemplate <bool _Invokable, class _Fp, class ..._Args>\nstruct __invoke_of_imp  // false\n{\n};\n\ntemplate <class _Fp, class ..._Args>\nstruct __invoke_of_imp<true, _Fp, _Args...>\n{\n    typedef typename __invokable_imp<_Fp, _Args...>::type type;\n};\n\ntemplate <class _Fp, class ..._Args>\nstruct __invoke_of\n    : public __invoke_of_imp<__invokable<_Fp, _Args...>::value, _Fp, _Args...>\n{\n};\n\ntemplate <class _Fp, class ..._Args>\nclass _LIBCPP_TYPE_VIS_ONLY result_of<_Fp(_Args...)>\n    : public __invoke_of<_Fp, _Args...>\n{\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using result_of_t = typename result_of<_Tp>::type;\n#endif\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\ntypename enable_if\n<\n    is_move_constructible<_Tp>::value &&\n    is_move_assignable<_Tp>::value\n>::type\n#else\nvoid\n#endif\nswap(_Tp& __x, _Tp& __y) _NOEXCEPT_(is_nothrow_move_constructible<_Tp>::value &&\n                                    is_nothrow_move_assignable<_Tp>::value)\n{\n    _Tp __t(_VSTD::move(__x));\n    __x = _VSTD::move(__y);\n    __y = _VSTD::move(__t);\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\niter_swap(_ForwardIterator1 __a, _ForwardIterator2 __b)\n    //                                  _NOEXCEPT_(_NOEXCEPT_(swap(*__a, *__b)))\n               _NOEXCEPT_(_NOEXCEPT_(swap(*_VSTD::declval<_ForwardIterator1>(),\n                                          *_VSTD::declval<_ForwardIterator2>())))\n{\n    swap(*__a, *__b);\n}\n\n// __swappable\n\nnamespace __detail\n{\n\nusing _VSTD::swap;\n__nat swap(__any, __any);\n\ntemplate <class _Tp>\nstruct __swappable\n{\n    typedef decltype(swap(_VSTD::declval<_Tp&>(), _VSTD::declval<_Tp&>())) type;\n    static const bool value = !is_same<type, __nat>::value;\n};\n\n}  // __detail\n\ntemplate <class _Tp>\nstruct __is_swappable\n    : public integral_constant<bool, __detail::__swappable<_Tp>::value>\n{\n};\n\n#if __has_feature(cxx_noexcept) || (_GNUC_VER >= 407 && __cplusplus >= 201103L)\n\ntemplate <bool, class _Tp>\nstruct __is_nothrow_swappable_imp\n    : public integral_constant<bool, noexcept(swap(_VSTD::declval<_Tp&>(),\n                                                   _VSTD::declval<_Tp&>()))>\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable_imp<false, _Tp>\n    : public false_type\n{\n};\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable\n    : public __is_nothrow_swappable_imp<__is_swappable<_Tp>::value, _Tp>\n{\n};\n\n#else  // __has_feature(cxx_noexcept)\n\ntemplate <class _Tp>\nstruct __is_nothrow_swappable\n    : public false_type\n{\n};\n\n#endif  // __has_feature(cxx_noexcept)\n\n#ifdef _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp>\nstruct underlying_type\n{\n    typedef _LIBCPP_UNDERLYING_TYPE(_Tp) type;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp> using underlying_type_t = typename underlying_type<_Tp>::type;\n#endif\n\n#else  // _LIBCPP_UNDERLYING_TYPE\n\ntemplate <class _Tp, bool _Support = false>\nstruct underlying_type\n{\n    static_assert(_Support, \"The underyling_type trait requires compiler \"\n                            \"support. Either no such support exists or \"\n                            \"libc++ does not know how to use it.\");\n};\n\n#endif // _LIBCPP_UNDERLYING_TYPE\n\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\ntemplate <class _Tp>\nstruct __has_operator_addressof_imp\n{\n    template <class>\n        static auto __test(__any) -> false_type;\n    template <class _Up>\n        static auto __test(_Up* __u)\n            -> typename __select_2nd<decltype(__u->operator&()), true_type>::type;\n\n    static const bool value = decltype(__test<_Tp>(nullptr))::value;\n};\n\ntemplate <class _Tp>\nstruct __has_operator_addressof\n    : public integral_constant<bool, __has_operator_addressof_imp<_Tp>::value>\n{};\n\n#endif  // _LIBCPP_HAS_NO_ADVANCED_SFINAE\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_TYPE_TRAITS\n","// -*- C++ -*-\n//===-------------------------- unordered_set -----------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_UNORDERED_SET\n#define _LIBCPP_UNORDERED_SET\n\n/*\n\n    unordered_set synopsis\n\n#include <initializer_list>\n\nnamespace std\n{\n\ntemplate <class Value, class Hash = hash<Value>, class Pred = equal_to<Value>,\n          class Alloc = allocator<Value>>\nclass unordered_set\n{\npublic:\n    // types\n    typedef Value                                                      key_type;\n    typedef key_type                                                   value_type;\n    typedef Hash                                                       hasher;\n    typedef Pred                                                       key_equal;\n    typedef Alloc                                                      allocator_type;\n    typedef value_type&                                                reference;\n    typedef const value_type&                                          const_reference;\n    typedef typename allocator_traits<allocator_type>::pointer         pointer;\n    typedef typename allocator_traits<allocator_type>::const_pointer   const_pointer;\n    typedef typename allocator_traits<allocator_type>::size_type       size_type;\n    typedef typename allocator_traits<allocator_type>::difference_type difference_type;\n\n    typedef /unspecified/ iterator;\n    typedef /unspecified/ const_iterator;\n    typedef /unspecified/ local_iterator;\n    typedef /unspecified/ const_local_iterator;\n\n    unordered_set()\n        noexcept(\n            is_nothrow_default_constructible<hasher>::value &&\n            is_nothrow_default_constructible<key_equal>::value &&\n            is_nothrow_default_constructible<allocator_type>::value);\n    explicit unordered_set(size_type n, const hasher& hf = hasher(),\n                           const key_equal& eql = key_equal(),\n                           const allocator_type& a = allocator_type());\n    template <class InputIterator>\n        unordered_set(InputIterator f, InputIterator l,\n                      size_type n = 0, const hasher& hf = hasher(),\n                      const key_equal& eql = key_equal(),\n                      const allocator_type& a = allocator_type());\n    explicit unordered_set(const allocator_type&);\n    unordered_set(const unordered_set&);\n    unordered_set(const unordered_set&, const Allocator&);\n    unordered_set(unordered_set&&)\n        noexcept(\n            is_nothrow_move_constructible<hasher>::value &&\n            is_nothrow_move_constructible<key_equal>::value &&\n            is_nothrow_move_constructible<allocator_type>::value);\n    unordered_set(unordered_set&&, const Allocator&);\n    unordered_set(initializer_list<value_type>, size_type n = 0,\n                  const hasher& hf = hasher(), const key_equal& eql = key_equal(),\n                  const allocator_type& a = allocator_type());\n    unordered_set(size_type n, const allocator_type& a); // C++14\n    unordered_set(size_type n, const hasher& hf, const allocator_type& a); // C++14\n    template <class InputIterator>\n      unordered_set(InputIterator f, InputIterator l, size_type n, const allocator_type& a); // C++14\n    template <class InputIterator>\n      unordered_set(InputIterator f, InputIterator l, size_type n, \n                    const hasher& hf,  const allocator_type& a); // C++14\n    unordered_set(initializer_list<value_type> il, size_type n, const allocator_type& a); // C++14\n    unordered_set(initializer_list<value_type> il, size_type n,\n                  const hasher& hf,  const allocator_type& a); // C++14\n    ~unordered_set();\n    unordered_set& operator=(const unordered_set&);\n    unordered_set& operator=(unordered_set&&)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<hasher>::value &&\n            is_nothrow_move_assignable<key_equal>::value);\n    unordered_set& operator=(initializer_list<value_type>);\n\n    allocator_type get_allocator() const noexcept;\n\n    bool      empty() const noexcept;\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n\n    iterator       begin() noexcept;\n    iterator       end() noexcept;\n    const_iterator begin()  const noexcept;\n    const_iterator end()    const noexcept;\n    const_iterator cbegin() const noexcept;\n    const_iterator cend()   const noexcept;\n\n    template <class... Args>\n        pair<iterator, bool> emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    pair<iterator, bool> insert(const value_type& obj);\n    pair<iterator, bool> insert(value_type&& obj);\n    iterator insert(const_iterator hint, const value_type& obj);\n    iterator insert(const_iterator hint, value_type&& obj);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type>);\n\n    iterator erase(const_iterator position);\n    size_type erase(const key_type& k);\n    iterator erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(unordered_set&)\n        noexcept(\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value) &&\n            __is_nothrow_swappable<hasher>::value &&\n            __is_nothrow_swappable<key_equal>::value);\n\n    hasher hash_function() const;\n    key_equal key_eq() const;\n\n    iterator       find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    size_type count(const key_type& k) const;\n    pair<iterator, iterator>             equal_range(const key_type& k);\n    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;\n\n    size_type bucket_count() const noexcept;\n    size_type max_bucket_count() const noexcept;\n\n    size_type bucket_size(size_type n) const;\n    size_type bucket(const key_type& k) const;\n\n    local_iterator       begin(size_type n);\n    local_iterator       end(size_type n);\n    const_local_iterator begin(size_type n) const;\n    const_local_iterator end(size_type n) const;\n    const_local_iterator cbegin(size_type n) const;\n    const_local_iterator cend(size_type n) const;\n\n    float load_factor() const noexcept;\n    float max_load_factor() const noexcept;\n    void max_load_factor(float z);\n    void rehash(size_type n);\n    void reserve(size_type n);\n};\n\ntemplate <class Value, class Hash, class Pred, class Alloc>\n    void swap(unordered_set<Value, Hash, Pred, Alloc>& x,\n              unordered_set<Value, Hash, Pred, Alloc>& y)\n              noexcept(noexcept(x.swap(y)));\n\ntemplate <class Value, class Hash, class Pred, class Alloc>\n    bool\n    operator==(const unordered_set<Value, Hash, Pred, Alloc>& x,\n               const unordered_set<Value, Hash, Pred, Alloc>& y);\n\ntemplate <class Value, class Hash, class Pred, class Alloc>\n    bool\n    operator!=(const unordered_set<Value, Hash, Pred, Alloc>& x,\n               const unordered_set<Value, Hash, Pred, Alloc>& y);\n\ntemplate <class Value, class Hash = hash<Value>, class Pred = equal_to<Value>,\n          class Alloc = allocator<Value>>\nclass unordered_multiset\n{\npublic:\n    // types\n    typedef Value                                                      key_type;\n    typedef key_type                                                   value_type;\n    typedef Hash                                                       hasher;\n    typedef Pred                                                       key_equal;\n    typedef Alloc                                                      allocator_type;\n    typedef value_type&                                                reference;\n    typedef const value_type&                                          const_reference;\n    typedef typename allocator_traits<allocator_type>::pointer         pointer;\n    typedef typename allocator_traits<allocator_type>::const_pointer   const_pointer;\n    typedef typename allocator_traits<allocator_type>::size_type       size_type;\n    typedef typename allocator_traits<allocator_type>::difference_type difference_type;\n\n    typedef /unspecified/ iterator;\n    typedef /unspecified/ const_iterator;\n    typedef /unspecified/ local_iterator;\n    typedef /unspecified/ const_local_iterator;\n\n    unordered_multiset()\n        noexcept(\n            is_nothrow_default_constructible<hasher>::value &&\n            is_nothrow_default_constructible<key_equal>::value &&\n            is_nothrow_default_constructible<allocator_type>::value);\n    explicit unordered_multiset(size_type n, const hasher& hf = hasher(),\n                           const key_equal& eql = key_equal(),\n                           const allocator_type& a = allocator_type());\n    template <class InputIterator>\n        unordered_multiset(InputIterator f, InputIterator l,\n                      size_type n = 0, const hasher& hf = hasher(),\n                      const key_equal& eql = key_equal(),\n                      const allocator_type& a = allocator_type());\n    explicit unordered_multiset(const allocator_type&);\n    unordered_multiset(const unordered_multiset&);\n    unordered_multiset(const unordered_multiset&, const Allocator&);\n    unordered_multiset(unordered_multiset&&)\n        noexcept(\n            is_nothrow_move_constructible<hasher>::value &&\n            is_nothrow_move_constructible<key_equal>::value &&\n            is_nothrow_move_constructible<allocator_type>::value);\n    unordered_multiset(unordered_multiset&&, const Allocator&);\n    unordered_multiset(initializer_list<value_type>, size_type n = /see below/,\n                  const hasher& hf = hasher(), const key_equal& eql = key_equal(),\n                  const allocator_type& a = allocator_type());\n    unordered_multiset(size_type n, const allocator_type& a); // C++14\n    unordered_multiset(size_type n, const hasher& hf, const allocator_type& a); // C++14\n    template <class InputIterator>\n      unordered_multiset(InputIterator f, InputIterator l, size_type n, const allocator_type& a); // C++14\n    template <class InputIterator>\n      unordered_multiset(InputIterator f, InputIterator l, size_type n,\n                         const hasher& hf, const allocator_type& a); // C++14\n    unordered_multiset(initializer_list<value_type> il, size_type n, const allocator_type& a); // C++14\n    unordered_multiset(initializer_list<value_type> il, size_type n, \n                       const hasher& hf,  const allocator_type& a); // C++14\n    ~unordered_multiset();\n    unordered_multiset& operator=(const unordered_multiset&);\n    unordered_multiset& operator=(unordered_multiset&&)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<hasher>::value &&\n            is_nothrow_move_assignable<key_equal>::value);\n    unordered_multiset& operator=(initializer_list<value_type>);\n\n    allocator_type get_allocator() const noexcept;\n\n    bool      empty() const noexcept;\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n\n    iterator       begin() noexcept;\n    iterator       end() noexcept;\n    const_iterator begin()  const noexcept;\n    const_iterator end()    const noexcept;\n    const_iterator cbegin() const noexcept;\n    const_iterator cend()   const noexcept;\n\n    template <class... Args>\n        iterator emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    iterator insert(const value_type& obj);\n    iterator insert(value_type&& obj);\n    iterator insert(const_iterator hint, const value_type& obj);\n    iterator insert(const_iterator hint, value_type&& obj);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type>);\n\n    iterator erase(const_iterator position);\n    size_type erase(const key_type& k);\n    iterator erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(unordered_multiset&)\n        noexcept(\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value) &&\n            __is_nothrow_swappable<hasher>::value &&\n            __is_nothrow_swappable<key_equal>::value);\n\n    hasher hash_function() const;\n    key_equal key_eq() const;\n\n    iterator       find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    size_type count(const key_type& k) const;\n    pair<iterator, iterator>             equal_range(const key_type& k);\n    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;\n\n    size_type bucket_count() const noexcept;\n    size_type max_bucket_count() const noexcept;\n\n    size_type bucket_size(size_type n) const;\n    size_type bucket(const key_type& k) const;\n\n    local_iterator       begin(size_type n);\n    local_iterator       end(size_type n);\n    const_local_iterator begin(size_type n) const;\n    const_local_iterator end(size_type n) const;\n    const_local_iterator cbegin(size_type n) const;\n    const_local_iterator cend(size_type n) const;\n\n    float load_factor() const noexcept;\n    float max_load_factor() const noexcept;\n    void max_load_factor(float z);\n    void rehash(size_type n);\n    void reserve(size_type n);\n};\n\ntemplate <class Value, class Hash, class Pred, class Alloc>\n    void swap(unordered_multiset<Value, Hash, Pred, Alloc>& x,\n              unordered_multiset<Value, Hash, Pred, Alloc>& y)\n              noexcept(noexcept(x.swap(y)));\n\ntemplate <class Value, class Hash, class Pred, class Alloc>\n    bool\n    operator==(const unordered_multiset<Value, Hash, Pred, Alloc>& x,\n               const unordered_multiset<Value, Hash, Pred, Alloc>& y);\n\ntemplate <class Value, class Hash, class Pred, class Alloc>\n    bool\n    operator!=(const unordered_multiset<Value, Hash, Pred, Alloc>& x,\n               const unordered_multiset<Value, Hash, Pred, Alloc>& y);\n}  // std\n\n*/\n\n#include <__config>\n#include <__hash_table>\n#include <functional>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Value, class _Hash = hash<_Value>, class _Pred = equal_to<_Value>,\n          class _Alloc = allocator<_Value> >\nclass _LIBCPP_TYPE_VIS_ONLY unordered_set\n{\npublic:\n    // types\n    typedef _Value                                                     key_type;\n    typedef key_type                                                   value_type;\n    typedef _Hash                                                      hasher;\n    typedef _Pred                                                      key_equal;\n    typedef _Alloc                                                     allocator_type;\n    typedef value_type&                                                reference;\n    typedef const value_type&                                          const_reference;\n    static_assert((is_same<value_type, typename allocator_type::value_type>::value),\n                  \"Invalid allocator::value_type\");\n\nprivate:\n    typedef __hash_table<value_type, hasher, key_equal, allocator_type> __table;\n\n    __table __table_;\n\npublic:\n    typedef typename __table::pointer         pointer;\n    typedef typename __table::const_pointer   const_pointer;\n    typedef typename __table::size_type       size_type;\n    typedef typename __table::difference_type difference_type;\n\n    typedef typename __table::const_iterator       iterator;\n    typedef typename __table::const_iterator       const_iterator;\n    typedef typename __table::const_local_iterator local_iterator;\n    typedef typename __table::const_local_iterator const_local_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_set()\n        _NOEXCEPT_(is_nothrow_default_constructible<__table>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    explicit unordered_set(size_type __n, const hasher& __hf = hasher(),\n                           const key_equal& __eql = key_equal());\n#if _LIBCPP_STD_VER > 11\n    inline _LIBCPP_INLINE_VISIBILITY\n    unordered_set(size_type __n, const allocator_type& __a)\n        : unordered_set(__n, hasher(), key_equal(), __a) {}\n    inline _LIBCPP_INLINE_VISIBILITY\n    unordered_set(size_type __n, const hasher& __hf, const allocator_type& __a)\n        : unordered_set(__n, __hf, key_equal(), __a) {}\n#endif\n    unordered_set(size_type __n, const hasher& __hf, const key_equal& __eql,\n                  const allocator_type& __a);\n    template <class _InputIterator>\n        unordered_set(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        unordered_set(_InputIterator __first, _InputIterator __last,\n                      size_type __n, const hasher& __hf = hasher(),\n                      const key_equal& __eql = key_equal());\n    template <class _InputIterator>\n        unordered_set(_InputIterator __first, _InputIterator __last,\n                      size_type __n, const hasher& __hf, const key_equal& __eql,\n                      const allocator_type& __a);\n#if _LIBCPP_STD_VER > 11\n    template <class _InputIterator>\n    inline _LIBCPP_INLINE_VISIBILITY\n        unordered_set(_InputIterator __first, _InputIterator __last, \n                    size_type __n, const allocator_type& __a)\n            : unordered_set(__first, __last, __n, hasher(), key_equal(), __a) {}\n    template <class _InputIterator>\n        unordered_set(_InputIterator __first, _InputIterator __last, \n                      size_type __n, const hasher& __hf, const allocator_type& __a)\n            : unordered_set(__first, __last, __n, __hf, key_equal(), __a) {}\n#endif\n    explicit unordered_set(const allocator_type& __a);\n    unordered_set(const unordered_set& __u);\n    unordered_set(const unordered_set& __u, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unordered_set(unordered_set&& __u)\n        _NOEXCEPT_(is_nothrow_move_constructible<__table>::value);\n    unordered_set(unordered_set&& __u, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    unordered_set(initializer_list<value_type> __il);\n    unordered_set(initializer_list<value_type> __il, size_type __n,\n                  const hasher& __hf = hasher(),\n                  const key_equal& __eql = key_equal());\n    unordered_set(initializer_list<value_type> __il, size_type __n,\n                  const hasher& __hf, const key_equal& __eql,\n                  const allocator_type& __a);\n#if _LIBCPP_STD_VER > 11\n    inline _LIBCPP_INLINE_VISIBILITY\n    unordered_set(initializer_list<value_type> __il, size_type __n,\n                                                      const allocator_type& __a)\n        : unordered_set(__il, __n, hasher(), key_equal(), __a) {}\n    inline _LIBCPP_INLINE_VISIBILITY\n    unordered_set(initializer_list<value_type> __il, size_type __n, \n                                  const hasher& __hf, const allocator_type& __a)\n        : unordered_set(__il, __n, __hf, key_equal(), __a) {}\n#endif\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    // ~unordered_set() = default;\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_set& operator=(const unordered_set& __u)\n    {\n        __table_ = __u.__table_;\n        return *this;\n    }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unordered_set& operator=(unordered_set&& __u)\n        _NOEXCEPT_(is_nothrow_move_assignable<__table>::value);\n#endif\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    unordered_set& operator=(initializer_list<value_type> __il);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(__table_.__node_alloc());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const _NOEXCEPT {return __table_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT  {return __table_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __table_.max_size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       begin() _NOEXCEPT        {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       end() _NOEXCEPT          {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin()  const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()    const _NOEXCEPT {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend()   const _NOEXCEPT {return __table_.end();}\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> emplace(_Args&&... __args)\n            {return __table_.__emplace_unique(_VSTD::forward<_Args>(__args)...);}\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        iterator emplace_hint(const_iterator __p, _Args&&... __args)\n        {\n            _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n                \"unordered_set::emplace_hint(const_iterator, args...) called with an iterator not\"\n                \" referring to this unordered_set\");\n            return __table_.__emplace_unique(_VSTD::forward<_Args>(__args)...).first;\n        }\n#else\n        iterator emplace_hint(const_iterator, _Args&&... __args)\n            {return __table_.__emplace_unique(_VSTD::forward<_Args>(__args)...).first;}\n#endif\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> insert(const value_type& __x)\n        {return __table_.__insert_unique(__x);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> insert(value_type&& __x)\n        {return __table_.__insert_unique(_VSTD::move(__x));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    iterator insert(const_iterator __p, const value_type& __x)\n        {\n            _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n                \"unordered_set::insert(const_iterator, const value_type&) called with an iterator not\"\n                \" referring to this unordered_set\");\n            return insert(__x).first;\n        }\n#else\n    iterator insert(const_iterator, const value_type& __x)\n        {return insert(__x).first;}\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    iterator insert(const_iterator __p, value_type&& __x)\n        {\n            _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n                \"unordered_set::insert(const_iterator, value_type&&) called with an iterator not\"\n                \" referring to this unordered_set\");\n            return insert(_VSTD::move(__x)).first;\n        }\n#else\n    iterator insert(const_iterator, value_type&& __x)\n        {return insert(_VSTD::move(__x)).first;}\n#endif\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _InputIterator>\n        void insert(_InputIterator __first, _InputIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __table_.erase(__p);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __table_.__erase_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __first, const_iterator __last)\n        {return __table_.erase(__first, __last);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__table_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(unordered_set& __u)\n        _NOEXCEPT_(__is_nothrow_swappable<__table>::value)\n        {__table_.swap(__u.__table_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    hasher hash_function() const {return __table_.hash_function();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_equal key_eq() const {return __table_.key_eq();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       find(const key_type& __k)       {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type count(const key_type& __k) const {return __table_.__count_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, iterator>             equal_range(const key_type& __k)\n        {return __table_.__equal_range_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const\n        {return __table_.__equal_range_unique(__k);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_count() const _NOEXCEPT {return __table_.bucket_count();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_bucket_count() const _NOEXCEPT {return __table_.max_bucket_count();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_size(size_type __n) const {return __table_.bucket_size(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       begin(size_type __n)        {return __table_.begin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       end(size_type __n)          {return __table_.end(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator begin(size_type __n) const  {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator end(size_type __n) const    {return __table_.cend(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cend(size_type __n) const   {return __table_.cend(__n);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    float load_factor() const _NOEXCEPT {return __table_.load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    float max_load_factor() const _NOEXCEPT {return __table_.max_load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}\n    _LIBCPP_INLINE_VISIBILITY\n    void rehash(size_type __n) {__table_.rehash(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    void reserve(size_type __n) {__table_.reserve(__n);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const\n        {return __table_.__dereferenceable(__i);}\n    bool __decrementable(const const_iterator* __i) const\n        {return __table_.__decrementable(__i);}\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(__i, __n);}\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(__i, __n);}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n};\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(size_type __n,\n        const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(size_type __n,\n        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(\n        _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__first, __last);\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nunordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(\n        const allocator_type& __a)\n    : __table_(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(\n        const unordered_set& __u)\n    : __table_(__u.__table_)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(\n        const unordered_set& __u, const allocator_type& __a)\n    : __table_(__u.__table_, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nunordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(\n        unordered_set&& __u)\n    _NOEXCEPT_(is_nothrow_move_constructible<__table>::value)\n    : __table_(_VSTD::move(__u.__table_))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(\n        unordered_set&& __u, const allocator_type& __a)\n    : __table_(_VSTD::move(__u.__table_), __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a != __u.get_allocator())\n    {\n        iterator __i = __u.begin();\n        while (__u.size() != 0)\n            __table_.__insert_unique(_VSTD::move(__u.__table_.remove(__i++)->__value_));\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    else\n        __get_db()->swap(this, &__u);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(\n        initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_set<_Value, _Hash, _Pred, _Alloc>::unordered_set(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nunordered_set<_Value, _Hash, _Pred, _Alloc>&\nunordered_set<_Value, _Hash, _Pred, _Alloc>::operator=(unordered_set&& __u)\n    _NOEXCEPT_(is_nothrow_move_assignable<__table>::value)\n{\n    __table_ = _VSTD::move(__u.__table_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nunordered_set<_Value, _Hash, _Pred, _Alloc>&\nunordered_set<_Value, _Hash, _Pred, _Alloc>::operator=(\n        initializer_list<value_type> __il)\n{\n    __table_.__assign_unique(__il.begin(), __il.end());\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nunordered_set<_Value, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,\n                                                    _InputIterator __last)\n{\n    for (; __first != __last; ++__first)\n        __table_.__insert_unique(*__first);\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n     unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nbool\noperator==(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n           const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n{\n    if (__x.size() != __y.size())\n        return false;\n    typedef typename unordered_set<_Value, _Hash, _Pred, _Alloc>::const_iterator\n                                                                 const_iterator;\n    for (const_iterator __i = __x.begin(), __ex = __x.end(), __ey = __y.end();\n            __i != __ex; ++__i)\n    {\n        const_iterator __j = __y.find(*__i);\n        if (__j == __ey || !(*__i == *__j))\n            return false;\n    }\n    return true;\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unordered_set<_Value, _Hash, _Pred, _Alloc>& __x,\n           const unordered_set<_Value, _Hash, _Pred, _Alloc>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Value, class _Hash = hash<_Value>, class _Pred = equal_to<_Value>,\n          class _Alloc = allocator<_Value> >\nclass _LIBCPP_TYPE_VIS_ONLY unordered_multiset\n{\npublic:\n    // types\n    typedef _Value                                                     key_type;\n    typedef key_type                                                   value_type;\n    typedef _Hash                                                      hasher;\n    typedef _Pred                                                      key_equal;\n    typedef _Alloc                                                     allocator_type;\n    typedef value_type&                                                reference;\n    typedef const value_type&                                          const_reference;\n    static_assert((is_same<value_type, typename allocator_type::value_type>::value),\n                  \"Invalid allocator::value_type\");\n\nprivate:\n    typedef __hash_table<value_type, hasher, key_equal, allocator_type> __table;\n\n    __table __table_;\n\npublic:\n    typedef typename __table::pointer         pointer;\n    typedef typename __table::const_pointer   const_pointer;\n    typedef typename __table::size_type       size_type;\n    typedef typename __table::difference_type difference_type;\n\n    typedef typename __table::const_iterator       iterator;\n    typedef typename __table::const_iterator       const_iterator;\n    typedef typename __table::const_local_iterator local_iterator;\n    typedef typename __table::const_local_iterator const_local_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multiset()\n        _NOEXCEPT_(is_nothrow_default_constructible<__table>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    explicit unordered_multiset(size_type __n, const hasher& __hf = hasher(),\n                                const key_equal& __eql = key_equal());\n    unordered_multiset(size_type __n, const hasher& __hf,\n                       const key_equal& __eql, const allocator_type& __a);\n#if _LIBCPP_STD_VER > 11\n    inline _LIBCPP_INLINE_VISIBILITY\n    unordered_multiset(size_type __n, const allocator_type& __a)\n        : unordered_multiset(__n, hasher(), key_equal(), __a) {}\n    inline _LIBCPP_INLINE_VISIBILITY\n    unordered_multiset(size_type __n, const hasher& __hf, const allocator_type& __a)\n        : unordered_multiset(__n, __hf, key_equal(), __a) {}\n#endif\n    template <class _InputIterator>\n        unordered_multiset(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        unordered_multiset(_InputIterator __first, _InputIterator __last,\n                      size_type __n, const hasher& __hf = hasher(),\n                      const key_equal& __eql = key_equal());\n    template <class _InputIterator>\n        unordered_multiset(_InputIterator __first, _InputIterator __last,\n                      size_type __n , const hasher& __hf,\n                      const key_equal& __eql, const allocator_type& __a);\n#if _LIBCPP_STD_VER > 11\n    template <class _InputIterator>\n    inline _LIBCPP_INLINE_VISIBILITY\n    unordered_multiset(_InputIterator __first, _InputIterator __last, \n                       size_type __n, const allocator_type& __a)\n        : unordered_multiset(__first, __last, __n, hasher(), key_equal(), __a) {}\n    template <class _InputIterator>\n    inline _LIBCPP_INLINE_VISIBILITY\n    unordered_multiset(_InputIterator __first, _InputIterator __last,\n                       size_type __n, const hasher& __hf, const allocator_type& __a)\n        : unordered_multiset(__first, __last, __n, __hf, key_equal(), __a) {}\n#endif\n    explicit unordered_multiset(const allocator_type& __a);\n    unordered_multiset(const unordered_multiset& __u);\n    unordered_multiset(const unordered_multiset& __u, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unordered_multiset(unordered_multiset&& __u)\n        _NOEXCEPT_(is_nothrow_move_constructible<__table>::value);\n    unordered_multiset(unordered_multiset&& __u, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    unordered_multiset(initializer_list<value_type> __il);\n    unordered_multiset(initializer_list<value_type> __il, size_type __n,\n                       const hasher& __hf = hasher(),\n                       const key_equal& __eql = key_equal());\n    unordered_multiset(initializer_list<value_type> __il, size_type __n,\n                       const hasher& __hf, const key_equal& __eql,\n                       const allocator_type& __a);\n#if _LIBCPP_STD_VER > 11\n    inline _LIBCPP_INLINE_VISIBILITY\n    unordered_multiset(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)\n      : unordered_multiset(__il, __n, hasher(), key_equal(), __a) {}\n    inline _LIBCPP_INLINE_VISIBILITY\n    unordered_multiset(initializer_list<value_type> __il, size_type __n, const hasher& __hf, const allocator_type& __a)\n      : unordered_multiset(__il, __n, __hf, key_equal(), __a) {}\n#endif\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    // ~unordered_multiset() = default;\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multiset& operator=(const unordered_multiset& __u)\n    {\n        __table_ = __u.__table_;\n        return *this;\n    }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unordered_multiset& operator=(unordered_multiset&& __u)\n        _NOEXCEPT_(is_nothrow_move_assignable<__table>::value);\n#endif\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    unordered_multiset& operator=(initializer_list<value_type> __il);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(__table_.__node_alloc());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const _NOEXCEPT {return __table_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT  {return __table_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __table_.max_size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       begin() _NOEXCEPT        {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       end() _NOEXCEPT          {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin()  const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()    const _NOEXCEPT {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend()   const _NOEXCEPT {return __table_.end();}\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator emplace(_Args&&... __args)\n            {return __table_.__emplace_multi(_VSTD::forward<_Args>(__args)...);}\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator emplace_hint(const_iterator __p, _Args&&... __args)\n            {return __table_.__emplace_hint_multi(__p, _VSTD::forward<_Args>(__args)...);}\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const value_type& __x) {return __table_.__insert_multi(__x);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(value_type&& __x) {return __table_.__insert_multi(_VSTD::move(__x));}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __x)\n        {return __table_.__insert_multi(__p, __x);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, value_type&& __x)\n        {return __table_.__insert_multi(__p, _VSTD::move(__x));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _InputIterator>\n        void insert(_InputIterator __first, _InputIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __table_.erase(__p);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __table_.__erase_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __first, const_iterator __last)\n        {return __table_.erase(__first, __last);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__table_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(unordered_multiset& __u)\n        _NOEXCEPT_(__is_nothrow_swappable<__table>::value)\n        {__table_.swap(__u.__table_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    hasher hash_function() const {return __table_.hash_function();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_equal key_eq() const {return __table_.key_eq();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       find(const key_type& __k)       {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type count(const key_type& __k) const {return __table_.__count_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, iterator>             equal_range(const key_type& __k)\n        {return __table_.__equal_range_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const\n        {return __table_.__equal_range_multi(__k);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_count() const _NOEXCEPT {return __table_.bucket_count();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_bucket_count() const _NOEXCEPT {return __table_.max_bucket_count();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_size(size_type __n) const {return __table_.bucket_size(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       begin(size_type __n)        {return __table_.begin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       end(size_type __n)          {return __table_.end(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator begin(size_type __n) const  {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator end(size_type __n) const    {return __table_.cend(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cend(size_type __n) const   {return __table_.cend(__n);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    float load_factor() const _NOEXCEPT {return __table_.load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    float max_load_factor() const _NOEXCEPT {return __table_.max_load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}\n    _LIBCPP_INLINE_VISIBILITY\n    void rehash(size_type __n) {__table_.rehash(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    void reserve(size_type __n) {__table_.reserve(__n);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const\n        {return __table_.__dereferenceable(__i);}\n    bool __decrementable(const const_iterator* __i) const\n        {return __table_.__decrementable(__i);}\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(__i, __n);}\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(__i, __n);}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n};\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(\n        size_type __n, const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(\n        size_type __n, const hasher& __hf, const key_equal& __eql,\n        const allocator_type& __a)\n    : __table_(__hf, __eql, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(\n        _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__first, __last);\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(\n        const allocator_type& __a)\n    : __table_(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(\n        const unordered_multiset& __u)\n    : __table_(__u.__table_)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(\n        const unordered_multiset& __u, const allocator_type& __a)\n    : __table_(__u.__table_, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(\n        unordered_multiset&& __u)\n    _NOEXCEPT_(is_nothrow_move_constructible<__table>::value)\n    : __table_(_VSTD::move(__u.__table_))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(\n        unordered_multiset&& __u, const allocator_type& __a)\n    : __table_(_VSTD::move(__u.__table_), __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a != __u.get_allocator())\n    {\n        iterator __i = __u.begin();\n        while (__u.size() != 0)\n            __table_.__insert_multi(_VSTD::move(__u.__table_.remove(__i++)->__value_));\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    else\n        __get_db()->swap(this, &__u);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(\n        initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::unordered_multiset(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>&\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::operator=(\n        unordered_multiset&& __u)\n    _NOEXCEPT_(is_nothrow_move_assignable<__table>::value)\n{\n    __table_ = _VSTD::move(__u.__table_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ninline\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>&\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::operator=(\n        initializer_list<value_type> __il)\n{\n    __table_.__assign_multi(__il.begin(), __il.end());\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nunordered_multiset<_Value, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,\n                                                         _InputIterator __last)\n{\n    for (; __first != __last; ++__first)\n        __table_.__insert_multi(*__first);\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n     unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\nbool\noperator==(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n           const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n{\n    if (__x.size() != __y.size())\n        return false;\n    typedef typename unordered_multiset<_Value, _Hash, _Pred, _Alloc>::const_iterator\n                                                                 const_iterator;\n    typedef pair<const_iterator, const_iterator> _EqRng;\n    for (const_iterator __i = __x.begin(), __ex = __x.end(); __i != __ex;)\n    {\n        _EqRng __xeq = __x.equal_range(*__i);\n        _EqRng __yeq = __y.equal_range(*__i);\n        if (_VSTD::distance(__xeq.first, __xeq.second) !=\n            _VSTD::distance(__yeq.first, __yeq.second) ||\n                  !_VSTD::is_permutation(__xeq.first, __xeq.second, __yeq.first))\n            return false;\n        __i = __xeq.second;\n    }\n    return true;\n}\n\ntemplate <class _Value, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __x,\n           const unordered_multiset<_Value, _Hash, _Pred, _Alloc>& __y)\n{\n    return !(__x == __y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_UNORDERED_SET\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP__HASH_TABLE\n#define _LIBCPP__HASH_TABLE\n\n#include <__config>\n#include <initializer_list>\n#include <memory>\n#include <iterator>\n#include <algorithm>\n#include <cmath>\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n_LIBCPP_FUNC_VIS\nsize_t __next_prime(size_t __n);\n\ntemplate <class _NodePtr>\nstruct __hash_node_base\n{\n    typedef __hash_node_base __first_node;\n\n    _NodePtr    __next_;\n\n    _LIBCPP_INLINE_VISIBILITY __hash_node_base() _NOEXCEPT : __next_(nullptr) {}\n};\n\ntemplate <class _Tp, class _VoidPtr>\nstruct __hash_node\n    : public __hash_node_base\n             <\n                 typename pointer_traits<_VoidPtr>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                     rebind<__hash_node<_Tp, _VoidPtr> >\n#else\n                     rebind<__hash_node<_Tp, _VoidPtr> >::other\n#endif\n             >\n{\n    typedef _Tp value_type;\n\n    size_t     __hash_;\n    value_type __value_;\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__is_power2(size_t __bc)\n{\n    return __bc > 2 && !(__bc & (__bc - 1));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\n__constrain_hash(size_t __h, size_t __bc)\n{\n    return !(__bc & (__bc - 1)) ? __h & (__bc - 1) : __h % __bc;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\n__next_pow2(size_t __n)\n{\n    return size_t(1) << (std::numeric_limits<size_t>::digits - __clz(__n-1));\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc> class __hash_table;\ntemplate <class _ConstNodePtr> class _LIBCPP_TYPE_VIS_ONLY __hash_const_iterator;\ntemplate <class _HashIterator> class _LIBCPP_TYPE_VIS_ONLY __hash_map_iterator;\ntemplate <class _HashIterator> class _LIBCPP_TYPE_VIS_ONLY __hash_map_const_iterator;\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n    class _LIBCPP_TYPE_VIS_ONLY unordered_map;\n\ntemplate <class _NodePtr>\nclass _LIBCPP_TYPE_VIS_ONLY __hash_iterator\n{\n    typedef _NodePtr __node_pointer;\n\n    __node_pointer            __node_;\n\npublic:\n    typedef forward_iterator_tag                         iterator_category;\n    typedef typename pointer_traits<__node_pointer>::element_type::value_type value_type;\n    typedef typename pointer_traits<__node_pointer>::difference_type difference_type;\n    typedef value_type&                                  reference;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n                     rebind<value_type>\n#else\n                     rebind<value_type>::other\n#endif\n                                                         pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __hash_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n    : __node_(nullptr)\n#endif\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator(const __hash_iterator& __i)\n        : __node_(__i.__node_)\n    {\n        __get_db()->__iterator_copy(this, &__i);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__hash_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator& operator=(const __hash_iterator& __i)\n    {\n        if (this != &__i)\n        {\n            __get_db()->__iterator_copy(this, &__i);\n            __node_ = __i.__node_;\n        }\n        return *this;\n    }\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n        reference operator*() const\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container iterator\");\n#endif\n            return __node_->__value_;\n        }\n    _LIBCPP_INLINE_VISIBILITY\n        pointer operator->() const\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container iterator\");\n#endif\n            return pointer_traits<pointer>::pointer_to(__node_->__value_);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator& operator++()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable unordered container iterator\");\n#endif\n        __node_ = __node_->__next_;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator operator++(int)\n    {\n        __hash_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __hash_iterator& __x, const __hash_iterator& __y)\n    {\n        return __x.__node_ == __y.__node_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __hash_iterator& __x, const __hash_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator(__node_pointer __node, const void* __c) _NOEXCEPT\n        : __node_(__node)\n        {\n            __get_db()->__insert_ic(this, __c);\n        }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_iterator(__node_pointer __node) _NOEXCEPT\n        : __node_(__node)\n        {}\n#endif\n\n    template <class, class, class, class> friend class __hash_table;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __hash_const_iterator;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __hash_map_iterator;\n    template <class, class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY unordered_map;\n    template <class, class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY unordered_multimap;\n};\n\ntemplate <class _ConstNodePtr>\nclass _LIBCPP_TYPE_VIS_ONLY __hash_const_iterator\n{\n    typedef _ConstNodePtr __node_pointer;\n\n    __node_pointer         __node_;\n\n    typedef typename remove_const<\n        typename pointer_traits<__node_pointer>::element_type\n                                 >::type __node;\n\npublic:\n    typedef forward_iterator_tag                       iterator_category;\n    typedef typename __node::value_type                value_type;\n    typedef typename pointer_traits<__node_pointer>::difference_type difference_type;\n    typedef const value_type&                          reference;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const value_type>\n#else\n            rebind<const value_type>::other\n#endif\n                                                       pointer;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__node>\n#else\n            rebind<__node>::other\n#endif\n                                                      __non_const_node_pointer;\n    typedef __hash_iterator<__non_const_node_pointer> __non_const_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY __hash_const_iterator() _NOEXCEPT\n#if _LIBCPP_STD_VER > 11\n    : __node_(nullptr)\n#endif\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n    _LIBCPP_INLINE_VISIBILITY \n    __hash_const_iterator(const __non_const_iterator& __x) _NOEXCEPT\n        : __node_(__x.__node_)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__iterator_copy(this, &__x);\n#endif\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator(const __hash_const_iterator& __i)\n        : __node_(__i.__node_)\n    {\n        __get_db()->__iterator_copy(this, &__i);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__hash_const_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator& operator=(const __hash_const_iterator& __i)\n    {\n        if (this != &__i)\n        {\n            __get_db()->__iterator_copy(this, &__i);\n            __node_ = __i.__node_;\n        }\n        return *this;\n    }\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n        reference operator*() const\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container const_iterator\");\n#endif\n            return __node_->__value_;\n        }\n    _LIBCPP_INLINE_VISIBILITY\n        pointer operator->() const\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container const_iterator\");\n#endif\n            return pointer_traits<pointer>::pointer_to(__node_->__value_);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator& operator++()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable unordered container const_iterator\");\n#endif\n        __node_ = __node_->__next_;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator operator++(int)\n    {\n        __hash_const_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __hash_const_iterator& __x, const __hash_const_iterator& __y)\n    {\n        return __x.__node_ == __y.__node_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __hash_const_iterator& __x, const __hash_const_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator(__node_pointer __node, const void* __c) _NOEXCEPT\n        : __node_(__node)\n        {\n            __get_db()->__insert_ic(this, __c);\n        }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_iterator(__node_pointer __node) _NOEXCEPT\n        : __node_(__node)\n        {}\n#endif\n\n    template <class, class, class, class> friend class __hash_table;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __hash_map_const_iterator;\n    template <class, class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY unordered_map;\n    template <class, class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY unordered_multimap;\n};\n\ntemplate <class _ConstNodePtr> class _LIBCPP_TYPE_VIS_ONLY __hash_const_local_iterator;\n\ntemplate <class _NodePtr>\nclass _LIBCPP_TYPE_VIS_ONLY __hash_local_iterator\n{\n    typedef _NodePtr __node_pointer;\n\n    __node_pointer         __node_;\n    size_t                 __bucket_;\n    size_t                 __bucket_count_;\n\n    typedef pointer_traits<__node_pointer>          __pointer_traits;\npublic:\n    typedef forward_iterator_tag                                iterator_category;\n    typedef typename __pointer_traits::element_type::value_type value_type;\n    typedef typename __pointer_traits::difference_type          difference_type;\n    typedef value_type&                                         reference;\n    typedef typename __pointer_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<value_type>\n#else\n            rebind<value_type>::other\n#endif\n                                                                pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __hash_local_iterator() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator(const __hash_local_iterator& __i)\n        : __node_(__i.__node_),\n          __bucket_(__i.__bucket_),\n          __bucket_count_(__i.__bucket_count_)\n    {\n        __get_db()->__iterator_copy(this, &__i);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__hash_local_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator& operator=(const __hash_local_iterator& __i)\n    {\n        if (this != &__i)\n        {\n            __get_db()->__iterator_copy(this, &__i);\n            __node_ = __i.__node_;\n            __bucket_ = __i.__bucket_;\n            __bucket_count_ = __i.__bucket_count_;\n        }\n        return *this;\n    }\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n        reference operator*() const\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container local_iterator\");\n#endif\n            return __node_->__value_;\n        }\n    _LIBCPP_INLINE_VISIBILITY\n        pointer operator->() const\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container local_iterator\");\n#endif\n            return pointer_traits<pointer>::pointer_to(__node_->__value_);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator& operator++()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable unordered container local_iterator\");\n#endif\n        __node_ = __node_->__next_;\n        if (__node_ != nullptr && __constrain_hash(__node_->__hash_, __bucket_count_) != __bucket_)\n            __node_ = nullptr;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator operator++(int)\n    {\n        __hash_local_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __hash_local_iterator& __x, const __hash_local_iterator& __y)\n    {\n        return __x.__node_ == __y.__node_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __hash_local_iterator& __x, const __hash_local_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator(__node_pointer __node, size_t __bucket,\n                          size_t __bucket_count, const void* __c) _NOEXCEPT\n        : __node_(__node),\n          __bucket_(__bucket),\n          __bucket_count_(__bucket_count)\n        {\n            __get_db()->__insert_ic(this, __c);\n            if (__node_ != nullptr)\n                __node_ = __node_->__next_;\n        }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_local_iterator(__node_pointer __node, size_t __bucket,\n                          size_t __bucket_count) _NOEXCEPT\n        : __node_(__node),\n          __bucket_(__bucket),\n          __bucket_count_(__bucket_count)\n        {\n            if (__node_ != nullptr)\n                __node_ = __node_->__next_;\n        }\n#endif\n    template <class, class, class, class> friend class __hash_table;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __hash_const_local_iterator;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __hash_map_iterator;\n};\n\ntemplate <class _ConstNodePtr>\nclass _LIBCPP_TYPE_VIS_ONLY __hash_const_local_iterator\n{\n    typedef _ConstNodePtr __node_pointer;\n\n    __node_pointer         __node_;\n    size_t                 __bucket_;\n    size_t                 __bucket_count_;\n\n    typedef pointer_traits<__node_pointer>          __pointer_traits;\n    typedef typename __pointer_traits::element_type __node;\n    typedef typename remove_const<__node>::type     __non_const_node;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__non_const_node>\n#else\n            rebind<__non_const_node>::other\n#endif\n                                                    __non_const_node_pointer;\n    typedef __hash_local_iterator<__non_const_node_pointer>\n                                                    __non_const_iterator;\npublic:\n    typedef forward_iterator_tag                       iterator_category;\n    typedef typename remove_const<\n                        typename __pointer_traits::element_type::value_type\n                     >::type                           value_type;\n    typedef typename __pointer_traits::difference_type difference_type;\n    typedef const value_type&                          reference;\n    typedef typename __pointer_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const value_type>\n#else\n            rebind<const value_type>::other\n#endif\n                                                       pointer;\n\n    _LIBCPP_INLINE_VISIBILITY __hash_const_local_iterator() _NOEXCEPT\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__insert_i(this);\n#endif\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator(const __non_const_iterator& __x) _NOEXCEPT\n        : __node_(__x.__node_),\n          __bucket_(__x.__bucket_),\n          __bucket_count_(__x.__bucket_count_)\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __get_db()->__iterator_copy(this, &__x);\n#endif\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator(const __hash_const_local_iterator& __i)\n        : __node_(__i.__node_),\n          __bucket_(__i.__bucket_),\n          __bucket_count_(__i.__bucket_count_)\n    {\n        __get_db()->__iterator_copy(this, &__i);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__hash_const_local_iterator()\n    {\n        __get_db()->__erase_i(this);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator& operator=(const __hash_const_local_iterator& __i)\n    {\n        if (this != &__i)\n        {\n            __get_db()->__iterator_copy(this, &__i);\n            __node_ = __i.__node_;\n            __bucket_ = __i.__bucket_;\n            __bucket_count_ = __i.__bucket_count_;\n        }\n        return *this;\n    }\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n    _LIBCPP_INLINE_VISIBILITY\n        reference operator*() const\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container const_local_iterator\");\n#endif\n            return __node_->__value_;\n        }\n    _LIBCPP_INLINE_VISIBILITY\n        pointer operator->() const\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                           \"Attempted to dereference a non-dereferenceable unordered container const_local_iterator\");\n#endif\n            return pointer_traits<pointer>::pointer_to(__node_->__value_);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator& operator++()\n    {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        _LIBCPP_ASSERT(__get_const_db()->__dereferenceable(this),\n                       \"Attempted to increment non-incrementable unordered container const_local_iterator\");\n#endif\n        __node_ = __node_->__next_;\n        if (__node_ != nullptr && __constrain_hash(__node_->__hash_, __bucket_count_) != __bucket_)\n            __node_ = nullptr;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator operator++(int)\n    {\n        __hash_const_local_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const __hash_const_local_iterator& __x, const __hash_const_local_iterator& __y)\n    {\n        return __x.__node_ == __y.__node_;\n    }\n    friend _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const __hash_const_local_iterator& __x, const __hash_const_local_iterator& __y)\n        {return !(__x == __y);}\n\nprivate:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator(__node_pointer __node, size_t __bucket,\n                                size_t __bucket_count, const void* __c) _NOEXCEPT\n        : __node_(__node),\n          __bucket_(__bucket),\n          __bucket_count_(__bucket_count)\n        {\n            __get_db()->__insert_ic(this, __c);\n            if (__node_ != nullptr)\n                __node_ = __node_->__next_;\n        }\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_const_local_iterator(__node_pointer __node, size_t __bucket,\n                                size_t __bucket_count) _NOEXCEPT\n        : __node_(__node),\n          __bucket_(__bucket),\n          __bucket_count_(__bucket_count)\n        {\n            if (__node_ != nullptr)\n                __node_ = __node_->__next_;\n        }\n#endif\n    template <class, class, class, class> friend class __hash_table;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __hash_map_const_iterator;\n};\n\ntemplate <class _Alloc>\nclass __bucket_list_deallocator\n{\n    typedef _Alloc                                          allocator_type;\n    typedef allocator_traits<allocator_type>                __alloc_traits;\n    typedef typename __alloc_traits::size_type              size_type;\n\n    __compressed_pair<size_type, allocator_type> __data_;\npublic:\n    typedef typename __alloc_traits::pointer pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bucket_list_deallocator()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n        : __data_(0) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bucket_list_deallocator(const allocator_type& __a, size_type __size)\n        _NOEXCEPT_(is_nothrow_copy_constructible<allocator_type>::value)\n        : __data_(__size, __a) {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bucket_list_deallocator(__bucket_list_deallocator&& __x)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n        : __data_(_VSTD::move(__x.__data_))\n    {\n        __x.size() = 0;\n    }\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type& size() _NOEXCEPT {return __data_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type  size() const _NOEXCEPT {return __data_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT {return __data_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT {return __data_.second();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        __alloc_traits::deallocate(__alloc(), __p, size());\n    }\n};\n\ntemplate <class _Alloc> class __hash_map_node_destructor;\n\ntemplate <class _Alloc>\nclass __hash_node_destructor\n{\n    typedef _Alloc                                          allocator_type;\n    typedef allocator_traits<allocator_type>                __alloc_traits;\n    typedef typename __alloc_traits::value_type::value_type value_type;\npublic:\n    typedef typename __alloc_traits::pointer                pointer;\nprivate:\n\n    allocator_type& __na_;\n\n    __hash_node_destructor& operator=(const __hash_node_destructor&);\n\npublic:\n    bool __value_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __hash_node_destructor(allocator_type& __na,\n                                    bool __constructed = false) _NOEXCEPT\n        : __na_(__na),\n          __value_constructed(__constructed)\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__value_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n\n    template <class> friend class __hash_map_node_destructor;\n};\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nclass __hash_table\n{\npublic:\n    typedef _Tp    value_type;\n    typedef _Hash  hasher;\n    typedef _Equal key_equal;\n    typedef _Alloc allocator_type;\n\nprivate:\n    typedef allocator_traits<allocator_type> __alloc_traits;\npublic:\n    typedef value_type&                              reference;\n    typedef const value_type&                        const_reference;\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\npublic:\n    // Create __node\n    typedef __hash_node<value_type, typename __alloc_traits::void_pointer> __node;\n    typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<__node>\n#else\n            rebind_alloc<__node>::other\n#endif\n                                                     __node_allocator;\n    typedef allocator_traits<__node_allocator>       __node_traits;\n    typedef typename __node_traits::pointer          __node_pointer;\n    typedef typename __node_traits::pointer          __node_const_pointer;\n    typedef __hash_node_base<__node_pointer>         __first_node;\n    typedef typename pointer_traits<__node_pointer>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<__first_node>\n#else\n            rebind<__first_node>::other\n#endif\n                                                     __node_base_pointer;\n\nprivate:\n\n    typedef typename __node_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<__node_pointer>\n#else\n            rebind_alloc<__node_pointer>::other\n#endif\n                                                            __pointer_allocator;\n    typedef __bucket_list_deallocator<__pointer_allocator> __bucket_list_deleter;\n    typedef unique_ptr<__node_pointer[], __bucket_list_deleter> __bucket_list;\n    typedef allocator_traits<__pointer_allocator>          __pointer_alloc_traits;\n    typedef typename __bucket_list_deleter::pointer __node_pointer_pointer;\n\n    // --- Member data begin ---\n    __bucket_list                                     __bucket_list_;\n    __compressed_pair<__first_node, __node_allocator> __p1_;\n    __compressed_pair<size_type, hasher>              __p2_;\n    __compressed_pair<float, key_equal>               __p3_;\n    // --- Member data end ---\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type& size() _NOEXCEPT {return __p2_.first();}\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    size_type  size() const _NOEXCEPT {return __p2_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    hasher& hash_function() _NOEXCEPT {return __p2_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const hasher& hash_function() const _NOEXCEPT {return __p2_.second();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    float& max_load_factor() _NOEXCEPT {return __p3_.first();}\n    _LIBCPP_INLINE_VISIBILITY\n    float  max_load_factor() const _NOEXCEPT {return __p3_.first();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    key_equal& key_eq() _NOEXCEPT {return __p3_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const key_equal& key_eq() const _NOEXCEPT {return __p3_.second();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __node_allocator& __node_alloc() _NOEXCEPT {return __p1_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const __node_allocator& __node_alloc() const _NOEXCEPT\n        {return __p1_.second();}\n\npublic:\n    typedef __hash_iterator<__node_pointer>                   iterator;\n    typedef __hash_const_iterator<__node_pointer>             const_iterator;\n    typedef __hash_local_iterator<__node_pointer>             local_iterator;\n    typedef __hash_const_local_iterator<__node_pointer>       const_local_iterator;\n\n    __hash_table()\n        _NOEXCEPT_(\n            is_nothrow_default_constructible<__bucket_list>::value &&\n            is_nothrow_default_constructible<__first_node>::value &&\n            is_nothrow_default_constructible<__node_allocator>::value &&\n            is_nothrow_default_constructible<hasher>::value &&\n            is_nothrow_default_constructible<key_equal>::value);\n    __hash_table(const hasher& __hf, const key_equal& __eql);\n    __hash_table(const hasher& __hf, const key_equal& __eql,\n                 const allocator_type& __a);\n    explicit __hash_table(const allocator_type& __a);\n    __hash_table(const __hash_table& __u);\n    __hash_table(const __hash_table& __u, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __hash_table(__hash_table&& __u)\n        _NOEXCEPT_(\n            is_nothrow_move_constructible<__bucket_list>::value &&\n            is_nothrow_move_constructible<__first_node>::value &&\n            is_nothrow_move_constructible<__node_allocator>::value &&\n            is_nothrow_move_constructible<hasher>::value &&\n            is_nothrow_move_constructible<key_equal>::value);\n    __hash_table(__hash_table&& __u, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    ~__hash_table();\n\n    __hash_table& operator=(const __hash_table& __u);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __hash_table& operator=(__hash_table&& __u)\n        _NOEXCEPT_(\n            __node_traits::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<__node_allocator>::value &&\n            is_nothrow_move_assignable<hasher>::value &&\n            is_nothrow_move_assignable<key_equal>::value);\n#endif\n    template <class _InputIterator>\n        void __assign_unique(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        void __assign_multi(_InputIterator __first, _InputIterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT\n    {\n        return allocator_traits<__pointer_allocator>::max_size(\n            __bucket_list_.get_deleter().__alloc());\n    }\n\n    pair<iterator, bool> __node_insert_unique(__node_pointer __nd);\n    iterator             __node_insert_multi(__node_pointer __nd);\n    iterator             __node_insert_multi(const_iterator __p,\n                                             __node_pointer __nd);\n\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class... _Args>\n        pair<iterator, bool> __emplace_unique(_Args&&... __args);\n    template <class... _Args>\n        iterator __emplace_multi(_Args&&... __args);\n    template <class... _Args>\n        iterator __emplace_hint_multi(const_iterator __p, _Args&&... __args);\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) && !defined(_LIBCPP_HAS_NO_VARIADICS)\n\n    pair<iterator, bool> __insert_unique(const value_type& __x);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp>\n        pair<iterator, bool> __insert_unique(_Pp&& __x);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp>\n        iterator __insert_multi(_Pp&& __x);\n    template <class _Pp>\n        iterator __insert_multi(const_iterator __p, _Pp&& __x);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    iterator __insert_multi(const value_type& __x);\n    iterator __insert_multi(const_iterator __p, const value_type& __x);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    void clear() _NOEXCEPT;\n    void rehash(size_type __n);\n    _LIBCPP_INLINE_VISIBILITY void reserve(size_type __n)\n        {rehash(static_cast<size_type>(ceil(__n / max_load_factor())));}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_count() const _NOEXCEPT\n    {\n        return __bucket_list_.get_deleter().size();\n    }\n\n    iterator       begin() _NOEXCEPT;\n    iterator       end() _NOEXCEPT;\n    const_iterator begin() const _NOEXCEPT;\n    const_iterator end() const _NOEXCEPT;\n\n    template <class _Key>\n        _LIBCPP_INLINE_VISIBILITY\n        size_type bucket(const _Key& __k) const\n        {\n            _LIBCPP_ASSERT(bucket_count() > 0,\n                \"unordered container::bucket(key) called when bucket_count() == 0\");\n            return __constrain_hash(hash_function()(__k), bucket_count());\n        }\n\n    template <class _Key>\n        iterator       find(const _Key& __x);\n    template <class _Key>\n        const_iterator find(const _Key& __x) const;\n\n    typedef __hash_node_destructor<__node_allocator> _Dp;\n    typedef unique_ptr<__node, _Dp> __node_holder;\n\n    iterator erase(const_iterator __p);\n    iterator erase(const_iterator __first, const_iterator __last);\n    template <class _Key>\n        size_type __erase_unique(const _Key& __k);\n    template <class _Key>\n        size_type __erase_multi(const _Key& __k);\n    __node_holder remove(const_iterator __p) _NOEXCEPT;\n\n    template <class _Key>\n        size_type __count_unique(const _Key& __k) const;\n    template <class _Key>\n        size_type __count_multi(const _Key& __k) const;\n\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_unique(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_unique(const _Key& __k) const;\n\n    template <class _Key>\n        pair<iterator, iterator>\n        __equal_range_multi(const _Key& __k);\n    template <class _Key>\n        pair<const_iterator, const_iterator>\n        __equal_range_multi(const _Key& __k) const;\n\n    void swap(__hash_table& __u)\n        _NOEXCEPT_(\n            (!allocator_traits<__pointer_allocator>::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<__pointer_allocator>::value) &&\n            (!__node_traits::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<__node_allocator>::value) &&\n            __is_nothrow_swappable<hasher>::value &&\n            __is_nothrow_swappable<key_equal>::value);\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_bucket_count() const _NOEXCEPT\n        {return __pointer_alloc_traits::max_size(__bucket_list_.get_deleter().__alloc());}\n    size_type bucket_size(size_type __n) const;\n    _LIBCPP_INLINE_VISIBILITY float load_factor() const _NOEXCEPT\n    {\n        size_type __bc = bucket_count();\n        return __bc != 0 ? (float)size() / __bc : 0.f;\n    }\n    _LIBCPP_INLINE_VISIBILITY void max_load_factor(float __mlf) _NOEXCEPT\n    {\n        _LIBCPP_ASSERT(__mlf > 0,\n            \"unordered container::max_load_factor(lf) called with lf <= 0\");\n        max_load_factor() = _VSTD::max(__mlf, load_factor());\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator\n    begin(size_type __n)\n    {\n        _LIBCPP_ASSERT(__n < bucket_count(),\n            \"unordered container::begin(n) called with n >= bucket_count()\");\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return local_iterator(__bucket_list_[__n], __n, bucket_count(), this);\n#else\n        return local_iterator(__bucket_list_[__n], __n, bucket_count());\n#endif\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator\n    end(size_type __n)\n    {\n        _LIBCPP_ASSERT(__n < bucket_count(),\n            \"unordered container::end(n) called with n >= bucket_count()\");\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return local_iterator(nullptr, __n, bucket_count(), this);\n#else\n        return local_iterator(nullptr, __n, bucket_count());\n#endif\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator\n    cbegin(size_type __n) const\n    {\n        _LIBCPP_ASSERT(__n < bucket_count(),\n            \"unordered container::cbegin(n) called with n >= bucket_count()\");\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return const_local_iterator(__bucket_list_[__n], __n, bucket_count(), this);\n#else\n        return const_local_iterator(__bucket_list_[__n], __n, bucket_count());\n#endif\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator\n    cend(size_type __n) const\n    {\n        _LIBCPP_ASSERT(__n < bucket_count(),\n            \"unordered container::cend(n) called with n >= bucket_count()\");\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return const_local_iterator(nullptr, __n, bucket_count(), this);\n#else\n        return const_local_iterator(nullptr, __n, bucket_count());\n#endif\n    }\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    void __rehash(size_type __n);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class ..._Args>\n        __node_holder __construct_node(_Args&& ...__args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n    __node_holder __construct_node(value_type&& __v, size_t __hash);\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __node_holder __construct_node(const value_type& __v);\n#endif\n    __node_holder __construct_node(const value_type& __v, size_t __hash);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const __hash_table& __u)\n        {__copy_assign_alloc(__u, integral_constant<bool,\n             __node_traits::propagate_on_container_copy_assignment::value>());}\n    void __copy_assign_alloc(const __hash_table& __u, true_type);\n    _LIBCPP_INLINE_VISIBILITY\n        void __copy_assign_alloc(const __hash_table&, false_type) {}\n\n    void __move_assign(__hash_table& __u, false_type);\n    void __move_assign(__hash_table& __u, true_type)\n        _NOEXCEPT_(\n            is_nothrow_move_assignable<__node_allocator>::value &&\n            is_nothrow_move_assignable<hasher>::value &&\n            is_nothrow_move_assignable<key_equal>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__hash_table& __u)\n        _NOEXCEPT_(\n            !__node_traits::propagate_on_container_move_assignment::value ||\n            (is_nothrow_move_assignable<__pointer_allocator>::value &&\n             is_nothrow_move_assignable<__node_allocator>::value))\n        {__move_assign_alloc(__u, integral_constant<bool,\n             __node_traits::propagate_on_container_move_assignment::value>());}\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__hash_table& __u, true_type)\n        _NOEXCEPT_(\n            is_nothrow_move_assignable<__pointer_allocator>::value &&\n            is_nothrow_move_assignable<__node_allocator>::value)\n    {\n        __bucket_list_.get_deleter().__alloc() =\n                _VSTD::move(__u.__bucket_list_.get_deleter().__alloc());\n        __node_alloc() = _VSTD::move(__u.__node_alloc());\n    }\n    _LIBCPP_INLINE_VISIBILITY\n        void __move_assign_alloc(__hash_table&, false_type) _NOEXCEPT {}\n\n    template <class _Ap>\n    _LIBCPP_INLINE_VISIBILITY\n    static\n    void\n    __swap_alloc(_Ap& __x, _Ap& __y)\n        _NOEXCEPT_(\n            !allocator_traits<_Ap>::propagate_on_container_swap::value ||\n            __is_nothrow_swappable<_Ap>::value)\n    {\n        __swap_alloc(__x, __y,\n                     integral_constant<bool,\n                        allocator_traits<_Ap>::propagate_on_container_swap::value\n                                      >());\n    }\n\n    template <class _Ap>\n    _LIBCPP_INLINE_VISIBILITY\n    static\n    void\n    __swap_alloc(_Ap& __x, _Ap& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<_Ap>::value)\n    {\n        using _VSTD::swap;\n        swap(__x, __y);\n    }\n\n    template <class _Ap>\n    _LIBCPP_INLINE_VISIBILITY\n    static\n    void\n    __swap_alloc(_Ap&, _Ap&, false_type) _NOEXCEPT {}\n\n    void __deallocate(__node_pointer __np) _NOEXCEPT;\n    __node_pointer __detach() _NOEXCEPT;\n\n    template <class, class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY unordered_map;\n    template <class, class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY unordered_multimap;\n};\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table()\n    _NOEXCEPT_(\n        is_nothrow_default_constructible<__bucket_list>::value &&\n        is_nothrow_default_constructible<__first_node>::value &&\n        is_nothrow_default_constructible<hasher>::value &&\n        is_nothrow_default_constructible<key_equal>::value)\n    : __p2_(0),\n      __p3_(1.0f)\n{\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const hasher& __hf,\n                                                       const key_equal& __eql)\n    : __bucket_list_(nullptr, __bucket_list_deleter()),\n      __p1_(),\n      __p2_(0, __hf),\n      __p3_(1.0f, __eql)\n{\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const hasher& __hf,\n                                                       const key_equal& __eql,\n                                                       const allocator_type& __a)\n    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),\n      __p1_(__node_allocator(__a)),\n      __p2_(0, __hf),\n      __p3_(1.0f, __eql)\n{\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const allocator_type& __a)\n    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),\n      __p1_(__node_allocator(__a)),\n      __p2_(0),\n      __p3_(1.0f)\n{\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const __hash_table& __u)\n    : __bucket_list_(nullptr,\n          __bucket_list_deleter(allocator_traits<__pointer_allocator>::\n              select_on_container_copy_construction(\n                  __u.__bucket_list_.get_deleter().__alloc()), 0)),\n      __p1_(allocator_traits<__node_allocator>::\n          select_on_container_copy_construction(__u.__node_alloc())),\n      __p2_(0, __u.hash_function()),\n      __p3_(__u.__p3_)\n{\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(const __hash_table& __u,\n                                                       const allocator_type& __a)\n    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),\n      __p1_(__node_allocator(__a)),\n      __p2_(0, __u.hash_function()),\n      __p3_(__u.__p3_)\n{\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(__hash_table&& __u)\n        _NOEXCEPT_(\n            is_nothrow_move_constructible<__bucket_list>::value &&\n            is_nothrow_move_constructible<__first_node>::value &&\n            is_nothrow_move_constructible<hasher>::value &&\n            is_nothrow_move_constructible<key_equal>::value)\n    : __bucket_list_(_VSTD::move(__u.__bucket_list_)),\n      __p1_(_VSTD::move(__u.__p1_)),\n      __p2_(_VSTD::move(__u.__p2_)),\n      __p3_(_VSTD::move(__u.__p3_))\n{\n    if (size() > 0)\n    {\n        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash_, bucket_count())] =\n            static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__p1_.first()));\n        __u.__p1_.first().__next_ = nullptr;\n        __u.size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__hash_table(__hash_table&& __u,\n                                                       const allocator_type& __a)\n    : __bucket_list_(nullptr, __bucket_list_deleter(__pointer_allocator(__a), 0)),\n      __p1_(__node_allocator(__a)),\n      __p2_(0, _VSTD::move(__u.hash_function())),\n      __p3_(_VSTD::move(__u.__p3_))\n{\n    if (__a == allocator_type(__u.__node_alloc()))\n    {\n        __bucket_list_.reset(__u.__bucket_list_.release());\n        __bucket_list_.get_deleter().size() = __u.__bucket_list_.get_deleter().size();\n        __u.__bucket_list_.get_deleter().size() = 0;\n        if (__u.size() > 0)\n        {\n            __p1_.first().__next_ = __u.__p1_.first().__next_;\n            __u.__p1_.first().__next_ = nullptr;\n            __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash_, bucket_count())] =\n                static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__p1_.first()));\n            size() = __u.size();\n            __u.size() = 0;\n        }\n    }\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::~__hash_table()\n{\n    __deallocate(__p1_.first().__next_);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__copy_assign_alloc(\n        const __hash_table& __u, true_type)\n{\n    if (__node_alloc() != __u.__node_alloc())\n    {\n        clear();\n        __bucket_list_.reset();\n        __bucket_list_.get_deleter().size() = 0;\n    }\n    __bucket_list_.get_deleter().__alloc() = __u.__bucket_list_.get_deleter().__alloc();\n    __node_alloc() = __u.__node_alloc();\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>&\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::operator=(const __hash_table& __u)\n{\n    if (this != &__u)\n    {\n        __copy_assign_alloc(__u);\n        hash_function() = __u.hash_function();\n        key_eq() = __u.key_eq();\n        max_load_factor() = __u.max_load_factor();\n        __assign_multi(__u.begin(), __u.end());\n    }\n    return *this;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__deallocate(__node_pointer __np)\n    _NOEXCEPT\n{\n    __node_allocator& __na = __node_alloc();\n    while (__np != nullptr)\n    {\n        __node_pointer __next = __np->__next_;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        __c_node* __c = __get_db()->__find_c_and_lock(this);\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            iterator* __i = static_cast<iterator*>((*__p)->__i_);\n            if (__i->__node_ == __np)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n#endif\n        __node_traits::destroy(__na, _VSTD::addressof(__np->__value_));\n        __node_traits::deallocate(__na, __np, 1);\n        __np = __next;\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_pointer\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__detach() _NOEXCEPT\n{\n    size_type __bc = bucket_count();\n    for (size_type __i = 0; __i < __bc; ++__i)\n        __bucket_list_[__i] = nullptr;\n    size() = 0;\n    __node_pointer __cache = __p1_.first().__next_;\n    __p1_.first().__next_ = nullptr;\n    return __cache;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__move_assign(\n        __hash_table& __u, true_type)\n    _NOEXCEPT_(\n        is_nothrow_move_assignable<__node_allocator>::value &&\n        is_nothrow_move_assignable<hasher>::value &&\n        is_nothrow_move_assignable<key_equal>::value)\n{\n    clear();\n    __bucket_list_.reset(__u.__bucket_list_.release());\n    __bucket_list_.get_deleter().size() = __u.__bucket_list_.get_deleter().size();\n    __u.__bucket_list_.get_deleter().size() = 0;\n    __move_assign_alloc(__u);\n    size() = __u.size();\n    hash_function() = _VSTD::move(__u.hash_function());\n    max_load_factor() = __u.max_load_factor();\n    key_eq() = _VSTD::move(__u.key_eq());\n    __p1_.first().__next_ = __u.__p1_.first().__next_;\n    if (size() > 0)\n    {\n        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash_, bucket_count())] =\n            static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__p1_.first()));\n        __u.__p1_.first().__next_ = nullptr;\n        __u.size() = 0;\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__move_assign(\n        __hash_table& __u, false_type)\n{\n    if (__node_alloc() == __u.__node_alloc())\n        __move_assign(__u, true_type());\n    else\n    {\n        hash_function() = _VSTD::move(__u.hash_function());\n        key_eq() = _VSTD::move(__u.key_eq());\n        max_load_factor() = __u.max_load_factor();\n        if (bucket_count() != 0)\n        {\n            __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            try\n            {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n                const_iterator __i = __u.begin();\n                while (__cache != nullptr && __u.size() != 0)\n                {\n                    __cache->__value_ = _VSTD::move(__u.remove(__i++)->__value_);\n                    __node_pointer __next = __cache->__next_;\n                    __node_insert_multi(__cache);\n                    __cache = __next;\n                }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n            }\n            catch (...)\n            {\n                __deallocate(__cache);\n                throw;\n            }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __deallocate(__cache);\n        }\n        const_iterator __i = __u.begin();\n        while (__u.size() != 0)\n        {\n            __node_holder __h =\n                    __construct_node(_VSTD::move(__u.remove(__i++)->__value_));\n            __node_insert_multi(__h.get());\n            __h.release();\n        }\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\n__hash_table<_Tp, _Hash, _Equal, _Alloc>&\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::operator=(__hash_table&& __u)\n    _NOEXCEPT_(\n        __node_traits::propagate_on_container_move_assignment::value &&\n        is_nothrow_move_assignable<__node_allocator>::value &&\n        is_nothrow_move_assignable<hasher>::value &&\n        is_nothrow_move_assignable<key_equal>::value)\n{\n    __move_assign(__u, integral_constant<bool,\n                  __node_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _InputIterator>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__assign_unique(_InputIterator __first,\n                                                          _InputIterator __last)\n{\n    if (bucket_count() != 0)\n    {\n        __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__value_ = *__first;\n                __node_pointer __next = __cache->__next_;\n                __node_insert_unique(__cache);\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            __deallocate(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __deallocate(__cache);\n    }\n    for (; __first != __last; ++__first)\n        __insert_unique(*__first);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _InputIterator>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__assign_multi(_InputIterator __first,\n                                                         _InputIterator __last)\n{\n    if (bucket_count() != 0)\n    {\n        __node_pointer __cache = __detach();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            for (; __cache != nullptr && __first != __last; ++__first)\n            {\n                __cache->__value_ = *__first;\n                __node_pointer __next = __cache->__next_;\n                __node_insert_multi(__cache);\n                __cache = __next;\n            }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n            __deallocate(__cache);\n            throw;\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        __deallocate(__cache);\n    }\n    for (; __first != __last; ++__first)\n        __insert_multi(*__first);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::begin() _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__p1_.first().__next_, this);\n#else\n    return iterator(__p1_.first().__next_);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::end() _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(nullptr, this);\n#else\n    return iterator(nullptr);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::begin() const _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return const_iterator(__p1_.first().__next_, this);\n#else\n    return const_iterator(__p1_.first().__next_);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::end() const _NOEXCEPT\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return const_iterator(nullptr, this);\n#else\n    return const_iterator(nullptr);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::clear() _NOEXCEPT\n{\n    if (size() > 0)\n    {\n        __deallocate(__p1_.first().__next_);\n        __p1_.first().__next_ = nullptr;\n        size_type __bc = bucket_count();\n        for (size_type __i = 0; __i < __bc; ++__i)\n            __bucket_list_[__i] = nullptr;\n        size() = 0;\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_unique(__node_pointer __nd)\n{\n    __nd->__hash_ = hash_function()(__nd->__value_);\n    size_type __bc = bucket_count();\n    bool __inserted = false;\n    __node_pointer __ndptr;\n    size_t __chash;\n    if (__bc != 0)\n    {\n        __chash = __constrain_hash(__nd->__hash_, __bc);\n        __ndptr = __bucket_list_[__chash];\n        if (__ndptr != nullptr)\n        {\n            for (__ndptr = __ndptr->__next_; __ndptr != nullptr &&\n                                             __constrain_hash(__ndptr->__hash_, __bc) == __chash;\n                                                     __ndptr = __ndptr->__next_)\n            {\n                if (key_eq()(__ndptr->__value_, __nd->__value_))\n                    goto __done;\n            }\n        }\n    }\n    {\n        if (size()+1 > __bc * max_load_factor() || __bc == 0)\n        {\n            rehash(_VSTD::max<size_type>(2 * __bc + !__is_power2(__bc),\n                           size_type(ceil(float(size() + 1) / max_load_factor()))));\n            __bc = bucket_count();\n            __chash = __constrain_hash(__nd->__hash_, __bc);\n        }\n        // insert_after __bucket_list_[__chash], or __first_node if bucket is null\n        __node_pointer __pn = __bucket_list_[__chash];\n        if (__pn == nullptr)\n        {\n            __pn = static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__p1_.first()));\n            __nd->__next_ = __pn->__next_;\n            __pn->__next_ = __nd;\n            // fix up __bucket_list_\n            __bucket_list_[__chash] = __pn;\n            if (__nd->__next_ != nullptr)\n                __bucket_list_[__constrain_hash(__nd->__next_->__hash_, __bc)] = __nd;\n        }\n        else\n        {\n            __nd->__next_ = __pn->__next_;\n            __pn->__next_ = __nd;\n        }\n        __ndptr = __nd;\n        // increment size\n        ++size();\n        __inserted = true;\n    }\n__done:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return pair<iterator, bool>(iterator(__ndptr, this), __inserted);\n#else\n    return pair<iterator, bool>(iterator(__ndptr), __inserted);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi(__node_pointer __cp)\n{\n    __cp->__hash_ = hash_function()(__cp->__value_);\n    size_type __bc = bucket_count();\n    if (size()+1 > __bc * max_load_factor() || __bc == 0)\n    {\n        rehash(_VSTD::max<size_type>(2 * __bc + !__is_power2(__bc),\n                       size_type(ceil(float(size() + 1) / max_load_factor()))));\n        __bc = bucket_count();\n    }\n    size_t __chash = __constrain_hash(__cp->__hash_, __bc);\n    __node_pointer __pn = __bucket_list_[__chash];\n    if (__pn == nullptr)\n    {\n        __pn = static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__p1_.first()));\n        __cp->__next_ = __pn->__next_;\n        __pn->__next_ = __cp;\n        // fix up __bucket_list_\n        __bucket_list_[__chash] = __pn;\n        if (__cp->__next_ != nullptr)\n            __bucket_list_[__constrain_hash(__cp->__next_->__hash_, __bc)] = __cp;\n    }\n    else\n    {\n        for (bool __found = false; __pn->__next_ != nullptr &&\n                                   __constrain_hash(__pn->__next_->__hash_, __bc) == __chash;\n                                                           __pn = __pn->__next_)\n        {\n            //      __found    key_eq()     action\n            //      false       false       loop\n            //      true        true        loop\n            //      false       true        set __found to true\n            //      true        false       break\n            if (__found != (__pn->__next_->__hash_ == __cp->__hash_ &&\n                            key_eq()(__pn->__next_->__value_, __cp->__value_)))\n            {\n                if (!__found)\n                    __found = true;\n                else\n                    break;\n            }\n        }\n        __cp->__next_ = __pn->__next_;\n        __pn->__next_ = __cp;\n        if (__cp->__next_ != nullptr)\n        {\n            size_t __nhash = __constrain_hash(__cp->__next_->__hash_, __bc);\n            if (__nhash != __chash)\n                __bucket_list_[__nhash] = __cp;\n        }\n    }\n    ++size();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(__cp, this);\n#else\n    return iterator(__cp);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_insert_multi(\n        const_iterator __p, __node_pointer __cp)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"unordered container::emplace_hint(const_iterator, args...) called with an iterator not\"\n        \" referring to this unordered container\");\n#endif\n    if (__p != end() && key_eq()(*__p, __cp->__value_))\n    {\n        __node_pointer __np = __p.__node_;\n        __cp->__hash_ = __np->__hash_;\n        size_type __bc = bucket_count();\n        if (size()+1 > __bc * max_load_factor() || __bc == 0)\n        {\n            rehash(_VSTD::max<size_type>(2 * __bc + !__is_power2(__bc),\n                           size_type(ceil(float(size() + 1) / max_load_factor()))));\n            __bc = bucket_count();\n        }\n        size_t __chash = __constrain_hash(__cp->__hash_, __bc);\n        __node_pointer __pp = __bucket_list_[__chash];\n        while (__pp->__next_ != __np)\n            __pp = __pp->__next_;\n        __cp->__next_ = __np;\n        __pp->__next_ = __cp;\n        ++size();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        return iterator(__cp, this);\n#else\n        return iterator(__cp);\n#endif\n    }\n    return __node_insert_multi(__cp);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__insert_unique(const value_type& __x)\n{\n    size_t __hash = hash_function()(__x);\n    size_type __bc = bucket_count();\n    bool __inserted = false;\n    __node_pointer __nd;\n    size_t __chash;\n    if (__bc != 0)\n    {\n        __chash = __constrain_hash(__hash, __bc);\n        __nd = __bucket_list_[__chash];\n        if (__nd != nullptr)\n        {\n            for (__nd = __nd->__next_; __nd != nullptr &&\n                                       __constrain_hash(__nd->__hash_, __bc) == __chash;\n                                                           __nd = __nd->__next_)\n            {\n                if (key_eq()(__nd->__value_, __x))\n                    goto __done;\n            }\n        }\n    }\n    {\n        __node_holder __h = __construct_node(__x, __hash);\n        if (size()+1 > __bc * max_load_factor() || __bc == 0)\n        {\n            rehash(_VSTD::max<size_type>(2 * __bc + !__is_power2(__bc),\n                           size_type(ceil(float(size() + 1) / max_load_factor()))));\n            __bc = bucket_count();\n            __chash = __constrain_hash(__hash, __bc);\n        }\n        // insert_after __bucket_list_[__chash], or __first_node if bucket is null\n        __node_pointer __pn = __bucket_list_[__chash];\n        if (__pn == nullptr)\n        {\n            __pn = static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__p1_.first()));\n            __h->__next_ = __pn->__next_;\n            __pn->__next_ = __h.get();\n            // fix up __bucket_list_\n            __bucket_list_[__chash] = __pn;\n            if (__h->__next_ != nullptr)\n                __bucket_list_[__constrain_hash(__h->__next_->__hash_, __bc)] = __h.get();\n        }\n        else\n        {\n            __h->__next_ = __pn->__next_;\n            __pn->__next_ = __h.get();\n        }\n        __nd = __h.release();\n        // increment size\n        ++size();\n        __inserted = true;\n    }\n__done:\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return pair<iterator, bool>(iterator(__nd, this), __inserted);\n#else\n    return pair<iterator, bool>(iterator(__nd), __inserted);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class... _Args>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_unique(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    pair<iterator, bool> __r = __node_insert_unique(__h.get());\n    if (__r.second)\n        __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class... _Args>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_multi(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __node_insert_multi(__h.get());\n    __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class... _Args>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__emplace_hint_multi(\n        const_iterator __p, _Args&&... __args)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"unordered container::emplace_hint(const_iterator, args...) called with an iterator not\"\n        \" referring to this unordered container\");\n#endif\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __node_insert_multi(__p, __h.get());\n    __h.release();\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Pp>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator, bool>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__insert_unique(_Pp&& __x)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Pp>(__x));\n    pair<iterator, bool> __r = __node_insert_unique(__h.get());\n    if (__r.second)\n        __h.release();\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Pp>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__insert_multi(_Pp&& __x)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Pp>(__x));\n    iterator __r = __node_insert_multi(__h.get());\n    __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Pp>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__insert_multi(const_iterator __p,\n                                                         _Pp&& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"unordered container::insert(const_iterator, rvalue) called with an iterator not\"\n        \" referring to this unordered container\");\n#endif\n    __node_holder __h = __construct_node(_VSTD::forward<_Pp>(__x));\n    iterator __r = __node_insert_multi(__p, __h.get());\n    __h.release();\n    return __r;\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__insert_multi(const value_type& __x)\n{\n    __node_holder __h = __construct_node(__x);\n    iterator __r = __node_insert_multi(__h.get());\n    __h.release();\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__insert_multi(const_iterator __p,\n                                                         const value_type& __x)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"unordered container::insert(const_iterator, lvalue) called with an iterator not\"\n        \" referring to this unordered container\");\n#endif\n    __node_holder __h = __construct_node(__x);\n    iterator __r = __node_insert_multi(__p, __h.get());\n    __h.release();\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::rehash(size_type __n)\n{\n    if (__n == 1)\n        __n = 2;\n    else if (__n & (__n - 1))\n        __n = __next_prime(__n);\n    size_type __bc = bucket_count();\n    if (__n > __bc)\n        __rehash(__n);\n    else if (__n < __bc)\n    {\n        __n = _VSTD::max<size_type>\n              (\n                  __n,\n                  __is_power2(__bc) ? __next_pow2(size_t(ceil(float(size()) / max_load_factor()))) :\n                                      __next_prime(size_t(ceil(float(size()) / max_load_factor())))\n              );\n        if (__n < __bc)\n            __rehash(__n);\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__rehash(size_type __nbc)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    __pointer_allocator& __npa = __bucket_list_.get_deleter().__alloc();\n    __bucket_list_.reset(__nbc > 0 ?\n                      __pointer_alloc_traits::allocate(__npa, __nbc) : nullptr);\n    __bucket_list_.get_deleter().size() = __nbc;\n    if (__nbc > 0)\n    {\n        for (size_type __i = 0; __i < __nbc; ++__i)\n            __bucket_list_[__i] = nullptr;\n        __node_pointer __pp(static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__p1_.first())));\n        __node_pointer __cp = __pp->__next_;\n        if (__cp != nullptr)\n        {\n            size_type __chash = __constrain_hash(__cp->__hash_, __nbc);\n            __bucket_list_[__chash] = __pp;\n            size_type __phash = __chash;\n            for (__pp = __cp, __cp = __cp->__next_; __cp != nullptr;\n                                                           __cp = __pp->__next_)\n            {\n                __chash = __constrain_hash(__cp->__hash_, __nbc);\n                if (__chash == __phash)\n                    __pp = __cp;\n                else\n                {\n                    if (__bucket_list_[__chash] == nullptr)\n                    {\n                        __bucket_list_[__chash] = __pp;\n                        __pp = __cp;\n                        __phash = __chash;\n                    }\n                    else\n                    {\n                        __node_pointer __np = __cp;\n                        for (; __np->__next_ != nullptr &&\n                               key_eq()(__cp->__value_, __np->__next_->__value_);\n                                                           __np = __np->__next_)\n                            ;\n                        __pp->__next_ = __np->__next_;\n                        __np->__next_ = __bucket_list_[__chash]->__next_;\n                        __bucket_list_[__chash]->__next_ = __cp;\n\n                    }\n                }\n            }\n        }\n    }\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::find(const _Key& __k)\n{\n    size_t __hash = hash_function()(__k);\n    size_type __bc = bucket_count();\n    if (__bc != 0)\n    {\n        size_t __chash = __constrain_hash(__hash, __bc);\n        __node_pointer __nd = __bucket_list_[__chash];\n        if (__nd != nullptr)\n        {\n            for (__nd = __nd->__next_; __nd != nullptr &&\n                                       __constrain_hash(__nd->__hash_, __bc) == __chash;\n                                                           __nd = __nd->__next_)\n            {\n                if (key_eq()(__nd->__value_, __k))\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                    return iterator(__nd, this);\n#else\n                    return iterator(__nd);\n#endif\n            }\n        }\n    }\n    return end();\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::find(const _Key& __k) const\n{\n    size_t __hash = hash_function()(__k);\n    size_type __bc = bucket_count();\n    if (__bc != 0)\n    {\n        size_t __chash = __constrain_hash(__hash, __bc);\n        __node_const_pointer __nd = __bucket_list_[__chash];\n        if (__nd != nullptr)\n        {\n            for (__nd = __nd->__next_; __nd != nullptr &&\n                                           __constrain_hash(__nd->__hash_, __bc) == __chash;\n                                                           __nd = __nd->__next_)\n            {\n                if (key_eq()(__nd->__value_, __k))\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                    return const_iterator(__nd, this);\n#else\n                    return const_iterator(__nd);\n#endif\n            }\n        }\n\n    }\n    return end();\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class ..._Args>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node(_Args&& ...__args)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__value_constructed = true;\n    __h->__hash_ = hash_function()(__h->__value_);\n    __h->__next_ = nullptr;\n    return __h;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node(value_type&& __v,\n                                                           size_t __hash)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), _VSTD::move(__v));\n    __h.get_deleter().__value_constructed = true;\n    __h->__hash_ = __hash;\n    __h->__next_ = nullptr;\n    return __h;\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node(const value_type& __v)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), __v);\n    __h.get_deleter().__value_constructed = true;\n    __h->__hash_ = hash_function()(__h->__value_);\n    __h->__next_ = nullptr;\n    return _VSTD::move(__h);  // explicitly moved for C++03\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__construct_node(const value_type& __v,\n                                                           size_t __hash)\n{\n    __node_allocator& __na = __node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_), __v);\n    __h.get_deleter().__value_constructed = true;\n    __h->__hash_ = __hash;\n    __h->__next_ = nullptr;\n    return _VSTD::move(__h);  // explicitly moved for C++03\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::erase(const_iterator __p)\n{\n    __node_pointer __np = __p.__node_;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n        \"unordered container erase(iterator) called with an iterator not\"\n        \" referring to this container\");\n    _LIBCPP_ASSERT(__p != end(),\n        \"unordered container erase(iterator) called with a non-dereferenceable iterator\");\n    iterator __r(__np, this);\n#else\n    iterator __r(__np);\n#endif\n    ++__r;\n    remove(__p);\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::erase(const_iterator __first,\n                                                const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"unodered container::erase(iterator, iterator) called with an iterator not\"\n        \" referring to this unodered container\");\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__last) == this,\n        \"unodered container::erase(iterator, iterator) called with an iterator not\"\n        \" referring to this unodered container\");\n#endif\n    for (const_iterator __p = __first; __first != __last; __p = __first)\n    {\n        ++__first;\n        erase(__p);\n    }\n    __node_pointer __np = __last.__node_;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator (__np, this);\n#else\n    return iterator (__np);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__erase_unique(const _Key& __k)\n{\n    iterator __i = find(__k);\n    if (__i == end())\n        return 0;\n    erase(__i);\n    return 1;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__erase_multi(const _Key& __k)\n{\n    size_type __r = 0;\n    iterator __i = find(__k);\n    if (__i != end())\n    {\n        iterator __e = end();\n        do\n        {\n            erase(__i++);\n            ++__r;\n        } while (__i != __e && key_eq()(*__i, __k));\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::__node_holder\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::remove(const_iterator __p) _NOEXCEPT\n{\n    // current node\n    __node_pointer __cn = __p.__node_;\n    size_type __bc = bucket_count();\n    size_t __chash = __constrain_hash(__cn->__hash_, __bc);\n    // find previous node\n    __node_pointer __pn = __bucket_list_[__chash];\n    for (; __pn->__next_ != __cn; __pn = __pn->__next_)\n        ;\n    // Fix up __bucket_list_\n        // if __pn is not in same bucket (before begin is not in same bucket) &&\n        //    if __cn->__next_ is not in same bucket (nullptr is not in same bucket)\n    if (__pn == static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__p1_.first()))\n                            || __constrain_hash(__pn->__hash_, __bc) != __chash)\n    {\n        if (__cn->__next_ == nullptr || __constrain_hash(__cn->__next_->__hash_, __bc) != __chash)\n            __bucket_list_[__chash] = nullptr;\n    }\n        // if __cn->__next_ is not in same bucket (nullptr is in same bucket)\n    if (__cn->__next_ != nullptr)\n    {\n        size_t __nhash = __constrain_hash(__cn->__next_->__hash_, __bc);\n        if (__nhash != __chash)\n            __bucket_list_[__nhash] = __pn;\n    }\n    // remove __cn\n    __pn->__next_ = __cn->__next_;\n    __cn->__next_ = nullptr;\n    --size();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    for (__i_node** __p = __c->end_; __p != __c->beg_; )\n    {\n        --__p;\n        iterator* __i = static_cast<iterator*>((*__p)->__i_);\n        if (__i->__node_ == __cn)\n        {\n            (*__p)->__c_ = nullptr;\n            if (--__c->end_ != __p)\n                memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n        }\n    }\n    __get_db()->unlock();\n#endif\n    return __node_holder(__cn, _Dp(__node_alloc(), true));\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__count_unique(const _Key& __k) const\n{\n    return static_cast<size_type>(find(__k) != end());\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__count_multi(const _Key& __k) const\n{\n    size_type __r = 0;\n    const_iterator __i = find(__k);\n    if (__i != end())\n    {\n        const_iterator __e = end();\n        do\n        {\n            ++__i;\n            ++__r;\n        } while (__i != __e && key_eq()(*__i, __k));\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator,\n     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_unique(\n        const _Key& __k)\n{\n    iterator __i = find(__k);\n    iterator __j = __i;\n    if (__i != end())\n        ++__j;\n    return pair<iterator, iterator>(__i, __j);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator,\n     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_unique(\n        const _Key& __k) const\n{\n    const_iterator __i = find(__k);\n    const_iterator __j = __i;\n    if (__i != end())\n        ++__j;\n    return pair<const_iterator, const_iterator>(__i, __j);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator,\n     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::iterator>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_multi(\n        const _Key& __k)\n{\n    iterator __i = find(__k);\n    iterator __j = __i;\n    if (__i != end())\n    {\n        iterator __e = end();\n        do\n        {\n            ++__j;\n        } while (__j != __e && key_eq()(*__j, __k));\n    }\n    return pair<iterator, iterator>(__i, __j);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntemplate <class _Key>\npair<typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator,\n     typename __hash_table<_Tp, _Hash, _Equal, _Alloc>::const_iterator>\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__equal_range_multi(\n        const _Key& __k) const\n{\n    const_iterator __i = find(__k);\n    const_iterator __j = __i;\n    if (__i != end())\n    {\n        const_iterator __e = end();\n        do\n        {\n            ++__j;\n        } while (__j != __e && key_eq()(*__j, __k));\n    }\n    return pair<const_iterator, const_iterator>(__i, __j);\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nvoid\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::swap(__hash_table& __u)\n    _NOEXCEPT_(\n        (!allocator_traits<__pointer_allocator>::propagate_on_container_swap::value ||\n         __is_nothrow_swappable<__pointer_allocator>::value) &&\n        (!__node_traits::propagate_on_container_swap::value ||\n         __is_nothrow_swappable<__node_allocator>::value) &&\n        __is_nothrow_swappable<hasher>::value &&\n        __is_nothrow_swappable<key_equal>::value)\n{\n    {\n    __node_pointer_pointer __npp = __bucket_list_.release();\n    __bucket_list_.reset(__u.__bucket_list_.release());\n    __u.__bucket_list_.reset(__npp);\n    }\n    _VSTD::swap(__bucket_list_.get_deleter().size(), __u.__bucket_list_.get_deleter().size());\n    __swap_alloc(__bucket_list_.get_deleter().__alloc(),\n             __u.__bucket_list_.get_deleter().__alloc());\n    __swap_alloc(__node_alloc(), __u.__node_alloc());\n    _VSTD::swap(__p1_.first().__next_, __u.__p1_.first().__next_);\n    __p2_.swap(__u.__p2_);\n    __p3_.swap(__u.__p3_);\n    if (size() > 0)\n        __bucket_list_[__constrain_hash(__p1_.first().__next_->__hash_, bucket_count())] =\n            static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__p1_.first()));\n    if (__u.size() > 0)\n        __u.__bucket_list_[__constrain_hash(__u.__p1_.first().__next_->__hash_, __u.bucket_count())] =\n            static_cast<__node_pointer>(pointer_traits<__node_base_pointer>::pointer_to(__u.__p1_.first()));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ntypename __hash_table<_Tp, _Hash, _Equal, _Alloc>::size_type\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::bucket_size(size_type __n) const\n{\n    _LIBCPP_ASSERT(__n < bucket_count(),\n        \"unordered container::bucket_size(n) called with n >= bucket_count()\");\n    __node_const_pointer __np = __bucket_list_[__n];\n    size_type __bc = bucket_count();\n    size_type __r = 0;\n    if (__np != nullptr)\n    {\n        for (__np = __np->__next_; __np != nullptr &&\n                                   __constrain_hash(__np->__hash_, __bc) == __n;\n                                                    __np = __np->__next_, ++__r)\n            ;\n    }\n    return __r;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__hash_table<_Tp, _Hash, _Equal, _Alloc>& __x,\n     __hash_table<_Tp, _Hash, _Equal, _Alloc>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nbool\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__dereferenceable(const const_iterator* __i) const\n{\n    return __i->__node_ != nullptr;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nbool\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__decrementable(const const_iterator*) const\n{\n    return false;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nbool\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__addable(const const_iterator*, ptrdiff_t) const\n{\n    return false;\n}\n\ntemplate <class _Tp, class _Hash, class _Equal, class _Alloc>\nbool\n__hash_table<_Tp, _Hash, _Equal, _Alloc>::__subscriptable(const const_iterator*, ptrdiff_t) const\n{\n    return false;\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP__HASH_TABLE\n","// -*- C++ -*-\n//===-------------------------- utility -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_UTILITY\n#define _LIBCPP_UTILITY\n\n/*\n    utility synopsis\n\nnamespace std\n{\n\ntemplate <class T>\n    void\n    swap(T& a, T& b);\n\nnamespace rel_ops\n{\n    template<class T> bool operator!=(const T&, const T&);\n    template<class T> bool operator> (const T&, const T&);\n    template<class T> bool operator<=(const T&, const T&);\n    template<class T> bool operator>=(const T&, const T&);\n}\n\ntemplate<class T>\nvoid\nswap(T& a, T& b) noexcept(is_nothrow_move_constructible<T>::value &&\n                          is_nothrow_move_assignable<T>::value);\n\ntemplate <class T, size_t N>\nvoid\nswap(T (&a)[N], T (&b)[N]) noexcept(noexcept(swap(*a, *b)));\n\ntemplate <class T> T&& forward(typename remove_reference<T>::type& t) noexcept;  // constexpr in C++14\ntemplate <class T> T&& forward(typename remove_reference<T>::type&& t) noexcept; // constexpr in C++14\n\ntemplate <class T> typename remove_reference<T>::type&& move(T&&) noexcept;      // constexpr in C++14\n\ntemplate <class T>\n    typename conditional\n    <\n        !is_nothrow_move_constructible<T>::value && is_copy_constructible<T>::value,\n        const T&,\n        T&&\n    >::type\n    move_if_noexcept(T& x) noexcept; // constexpr in C++14\n\ntemplate <class T> typename add_rvalue_reference<T>::type declval() noexcept;\n\ntemplate <class T1, class T2>\nstruct pair\n{\n    typedef T1 first_type;\n    typedef T2 second_type;\n\n    T1 first;\n    T2 second;\n\n    pair(const pair&) = default;\n    pair(pair&&) = default;\n    constexpr pair();\n    pair(const T1& x, const T2& y);                          // constexpr in C++14\n    template <class U, class V> pair(U&& x, V&& y);          // constexpr in C++14\n    template <class U, class V> pair(const pair<U, V>& p);   // constexpr in C++14\n    template <class U, class V> pair(pair<U, V>&& p);        // constexpr in C++14\n    template <class... Args1, class... Args2>\n        pair(piecewise_construct_t, tuple<Args1...> first_args,\n             tuple<Args2...> second_args);\n\n    template <class U, class V> pair& operator=(const pair<U, V>& p);\n    pair& operator=(pair&& p) noexcept(is_nothrow_move_assignable<T1>::value &&\n                                       is_nothrow_move_assignable<T2>::value);\n    template <class U, class V> pair& operator=(pair<U, V>&& p);\n\n    void swap(pair& p) noexcept(noexcept(swap(first, p.first)) &&\n                                noexcept(swap(second, p.second)));\n};\n\ntemplate <class T1, class T2> bool operator==(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator!=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator< (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator> (const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator>=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\ntemplate <class T1, class T2> bool operator<=(const pair<T1,T2>&, const pair<T1,T2>&); // constexpr in C++14\n\ntemplate <class T1, class T2> pair<V1, V2> make_pair(T1&&, T2&&);   // constexpr in C++14\ntemplate <class T1, class T2>\nvoid\nswap(pair<T1, T2>& x, pair<T1, T2>& y) noexcept(noexcept(x.swap(y)));\n\nstruct piecewise_construct_t { };\nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n\ntemplate <class T> class tuple_size;\ntemplate <size_t I, class T> class tuple_element;\n\ntemplate <class T1, class T2> struct tuple_size<pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<0, pair<T1, T2> >;\ntemplate <class T1, class T2> struct tuple_element<1, pair<T1, T2> >;\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, pair<T1, T2> >::type&\n    get(pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    const typename const tuple_element<I, pair<T1, T2> >::type&\n    get(const pair<T1, T2>&) noexcept; // constexpr in C++14\n\ntemplate<size_t I, class T1, class T2>\n    typename tuple_element<I, pair<T1, T2> >::type&&\n    get(pair<T1, T2>&&) noexcept; // constexpr in C++14\n\ntemplate<class T1, class T2>\n    constexpr T1& get(pair<T1, T2>&) noexcept; // C++14\n\ntemplate<size_t I, class T1, class T2>\n    constexpr T1 const& get(pair<T1, T2> const &) noexcept; // C++14\n\ntemplate<size_t I, class T1, class T2>\n    constexpr T1&& get(pair<T1, T2>&&) noexcept; // C++14\n\n// C++14\n\ntemplate<class T, T... I>\nstruct integer_sequence\n{\n    typedef T value_type;\n\n    static constexpr size_t size() noexcept;\n};\n\ntemplate<size_t... I>\n  using index_sequence = integer_sequence<size_t, I...>;\n\ntemplate<class T, T N>\n  using make_integer_sequence = integer_sequence<T, 0, 1, ..., N-1>;\ntemplate<size_t N>\n  using make_index_sequence = make_integer_sequence<size_t, N>;\n\ntemplate<class... T>\n  using index_sequence_for = make_index_sequence<sizeof...(T)>;\n\ntemplate<class T, class U=T> \n    T exchange(T& obj, U&& new_value);\n}  // std\n\n*/\n\n#include <__config>\n#include <__tuple>\n#include <type_traits>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nnamespace rel_ops\n{\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _Tp& __x, const _Tp& __y)\n{\n    return __y < __x;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _Tp& __x, const _Tp& __y)\n{\n    return !(__x < __y);\n}\n\n}  // rel_ops\n\n// swap_ranges\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator2\nswap_ranges(_ForwardIterator1 __first1, _ForwardIterator1 __last1, _ForwardIterator2 __first2)\n{\n    for(; __first1 != __last1; ++__first1, ++__first2)\n        swap(*__first1, *__first2);\n    return __first2;\n}\n\ntemplate<class _Tp, size_t _Np>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(_Tp (&__a)[_Np], _Tp (&__b)[_Np]) _NOEXCEPT_(__is_nothrow_swappable<_Tp>::value)\n{\n    _VSTD::swap_ranges(__a, __a + _Np, __b);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\ntypename conditional\n<\n    !is_nothrow_move_constructible<_Tp>::value && is_copy_constructible<_Tp>::value,\n    const _Tp&,\n    _Tp&&\n>::type\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\nconst _Tp&\n#endif\nmove_if_noexcept(_Tp& __x) _NOEXCEPT\n{\n    return _VSTD::move(__x);\n}\n\nstruct _LIBCPP_TYPE_VIS_ONLY piecewise_construct_t { };\n#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_UTILITY)\nextern const piecewise_construct_t piecewise_construct;// = piecewise_construct_t();\n#else\nconstexpr piecewise_construct_t piecewise_construct = piecewise_construct_t();\n#endif\n\ntemplate <class _T1, class _T2>\nstruct _LIBCPP_TYPE_VIS_ONLY pair\n{\n    typedef _T1 first_type;\n    typedef _T2 second_type;\n\n    _T1 first;\n    _T2 second;\n\n    // pair(const pair&) = default;\n    // pair(pair&&) = default;\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR pair() : first(), second() {}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    pair(const _T1& __x, const _T2& __y)\n        : first(__x), second(__y) {}\n\n    template<class _U1, class _U2>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(const pair<_U1, _U2>& __p\n#ifndef _LIBCPP_HAS_NO_ADVANCED_SFINAE\n                 ,typename enable_if<is_convertible<const _U1&, _T1>::value &&\n                                    is_convertible<const _U2&, _T2>::value>::type* = 0\n#endif\n                                      )\n            : first(__p.first), second(__p.second) {}\n\n#if !defined(_LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS) && _LIBCPP_TRIVIAL_PAIR_COPY_CTOR\n    _LIBCPP_INLINE_VISIBILITY\n    pair(const pair& __p) = default;\n#elif !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES) || !_LIBCPP_TRIVIAL_PAIR_COPY_CTOR\n    _LIBCPP_INLINE_VISIBILITY\n    pair(const pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<first_type>::value &&\n                   is_nothrow_copy_constructible<second_type>::value)\n        : first(__p.first),\n          second(__p.second)\n    {\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair& operator=(const pair& __p)\n        _NOEXCEPT_(is_nothrow_copy_assignable<first_type>::value &&\n                   is_nothrow_copy_assignable<second_type>::value)\n    {\n        first = __p.first;\n        second = __p.second;\n        return *this;\n    }\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _U1, class _U2,\n              class = typename enable_if<is_convertible<_U1, first_type>::value &&\n                                         is_convertible<_U2, second_type>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(_U1&& __u1, _U2&& __u2)\n            : first(_VSTD::forward<_U1>(__u1)),\n              second(_VSTD::forward<_U2>(__u2))\n            {}\n\n    template<class _U1, class _U2>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(pair<_U1, _U2>&& __p,\n                 typename enable_if<is_convertible<_U1, _T1>::value &&\n                                    is_convertible<_U2, _T2>::value>::type* = 0)\n            : first(_VSTD::forward<_U1>(__p.first)),\n              second(_VSTD::forward<_U2>(__p.second)) {}\n\n#ifndef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n    _LIBCPP_INLINE_VISIBILITY\n    pair(pair&& __p) = default;\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    pair(pair&& __p) _NOEXCEPT_(is_nothrow_move_constructible<first_type>::value &&\n                                is_nothrow_move_constructible<second_type>::value)\n        : first(_VSTD::forward<first_type>(__p.first)),\n          second(_VSTD::forward<second_type>(__p.second))\n    {\n    }\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    pair&\n    operator=(pair&& __p) _NOEXCEPT_(is_nothrow_move_assignable<first_type>::value &&\n                                     is_nothrow_move_assignable<second_type>::value)\n    {\n        first = _VSTD::forward<first_type>(__p.first);\n        second = _VSTD::forward<second_type>(__p.second);\n        return *this;\n    }\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template<class _Tuple,\n             class = typename enable_if<__tuple_convertible<_Tuple, pair>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n        pair(_Tuple&& __p)\n            : first(_VSTD::forward<typename tuple_element<0,\n                                  typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<0>(__p))),\n              second(_VSTD::forward<typename tuple_element<1,\n                                   typename __make_tuple_types<_Tuple>::type>::type>(_VSTD::get<1>(__p)))\n            {}\n\n\n\n    template <class... _Args1, class... _Args2>\n        _LIBCPP_INLINE_VISIBILITY\n        pair(piecewise_construct_t __pc, tuple<_Args1...> __first_args,\n                                    tuple<_Args2...> __second_args)\n            : pair(__pc, __first_args, __second_args,\n                   typename __make_tuple_indices<sizeof...(_Args1)>::type(),\n                   typename __make_tuple_indices<sizeof...(_Args2) >::type())\n            {}\n\n    template <class _Tuple,\n              class = typename enable_if<__tuple_assignable<_Tuple, pair>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        pair&\n        operator=(_Tuple&& __p)\n        {\n            typedef typename __make_tuple_types<_Tuple>::type _TupleRef;\n            typedef typename tuple_element<0, _TupleRef>::type _U0;\n            typedef typename tuple_element<1, _TupleRef>::type _U1;\n            first  = _VSTD::forward<_U0>(_VSTD::get<0>(__p));\n            second = _VSTD::forward<_U1>(_VSTD::get<1>(__p));\n            return *this;\n        }\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    swap(pair& __p) _NOEXCEPT_(__is_nothrow_swappable<first_type>::value &&\n                               __is_nothrow_swappable<second_type>::value)\n    {\n        _VSTD::iter_swap(&first, &__p.first);\n        _VSTD::iter_swap(&second, &__p.second);\n    }\nprivate:\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class... _Args1, class... _Args2, size_t... _I1, size_t... _I2>\n        _LIBCPP_INLINE_VISIBILITY\n        pair(piecewise_construct_t,\n             tuple<_Args1...>& __first_args, tuple<_Args2...>& __second_args,\n             __tuple_indices<_I1...>, __tuple_indices<_I2...>);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator==(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first == __y.first && __x.second == __y.second;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator!=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator< (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __x.first < __y.first || (!(__y.first < __x.first) && __x.second < __y.second);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator> (const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return __y < __x;\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator>=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__x < __y);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nbool\noperator<=(const pair<_T1,_T2>& __x, const pair<_T1,_T2>& __y)\n{\n    return !(__y < __x);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_swappable<_T1>::value &&\n    __is_swappable<_T2>::value,\n    void\n>::type\nswap(pair<_T1, _T2>& __x, pair<_T1, _T2>& __y)\n                     _NOEXCEPT_((__is_nothrow_swappable<_T1>::value &&\n                                 __is_nothrow_swappable<_T2>::value))\n{\n    __x.swap(__y);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp> class _LIBCPP_TYPE_VIS_ONLY reference_wrapper;\n\ntemplate <class _Tp>\nstruct __make_pair_return_impl\n{\n    typedef _Tp type;\n};\n\ntemplate <class _Tp>\nstruct __make_pair_return_impl<reference_wrapper<_Tp>>\n{\n    typedef _Tp& type;\n};\n\ntemplate <class _Tp>\nstruct __make_pair_return\n{\n    typedef typename __make_pair_return_impl<typename decay<_Tp>::type>::type type;\n};\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>\nmake_pair(_T1&& __t1, _T2&& __t2)\n{\n    return pair<typename __make_pair_return<_T1>::type, typename __make_pair_return<_T2>::type>\n               (_VSTD::forward<_T1>(__t1), _VSTD::forward<_T2>(__t2));\n}\n\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_T1,_T2>\nmake_pair(_T1 __x, _T2 __y)\n{\n    return pair<_T1, _T2>(__x, __y);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _T1, class _T2>\n  class _LIBCPP_TYPE_VIS_ONLY tuple_size<pair<_T1, _T2> >\n    : public integral_constant<size_t, 2> {};\n\ntemplate <class _T1, class _T2>\n  class _LIBCPP_TYPE_VIS_ONLY tuple_size<const pair<_T1, _T2> >\n    : public integral_constant<size_t, 2> {};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<0, pair<_T1, _T2> >\n{\npublic:\n    typedef _T1 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<1, pair<_T1, _T2> >\n{\npublic:\n    typedef _T2 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<0, const pair<_T1, _T2> >\n{\npublic:\n    typedef const _T1 type;\n};\n\ntemplate <class _T1, class _T2>\nclass _LIBCPP_TYPE_VIS_ONLY tuple_element<1, const pair<_T1, _T2> >\n{\npublic:\n    typedef const _T2 type;\n};\n\ntemplate <size_t _Ip> struct __get_pair;\n\ntemplate <>\nstruct __get_pair<0>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T1&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.first;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T1&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T1>(__p.first);}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <>\nstruct __get_pair<1>\n{\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&\n    get(pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    const _T2&\n    get(const pair<_T1, _T2>& __p) _NOEXCEPT {return __p.second;}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    template <class _T1, class _T2>\n    static\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    _T2&&\n    get(pair<_T1, _T2>&& __p) _NOEXCEPT {return _VSTD::forward<_T2>(__p.second);}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst typename tuple_element<_Ip, pair<_T1, _T2> >::type&\nget(const pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(__p);\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <size_t _Ip, class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\ntypename tuple_element<_Ip, pair<_T1, _T2> >::type&&\nget(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<_Ip>::get(_VSTD::move(__p));\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 & get(pair<_T1, _T2>& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const & get(pair<_T1, _T2> const& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 && get(pair<_T1, _T2>&& __p) _NOEXCEPT\n{\n    return __get_pair<0>::get(_VSTD::move(__p));\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 & get(pair<_T2, _T1>& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 const & get(pair<_T2, _T1> const& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(__p);\n}\n\ntemplate <class _T1, class _T2>\ninline _LIBCPP_INLINE_VISIBILITY\nconstexpr _T1 && get(pair<_T2, _T1>&& __p) _NOEXCEPT\n{\n    return __get_pair<1>::get(_VSTD::move(__p));\n}\n\n#endif\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate<class _Tp, _Tp... _Ip>\nstruct _LIBCPP_TYPE_VIS_ONLY integer_sequence\n{\n    typedef _Tp value_type;\n    static_assert( is_integral<_Tp>::value,\n                  \"std::integer_sequence can only be instantiated with an integral type\" );\n    static\n    _LIBCPP_INLINE_VISIBILITY\n    constexpr\n    size_t\n    size() noexcept { return sizeof...(_Ip); }\n};\n\ntemplate<size_t... _Ip>\n    using index_sequence = integer_sequence<size_t, _Ip...>;\n\nnamespace __detail {\n\ntemplate<typename _Tp, size_t ..._Extra> struct __repeat;\ntemplate<typename _Tp, _Tp ..._Np, size_t ..._Extra> struct __repeat<integer_sequence<_Tp, _Np...>, _Extra...> {\n  typedef integer_sequence<_Tp,\n                           _Np...,\n                           sizeof...(_Np) + _Np...,\n                           2 * sizeof...(_Np) + _Np...,\n                           3 * sizeof...(_Np) + _Np...,\n                           4 * sizeof...(_Np) + _Np...,\n                           5 * sizeof...(_Np) + _Np...,\n                           6 * sizeof...(_Np) + _Np...,\n                           7 * sizeof...(_Np) + _Np...,\n                           _Extra...> type;\n};\n\ntemplate<size_t _Np> struct __parity;\ntemplate<size_t _Np> struct __make : __parity<_Np % 8>::template __pmake<_Np> {};\n\ntemplate<> struct __make<0> { typedef integer_sequence<size_t> type; };\ntemplate<> struct __make<1> { typedef integer_sequence<size_t, 0> type; };\ntemplate<> struct __make<2> { typedef integer_sequence<size_t, 0, 1> type; };\ntemplate<> struct __make<3> { typedef integer_sequence<size_t, 0, 1, 2> type; };\ntemplate<> struct __make<4> { typedef integer_sequence<size_t, 0, 1, 2, 3> type; };\ntemplate<> struct __make<5> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4> type; };\ntemplate<> struct __make<6> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4, 5> type; };\ntemplate<> struct __make<7> { typedef integer_sequence<size_t, 0, 1, 2, 3, 4, 5, 6> type; };\n\ntemplate<> struct __parity<0> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type> {}; };\ntemplate<> struct __parity<1> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 1> {}; };\ntemplate<> struct __parity<2> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<3> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<4> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<5> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<6> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 6, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\ntemplate<> struct __parity<7> { template<size_t _Np> struct __pmake : __repeat<typename __make<_Np / 8>::type, _Np - 7, _Np - 6, _Np - 5, _Np - 4, _Np - 3, _Np - 2, _Np - 1> {}; };\n\ntemplate<typename _Tp, typename _Up> struct __convert {\n  template<typename> struct __result;\n  template<_Tp ..._Np> struct __result<integer_sequence<_Tp, _Np...> > { typedef integer_sequence<_Up, _Np...> type; };\n};\ntemplate<typename _Tp> struct __convert<_Tp, _Tp> { template<typename _Up> struct __result { typedef _Up type; }; };\n\n}\n\ntemplate<typename _Tp, _Tp _Np> using __make_integer_sequence_unchecked =\n  typename __detail::__convert<size_t, _Tp>::template __result<typename __detail::__make<_Np>::type>::type;\n\ntemplate <class _Tp, _Tp _Ep>\nstruct __make_integer_sequence\n{\n    static_assert(is_integral<_Tp>::value,\n                  \"std::make_integer_sequence can only be instantiated with an integral type\" );\n    static_assert(0 <= _Ep, \"std::make_integer_sequence input shall not be negative\");\n    typedef __make_integer_sequence_unchecked<_Tp, _Ep> type;\n};\n\ntemplate<class _Tp, _Tp _Np>\n    using make_integer_sequence = typename __make_integer_sequence<_Tp, _Np>::type;\n\ntemplate<size_t _Np>\n    using make_index_sequence = make_integer_sequence<size_t, _Np>;\n\ntemplate<class... _Tp>\n    using index_sequence_for = make_index_sequence<sizeof...(_Tp)>;\n  \n#endif  // _LIBCPP_STD_VER > 11\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _T1, class _T2 = _T1>\ninline _LIBCPP_INLINE_VISIBILITY\n_T1 exchange(_T1& __obj, _T2 && __new_value)\n{\n    _T1 __old_value = _VSTD::move(__obj);\n    __obj = _VSTD::forward<_T2>(__new_value);\n    return __old_value;\n}    \n#endif  // _LIBCPP_STD_VER > 11\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_UTILITY\n","// -*- C++ -*-\n//===---------------------------- ios -------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_IOS\n#define _LIBCPP_IOS\n\n/*\n    ios synopsis\n\n#include <iosfwd>\n\nnamespace std\n{\n\ntypedef OFF_T streamoff;\ntypedef SZ_T streamsize;\ntemplate <class stateT> class fpos;\n\nclass ios_base\n{\npublic:\n    class failure;\n\n    typedef T1 fmtflags;\n    static constexpr fmtflags boolalpha;\n    static constexpr fmtflags dec;\n    static constexpr fmtflags fixed;\n    static constexpr fmtflags hex;\n    static constexpr fmtflags internal;\n    static constexpr fmtflags left;\n    static constexpr fmtflags oct;\n    static constexpr fmtflags right;\n    static constexpr fmtflags scientific;\n    static constexpr fmtflags showbase;\n    static constexpr fmtflags showpoint;\n    static constexpr fmtflags showpos;\n    static constexpr fmtflags skipws;\n    static constexpr fmtflags unitbuf;\n    static constexpr fmtflags uppercase;\n    static constexpr fmtflags adjustfield;\n    static constexpr fmtflags basefield;\n    static constexpr fmtflags floatfield;\n\n    typedef T2 iostate;\n    static constexpr iostate badbit;\n    static constexpr iostate eofbit;\n    static constexpr iostate failbit;\n    static constexpr iostate goodbit;\n\n    typedef T3 openmode;\n    static constexpr openmode app;\n    static constexpr openmode ate;\n    static constexpr openmode binary;\n    static constexpr openmode in;\n    static constexpr openmode out;\n    static constexpr openmode trunc;\n\n    typedef T4 seekdir;\n    static constexpr seekdir beg;\n    static constexpr seekdir cur;\n    static constexpr seekdir end;\n\n    class Init;\n\n    // 27.5.2.2 fmtflags state:\n    fmtflags flags() const;\n    fmtflags flags(fmtflags fmtfl);\n    fmtflags setf(fmtflags fmtfl);\n    fmtflags setf(fmtflags fmtfl, fmtflags mask);\n    void unsetf(fmtflags mask);\n\n    streamsize precision() const;\n    streamsize precision(streamsize prec);\n    streamsize width() const;\n    streamsize width(streamsize wide);\n\n    // 27.5.2.3 locales:\n    locale imbue(const locale& loc);\n    locale getloc() const;\n\n    // 27.5.2.5 storage:\n    static int xalloc();\n    long& iword(int index);\n    void*& pword(int index);\n\n    // destructor\n    virtual ~ios_base();\n\n    // 27.5.2.6 callbacks;\n    enum event { erase_event, imbue_event, copyfmt_event };\n    typedef void (*event_callback)(event, ios_base&, int index);\n    void register_callback(event_callback fn, int index);\n\n    ios_base(const ios_base&) = delete;\n    ios_base& operator=(const ios_base&) = delete;\n\n    static bool sync_with_stdio(bool sync = true);\n\nprotected:\n    ios_base();\n};\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_ios\n    : public ios_base\n{\npublic:\n    // types:\n    typedef charT char_type;\n    typedef typename traits::int_type int_type;\n    typedef typename traits::pos_type pos_type;\n    typedef typename traits::off_type off_type;\n    typedef traits traits_type;\n\n    operator unspecified-bool-type() const;\n    bool operator!() const;\n    iostate rdstate() const;\n    void clear(iostate state = goodbit);\n    void setstate(iostate state);\n    bool good() const;\n    bool eof() const;\n    bool fail() const;\n    bool bad() const;\n\n    iostate exceptions() const;\n    void exceptions(iostate except);\n\n    // 27.5.4.1 Constructor/destructor:\n    explicit basic_ios(basic_streambuf<charT,traits>* sb);\n    virtual ~basic_ios();\n\n    // 27.5.4.2 Members:\n    basic_ostream<charT,traits>* tie() const;\n    basic_ostream<charT,traits>* tie(basic_ostream<charT,traits>* tiestr);\n\n    basic_streambuf<charT,traits>* rdbuf() const;\n    basic_streambuf<charT,traits>* rdbuf(basic_streambuf<charT,traits>* sb);\n\n    basic_ios& copyfmt(const basic_ios& rhs);\n\n    char_type fill() const;\n    char_type fill(char_type ch);\n\n    locale imbue(const locale& loc);\n\n    char narrow(char_type c, char dfault) const;\n    char_type widen(char c) const;\n\n    basic_ios(const basic_ios& ) = delete;\n    basic_ios& operator=(const basic_ios&) = delete;\n\nprotected:\n    basic_ios();\n    void init(basic_streambuf<charT,traits>* sb);\n    void move(basic_ios& rhs);\n    void swap(basic_ios& rhs) noexcept;\n    void set_rdbuf(basic_streambuf<charT, traits>* sb);\n};\n\n// 27.5.5, manipulators:\nios_base& boolalpha (ios_base& str);\nios_base& noboolalpha(ios_base& str);\nios_base& showbase (ios_base& str);\nios_base& noshowbase (ios_base& str);\nios_base& showpoint (ios_base& str);\nios_base& noshowpoint(ios_base& str);\nios_base& showpos (ios_base& str);\nios_base& noshowpos (ios_base& str);\nios_base& skipws (ios_base& str);\nios_base& noskipws (ios_base& str);\nios_base& uppercase (ios_base& str);\nios_base& nouppercase(ios_base& str);\nios_base& unitbuf (ios_base& str);\nios_base& nounitbuf (ios_base& str);\n\n// 27.5.5.2 adjustfield:\nios_base& internal (ios_base& str);\nios_base& left (ios_base& str);\nios_base& right (ios_base& str);\n\n// 27.5.5.3 basefield:\nios_base& dec (ios_base& str);\nios_base& hex (ios_base& str);\nios_base& oct (ios_base& str);\n\n// 27.5.5.4 floatfield:\nios_base& fixed (ios_base& str);\nios_base& scientific (ios_base& str);\nios_base& hexfloat (ios_base& str);\nios_base& defaultfloat(ios_base& str);\n\n// 27.5.5.5 error reporting:\nenum class io_errc\n{\n    stream = 1\n};\n\nconcept_map ErrorCodeEnum<io_errc> { };\nerror_code make_error_code(io_errc e) noexcept; \nerror_condition make_error_condition(io_errc e) noexcept; \nstorage-class-specifier const error_category& iostream_category() noexcept;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <__locale>\n#include <system_error>\n\n#if __has_feature(cxx_atomic) && !defined(_LIBCPP_HAS_NO_THREADS)\n#include <atomic>     // for __xindex_\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntypedef ptrdiff_t streamsize;\n\nclass _LIBCPP_TYPE_VIS ios_base\n{\npublic:\n    class _LIBCPP_TYPE_VIS failure;\n\n    typedef unsigned int fmtflags;\n    static const fmtflags boolalpha   = 0x0001;\n    static const fmtflags dec         = 0x0002;\n    static const fmtflags fixed       = 0x0004;\n    static const fmtflags hex         = 0x0008;\n    static const fmtflags internal    = 0x0010;\n    static const fmtflags left        = 0x0020;\n    static const fmtflags oct         = 0x0040;\n    static const fmtflags right       = 0x0080;\n    static const fmtflags scientific  = 0x0100;\n    static const fmtflags showbase    = 0x0200;\n    static const fmtflags showpoint   = 0x0400;\n    static const fmtflags showpos     = 0x0800;\n    static const fmtflags skipws      = 0x1000;\n    static const fmtflags unitbuf     = 0x2000;\n    static const fmtflags uppercase   = 0x4000;\n    static const fmtflags adjustfield = left | right | internal;\n    static const fmtflags basefield   = dec | oct | hex;\n    static const fmtflags floatfield  = scientific | fixed;\n\n    typedef unsigned int iostate;\n    typedef iostate      io_state;\n    static const iostate badbit  = 0x1;\n    static const iostate eofbit  = 0x2;\n    static const iostate failbit = 0x4;\n    static const iostate goodbit = 0x0;\n\n    typedef unsigned int openmode;\n    typedef openmode     open_mode;\n    static const openmode app    = 0x01;\n    static const openmode ate    = 0x02;\n    static const openmode binary = 0x04;\n    static const openmode in     = 0x08;\n    static const openmode out    = 0x10;\n    static const openmode trunc  = 0x20;\n\n    enum seekdir {beg, cur, end};\n    typedef seekdir seek_dir;\n\n    typedef _VSTD::streamoff streamoff;\n    typedef _VSTD::streampos streampos;\n\n    class _LIBCPP_TYPE_VIS Init;\n\n    // 27.5.2.2 fmtflags state:\n    _LIBCPP_INLINE_VISIBILITY fmtflags flags() const;\n    _LIBCPP_INLINE_VISIBILITY fmtflags flags(fmtflags __fmtfl);\n    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl);\n    _LIBCPP_INLINE_VISIBILITY fmtflags setf(fmtflags __fmtfl, fmtflags __mask);\n    _LIBCPP_INLINE_VISIBILITY void unsetf(fmtflags __mask);\n\n    _LIBCPP_INLINE_VISIBILITY streamsize precision() const;\n    _LIBCPP_INLINE_VISIBILITY streamsize precision(streamsize __prec);\n    _LIBCPP_INLINE_VISIBILITY streamsize width() const;\n    _LIBCPP_INLINE_VISIBILITY streamsize width(streamsize __wide);\n\n    // 27.5.2.3 locales:\n    locale imbue(const locale& __loc);\n    locale getloc() const;\n\n    // 27.5.2.5 storage:\n    static int xalloc();\n    long& iword(int __index);\n    void*& pword(int __index);\n\n    // destructor\n    virtual ~ios_base();\n\n    // 27.5.2.6 callbacks;\n    enum event { erase_event, imbue_event, copyfmt_event };\n    typedef void (*event_callback)(event, ios_base&, int __index);\n    void register_callback(event_callback __fn, int __index);\n\nprivate:\n    ios_base(const ios_base&); // = delete;\n    ios_base& operator=(const ios_base&); // = delete;\n\npublic:\n    static bool sync_with_stdio(bool __sync = true);\n\n    _LIBCPP_INLINE_VISIBILITY iostate rdstate() const;\n    void clear(iostate __state = goodbit);\n    _LIBCPP_INLINE_VISIBILITY void setstate(iostate __state);\n\n    _LIBCPP_INLINE_VISIBILITY bool good() const;\n    _LIBCPP_INLINE_VISIBILITY bool eof() const;\n    _LIBCPP_INLINE_VISIBILITY bool fail() const;\n    _LIBCPP_INLINE_VISIBILITY bool bad() const;\n\n    _LIBCPP_INLINE_VISIBILITY iostate exceptions() const;\n    _LIBCPP_INLINE_VISIBILITY void exceptions(iostate __iostate);\n\n    void __set_badbit_and_consider_rethrow();\n    void __set_failbit_and_consider_rethrow();\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ios_base() {// purposefully does no initialization\n               }\n\n    void init(void* __sb);\n    _LIBCPP_ALWAYS_INLINE void* rdbuf() const {return __rdbuf_;}\n\n    _LIBCPP_ALWAYS_INLINE\n    void rdbuf(void* __sb)\n    {\n        __rdbuf_ = __sb;\n        clear();\n    }\n\n    void __call_callbacks(event);\n    void copyfmt(const ios_base&);\n    void move(ios_base&);\n    void swap(ios_base&) _NOEXCEPT;\n\n    _LIBCPP_ALWAYS_INLINE\n    void set_rdbuf(void* __sb)\n    {\n        __rdbuf_ = __sb;\n    }\n\nprivate:\n    // All data members must be scalars\n    fmtflags        __fmtflags_;\n    streamsize      __precision_;\n    streamsize      __width_;\n    iostate         __rdstate_;\n    iostate         __exceptions_;\n    void*           __rdbuf_;\n    void*           __loc_;\n    event_callback* __fn_;\n    int*            __index_;\n    size_t          __event_size_;\n    size_t          __event_cap_;\n#if __has_feature(cxx_atomic) && !defined(_LIBCPP_HAS_NO_THREADS)\n    static atomic<int> __xindex_;\n#else\n    static int      __xindex_;\n#endif\n    long*           __iarray_;\n    size_t          __iarray_size_;\n    size_t          __iarray_cap_;\n    void**          __parray_;\n    size_t          __parray_size_;\n    size_t          __parray_cap_;\n};\n\n//enum class io_errc\n_LIBCPP_DECLARE_STRONG_ENUM(io_errc)\n{\n    stream = 1\n};\n_LIBCPP_DECLARE_STRONG_ENUM_EPILOG(io_errc)\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY is_error_code_enum<io_errc> : public true_type { };\n\n#ifdef _LIBCPP_HAS_NO_STRONG_ENUMS\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY is_error_code_enum<io_errc::__lx> : public true_type { };\n#endif\n\n_LIBCPP_FUNC_VIS\nconst error_category& iostream_category() _NOEXCEPT;\n\ninline _LIBCPP_INLINE_VISIBILITY\nerror_code\nmake_error_code(io_errc __e) _NOEXCEPT\n{\n    return error_code(static_cast<int>(__e), iostream_category());\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nerror_condition\nmake_error_condition(io_errc __e) _NOEXCEPT\n{\n    return error_condition(static_cast<int>(__e), iostream_category());\n}\n\nclass _LIBCPP_EXCEPTION_ABI ios_base::failure\n    : public system_error\n{\npublic:\n    explicit failure(const string& __msg, const error_code& __ec = io_errc::stream);\n    explicit failure(const char* __msg, const error_code& __ec = io_errc::stream);\n    virtual ~failure() throw();\n};\n\nclass _LIBCPP_TYPE_VIS ios_base::Init\n{\npublic:\n    Init();\n    ~Init();\n};\n\n// fmtflags\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::flags() const\n{\n    return __fmtflags_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::flags(fmtflags __fmtfl)\n{\n    fmtflags __r = __fmtflags_;\n    __fmtflags_ = __fmtfl;\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::setf(fmtflags __fmtfl)\n{\n    fmtflags __r = __fmtflags_;\n    __fmtflags_ |= __fmtfl;\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::unsetf(fmtflags __mask)\n{\n    __fmtflags_ &= ~__mask;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::fmtflags\nios_base::setf(fmtflags __fmtfl, fmtflags __mask)\n{\n    fmtflags __r = __fmtflags_;\n    unsetf(__mask);\n    __fmtflags_ |= __fmtfl & __mask;\n    return __r;\n}\n\n// precision\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::precision() const\n{\n    return __precision_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::precision(streamsize __prec)\n{\n    streamsize __r = __precision_;\n    __precision_ = __prec;\n    return __r;\n}\n\n// width\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::width() const\n{\n    return __width_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nios_base::width(streamsize __wide)\n{\n    streamsize __r = __width_;\n    __width_ = __wide;\n    return __r;\n}\n\n// iostate\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::iostate\nios_base::rdstate() const\n{\n    return __rdstate_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::setstate(iostate __state)\n{\n    clear(__rdstate_ | __state);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::good() const\n{\n    return __rdstate_ == 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::eof() const\n{\n    return (__rdstate_ & eofbit) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::fail() const\n{\n    return (__rdstate_ & (failbit | badbit)) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nios_base::bad() const\n{\n    return (__rdstate_ & badbit) != 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base::iostate\nios_base::exceptions() const\n{\n    return __exceptions_;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nios_base::exceptions(iostate __iostate)\n{\n    __exceptions_ = __iostate;\n    clear(__rdstate_);\n}\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_ios\n    : public ios_base\n{\npublic:\n    // types:\n    typedef _CharT char_type;\n    typedef _Traits traits_type;\n\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    _LIBCPP_ALWAYS_INLINE\n        _LIBCPP_EXPLICIT\n        operator bool() const {return !fail();}\n    _LIBCPP_ALWAYS_INLINE bool operator!() const    {return  fail();}\n    _LIBCPP_ALWAYS_INLINE iostate rdstate() const   {return ios_base::rdstate();}\n    _LIBCPP_ALWAYS_INLINE void clear(iostate __state = goodbit) {ios_base::clear(__state);}\n    _LIBCPP_ALWAYS_INLINE void setstate(iostate __state) {ios_base::setstate(__state);}\n    _LIBCPP_ALWAYS_INLINE bool good() const {return ios_base::good();}\n    _LIBCPP_ALWAYS_INLINE bool eof() const  {return ios_base::eof();}\n    _LIBCPP_ALWAYS_INLINE bool fail() const {return ios_base::fail();}\n    _LIBCPP_ALWAYS_INLINE bool bad() const  {return ios_base::bad();}\n\n    _LIBCPP_ALWAYS_INLINE iostate exceptions() const {return ios_base::exceptions();}\n    _LIBCPP_ALWAYS_INLINE void exceptions(iostate __iostate) {ios_base::exceptions(__iostate);}\n\n    // 27.5.4.1 Constructor/destructor:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit basic_ios(basic_streambuf<char_type,traits_type>* __sb);\n    virtual ~basic_ios();\n\n    // 27.5.4.2 Members:\n    _LIBCPP_INLINE_VISIBILITY \n    basic_ostream<char_type, traits_type>* tie() const;\n    _LIBCPP_INLINE_VISIBILITY \n    basic_ostream<char_type, traits_type>* tie(basic_ostream<char_type, traits_type>* __tiestr);\n\n    _LIBCPP_INLINE_VISIBILITY \n    basic_streambuf<char_type, traits_type>* rdbuf() const;\n    _LIBCPP_INLINE_VISIBILITY \n    basic_streambuf<char_type, traits_type>* rdbuf(basic_streambuf<char_type, traits_type>* __sb);\n\n    basic_ios& copyfmt(const basic_ios& __rhs);\n\n    _LIBCPP_INLINE_VISIBILITY \n    char_type fill() const;\n    _LIBCPP_INLINE_VISIBILITY \n    char_type fill(char_type __ch);\n\n    _LIBCPP_INLINE_VISIBILITY \n    locale imbue(const locale& __loc);\n\n    _LIBCPP_INLINE_VISIBILITY \n    char narrow(char_type __c, char __dfault) const;\n    _LIBCPP_INLINE_VISIBILITY \n    char_type widen(char __c) const;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    basic_ios() {// purposefully does no initialization\n                }\n    _LIBCPP_INLINE_VISIBILITY \n    void init(basic_streambuf<char_type, traits_type>* __sb);\n\n    _LIBCPP_INLINE_VISIBILITY \n    void move(basic_ios& __rhs);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_ALWAYS_INLINE\n    void move(basic_ios&& __rhs) {move(__rhs);}\n#endif\n    _LIBCPP_INLINE_VISIBILITY \n    void swap(basic_ios& __rhs) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY \n    void set_rdbuf(basic_streambuf<char_type, traits_type>* __sb);\nprivate:\n    basic_ostream<char_type, traits_type>* __tie_;\n     mutable int_type __fill_;\n};\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ios<_CharT, _Traits>::basic_ios(basic_streambuf<char_type,traits_type>* __sb)\n{\n    init(__sb);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ios<_CharT, _Traits>::~basic_ios()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::init(basic_streambuf<char_type, traits_type>* __sb)\n{\n    ios_base::init(__sb);\n    __tie_ = 0;\n    __fill_ = traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::tie() const\n{\n    return __tie_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::tie(basic_ostream<char_type, traits_type>* __tiestr)\n{\n    basic_ostream<char_type, traits_type>* __r = __tie_;\n    __tie_ = __tiestr;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::rdbuf() const\n{\n    return static_cast<basic_streambuf<char_type, traits_type>*>(ios_base::rdbuf());\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_ios<_CharT, _Traits>::rdbuf(basic_streambuf<char_type, traits_type>* __sb)\n{\n    basic_streambuf<char_type, traits_type>* __r = rdbuf();\n    ios_base::rdbuf(__sb);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale\nbasic_ios<_CharT, _Traits>::imbue(const locale& __loc)\n{\n    locale __r = getloc();\n    ios_base::imbue(__loc);\n    if (rdbuf())\n        rdbuf()->pubimbue(__loc);\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nchar\nbasic_ios<_CharT, _Traits>::narrow(char_type __c, char __dfault) const\n{\n    return use_facet<ctype<char_type> >(getloc()).narrow(__c, __dfault);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::widen(char __c) const\n{\n    return use_facet<ctype<char_type> >(getloc()).widen(__c);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::fill() const\n{\n    if (traits_type::eq_int_type(traits_type::eof(), __fill_))\n        __fill_ = widen(' ');\n    return __fill_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\nbasic_ios<_CharT, _Traits>::fill(char_type __ch)\n{\n    char_type __r = __fill_;\n    __fill_ = __ch;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_ios<_CharT, _Traits>&\nbasic_ios<_CharT, _Traits>::copyfmt(const basic_ios& __rhs)\n{\n    if (this != &__rhs)\n    {\n        __call_callbacks(erase_event);\n        ios_base::copyfmt(__rhs);\n        __tie_ = __rhs.__tie_;\n        __fill_ = __rhs.__fill_;\n        __call_callbacks(copyfmt_event);\n        exceptions(__rhs.exceptions());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::move(basic_ios& __rhs)\n{\n    ios_base::move(__rhs);\n    __tie_ = __rhs.__tie_;\n    __rhs.__tie_ = 0;\n    __fill_ = __rhs.__fill_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::swap(basic_ios& __rhs) _NOEXCEPT\n{\n    ios_base::swap(__rhs);\n    _VSTD::swap(__tie_, __rhs.__tie_);\n    _VSTD::swap(__fill_, __rhs.__fill_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_ios<_CharT, _Traits>::set_rdbuf(basic_streambuf<char_type, traits_type>* __sb)\n{\n    ios_base::set_rdbuf(__sb);\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nboolalpha(ios_base& __str)\n{\n    __str.setf(ios_base::boolalpha);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoboolalpha(ios_base& __str)\n{\n    __str.unsetf(ios_base::boolalpha);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowbase(ios_base& __str)\n{\n    __str.setf(ios_base::showbase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowbase(ios_base& __str)\n{\n    __str.unsetf(ios_base::showbase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowpoint(ios_base& __str)\n{\n    __str.setf(ios_base::showpoint);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowpoint(ios_base& __str)\n{\n    __str.unsetf(ios_base::showpoint);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nshowpos(ios_base& __str)\n{\n    __str.setf(ios_base::showpos);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoshowpos(ios_base& __str)\n{\n    __str.unsetf(ios_base::showpos);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nskipws(ios_base& __str)\n{\n    __str.setf(ios_base::skipws);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnoskipws(ios_base& __str)\n{\n    __str.unsetf(ios_base::skipws);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nuppercase(ios_base& __str)\n{\n    __str.setf(ios_base::uppercase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnouppercase(ios_base& __str)\n{\n    __str.unsetf(ios_base::uppercase);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nunitbuf(ios_base& __str)\n{\n    __str.setf(ios_base::unitbuf);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nnounitbuf(ios_base& __str)\n{\n    __str.unsetf(ios_base::unitbuf);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ninternal(ios_base& __str)\n{\n    __str.setf(ios_base::internal, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nleft(ios_base& __str)\n{\n    __str.setf(ios_base::left, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nright(ios_base& __str)\n{\n    __str.setf(ios_base::right, ios_base::adjustfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ndec(ios_base& __str)\n{\n    __str.setf(ios_base::dec, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nhex(ios_base& __str)\n{\n    __str.setf(ios_base::hex, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\noct(ios_base& __str)\n{\n    __str.setf(ios_base::oct, ios_base::basefield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nfixed(ios_base& __str)\n{\n    __str.setf(ios_base::fixed, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nscientific(ios_base& __str)\n{\n    __str.setf(ios_base::scientific, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\nhexfloat(ios_base& __str)\n{\n    __str.setf(ios_base::fixed | ios_base::scientific, ios_base::floatfield);\n    return __str;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nios_base&\ndefaultfloat(ios_base& __str)\n{\n    __str.unsetf(ios_base::floatfield);\n    return __str;\n}\n\ntemplate <class _CharT, class _Traits>\nclass __save_flags\n{\n    typedef basic_ios<_CharT, _Traits> __stream_type;\n    typedef typename __stream_type::fmtflags fmtflags;\n\n    __stream_type& __stream_;\n    fmtflags       __fmtflags_;\n    _CharT         __fill_;\n\n    __save_flags(const __save_flags&);\n    __save_flags& operator=(const __save_flags&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __save_flags(__stream_type& __stream)\n        : __stream_(__stream),\n          __fmtflags_(__stream.flags()),\n          __fill_(__stream.fill())\n        {}\n    _LIBCPP_INLINE_VISIBILITY\n    ~__save_flags()\n    {\n        __stream_.flags(__fmtflags_);\n        __stream_.fill(__fill_);\n    }\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_IOS\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP___LOCALE\n#define _LIBCPP___LOCALE\n\n#include <__config>\n#include <string>\n#include <memory>\n#include <utility>\n#include <mutex>\n#include <cstdint>\n#include <cctype>\n#include <locale.h>\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n# include <support/win32/locale_win32.h>\n#elif defined(_AIX)\n# include <support/ibm/xlocale.h>\n#elif defined(__ANDROID__)\n// Android gained the locale aware functions in L (API level 21)\n# include <android/api-level.h>\n# if __ANDROID_API__ <= 20\n#  include <support/android/locale_bionic.h>\n# endif\n#elif (defined(__GLIBC__) || defined(__APPLE__)      || defined(__FreeBSD__) \\\n    || defined(__sun__)   || defined(__EMSCRIPTEN__) || defined(__IBMCPP__))\n# include <xlocale.h>\n#endif // __GLIBC__ || __APPLE__ || __FreeBSD__ || __sun__ || __EMSCRIPTEN__ || __IBMCPP__\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nclass _LIBCPP_TYPE_VIS locale;\n\ntemplate <class _Facet>\n_LIBCPP_INLINE_VISIBILITY\nbool\nhas_facet(const locale&) _NOEXCEPT;\n\ntemplate <class _Facet>\n_LIBCPP_INLINE_VISIBILITY\nconst _Facet&\nuse_facet(const locale&);\n\nclass _LIBCPP_TYPE_VIS locale\n{\npublic:\n    // types:\n    class _LIBCPP_TYPE_VIS facet;\n    class _LIBCPP_TYPE_VIS id;\n\n    typedef int category;\n    static const category // values assigned here are for exposition only\n        none     = 0,\n        collate  = LC_COLLATE_MASK,\n        ctype    = LC_CTYPE_MASK,\n        monetary = LC_MONETARY_MASK,\n        numeric  = LC_NUMERIC_MASK,\n        time     = LC_TIME_MASK,\n        messages = LC_MESSAGES_MASK,\n        all = collate | ctype | monetary | numeric | time | messages;\n\n    // construct/copy/destroy:\n    locale()  _NOEXCEPT;\n    locale(const locale&)  _NOEXCEPT;\n    explicit locale(const char*);\n    explicit locale(const string&);\n    locale(const locale&, const char*, category);\n    locale(const locale&, const string&, category);\n    template <class _Facet>\n        _LIBCPP_INLINE_VISIBILITY locale(const locale&, _Facet*);\n    locale(const locale&, const locale&, category);\n\n    ~locale();\n\n    const locale& operator=(const locale&)  _NOEXCEPT;\n\n    template <class _Facet> locale combine(const locale&) const;\n\n    // locale operations:\n    string name() const;\n    bool operator==(const locale&) const;\n    bool operator!=(const locale& __y) const {return !(*this == __y);}\n    template <class _CharT, class _Traits, class _Allocator>\n      bool operator()(const basic_string<_CharT, _Traits, _Allocator>&,\n                      const basic_string<_CharT, _Traits, _Allocator>&) const;\n\n    // global locale objects:\n    static locale global(const locale&);\n    static const locale& classic();\n\nprivate:\n    class __imp;\n    __imp* __locale_;\n\n    void __install_ctor(const locale&, facet*, long);\n    static locale& __global();\n    bool has_facet(id&) const;\n    const facet* use_facet(id&) const;\n\n    template <class _Facet> friend bool has_facet(const locale&)  _NOEXCEPT;\n    template <class _Facet> friend const _Facet& use_facet(const locale&);\n};\n\nclass _LIBCPP_TYPE_VIS locale::facet\n    : public __shared_count\n{\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit facet(size_t __refs = 0)\n        : __shared_count(static_cast<long>(__refs)-1) {}\n\n    virtual ~facet();\n\n//    facet(const facet&) = delete;     // effectively done in __shared_count\n//    void operator=(const facet&) = delete;\nprivate:\n    virtual void __on_zero_shared() _NOEXCEPT;\n};\n\nclass _LIBCPP_TYPE_VIS locale::id\n{\n    once_flag      __flag_;\n    int32_t        __id_;\n\n    static int32_t __next_id;\npublic:\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR id() :__id_(0) {}\nprivate:\n    void __init();\n    void operator=(const id&); // = delete;\n    id(const id&); // = delete;\npublic:  // only needed for tests\n    long __get();\n\n    friend class locale;\n    friend class locale::__imp;\n};\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale::locale(const locale& __other, _Facet* __f)\n{\n    __install_ctor(__other, __f, __f ? __f->id.__get() : 0);\n}\n\ntemplate <class _Facet>\nlocale\nlocale::combine(const locale& __other) const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (!_VSTD::has_facet<_Facet>(__other))\n        throw runtime_error(\"locale::combine: locale missing facet\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return locale(*this, &const_cast<_Facet&>(_VSTD::use_facet<_Facet>(__other)));\n}\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nhas_facet(const locale& __l)  _NOEXCEPT\n{\n    return __l.has_facet(_Facet::id);\n}\n\ntemplate <class _Facet>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _Facet&\nuse_facet(const locale& __l)\n{\n    return static_cast<const _Facet&>(*__l.use_facet(_Facet::id));\n}\n\n// template <class _CharT> class collate;\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS_ONLY collate\n    : public locale::facet\n{\npublic:\n    typedef _CharT char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit collate(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const char_type* __lo1, const char_type* __hi1,\n                const char_type* __lo2, const char_type* __hi2) const\n    {\n        return do_compare(__lo1, __hi1, __lo2, __hi2);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    string_type transform(const char_type* __lo, const char_type* __hi) const\n    {\n        return do_transform(__lo, __hi);\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    long hash(const char_type* __lo, const char_type* __hi) const\n    {\n        return do_hash(__lo, __hi);\n    }\n\n    static locale::id id;\n\nprotected:\n    ~collate();\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const\n        {return string_type(__lo, __hi);}\n    virtual long do_hash(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <class _CharT> locale::id collate<_CharT>::id;\n\ntemplate <class _CharT>\ncollate<_CharT>::~collate()\n{\n}\n\ntemplate <class _CharT>\nint\ncollate<_CharT>::do_compare(const char_type* __lo1, const char_type* __hi1,\n                            const char_type* __lo2, const char_type* __hi2) const\n{\n    for (; __lo2 != __hi2; ++__lo1, ++__lo2)\n    {\n        if (__lo1 == __hi1 || *__lo1 < *__lo2)\n            return -1;\n        if (*__lo2 < *__lo1)\n            return 1;\n    }\n    return __lo1 != __hi1;\n}\n\ntemplate <class _CharT>\nlong\ncollate<_CharT>::do_hash(const char_type* __lo, const char_type* __hi) const\n{\n    size_t __h = 0;\n    const size_t __sr = __CHAR_BIT__ * sizeof(size_t) - 8;\n    const size_t __mask = size_t(0xF) << (__sr + 4);\n    for(const char_type* __p = __lo; __p != __hi; ++__p)\n    {\n        __h = (__h << 4) + static_cast<size_t>(*__p);\n        size_t __g = __h & __mask;\n        __h ^= __g | (__g >> __sr);\n    }\n    return static_cast<long>(__h);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS collate<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS collate<wchar_t>)\n\n// template <class CharT> class collate_byname;\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS_ONLY collate_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS collate_byname<char>\n    : public collate<char>\n{\n    locale_t __l;\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit collate_byname(const char* __n, size_t __refs = 0);\n    explicit collate_byname(const string& __n, size_t __refs = 0);\n\nprotected:\n    ~collate_byname();\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS collate_byname<wchar_t>\n    : public collate<wchar_t>\n{\n    locale_t __l;\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit collate_byname(const char* __n, size_t __refs = 0);\n    explicit collate_byname(const string& __n, size_t __refs = 0);\n\nprotected:\n    ~collate_byname();\n\n    virtual int do_compare(const char_type* __lo1, const char_type* __hi1,\n                           const char_type* __lo2, const char_type* __hi2) const;\n    virtual string_type do_transform(const char_type* __lo, const char_type* __hi) const;\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbool\nlocale::operator()(const basic_string<_CharT, _Traits, _Allocator>& __x,\n                   const basic_string<_CharT, _Traits, _Allocator>& __y) const\n{\n    return _VSTD::use_facet<_VSTD::collate<_CharT> >(*this).compare(\n                                       __x.data(), __x.data() + __x.size(),\n                                       __y.data(), __y.data() + __y.size()) < 0;\n}\n\n// template <class charT> class ctype\n\nclass _LIBCPP_TYPE_VIS ctype_base\n{\npublic:\n#ifdef __GLIBC__\n    typedef unsigned short mask;\n    static const mask space  = _ISspace;\n    static const mask print  = _ISprint;\n    static const mask cntrl  = _IScntrl;\n    static const mask upper  = _ISupper;\n    static const mask lower  = _ISlower;\n    static const mask alpha  = _ISalpha;\n    static const mask digit  = _ISdigit;\n    static const mask punct  = _ISpunct;\n    static const mask xdigit = _ISxdigit;\n    static const mask blank  = _ISblank;\n#elif defined(_WIN32)\n    typedef unsigned short mask;\n    static const mask space  = _SPACE;\n    static const mask print  = _BLANK|_PUNCT|_ALPHA|_DIGIT;\n    static const mask cntrl  = _CONTROL;\n    static const mask upper  = _UPPER;\n    static const mask lower  = _LOWER;\n    static const mask alpha  = _ALPHA;\n    static const mask digit  = _DIGIT;\n    static const mask punct  = _PUNCT;\n    static const mask xdigit = _HEX;\n    static const mask blank  = _BLANK;\n#elif defined(__APPLE__) || defined(__FreeBSD__) || defined(__EMSCRIPTEN__) || defined(__NetBSD__) || defined(__ANDROID__)\n#ifdef __APPLE__\n    typedef __uint32_t mask;\n#elif defined(__FreeBSD__)\n    typedef unsigned long mask;\n#elif defined(__EMSCRIPTEN__) ||  defined(__NetBSD__)\n    typedef unsigned short mask;\n#elif defined(__ANDROID__)\n    typedef unsigned char mask;\n#endif\n    static const mask space  = _CTYPE_S;\n    static const mask print  = _CTYPE_R;\n    static const mask cntrl  = _CTYPE_C;\n    static const mask upper  = _CTYPE_U;\n    static const mask lower  = _CTYPE_L;\n    static const mask alpha  = _CTYPE_A;\n    static const mask digit  = _CTYPE_D;\n    static const mask punct  = _CTYPE_P;\n# if defined(__ANDROID__)\n    static const mask xdigit = _CTYPE_X | _CTYPE_D;\n# else\n    static const mask xdigit = _CTYPE_X;\n# endif\n\n# if defined(__NetBSD__)\n    static const mask blank  = _CTYPE_BL;\n# else\n    static const mask blank  = _CTYPE_B;\n# endif\n#elif defined(__sun__) || defined(_AIX)\n    typedef unsigned int mask;\n    static const mask space  = _ISSPACE;\n    static const mask print  = _ISPRINT;\n    static const mask cntrl  = _ISCNTRL;\n    static const mask upper  = _ISUPPER;\n    static const mask lower  = _ISLOWER;\n    static const mask alpha  = _ISALPHA;\n    static const mask digit  = _ISDIGIT;\n    static const mask punct  = _ISPUNCT;\n    static const mask xdigit = _ISXDIGIT;\n    static const mask blank  = _ISBLANK;\n#else  // __GLIBC__ || _WIN32 || __APPLE__ || __FreeBSD__ || __EMSCRIPTEN__ || __sun__\n    typedef unsigned long mask;\n    static const mask space  = 1<<0;\n    static const mask print  = 1<<1;\n    static const mask cntrl  = 1<<2;\n    static const mask upper  = 1<<3;\n    static const mask lower  = 1<<4;\n    static const mask alpha  = 1<<5;\n    static const mask digit  = 1<<6;\n    static const mask punct  = 1<<7;\n    static const mask xdigit = 1<<8;\n    static const mask blank  = 1<<9;\n#endif  // __GLIBC__ || _WIN32 || __APPLE__ || __FreeBSD__\n    static const mask alnum  = alpha | digit;\n    static const mask graph  = alnum | punct;\n\n    _LIBCPP_ALWAYS_INLINE ctype_base() {}\n};\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS_ONLY ctype;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype<wchar_t>\n    : public locale::facet,\n      public ctype_base\n{\npublic:\n    typedef wchar_t char_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit ctype(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    bool is(mask __m, char_type __c) const\n    {\n        return do_is(__m, __c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const\n    {\n        return do_is(__low, __high, __vec);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_is(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        return do_scan_is(__m, __low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        return do_scan_not(__m, __low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type toupper(char_type __c) const\n    {\n        return do_toupper(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* toupper(char_type* __low, const char_type* __high) const\n    {\n        return do_toupper(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type tolower(char_type __c) const\n    {\n        return do_tolower(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* tolower(char_type* __low, const char_type* __high) const\n    {\n        return do_tolower(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type widen(char __c) const\n    {\n        return do_widen(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* widen(const char* __low, const char* __high, char_type* __to) const\n    {\n        return do_widen(__low, __high, __to);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char narrow(char_type __c, char __dfault) const\n    {\n        return do_narrow(__c, __dfault);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const\n    {\n        return do_narrow(__low, __high, __dfault, __to);\n    }\n\n    static locale::id id;\n\nprotected:\n    ~ctype();\n    virtual bool do_is(mask __m, char_type __c) const;\n    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;\n    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;\n    virtual char do_narrow(char_type, char __dfault) const;\n    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype<char>\n    : public locale::facet, public ctype_base\n{\n    const mask* __tab_;\n    bool        __del_;\npublic:\n    typedef char char_type;\n\n    explicit ctype(const mask* __tab = 0, bool __del = false, size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE\n    bool is(mask __m, char_type __c) const\n    {\n        return isascii(__c) ? (__tab_[static_cast<int>(__c)] & __m) !=0 : false;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* is(const char_type* __low, const char_type* __high, mask* __vec) const\n    {\n        for (; __low != __high; ++__low, ++__vec)\n            *__vec = isascii(*__low) ? __tab_[static_cast<int>(*__low)] : 0;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_is (mask __m, const char_type* __low, const char_type* __high) const\n    {\n        for (; __low != __high; ++__low)\n            if (isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m))\n                break;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* scan_not(mask __m, const char_type* __low, const char_type* __high) const\n    {\n        for (; __low != __high; ++__low)\n            if (!(isascii(*__low) && (__tab_[static_cast<int>(*__low)] & __m)))\n                break;\n        return __low;\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type toupper(char_type __c) const\n    {\n        return do_toupper(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* toupper(char_type* __low, const char_type* __high) const\n    {\n        return do_toupper(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type tolower(char_type __c) const\n    {\n        return do_tolower(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char_type* tolower(char_type* __low, const char_type* __high) const\n    {\n        return do_tolower(__low, __high);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char_type widen(char __c) const\n    {\n        return do_widen(__c);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* widen(const char* __low, const char* __high, char_type* __to) const\n    {\n        return do_widen(__low, __high, __to);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    char narrow(char_type __c, char __dfault) const\n    {\n        return do_narrow(__c, __dfault);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    const char* narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const\n    {\n        return do_narrow(__low, __high, __dfault, __to);\n    }\n\n    static locale::id id;\n\n#ifdef _CACHED_RUNES\n    static const size_t table_size = _CACHED_RUNES;\n#else\n    static const size_t table_size = 256;  // FIXME: Don't hardcode this.\n#endif\n    _LIBCPP_ALWAYS_INLINE const mask* table() const  _NOEXCEPT {return __tab_;}\n    static const mask* classic_table()  _NOEXCEPT;\n#if defined(__GLIBC__) || defined(__EMSCRIPTEN__)\n    static const int* __classic_upper_table() _NOEXCEPT;\n    static const int* __classic_lower_table() _NOEXCEPT;\n#endif\n#if defined(__NetBSD__)\n    static const short* __classic_upper_table() _NOEXCEPT;\n    static const short* __classic_lower_table() _NOEXCEPT;\n#endif\n\nprotected:\n    ~ctype();\n    virtual char_type do_toupper(char_type __c) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type __c) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char __c) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __to) const;\n    virtual char do_narrow(char_type __c, char __dfault) const;\n    virtual const char* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __to) const;\n};\n\n// template <class CharT> class ctype_byname;\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS_ONLY ctype_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype_byname<char>\n    : public ctype<char>\n{\n    locale_t __l;\n\npublic:\n    explicit ctype_byname(const char*, size_t = 0);\n    explicit ctype_byname(const string&, size_t = 0);\n\nprotected:\n    ~ctype_byname();\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS ctype_byname<wchar_t>\n    : public ctype<wchar_t>\n{\n    locale_t __l;\n\npublic:\n    explicit ctype_byname(const char*, size_t = 0);\n    explicit ctype_byname(const string&, size_t = 0);\n\nprotected:\n    ~ctype_byname();\n    virtual bool do_is(mask __m, char_type __c) const;\n    virtual const char_type* do_is(const char_type* __low, const char_type* __high, mask* __vec) const;\n    virtual const char_type* do_scan_is(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual const char_type* do_scan_not(mask __m, const char_type* __low, const char_type* __high) const;\n    virtual char_type do_toupper(char_type) const;\n    virtual const char_type* do_toupper(char_type* __low, const char_type* __high) const;\n    virtual char_type do_tolower(char_type) const;\n    virtual const char_type* do_tolower(char_type* __low, const char_type* __high) const;\n    virtual char_type do_widen(char) const;\n    virtual const char* do_widen(const char* __low, const char* __high, char_type* __dest) const;\n    virtual char do_narrow(char_type, char __dfault) const;\n    virtual const char_type* do_narrow(const char_type* __low, const char_type* __high, char __dfault, char* __dest) const;\n};\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisspace(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::space, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisprint(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::print, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\niscntrl(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::cntrl, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisupper(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::upper, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nislower(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::lower, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisalpha(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alpha, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisdigit(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::digit, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nispunct(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::punct, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisxdigit(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::xdigit, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisalnum(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::alnum, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nisgraph(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).is(ctype_base::graph, __c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\ntoupper(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).toupper(__c);\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT\ntolower(_CharT __c, const locale& __loc)\n{\n    return use_facet<ctype<_CharT> >(__loc).tolower(__c);\n}\n\n// codecvt_base\n\nclass _LIBCPP_TYPE_VIS codecvt_base\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE codecvt_base() {}\n    enum result {ok, partial, error, noconv};\n};\n\n// template <class internT, class externT, class stateT> class codecvt;\n\ntemplate <class _InternT, class _ExternT, class _StateT> class _LIBCPP_TYPE_VIS_ONLY codecvt;\n\n// template <> class codecvt<char, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char      intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<wchar_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<wchar_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\n    locale_t __l;\npublic:\n    typedef wchar_t   intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    explicit codecvt(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    explicit codecvt(const char*, size_t __refs = 0);\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<char16_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char16_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char16_t  intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <> class codecvt<char32_t, char, mbstate_t>\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS codecvt<char32_t, char, mbstate_t>\n    : public locale::facet,\n      public codecvt_base\n{\npublic:\n    typedef char32_t  intern_type;\n    typedef char      extern_type;\n    typedef mbstate_t state_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    result out(state_type& __st,\n               const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n               extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_out(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result unshift(state_type& __st,\n                   extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const\n    {\n        return do_unshift(__st, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    result in(state_type& __st,\n              const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n              intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const\n    {\n        return do_in(__st, __frm, __frm_end, __frm_nxt, __to, __to_end, __to_nxt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int encoding() const  _NOEXCEPT\n    {\n        return do_encoding();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    bool always_noconv() const  _NOEXCEPT\n    {\n        return do_always_noconv();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int length(state_type& __st, const extern_type* __frm, const extern_type* __end, size_t __mx) const\n    {\n        return do_length(__st, __frm, __end, __mx);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    int max_length() const  _NOEXCEPT\n    {\n        return do_max_length();\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt(const char*, size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    ~codecvt();\n\n    virtual result do_out(state_type& __st,\n                          const intern_type* __frm, const intern_type* __frm_end, const intern_type*& __frm_nxt,\n                          extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual result do_in(state_type& __st,\n                         const extern_type* __frm, const extern_type* __frm_end, const extern_type*& __frm_nxt,\n                         intern_type* __to, intern_type* __to_end, intern_type*& __to_nxt) const;\n    virtual result do_unshift(state_type& __st,\n                              extern_type* __to, extern_type* __to_end, extern_type*& __to_nxt) const;\n    virtual int do_encoding() const  _NOEXCEPT;\n    virtual bool do_always_noconv() const  _NOEXCEPT;\n    virtual int do_length(state_type&, const extern_type* __frm, const extern_type* __end, size_t __mx) const;\n    virtual int do_max_length() const  _NOEXCEPT;\n};\n\n// template <class _InternT, class _ExternT, class _StateT> class codecvt_byname\n\ntemplate <class _InternT, class _ExternT, class _StateT>\nclass _LIBCPP_TYPE_VIS_ONLY codecvt_byname\n    : public codecvt<_InternT, _ExternT, _StateT>\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt_byname(const char* __nm, size_t __refs = 0)\n        : codecvt<_InternT, _ExternT, _StateT>(__nm, __refs) {}\n    _LIBCPP_ALWAYS_INLINE\n    explicit codecvt_byname(const string& __nm, size_t __refs = 0)\n        : codecvt<_InternT, _ExternT, _StateT>(__nm.c_str(), __refs) {}\nprotected:\n    ~codecvt_byname();\n};\n\ntemplate <class _InternT, class _ExternT, class _StateT>\ncodecvt_byname<_InternT, _ExternT, _StateT>::~codecvt_byname()\n{\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS codecvt_byname<char, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS codecvt_byname<wchar_t, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS codecvt_byname<char16_t, char, mbstate_t>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS codecvt_byname<char32_t, char, mbstate_t>)\n\n_LIBCPP_FUNC_VIS void __throw_runtime_error(const char*);\n\ntemplate <size_t _Np>\nstruct __narrow_to_utf8\n{\n    template <class _OutputIterator, class _CharT>\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const;\n};\n\ntemplate <>\nstruct __narrow_to_utf8<8>\n{\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        for (; __wb < __we; ++__wb, ++__s)\n            *__s = *__wb;\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __narrow_to_utf8<16>\n    : public codecvt<char16_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __narrow_to_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}\n\n    ~__narrow_to_utf8();\n\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__wb < __we && __r != error)\n        {\n            const int __sz = 32;\n            char __buf[__sz];\n            char* __bn;\n            const char16_t* __wn = (const char16_t*)__wb;\n            __r = do_out(__mb, (const char16_t*)__wb, (const char16_t*)__we, __wn,\n                         __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __wn == (const char16_t*)__wb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = *__p;\n            __wb = (const _CharT*)__wn;\n        }\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __narrow_to_utf8<32>\n    : public codecvt<char32_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __narrow_to_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}\n\n    ~__narrow_to_utf8();\n\n    template <class _OutputIterator, class _CharT>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const _CharT* __wb, const _CharT* __we) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__wb < __we && __r != error)\n        {\n            const int __sz = 32;\n            char __buf[__sz];\n            char* __bn;\n            const char32_t* __wn = (const char32_t*)__wb;\n            __r = do_out(__mb, (const char32_t*)__wb, (const char32_t*)__we, __wn,\n                         __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __wn == (const char32_t*)__wb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = *__p;\n            __wb = (const _CharT*)__wn;\n        }\n        return __s;\n    }\n};\n\ntemplate <size_t _Np>\nstruct __widen_from_utf8\n{\n    template <class _OutputIterator>\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const;\n};\n\ntemplate <>\nstruct __widen_from_utf8<8>\n{\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        for (; __nb < __ne; ++__nb, ++__s)\n            *__s = *__nb;\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __widen_from_utf8<16>\n    : public codecvt<char16_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __widen_from_utf8() : codecvt<char16_t, char, mbstate_t>(1) {}\n\n    ~__widen_from_utf8();\n\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__nb < __ne && __r != error)\n        {\n            const int __sz = 32;\n            char16_t __buf[__sz];\n            char16_t* __bn;\n            const char* __nn = __nb;\n            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,\n                        __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __nn == __nb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char16_t* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = (wchar_t)*__p;\n            __nb = __nn;\n        }\n        return __s;\n    }\n};\n\ntemplate <>\nstruct __widen_from_utf8<32>\n    : public codecvt<char32_t, char, mbstate_t>\n{\n    _LIBCPP_ALWAYS_INLINE\n    __widen_from_utf8() : codecvt<char32_t, char, mbstate_t>(1) {}\n\n    ~__widen_from_utf8();\n\n    template <class _OutputIterator>\n    _LIBCPP_ALWAYS_INLINE\n    _OutputIterator\n    operator()(_OutputIterator __s, const char* __nb, const char* __ne) const\n    {\n        result __r = ok;\n        mbstate_t __mb;\n        while (__nb < __ne && __r != error)\n        {\n            const int __sz = 32;\n            char32_t __buf[__sz];\n            char32_t* __bn;\n            const char* __nn = __nb;\n            __r = do_in(__mb, __nb, __ne - __nb > __sz ? __nb+__sz : __ne, __nn,\n                        __buf, __buf+__sz, __bn);\n            if (__r == codecvt_base::error || __nn == __nb)\n                __throw_runtime_error(\"locale not supported\");\n            for (const char32_t* __p = __buf; __p < __bn; ++__p, ++__s)\n                *__s = (wchar_t)*__p;\n            __nb = __nn;\n        }\n        return __s;\n    }\n};\n\n// template <class charT> class numpunct\n\ntemplate <class _CharT> class _LIBCPP_TYPE_VIS_ONLY numpunct;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct<char>\n    : public locale::facet\n{\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE char_type decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string grouping() const         {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type truename() const    {return do_truename();}\n    _LIBCPP_ALWAYS_INLINE string_type falsename() const   {return do_falsename();}\n\n    static locale::id id;\n\nprotected:\n    ~numpunct();\n    virtual char_type do_decimal_point() const;\n    virtual char_type do_thousands_sep() const;\n    virtual string do_grouping() const;\n    virtual string_type do_truename() const;\n    virtual string_type do_falsename() const;\n\n    char_type __decimal_point_;\n    char_type __thousands_sep_;\n    string __grouping_;\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct<wchar_t>\n    : public locale::facet\n{\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct(size_t __refs = 0);\n\n    _LIBCPP_ALWAYS_INLINE char_type decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string grouping() const         {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type truename() const    {return do_truename();}\n    _LIBCPP_ALWAYS_INLINE string_type falsename() const   {return do_falsename();}\n\n    static locale::id id;\n\nprotected:\n    ~numpunct();\n    virtual char_type do_decimal_point() const;\n    virtual char_type do_thousands_sep() const;\n    virtual string do_grouping() const;\n    virtual string_type do_truename() const;\n    virtual string_type do_falsename() const;\n\n    char_type __decimal_point_;\n    char_type __thousands_sep_;\n    string __grouping_;\n};\n\n// template <class charT> class numpunct_byname\n\ntemplate <class charT> class _LIBCPP_TYPE_VIS_ONLY numpunct_byname;\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct_byname<char>\n: public numpunct<char>\n{\npublic:\n    typedef char char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct_byname(const char* __nm, size_t __refs = 0);\n    explicit numpunct_byname(const string& __nm, size_t __refs = 0);\n\nprotected:\n    ~numpunct_byname();\n\nprivate:\n    void __init(const char*);\n};\n\ntemplate <>\nclass _LIBCPP_TYPE_VIS numpunct_byname<wchar_t>\n: public numpunct<wchar_t>\n{\npublic:\n    typedef wchar_t char_type;\n    typedef basic_string<char_type> string_type;\n\n    explicit numpunct_byname(const char* __nm, size_t __refs = 0);\n    explicit numpunct_byname(const string& __nm, size_t __refs = 0);\n\nprotected:\n    ~numpunct_byname();\n\nprivate:\n    void __init(const char*);\n};\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP___LOCALE\n","#pragma once\n\n#include <stddef.h>\n#include <assert.h>\n#include <string>\n#include <functional>\n#include <vector>\n#include <map>\n#include <type_traits>\n#include <emscripten/val.h>\n#include <emscripten/wire.h>\n\nnamespace emscripten {\n    enum class sharing_policy {\n        NONE = 0,\n        INTRUSIVE = 1,\n        BY_EMVAL = 2,\n    };\n\n    namespace internal {\n        typedef long GenericEnumValue;\n\n        typedef void (*GenericFunction)();\n\n        // Implemented in JavaScript.  Don't call these directly.\n        extern \"C\" {\n            void _embind_fatal_error(\n                const char* name,\n                const char* payload) __attribute__((noreturn));\n\n            void _embind_register_void(\n                TYPEID voidType,\n                const char* name);\n\n            void _embind_register_bool(\n                TYPEID boolType,\n                const char* name,\n                size_t size,\n                bool trueValue,\n                bool falseValue);\n\n            void _embind_register_integer(\n                TYPEID integerType,\n                const char* name,\n                size_t size,\n                long minRange,\n                unsigned long maxRange);\n\n            void _embind_register_float(\n                TYPEID floatType,\n                const char* name,\n                size_t size);\n            \n            void _embind_register_std_string(\n                TYPEID stringType,\n                const char* name);\n\n            void _embind_register_std_wstring(\n                TYPEID stringType,\n                size_t charSize,\n                const char* name);\n\n            void _embind_register_emval(\n                TYPEID emvalType,\n                const char* name);\n\n            void _embind_register_memory_view(\n                TYPEID memoryViewType,\n                unsigned typedArrayIndex,\n                const char* name);\n\n            void _embind_register_function(\n                const char* name,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* signature,\n                GenericFunction invoker,\n                GenericFunction function);\n\n            void _embind_register_value_array(\n                TYPEID tupleType,\n                const char* name,\n                const char* constructorSignature,\n                GenericFunction constructor,\n                const char* destructorSignature,\n                GenericFunction destructor);\n            \n            void _embind_register_value_array_element(\n                TYPEID tupleType,\n                TYPEID getterReturnType,\n                const char* getterSignature,\n                GenericFunction getter,\n                void* getterContext,\n                TYPEID setterArgumentType,\n                const char* setterSignature,\n                GenericFunction setter,\n                void* setterContext);\n\n            void _embind_finalize_value_array(TYPEID tupleType);\n\n            void _embind_register_value_object(\n                TYPEID structType,\n                const char* fieldName,\n                const char* constructorSignature,\n                GenericFunction constructor,\n                const char* destructorSignature,\n                GenericFunction destructor);\n            \n            void _embind_register_value_object_field(\n                TYPEID structType,\n                const char* fieldName,\n                TYPEID getterReturnType,\n                const char* getterSignature,\n                GenericFunction getter,\n                void* getterContext,\n                TYPEID setterArgumentType,\n                const char* setterSignature,\n                GenericFunction setter,\n                void* setterContext);\n\n            void _embind_finalize_value_object(TYPEID structType);\n\n            void _embind_register_class(\n                TYPEID classType,\n                TYPEID pointerType,\n                TYPEID constPointerType,\n                TYPEID baseClassType,\n                const char* getActualTypeSignature,\n                GenericFunction getActualType,\n                const char* upcastSignature,\n                GenericFunction upcast,\n                const char* downcastSignature,\n                GenericFunction downcast,\n                const char* className,\n                const char* destructorSignature,\n                GenericFunction destructor);\n\n            void _embind_register_class_constructor(\n                TYPEID classType,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* invokerSignature,\n                GenericFunction invoker,\n                GenericFunction constructor);\n\n            void _embind_register_class_function(\n                TYPEID classType,\n                const char* methodName,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* invokerSignature,\n                GenericFunction invoker,\n                void* context,\n                unsigned isPureVirtual);\n\n            void _embind_register_class_property(\n                TYPEID classType,\n                const char* fieldName,\n                TYPEID getterReturnType,\n                const char* getterSignature,\n                GenericFunction getter,\n                void* getterContext,\n                TYPEID setterArgumentType,\n                const char* setterSignature,\n                GenericFunction setter,\n                void* setterContext);\n\n            void _embind_register_class_class_function(\n                TYPEID classType,\n                const char* methodName,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                const char* invokerSignature,\n                GenericFunction invoker,\n                GenericFunction method);\n\n            void _embind_register_class_class_property(\n                TYPEID classType,\n                const char* fieldName,\n                TYPEID fieldType,\n                const void* fieldContext,\n                const char* getterSignature,\n                GenericFunction getter,\n                const char* setterSignature,\n                GenericFunction setter);\n\n            EM_VAL _embind_create_inheriting_constructor(\n                const char* constructorName,\n                TYPEID wrapperType,\n                EM_VAL properties);\n\n            void _embind_register_enum(\n                TYPEID enumType,\n                const char* name,\n                size_t size,\n                bool isSigned);\n\n            void _embind_register_smart_ptr(\n                TYPEID pointerType,\n                TYPEID pointeeType,\n                const char* pointerName,\n                sharing_policy sharingPolicy,\n                const char* getPointeeSignature,\n                GenericFunction getPointee,\n                const char* constructorSignature,\n                GenericFunction constructor,\n                const char* shareSignature,\n                GenericFunction share,\n                const char* destructorSignature,\n                GenericFunction destructor);\n\n            void _embind_register_enum_value(\n                TYPEID enumType,\n                const char* valueName,\n                GenericEnumValue value);\n\n            void _embind_register_constant(\n                const char* name,\n                TYPEID constantType,\n                uintptr_t value);\n        }\n    }\n}\n\nnamespace emscripten {\n    ////////////////////////////////////////////////////////////////////////////////\n    // POLICIES\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<int Index>\n    struct arg {\n        static constexpr int index = Index + 1;\n    };\n\n    struct ret_val {\n        static constexpr int index = 0;\n    };\n\n    /*\n    template<typename Slot>\n    struct allow_raw_pointer {\n        template<typename InputType, int Index>\n        struct Transform {\n            typedef typename std::conditional<\n                Index == Slot::index,\n                internal::AllowedRawPointer<typename std::remove_pointer<InputType>::type>,\n                InputType\n            >::type type;\n        };\n    };\n    */\n\n    // whitelist all raw pointers\n    struct allow_raw_pointers {\n        template<typename InputType, int Index>\n        struct Transform {\n            typedef typename std::conditional<\n                std::is_pointer<InputType>::value,\n                internal::AllowedRawPointer<typename std::remove_pointer<InputType>::type>,\n                InputType\n            >::type type;\n        };\n    };\n\n    // this is temporary until arg policies are reworked\n    template<typename Slot>\n    struct allow_raw_pointer : public allow_raw_pointers {\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // select_overload and select_const\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename Signature>\n    Signature* select_overload(Signature* fn) {\n        return fn;\n    }\n\n    template<typename Signature, typename ClassType>\n    auto select_overload(Signature (ClassType::*fn)) -> decltype(fn) {\n        return fn;\n    }\n\n    template<typename ClassType, typename ReturnType, typename... Args>\n    auto select_const(ReturnType (ClassType::*method)(Args...) const) -> decltype(method) {\n        return method;\n    }\n\n    namespace internal {        \n        // this should be in <type_traits>, but alas, it's not\n        template<typename T> struct remove_class;\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...)> { using type = R(A...); };\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...) const> { using type = R(A...); };\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...) volatile> { using type = R(A...); };\n        template<typename C, typename R, typename... A>\n        struct remove_class<R(C::*)(A...) const volatile> { using type = R(A...); };\n\n        template<typename LambdaType>\n        using LambdaSignature = typename remove_class<\n            decltype(&LambdaType::operator())\n        >::type;\n    }\n\n    // requires captureless lambda because implicitly coerces to function pointer\n    template<typename LambdaType>\n    internal::LambdaSignature<LambdaType>* optional_override(const LambdaType& fp) {\n        return fp;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // Invoker\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename ReturnType, typename... Args>\n        struct Invoker {\n            static typename internal::BindingType<ReturnType>::WireType invoke(\n                ReturnType (*fn)(Args...),\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return internal::BindingType<ReturnType>::toWireType(\n                    fn(\n                        internal::BindingType<Args>::fromWireType(args)...\n                    )\n                );\n            }\n        };\n\n        template<typename... Args>\n        struct Invoker<void, Args...> {\n            static void invoke(\n                void (*fn)(Args...),\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return fn(\n                    internal::BindingType<Args>::fromWireType(args)...\n                );\n            }\n        };\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // SignatureCode, SignatureString\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename T>\n        struct SignatureCode {};\n\n        template<>\n        struct SignatureCode<int> {\n            static constexpr char get() {\n                return 'i';\n            }\n        };\n\n        template<>\n        struct SignatureCode<void> {\n            static constexpr char get() {\n                return 'v';\n            }\n        };\n\n        template<>\n        struct SignatureCode<float> {\n            static constexpr char get() {\n                return 'f';\n            }\n        };\n\n        template<>\n        struct SignatureCode<double> {\n            static constexpr char get() {\n                return 'd';\n            }\n        };\n\n        template<typename... Args>\n        const char* getGenericSignature() {\n            static constexpr char signature[] = { SignatureCode<Args>::get()..., 0 };\n            return signature;\n        }\n\n        template<typename T> struct SignatureTranslator { using type = int; };\n        template<> struct SignatureTranslator<void> { using type = void; };\n        template<> struct SignatureTranslator<float> { using type = float; };\n        template<> struct SignatureTranslator<double> { using type = double; };\n\n        template<typename... Args>\n        EMSCRIPTEN_ALWAYS_INLINE const char* getSpecificSignature() {\n            return getGenericSignature<typename SignatureTranslator<Args>::type...>();\n        }\n\n        template<typename Return, typename... Args>\n        EMSCRIPTEN_ALWAYS_INLINE const char* getSignature(Return (*)(Args...)) {\n            return getSpecificSignature<Return, Args...>();\n        }\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // FUNCTIONS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    extern \"C\" {\n        void* __getDynamicPointerType(void* p);\n    }\n\n    template<typename ReturnType, typename... Args, typename... Policies>\n    void function(const char* name, ReturnType (*fn)(Args...), Policies...) {\n        using namespace internal;\n        typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, Args...> args;\n        auto invoker = &Invoker<ReturnType, Args...>::invoke;\n        _embind_register_function(\n            name,\n            args.getCount(),\n            args.getTypes(),\n            getSignature(invoker),\n            reinterpret_cast<GenericFunction>(invoker),\n            reinterpret_cast<GenericFunction>(fn));\n    }\n\n    namespace internal {\n        template<typename ClassType, typename... Args>\n        ClassType* operator_new(Args&&... args) {\n            return new ClassType(std::forward<Args>(args)...);\n        }\n\n        template<typename WrapperType, typename ClassType, typename... Args>\n        WrapperType wrapped_new(Args&&... args) {\n            return WrapperType(new ClassType(std::forward<Args>(args)...));\n        }\n\n        template<typename ClassType, typename... Args>\n        ClassType* raw_constructor(\n            typename internal::BindingType<Args>::WireType... args\n        ) {\n            return new ClassType(\n                internal::BindingType<Args>::fromWireType(args)...\n            );\n        }\n\n        template<typename ClassType>\n        void raw_destructor(ClassType* ptr) {\n            delete ptr;\n        }\n\n        template<typename FunctionPointerType, typename ReturnType, typename ThisType, typename... Args>\n        struct FunctionInvoker {\n            static typename internal::BindingType<ReturnType>::WireType invoke(\n                FunctionPointerType* function,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return internal::BindingType<ReturnType>::toWireType(\n                    (*function)(\n                        internal::BindingType<ThisType>::fromWireType(wireThis),\n                        internal::BindingType<Args>::fromWireType(args)...)\n                );\n            }\n        };\n\n        template<typename FunctionPointerType, typename ThisType, typename... Args>\n        struct FunctionInvoker<FunctionPointerType, void, ThisType, Args...> {\n            static void invoke(\n                FunctionPointerType* function,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                (*function)(\n                    internal::BindingType<ThisType>::fromWireType(wireThis),\n                    internal::BindingType<Args>::fromWireType(args)...);\n            }\n        };\n\n        template<typename MemberPointer,\n                 typename ReturnType,\n                 typename ThisType,\n                 typename... Args>\n        struct MethodInvoker {\n            static typename internal::BindingType<ReturnType>::WireType invoke(\n                const MemberPointer& method,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return internal::BindingType<ReturnType>::toWireType(\n                    (internal::BindingType<ThisType>::fromWireType(wireThis)->*method)(\n                        internal::BindingType<Args>::fromWireType(args)...\n                    )\n                );\n            }\n        };\n\n        template<typename MemberPointer,\n                 typename ThisType,\n                 typename... Args>\n        struct MethodInvoker<MemberPointer, void, ThisType, Args...> {\n            static void invoke(\n                const MemberPointer& method,\n                typename internal::BindingType<ThisType>::WireType wireThis,\n                typename internal::BindingType<Args>::WireType... args\n            ) {\n                return (internal::BindingType<ThisType>::fromWireType(wireThis)->*method)(\n                    internal::BindingType<Args>::fromWireType(args)...\n                );\n            }\n        };\n\n        template<typename InstanceType, typename MemberType>\n        struct MemberAccess {\n            typedef MemberType InstanceType::*MemberPointer;\n            typedef internal::BindingType<MemberType> MemberBinding;\n            typedef typename MemberBinding::WireType WireType;\n            \n            template<typename ClassType>\n            static WireType getWire(\n                const MemberPointer& field,\n                const ClassType& ptr\n            ) {\n                return MemberBinding::toWireType(ptr.*field);\n            }\n            \n            template<typename ClassType>\n            static void setWire(\n                const MemberPointer& field,\n                ClassType& ptr,\n                WireType value\n            ) {\n                ptr.*field = MemberBinding::fromWireType(value);\n            }\n        };\n\n        template<typename FieldType>\n        struct GlobalAccess {\n            typedef internal::BindingType<FieldType> MemberBinding;\n            typedef typename MemberBinding::WireType WireType;\n\n            static WireType get(FieldType* context) {\n                return MemberBinding::toWireType(*context);\n            }\n\n            static void set(FieldType* context, WireType value) {\n                *context = MemberBinding::fromWireType(value);\n            }\n        };\n\n        // TODO: This could do a reinterpret-cast if sizeof(T) === sizeof(void*)\n        template<typename T>\n        inline T* getContext(const T& t) {\n            // not a leak because this is called once per binding\n            return new T(t);\n        }\n\n        template<typename T>\n        struct GetterPolicy;\n\n        template<typename GetterReturnType, typename GetterThisType>\n        struct GetterPolicy<GetterReturnType (GetterThisType::*)() const> {\n            typedef GetterReturnType ReturnType;\n            typedef GetterReturnType (GetterThisType::*Context)() const;\n\n            typedef internal::BindingType<ReturnType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static WireType get(const Context& context, const ClassType& ptr) {\n                return Binding::toWireType((ptr.*context)());\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        template<typename GetterReturnType, typename GetterThisType>\n        struct GetterPolicy<GetterReturnType (*)(const GetterThisType&)> {\n            typedef GetterReturnType ReturnType;\n            typedef GetterReturnType (*Context)(const GetterThisType&);\n\n            typedef internal::BindingType<ReturnType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static WireType get(const Context& context, const ClassType& ptr) {\n                return Binding::toWireType(context(ptr));\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        template<typename T>\n        struct SetterPolicy;\n\n        template<typename SetterThisType, typename SetterArgumentType>\n        struct SetterPolicy<void (SetterThisType::*)(SetterArgumentType)> {\n            typedef SetterArgumentType ArgumentType;\n            typedef void (SetterThisType::*Context)(SetterArgumentType);\n\n            typedef internal::BindingType<SetterArgumentType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static void set(const Context& context, ClassType& ptr, WireType wt) {\n                (ptr.*context)(Binding::fromWireType(wt));\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        template<typename SetterThisType, typename SetterArgumentType>\n        struct SetterPolicy<void (*)(SetterThisType&, SetterArgumentType)> {\n            typedef SetterArgumentType ArgumentType;\n            typedef void (*Context)(SetterThisType&, SetterArgumentType);\n\n            typedef internal::BindingType<SetterArgumentType> Binding;\n            typedef typename Binding::WireType WireType;\n\n            template<typename ClassType>\n            static void set(const Context& context, ClassType& ptr, WireType wt) {\n                context(ptr, Binding::fromWireType(wt));\n            }\n\n            static void* getContext(Context context) {\n                return internal::getContext(context);\n            }\n        };\n\n        class noncopyable {\n        protected:\n            noncopyable() {}\n            ~noncopyable() {}\n        private:\n            noncopyable(const noncopyable&) = delete;\n            const noncopyable& operator=(const noncopyable&) = delete;\n        };\n\n        template<typename ClassType, typename ElementType>\n        typename BindingType<ElementType>::WireType get_by_index(int index, ClassType& ptr) {\n            return BindingType<ElementType>::toWireType(ptr[index]);\n        }\n\n        template<typename ClassType, typename ElementType>\n        void set_by_index(int index, ClassType& ptr, typename BindingType<ElementType>::WireType wt) {\n            ptr[index] = BindingType<ElementType>::fromWireType(wt);\n        }\n    }\n\n    template<int Index>\n    struct index {\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // VALUE TUPLES\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename ClassType>\n    class value_array : public internal::noncopyable {\n    public:\n        typedef ClassType class_type;\n\n        value_array(const char* name) {\n            using namespace internal;\n\n            auto constructor = &raw_constructor<ClassType>;\n            auto destructor = &raw_destructor<ClassType>;\n            _embind_register_value_array(\n                TypeID<ClassType>::get(),\n                name,\n                getSignature(constructor),\n                reinterpret_cast<GenericFunction>(constructor),\n                getSignature(destructor),\n                reinterpret_cast<GenericFunction>(destructor));\n        }\n\n        ~value_array() {\n            using namespace internal;\n            _embind_finalize_value_array(TypeID<ClassType>::get());\n        }\n\n        template<typename InstanceType, typename ElementType>\n        value_array& element(ElementType InstanceType::*field) {\n            using namespace internal;\n\n            auto getter = &MemberAccess<InstanceType, ElementType>\n                ::template getWire<ClassType>;\n            auto setter = &MemberAccess<InstanceType, ElementType>\n                ::template setWire<ClassType>;\n\n            _embind_register_value_array_element(\n                TypeID<ClassType>::get(),\n                TypeID<ElementType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<ElementType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename Getter, typename Setter>\n        value_array& element(Getter getter, Setter setter) {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            typedef SetterPolicy<Setter> SP;\n\n            auto g = &GP::template get<ClassType>;\n            auto s = &SP::template set<ClassType>;\n\n            _embind_register_value_array_element(\n                TypeID<ClassType>::get(),\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(g),\n                reinterpret_cast<GenericFunction>(g),\n                GP::getContext(getter),\n                TypeID<typename SP::ArgumentType>::get(),\n                getSignature(s),\n                reinterpret_cast<GenericFunction>(s),\n                SP::getContext(setter));\n            return *this;\n        }\n\n        template<int Index>\n        value_array& element(index<Index>) {\n            using namespace internal;\n            ClassType* null = 0;\n            typedef typename std::remove_reference<decltype((*null)[Index])>::type ElementType;\n            auto getter = &internal::get_by_index<ClassType, ElementType>;\n            auto setter = &internal::set_by_index<ClassType, ElementType>;\n\n            _embind_register_value_array_element(\n                TypeID<ClassType>::get(),\n                TypeID<ElementType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                reinterpret_cast<void*>(Index),\n                TypeID<ElementType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                reinterpret_cast<void*>(Index));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // VALUE STRUCTS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename ClassType>\n    class value_object : public internal::noncopyable {\n    public:\n        typedef ClassType class_type;\n\n        value_object(const char* name) {\n            using namespace internal;\n\n            auto ctor = &raw_constructor<ClassType>;\n            auto dtor = &raw_destructor<ClassType>;\n\n            _embind_register_value_object(\n                TypeID<ClassType>::get(),\n                name,\n                getSignature(ctor),\n                reinterpret_cast<GenericFunction>(ctor),\n                getSignature(dtor),\n                reinterpret_cast<GenericFunction>(dtor));\n        }\n\n        ~value_object() {\n            using namespace internal;\n            _embind_finalize_value_object(internal::TypeID<ClassType>::get());\n        }\n\n        template<typename InstanceType, typename FieldType>\n        value_object& field(const char* fieldName, FieldType InstanceType::*field) {\n            using namespace internal;\n\n            auto getter = &MemberAccess<InstanceType, FieldType>\n                ::template getWire<ClassType>;\n            auto setter = &MemberAccess<InstanceType, FieldType>\n                ::template setWire<ClassType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<FieldType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n    \n        template<typename Getter, typename Setter>\n        value_object& field(\n            const char* fieldName,\n            Getter getter,\n            Setter setter\n        ) {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            typedef SetterPolicy<Setter> SP;\n\n            auto g = &GP::template get<ClassType>;\n            auto s = &SP::template set<ClassType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(g),\n                reinterpret_cast<GenericFunction>(g),\n                GP::getContext(getter),\n                TypeID<typename SP::ArgumentType>::get(),\n                getSignature(s),\n                reinterpret_cast<GenericFunction>(s),\n                SP::getContext(setter));\n            return *this;\n        }\n\n        template<int Index>\n        value_object& field(const char* fieldName, index<Index>) {\n            using namespace internal;\n            ClassType* null = 0;\n            typedef typename std::remove_reference<decltype((*null)[Index])>::type ElementType;\n\n            auto getter = &internal::get_by_index<ClassType, ElementType>;\n            auto setter = &internal::set_by_index<ClassType, ElementType>;\n\n            _embind_register_value_object_field(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<ElementType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                reinterpret_cast<void*>(Index),\n                TypeID<ElementType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                reinterpret_cast<void*>(Index));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // SMART POINTERS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename PointerType>\n    struct default_smart_ptr_trait {\n        static sharing_policy get_sharing_policy() {\n            return sharing_policy::NONE;\n        }\n\n        static void* share(void* v) {\n            return 0; // no sharing\n        }\n\n        static PointerType* construct_null() {\n            return new PointerType;\n        }\n    };\n\n    // specialize if you have a different pointer type\n    template<typename PointerType>\n    struct smart_ptr_trait : public default_smart_ptr_trait<PointerType> {\n        typedef typename PointerType::element_type element_type;\n\n        static element_type* get(const PointerType& ptr) {\n            return ptr.get();\n        }\n    };\n\n    template<typename PointeeType>\n    struct smart_ptr_trait<std::shared_ptr<PointeeType>> {\n        typedef std::shared_ptr<PointeeType> PointerType;\n        typedef typename PointerType::element_type element_type;\n\n        static element_type* get(const PointerType& ptr) {\n            return ptr.get();\n        }\n\n        static sharing_policy get_sharing_policy() {\n            return sharing_policy::BY_EMVAL;\n        }\n\n        static std::shared_ptr<PointeeType>* share(PointeeType* p, internal::EM_VAL v) {\n            return new std::shared_ptr<PointeeType>(\n                p,\n                val_deleter(val::take_ownership(v)));\n        }\n\n        static PointerType* construct_null() {\n            return new PointerType;\n        }\n\n    private:\n        class val_deleter {\n        public:\n            val_deleter() = delete;\n            explicit val_deleter(val v)\n                : v(v)\n            {}\n            void operator()(void const*) {\n                v();\n                // eventually we'll need to support emptied out val\n                v = val::undefined();\n            }\n        private:\n            val v;\n        };\n    };\n\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // CLASSES\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        class WrapperBase {\n        public:\n            void setNotifyJSOnDestruction(bool notify) {\n                notifyJSOnDestruction = notify;\n            }\n\n        protected:\n            bool notifyJSOnDestruction = false;\n        };\n    }\n\n    // abstract classes\n    template<typename T>\n    class wrapper : public T, public internal::WrapperBase {\n    public:\n        typedef T class_type;\n\n        template<typename... Args>\n        explicit wrapper(val&& wrapped, Args&&... args)\n            : T(std::forward<Args>(args)...)\n            , wrapped(std::forward<val>(wrapped))\n        {}\n\n        ~wrapper() {\n            if (notifyJSOnDestruction) {\n                call<void>(\"__destruct\");\n            }\n        }\n\n        template<typename ReturnType, typename... Args>\n        ReturnType call(const char* name, Args&&... args) const {\n            return wrapped.call<ReturnType>(name, std::forward<Args>(args)...);\n        }\n\n    private:\n        val wrapped;\n    };\n\n#define EMSCRIPTEN_WRAPPER(T)                                           \\\n    template<typename... Args>                                          \\\n    T(::emscripten::val&& v, Args&&... args)                            \\\n        : wrapper(std::forward<::emscripten::val>(v), std::forward<Args>(args)...) \\\n    {}\n\n    namespace internal {\n        struct NoBaseClass {\n            template<typename ClassType>\n            static void verify() {\n            }\n\n            static TYPEID get() {\n                return nullptr;\n            }\n\n            template<typename ClassType>\n            static GenericFunction getUpcaster() {\n                return nullptr;\n            }\n\n            template<typename ClassType>\n            static GenericFunction getDowncaster() {\n                return nullptr;\n            }\n        };\n\n        // NOTE: this returns the class type, not the pointer type\n        template<typename T>\n        inline TYPEID getActualType(T* ptr) {\n            return getLightTypeID(*ptr);\n        };\n    }\n\n    template<typename BaseClass>\n    struct base {\n        typedef BaseClass class_type;\n\n        template<typename ClassType>\n        static void verify() {\n            static_assert(!std::is_same<ClassType, BaseClass>::value, \"Base must not have same type as class\");\n            static_assert(std::is_base_of<BaseClass, ClassType>::value, \"Derived class must derive from base\");\n        }\n\n        static internal::TYPEID get() {\n            return internal::TypeID<BaseClass>::get();\n        }\n        \n        template<typename ClassType>\n        using Upcaster = BaseClass* (*)(ClassType*);\n\n        template<typename ClassType>\n        using Downcaster = ClassType* (*)(BaseClass*);\n        \n        template<typename ClassType>\n        static Upcaster<ClassType> getUpcaster() {\n            return &convertPointer<ClassType, BaseClass>;\n        }\n        \n        template<typename ClassType>\n        static Downcaster<ClassType> getDowncaster() {\n            return &convertPointer<BaseClass, ClassType>;\n        }\n\n        template<typename From, typename To>\n        static To* convertPointer(From* ptr) {\n            return static_cast<To*>(ptr);\n        }\n    };\n\n    namespace internal {\n        template<typename WrapperType>\n        val wrapped_extend(const std::string& name, const val& properties) {\n            return val::take_ownership(_embind_create_inheriting_constructor(\n                name.c_str(),\n                TypeID<WrapperType>::get(),\n                properties.__get_handle()));\n        }\n    };\n\n    struct pure_virtual {\n        template<typename InputType, int Index>\n        struct Transform {\n            typedef InputType type;\n        };\n    };\n\n    namespace internal {\n        template<typename... Policies>\n        struct isPureVirtual;\n\n        template<typename... Rest>\n        struct isPureVirtual<pure_virtual, Rest...> {\n            static constexpr bool value = true;\n        };\n\n        template<typename T, typename... Rest>\n        struct isPureVirtual<T, Rest...> {\n            static constexpr bool value = isPureVirtual<Rest...>::value;\n        };\n\n        template<>\n        struct isPureVirtual<> {\n            static constexpr bool value = false;\n        };\n    }\n\n    template<typename... ConstructorArgs>\n    struct constructor {\n    };\n\n    template<typename ClassType, typename BaseSpecifier = internal::NoBaseClass>\n    class class_ {\n    public:\n        typedef ClassType class_type;\n        typedef BaseSpecifier base_specifier;\n\n        class_() = delete;\n\n        EMSCRIPTEN_ALWAYS_INLINE explicit class_(const char* name) {\n            using namespace internal;\n\n            BaseSpecifier::template verify<ClassType>();\n\n            auto _getActualType = &getActualType<ClassType>;\n            auto upcast = BaseSpecifier::template getUpcaster<ClassType>();\n            auto downcast = BaseSpecifier::template getDowncaster<ClassType>();\n            auto destructor = &raw_destructor<ClassType>;\n\n            _embind_register_class(\n                TypeID<ClassType>::get(),\n                TypeID<AllowedRawPointer<ClassType>>::get(),\n                TypeID<AllowedRawPointer<const ClassType>>::get(),\n                BaseSpecifier::get(),\n                getSignature(_getActualType),\n                reinterpret_cast<GenericFunction>(_getActualType),\n                getSignature(upcast),\n                reinterpret_cast<GenericFunction>(upcast),\n                getSignature(downcast),\n                reinterpret_cast<GenericFunction>(downcast),\n                name,\n                getSignature(destructor),\n                reinterpret_cast<GenericFunction>(destructor));\n        }\n\n        template<typename PointerType>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& smart_ptr(const char* name) const {\n            using namespace internal;\n\n            typedef smart_ptr_trait<PointerType> PointerTrait;\n            typedef typename PointerTrait::element_type PointeeType;\n            \n            static_assert(std::is_same<ClassType, typename std::remove_cv<PointeeType>::type>::value, \"smart pointer must point to this class\");\n\n            auto get = &PointerTrait::get;\n            auto construct_null = &PointerTrait::construct_null;\n            auto share = &PointerTrait::share;\n            auto destructor = &raw_destructor<PointerType>;\n\n            _embind_register_smart_ptr(\n                TypeID<PointerType>::get(),\n                TypeID<PointeeType>::get(),\n                name,\n                PointerTrait::get_sharing_policy(),\n                getSignature(get),\n                reinterpret_cast<GenericFunction>(get),\n                getSignature(construct_null),\n                reinterpret_cast<GenericFunction>(construct_null),\n                getSignature(share),\n                reinterpret_cast<GenericFunction>(share),\n                getSignature(destructor),\n                reinterpret_cast<GenericFunction>(destructor));\n            return *this;\n        };\n\n        template<typename... ConstructorArgs, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& constructor(Policies... policies) const {\n            return constructor(\n                &internal::operator_new<ClassType, ConstructorArgs...>,\n                policies...);\n        }\n\n        template<typename... Args, typename ReturnType, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& constructor(ReturnType (*factory)(Args...), Policies...) const {\n            using namespace internal;\n\n            // TODO: allows all raw pointers... policies need a rethink\n            typename WithPolicies<allow_raw_pointers, Policies...>::template ArgTypeList<ReturnType, Args...> args;\n            auto invoke = &Invoker<ReturnType, Args...>::invoke;\n            _embind_register_class_constructor(\n                TypeID<ClassType>::get(),\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                reinterpret_cast<GenericFunction>(factory));\n            return *this;\n        }\n\n        template<typename SmartPtr, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& smart_ptr_constructor(const char* smartPtrName, SmartPtr (*factory)(Args...), Policies...) const {\n            using namespace internal;\n\n            smart_ptr<SmartPtr>(smartPtrName);\n\n            typename WithPolicies<Policies...>::template ArgTypeList<SmartPtr, Args...> args;\n            auto invoke = &Invoker<SmartPtr, Args...>::invoke;\n            _embind_register_class_constructor(\n                TypeID<ClassType>::get(),\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                reinterpret_cast<GenericFunction>(factory));\n            return *this;\n        }\n\n        template<typename WrapperType, typename... ConstructorArgs>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& allow_subclass(\n            const char* wrapperClassName,\n            ::emscripten::constructor<ConstructorArgs...> = ::emscripten::constructor<>()\n        ) const {\n            using namespace internal;\n\n            auto cls = class_<WrapperType, base<ClassType>>(wrapperClassName)\n                .function(\"notifyOnDestruction\", select_overload<void(WrapperType&)>([](WrapperType& wrapper) {\n                    wrapper.setNotifyJSOnDestruction(true);\n                }))\n                ;\n\n            return\n                class_function(\n                    \"implement\",\n                    &wrapped_new<WrapperType*, WrapperType, val, ConstructorArgs...>,\n                    allow_raw_pointer<ret_val>())\n                .class_function(\n                    \"extend\",\n                    &wrapped_extend<WrapperType>)\n                ;\n        }\n\n        template<typename WrapperType, typename PointerType, typename... ConstructorArgs>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& allow_subclass(\n            const char* wrapperClassName,\n            const char* pointerName,\n            ::emscripten::constructor<ConstructorArgs...> = ::emscripten::constructor<>()\n        ) const {\n            using namespace internal;\n\n            auto cls = class_<WrapperType, base<ClassType>>(wrapperClassName)\n                .function(\"notifyOnDestruction\", select_overload<void(WrapperType&)>([](WrapperType& wrapper) {\n                    wrapper.setNotifyJSOnDestruction(true);\n                }))\n                .template smart_ptr<PointerType>(pointerName)\n                ;\n\n            return\n                class_function(\n                    \"implement\",\n                    &wrapped_new<PointerType, WrapperType, val, ConstructorArgs...>,\n                    allow_raw_pointer<ret_val>())\n                .class_function(\n                    \"extend\",\n                    &wrapped_extend<WrapperType>)\n                ;\n        }\n\n        template<typename ReturnType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& function(const char* methodName, ReturnType (ClassType::*memberFunction)(Args...), Policies...) const {\n            using namespace internal;\n\n            auto invoker = &MethodInvoker<decltype(memberFunction), ReturnType, ClassType*, Args...>::invoke;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, AllowedRawPointer<ClassType>, Args...> args;\n            _embind_register_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoker),\n                reinterpret_cast<GenericFunction>(invoker),\n                getContext(memberFunction),\n                isPureVirtual<Policies...>::value);\n            return *this;\n        }\n\n        template<typename ReturnType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& function(const char* methodName, ReturnType (ClassType::*memberFunction)(Args...) const, Policies...) const {\n            using namespace internal;\n\n            auto invoker = &MethodInvoker<decltype(memberFunction), ReturnType, const ClassType*, Args...>::invoke;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, AllowedRawPointer<const ClassType>, Args...> args;\n            _embind_register_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoker),\n                reinterpret_cast<GenericFunction>(invoker),\n                getContext(memberFunction),\n                isPureVirtual<Policies...>::value);\n            return *this;\n        }\n\n        template<typename ReturnType, typename ThisType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& function(const char* methodName, ReturnType (*function)(ThisType, Args...), Policies...) const {\n            using namespace internal;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, ThisType, Args...> args;\n            auto invoke = &FunctionInvoker<decltype(function), ReturnType, ThisType, Args...>::invoke;\n            _embind_register_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                getContext(function),\n                false);\n            return *this;\n        }\n\n        template<typename FieldType, typename = typename std::enable_if<!std::is_function<FieldType>::value>::type>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, const FieldType ClassType::*field) const {\n            using namespace internal;\n            \n            auto getter = &MemberAccess<ClassType, FieldType>::template getWire<ClassType>;\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                0,\n                0,\n                0,\n                0);\n            return *this;\n        }\n\n        template<typename FieldType, typename = typename std::enable_if<!std::is_function<FieldType>::value>::type>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, FieldType ClassType::*field) const {\n            using namespace internal;\n\n            auto getter = &MemberAccess<ClassType, FieldType>::template getWire<ClassType>;\n            auto setter = &MemberAccess<ClassType, FieldType>::template setWire<ClassType>;\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<FieldType>::get(),\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getContext(field),\n                TypeID<FieldType>::get(),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter),\n                getContext(field));\n            return *this;\n        }\n\n        template<typename Getter>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, Getter getter) const {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            auto gter = &GP::template get<ClassType>;\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(gter),\n                reinterpret_cast<GenericFunction>(gter),\n                GP::getContext(getter),\n                0,\n                0,\n                0,\n                0);\n            return *this;\n        }\n\n        template<typename Getter, typename Setter>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& property(const char* fieldName, Getter getter, Setter setter) const {\n            using namespace internal;\n            typedef GetterPolicy<Getter> GP;\n            typedef SetterPolicy<Setter> SP;\n\n            auto gter = &GP::template get<ClassType>;\n            auto ster = &SP::template set<ClassType>;\n\n            _embind_register_class_property(\n                TypeID<ClassType>::get(),\n                fieldName,\n                TypeID<typename GP::ReturnType>::get(),\n                getSignature(gter),\n                reinterpret_cast<GenericFunction>(gter),\n                GP::getContext(getter),\n                TypeID<typename SP::ArgumentType>::get(),\n                getSignature(ster),\n                reinterpret_cast<GenericFunction>(ster),\n                SP::getContext(setter));\n            return *this;\n        }\n\n        template<typename ReturnType, typename... Args, typename... Policies>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& class_function(const char* methodName, ReturnType (*classMethod)(Args...), Policies...) const {\n            using namespace internal;\n\n            typename WithPolicies<Policies...>::template ArgTypeList<ReturnType, Args...> args;\n            auto invoke = &internal::Invoker<ReturnType, Args...>::invoke;\n            _embind_register_class_class_function(\n                TypeID<ClassType>::get(),\n                methodName,\n                args.getCount(),\n                args.getTypes(),\n                getSignature(invoke),\n                reinterpret_cast<GenericFunction>(invoke),\n                reinterpret_cast<GenericFunction>(classMethod));\n            return *this;\n        }\n\n        template<typename FieldType>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& class_property(const char* name, const FieldType* field) const {\n            using namespace internal;\n\n            auto getter = &GlobalAccess<FieldType>::get;\n            _embind_register_class_class_property(\n                TypeID<ClassType>::get(),\n                name,\n                TypeID<FieldType>::get(),\n                field,\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                0,\n                0);\n            return *this;\n        }\n\n        template<typename FieldType>\n        EMSCRIPTEN_ALWAYS_INLINE const class_& class_property(const char* name, FieldType* field) const {\n            using namespace internal;\n\n            auto getter = &GlobalAccess<FieldType>::get;\n            auto setter = &GlobalAccess<FieldType>::set;\n            _embind_register_class_class_property(\n                TypeID<ClassType>::get(),\n                name,\n                TypeID<FieldType>::get(),\n                field,\n                getSignature(getter),\n                reinterpret_cast<GenericFunction>(getter),\n                getSignature(setter),\n                reinterpret_cast<GenericFunction>(setter));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // VECTORS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename VectorType>\n        struct VectorAccess {\n            static val get(\n                const VectorType& v,\n                typename VectorType::size_type index\n            ) {\n                if (index < v.size()) {\n                    return val(v[index]);\n                } else {\n                    return val::undefined();\n                }\n            }\n\n            static bool set(\n                VectorType& v,\n                typename VectorType::size_type index,\n                const typename VectorType::value_type& value\n            ) {\n                v[index] = value;\n                return true;\n            }\n        };\n    }\n\n    template<typename T>\n    class_<std::vector<T>> register_vector(const char* name) {\n        typedef std::vector<T> VecType;\n\n        void (VecType::*push_back)(const T&) = &VecType::push_back;\n        void (VecType::*resize)(const size_t, const T&) = &VecType::resize;\n        return class_<std::vector<T>>(name)\n            .template constructor<>()\n            .function(\"push_back\", push_back)\n            .function(\"resize\", resize)\n            .function(\"size\", &VecType::size)\n            .function(\"get\", &internal::VectorAccess<VecType>::get)\n            .function(\"set\", &internal::VectorAccess<VecType>::set)\n            ;\n    }\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // MAPS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename MapType>\n        struct MapAccess {\n            static val get(\n                const MapType& m,\n                const typename MapType::key_type& k\n            ) {\n                auto i = m.find(k);\n                if (i == m.end()) {\n                    return val::undefined();\n                } else {\n                    return val(i->second);\n                }\n            }\n\n            static void set(\n                MapType& m,\n                const typename MapType::key_type& k,\n                const typename MapType::mapped_type& v\n            ) {\n                m[k] = v;\n            }\n        };\n    }\n\n    template<typename K, typename V>\n    class_<std::map<K, V>> register_map(const char* name) {\n        typedef std::map<K,V> MapType;\n\n        return class_<MapType>(name)\n            .template constructor<>()\n            .function(\"size\", &MapType::size)\n            .function(\"get\", internal::MapAccess<MapType>::get)\n            .function(\"set\", internal::MapAccess<MapType>::set)\n            ;\n    }\n\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // ENUMS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    template<typename EnumType>\n    class enum_ {\n    public:\n        typedef EnumType enum_type;\n\n        enum_(const char* name) {\n            using namespace internal;\n            _embind_register_enum(\n                internal::TypeID<EnumType>::get(),\n                name,\n                sizeof(EnumType),\n                std::is_signed<typename std::underlying_type<EnumType>::type>::value);\n        }\n\n        enum_& value(const char* name, EnumType value) {\n            using namespace internal;\n            // TODO: there's still an issue here.\n            // if EnumType is an unsigned long, then JS may receive it as a signed long\n            static_assert(sizeof(value) <= sizeof(internal::GenericEnumValue), \"enum type must fit in a GenericEnumValue\");\n\n            _embind_register_enum_value(\n                internal::TypeID<EnumType>::get(),\n                name,\n                static_cast<internal::GenericEnumValue>(value));\n            return *this;\n        }\n    };\n\n    ////////////////////////////////////////////////////////////////////////////////\n    // CONSTANTS\n    ////////////////////////////////////////////////////////////////////////////////\n\n    namespace internal {\n        template<typename T>\n        uintptr_t asGenericValue(T t) {\n            return static_cast<uintptr_t>(t);\n        }\n\n        template<typename T>\n        uintptr_t asGenericValue(T* p) {\n            return reinterpret_cast<uintptr_t>(p);\n        }\n    }\n\n    template<typename ConstantType>\n    void constant(const char* name, const ConstantType& v) {\n        using namespace internal;\n        typedef BindingType<const ConstantType&> BT;\n        _embind_register_constant(\n            name,\n            TypeID<const ConstantType&>::get(),\n            asGenericValue(BT::toWireType(v)));\n    }\n}\n\n#define EMSCRIPTEN_BINDINGS(name)                                       \\\n    static struct EmscriptenBindingInitializer_##name {                 \\\n        EmscriptenBindingInitializer_##name();                          \\\n    } EmscriptenBindingInitializer_##name##_instance;                   \\\n    EmscriptenBindingInitializer_##name::EmscriptenBindingInitializer_##name()\n","// -*- C++ -*-\n//===--------------------------- string -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is distributed under the University of Illinois Open Source\n// License. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STRING\n#define _LIBCPP_STRING\n\n/*\n    string synopsis\n\nnamespace std\n{\n\ntemplate <class stateT>\nclass fpos\n{\nprivate:\n    stateT st;\npublic:\n    fpos(streamoff = streamoff());\n\n    operator streamoff() const;\n\n    stateT state() const;\n    void state(stateT);\n\n    fpos& operator+=(streamoff);\n    fpos  operator+ (streamoff) const;\n    fpos& operator-=(streamoff);\n    fpos  operator- (streamoff) const;\n};\n\ntemplate <class stateT> streamoff operator-(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class stateT> bool operator==(const fpos<stateT>& x, const fpos<stateT>& y);\ntemplate <class stateT> bool operator!=(const fpos<stateT>& x, const fpos<stateT>& y);\n\ntemplate <class charT>\nstruct char_traits\n{\n    typedef charT     char_type;\n    typedef ...       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static void assign(char_type& c1, const char_type& c2) noexcept;\n    static constexpr bool eq(char_type c1, char_type c2) noexcept;\n    static constexpr bool lt(char_type c1, char_type c2) noexcept;\n\n    static int              compare(const char_type* s1, const char_type* s2, size_t n);\n    static size_t           length(const char_type* s);\n    static const char_type* find(const char_type* s, size_t n, const char_type& a);\n    static char_type*       move(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       copy(char_type* s1, const char_type* s2, size_t n);\n    static char_type*       assign(char_type* s, size_t n, char_type a);\n\n    static constexpr int_type  not_eof(int_type c) noexcept;\n    static constexpr char_type to_char_type(int_type c) noexcept;\n    static constexpr int_type  to_int_type(char_type c) noexcept;\n    static constexpr bool      eq_int_type(int_type c1, int_type c2) noexcept;\n    static constexpr int_type  eof() noexcept;\n};\n\ntemplate <> struct char_traits<char>;\ntemplate <> struct char_traits<wchar_t>;\n\ntemplate<class charT, class traits = char_traits<charT>, class Allocator = allocator<charT> >\nclass basic_string\n{\npublic:\n// types:\n    typedef traits traits_type;\n    typedef typename traits_type::char_type value_type;\n    typedef Allocator allocator_type;\n    typedef typename allocator_type::size_type size_type;\n    typedef typename allocator_type::difference_type difference_type;\n    typedef typename allocator_type::reference reference;\n    typedef typename allocator_type::const_reference const_reference;\n    typedef typename allocator_type::pointer pointer;\n    typedef typename allocator_type::const_pointer const_pointer;\n    typedef implementation-defined iterator;\n    typedef implementation-defined const_iterator;\n    typedef std::reverse_iterator<iterator> reverse_iterator;\n    typedef std::reverse_iterator<const_iterator> const_reverse_iterator;\n\n    static const size_type npos = -1;\n\n    basic_string()\n        noexcept(is_nothrow_default_constructible<allocator_type>::value);\n    explicit basic_string(const allocator_type& a);\n    basic_string(const basic_string& str);\n    basic_string(basic_string&& str)\n        noexcept(is_nothrow_move_constructible<allocator_type>::value);\n    basic_string(const basic_string& str, size_type pos, size_type n = npos,\n                 const allocator_type& a = allocator_type());\n    basic_string(const value_type* s, const allocator_type& a = allocator_type());\n    basic_string(const value_type* s, size_type n, const allocator_type& a = allocator_type());\n    basic_string(size_type n, value_type c, const allocator_type& a = allocator_type());\n    template<class InputIterator>\n        basic_string(InputIterator begin, InputIterator end,\n                     const allocator_type& a = allocator_type());\n    basic_string(initializer_list<value_type>, const Allocator& = Allocator());\n    basic_string(const basic_string&, const Allocator&);\n    basic_string(basic_string&&, const Allocator&);\n\n    ~basic_string();\n\n    basic_string& operator=(const basic_string& str);\n    basic_string& operator=(basic_string&& str)\n        noexcept(\n             allocator_type::propagate_on_container_move_assignment::value &&\n             is_nothrow_move_assignable<allocator_type>::value);\n    basic_string& operator=(const value_type* s);\n    basic_string& operator=(value_type c);\n    basic_string& operator=(initializer_list<value_type>);\n\n    iterator       begin() noexcept;\n    const_iterator begin() const noexcept;\n    iterator       end() noexcept;\n    const_iterator end() const noexcept;\n\n    reverse_iterator       rbegin() noexcept;\n    const_reverse_iterator rbegin() const noexcept;\n    reverse_iterator       rend() noexcept;\n    const_reverse_iterator rend() const noexcept;\n\n    const_iterator         cbegin() const noexcept;\n    const_iterator         cend() const noexcept;\n    const_reverse_iterator crbegin() const noexcept;\n    const_reverse_iterator crend() const noexcept;\n\n    size_type size() const noexcept;\n    size_type length() const noexcept;\n    size_type max_size() const noexcept;\n    size_type capacity() const noexcept;\n\n    void resize(size_type n, value_type c);\n    void resize(size_type n);\n\n    void reserve(size_type res_arg = 0);\n    void shrink_to_fit();\n    void clear() noexcept;\n    bool empty() const noexcept;\n\n    const_reference operator[](size_type pos) const;\n    reference       operator[](size_type pos);\n\n    const_reference at(size_type n) const;\n    reference       at(size_type n);\n\n    basic_string& operator+=(const basic_string& str);\n    basic_string& operator+=(const value_type* s);\n    basic_string& operator+=(value_type c);\n    basic_string& operator+=(initializer_list<value_type>);\n\n    basic_string& append(const basic_string& str);\n    basic_string& append(const basic_string& str, size_type pos, size_type n=npos); //C++14\n    basic_string& append(const value_type* s, size_type n);\n    basic_string& append(const value_type* s);\n    basic_string& append(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& append(InputIterator first, InputIterator last);\n    basic_string& append(initializer_list<value_type>);\n\n    void push_back(value_type c);\n    void pop_back();\n    reference       front();\n    const_reference front() const;\n    reference       back();\n    const_reference back() const;\n\n    basic_string& assign(const basic_string& str);\n    basic_string& assign(basic_string&& str);\n    basic_string& assign(const basic_string& str, size_type pos, size_type n=npos); // C++14\n    basic_string& assign(const value_type* s, size_type n);\n    basic_string& assign(const value_type* s);\n    basic_string& assign(size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& assign(InputIterator first, InputIterator last);\n    basic_string& assign(initializer_list<value_type>);\n\n    basic_string& insert(size_type pos1, const basic_string& str);\n    basic_string& insert(size_type pos1, const basic_string& str,\n                         size_type pos2, size_type n);\n    basic_string& insert(size_type pos, const value_type* s, size_type n=npos); //C++14\n    basic_string& insert(size_type pos, const value_type* s);\n    basic_string& insert(size_type pos, size_type n, value_type c);\n    iterator      insert(const_iterator p, value_type c);\n    iterator      insert(const_iterator p, size_type n, value_type c);\n    template<class InputIterator>\n        iterator insert(const_iterator p, InputIterator first, InputIterator last);\n    iterator      insert(const_iterator p, initializer_list<value_type>);\n\n    basic_string& erase(size_type pos = 0, size_type n = npos);\n    iterator      erase(const_iterator position);\n    iterator      erase(const_iterator first, const_iterator last);\n\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str);\n    basic_string& replace(size_type pos1, size_type n1, const basic_string& str,\n                          size_type pos2, size_type n2=npos); // C++14\n    basic_string& replace(size_type pos, size_type n1, const value_type* s, size_type n2);\n    basic_string& replace(size_type pos, size_type n1, const value_type* s);\n    basic_string& replace(size_type pos, size_type n1, size_type n2, value_type c);\n    basic_string& replace(const_iterator i1, const_iterator i2, const basic_string& str);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s, size_type n);\n    basic_string& replace(const_iterator i1, const_iterator i2, const value_type* s);\n    basic_string& replace(const_iterator i1, const_iterator i2, size_type n, value_type c);\n    template<class InputIterator>\n        basic_string& replace(const_iterator i1, const_iterator i2, InputIterator j1, InputIterator j2);\n    basic_string& replace(const_iterator i1, const_iterator i2, initializer_list<value_type>);\n\n    size_type copy(value_type* s, size_type n, size_type pos = 0) const;\n    basic_string substr(size_type pos = 0, size_type n = npos) const;\n\n    void swap(basic_string& str)\n        noexcept(!allocator_type::propagate_on_container_swap::value ||\n                 __is_nothrow_swappable<allocator_type>::value)\n\n    const value_type* c_str() const noexcept;\n    const value_type* data() const noexcept;\n\n    allocator_type get_allocator() const noexcept;\n\n    size_type find(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find(value_type c, size_type pos = 0) const noexcept;\n\n    size_type rfind(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type rfind(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type rfind(const value_type* s, size_type pos = npos) const noexcept;\n    size_type rfind(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_of(value_type c, size_type pos = npos) const noexcept;\n\n    size_type find_first_not_of(const basic_string& str, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_first_not_of(const value_type* s, size_type pos = 0) const noexcept;\n    size_type find_first_not_of(value_type c, size_type pos = 0) const noexcept;\n\n    size_type find_last_not_of(const basic_string& str, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos, size_type n) const noexcept;\n    size_type find_last_not_of(const value_type* s, size_type pos = npos) const noexcept;\n    size_type find_last_not_of(value_type c, size_type pos = npos) const noexcept;\n\n    int compare(const basic_string& str) const noexcept;\n    int compare(size_type pos1, size_type n1, const basic_string& str) const;\n    int compare(size_type pos1, size_type n1, const basic_string& str,\n                size_type pos2, size_type n2=npos) const; // C++14\n    int compare(const value_type* s) const noexcept;\n    int compare(size_type pos1, size_type n1, const value_type* s) const;\n    int compare(size_type pos1, size_type n1, const value_type* s, size_type n2) const;\n\n    bool __invariants() const;\n};\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs,\n          const basic_string<charT, traits, Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const charT* lhs , const basic_string<charT,traits,Allocator>&rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(charT lhs, const basic_string<charT,traits,Allocator>& rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_string<charT, traits, Allocator>\noperator+(const basic_string<charT, traits, Allocator>& lhs, charT rhs);\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator==(const basic_string<charT,traits,Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT,traits,Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator!=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator< (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator> (const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator<=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs,\n                const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const basic_string<charT, traits, Allocator>& lhs, const charT* rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nbool operator>=(const charT* lhs, const basic_string<charT, traits, Allocator>& rhs) noexcept;\n\ntemplate<class charT, class traits, class Allocator>\nvoid swap(basic_string<charT, traits, Allocator>& lhs,\n          basic_string<charT, traits, Allocator>& rhs)\n            noexcept(noexcept(lhs.swap(rhs)));\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\noperator>>(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_ostream<charT, traits>&\noperator<<(basic_ostream<charT, traits>& os, const basic_string<charT, traits, Allocator>& str);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str,\n        charT delim);\n\ntemplate<class charT, class traits, class Allocator>\nbasic_istream<charT, traits>&\ngetline(basic_istream<charT, traits>& is, basic_string<charT, traits, Allocator>& str);\n\ntypedef basic_string<char>    string;\ntypedef basic_string<wchar_t> wstring;\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\nint                stoi  (const string& str, size_t* idx = 0, int base = 10);\nlong               stol  (const string& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const string& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const string& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const string& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const string& str, size_t* idx = 0);\ndouble      stod (const string& str, size_t* idx = 0);\nlong double stold(const string& str, size_t* idx = 0);\n\nstring to_string(int val);\nstring to_string(unsigned val);\nstring to_string(long val);\nstring to_string(unsigned long val);\nstring to_string(long long val);\nstring to_string(unsigned long long val);\nstring to_string(float val);\nstring to_string(double val);\nstring to_string(long double val);\n\nint                stoi  (const wstring& str, size_t* idx = 0, int base = 10);\nlong               stol  (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long      stoul (const wstring& str, size_t* idx = 0, int base = 10);\nlong long          stoll (const wstring& str, size_t* idx = 0, int base = 10);\nunsigned long long stoull(const wstring& str, size_t* idx = 0, int base = 10);\n\nfloat       stof (const wstring& str, size_t* idx = 0);\ndouble      stod (const wstring& str, size_t* idx = 0);\nlong double stold(const wstring& str, size_t* idx = 0);\n\nwstring to_wstring(int val);\nwstring to_wstring(unsigned val);\nwstring to_wstring(long val);\nwstring to_wstring(unsigned long val);\nwstring to_wstring(long long val);\nwstring to_wstring(unsigned long long val);\nwstring to_wstring(float val);\nwstring to_wstring(double val);\nwstring to_wstring(long double val);\n\ntemplate <> struct hash<string>;\ntemplate <> struct hash<u16string>;\ntemplate <> struct hash<u32string>;\ntemplate <> struct hash<wstring>;\n\nbasic_string<char>     operator \"\" s( const char *str,     size_t len ); // C++14\nbasic_string<wchar_t>  operator \"\" s( const wchar_t *str,  size_t len ); // C++14\nbasic_string<char16_t> operator \"\" s( const char16_t *str, size_t len ); // C++14\nbasic_string<char32_t> operator \"\" s( const char32_t *str, size_t len ); // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <cstring>\n#include <cstdio>  // For EOF.\n#include <cwchar>\n#include <algorithm>\n#include <iterator>\n#include <utility>\n#include <memory>\n#include <stdexcept>\n#include <type_traits>\n#include <initializer_list>\n#include <__functional_base>\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n#include <cstdint>\n#endif\n#if defined(_LIBCPP_NO_EXCEPTIONS)\n#include <cassert>\n#endif\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// fpos\n\ntemplate <class _StateT>\nclass _LIBCPP_TYPE_VIS_ONLY fpos\n{\nprivate:\n    _StateT __st_;\n    streamoff __off_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY fpos(streamoff __off = streamoff()) : __st_(), __off_(__off) {}\n\n    _LIBCPP_INLINE_VISIBILITY operator streamoff() const {return __off_;}\n\n    _LIBCPP_INLINE_VISIBILITY _StateT state() const {return __st_;}\n    _LIBCPP_INLINE_VISIBILITY void state(_StateT __st) {__st_ = __st;}\n\n    _LIBCPP_INLINE_VISIBILITY fpos& operator+=(streamoff __off) {__off_ += __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator+ (streamoff __off) const {fpos __t(*this); __t += __off; return __t;}\n    _LIBCPP_INLINE_VISIBILITY fpos& operator-=(streamoff __off) {__off_ -= __off; return *this;}\n    _LIBCPP_INLINE_VISIBILITY fpos  operator- (streamoff __off) const {fpos __t(*this); __t -= __off; return __t;}\n};\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamoff operator-(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) - streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator==(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) == streamoff(__y);}\n\ntemplate <class _StateT>\ninline _LIBCPP_INLINE_VISIBILITY\nbool operator!=(const fpos<_StateT>& __x, const fpos<_StateT>& __y)\n    {return streamoff(__x) != streamoff(__y);}\n\n// char_traits\n\ntemplate <class _CharT>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits\n{\n    typedef _CharT    char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    static size_t           length(const char_type* __s);\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type  to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool      eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\ntemplate <class _CharT>\nint\nchar_traits<_CharT>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\nchar_traits<_CharT>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\nconst _CharT*\nchar_traits<_CharT>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ntemplate <class _CharT>\n_CharT*\nchar_traits<_CharT>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT*\nchar_traits<_CharT>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n_CharT*\nchar_traits<_CharT>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n// char_traits<char>\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<char>\n{\n    typedef char      char_type;\n    typedef int       int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n            {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return (unsigned char)__c1 < (unsigned char)__c2;}\n\n    static inline int compare(const char_type* __s1, const char_type* __s2, size_t __n)\n        {return memcmp(__s1, __s2, __n);}\n    static inline size_t length(const char_type* __s) {return strlen(__s);}\n    static inline const char_type* find(const char_type* __s, size_t __n, const char_type& __a)\n        {return (const char_type*)memchr(__s, to_int_type(__a), __n);}\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n)\n        {return (char_type*)memmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return (char_type*)memcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a)\n        {return (char_type*)memset(__s, to_int_type(__a), __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type((unsigned char)__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type  eof() _NOEXCEPT\n        {return int_type(EOF);}\n};\n\n// char_traits<wchar_t>\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<wchar_t>\n{\n    typedef wchar_t   char_type;\n    typedef wint_t    int_type;\n    typedef streamoff off_type;\n    typedef streampos pos_type;\n    typedef mbstate_t state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static inline int compare(const char_type* __s1, const char_type* __s2, size_t __n)\n        {return wmemcmp(__s1, __s2, __n);}\n    static inline size_t length(const char_type* __s)\n        {return wcslen(__s);}\n    static inline const char_type* find(const char_type* __s, size_t __n, const char_type& __a)\n        {return (const char_type*)wmemchr(__s, __a, __n);}\n    static inline char_type* move(char_type* __s1, const char_type* __s2, size_t __n)\n        {return (char_type*)wmemmove(__s1, __s2, __n);}\n    static inline char_type* copy(char_type* __s1, const char_type* __s2, size_t __n)\n        {\n            _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n            return (char_type*)wmemcpy(__s1, __s2, __n);\n        }\n    static inline char_type* assign(char_type* __s, size_t __n, char_type __a)\n        {return (char_type*)wmemset(__s, __a, __n);}\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(WEOF);}\n};\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<char16_t>\n{\n    typedef char16_t       char_type;\n    typedef uint_least16_t int_type;\n    typedef streamoff      off_type;\n    typedef u16streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    static size_t           length(const char_type* __s);\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xDFFF);}\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\nint\nchar_traits<char16_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\nchar_traits<char16_t>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nconst char16_t*\nchar_traits<char16_t>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar16_t*\nchar_traits<char16_t>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar16_t*\nchar_traits<char16_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar16_t*\nchar_traits<char16_t>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY char_traits<char32_t>\n{\n    typedef char32_t       char_type;\n    typedef uint_least32_t int_type;\n    typedef streamoff      off_type;\n    typedef u32streampos   pos_type;\n    typedef mbstate_t      state_type;\n\n    static inline void assign(char_type& __c1, const char_type& __c2) _NOEXCEPT\n        {__c1 = __c2;}\n    static inline _LIBCPP_CONSTEXPR bool eq(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR bool lt(char_type __c1, char_type __c2) _NOEXCEPT\n        {return __c1 < __c2;}\n\n    static int              compare(const char_type* __s1, const char_type* __s2, size_t __n);\n    static size_t           length(const char_type* __s);\n    static const char_type* find(const char_type* __s, size_t __n, const char_type& __a);\n    static char_type*       move(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       copy(char_type* __s1, const char_type* __s2, size_t __n);\n    static char_type*       assign(char_type* __s, size_t __n, char_type __a);\n\n    static inline _LIBCPP_CONSTEXPR int_type  not_eof(int_type __c) _NOEXCEPT\n        {return eq_int_type(__c, eof()) ? ~eof() : __c;}\n    static inline _LIBCPP_CONSTEXPR char_type to_char_type(int_type __c) _NOEXCEPT\n        {return char_type(__c);}\n    static inline _LIBCPP_CONSTEXPR int_type to_int_type(char_type __c) _NOEXCEPT\n        {return int_type(__c);}\n    static inline _LIBCPP_CONSTEXPR bool eq_int_type(int_type __c1, int_type __c2) _NOEXCEPT\n        {return __c1 == __c2;}\n    static inline _LIBCPP_CONSTEXPR int_type eof() _NOEXCEPT\n        {return int_type(0xFFFFFFFF);}\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\nint\nchar_traits<char32_t>::compare(const char_type* __s1, const char_type* __s2, size_t __n)\n{\n    for (; __n; --__n, ++__s1, ++__s2)\n    {\n        if (lt(*__s1, *__s2))\n            return -1;\n        if (lt(*__s2, *__s1))\n            return 1;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nsize_t\nchar_traits<char32_t>::length(const char_type* __s)\n{\n    size_t __len = 0;\n    for (; !eq(*__s, char_type(0)); ++__s)\n        ++__len;\n    return __len;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nconst char32_t*\nchar_traits<char32_t>::find(const char_type* __s, size_t __n, const char_type& __a)\n{\n    for (; __n; --__n)\n    {\n        if (eq(*__s, __a))\n            return __s;\n        ++__s;\n    }\n    return 0;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar32_t*\nchar_traits<char32_t>::move(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    char_type* __r = __s1;\n    if (__s1 < __s2)\n    {\n        for (; __n; --__n, ++__s1, ++__s2)\n            assign(*__s1, *__s2);\n    }\n    else if (__s2 < __s1)\n    {\n        __s1 += __n;\n        __s2 += __n;\n        for (; __n; --__n)\n            assign(*--__s1, *--__s2);\n    }\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar32_t*\nchar_traits<char32_t>::copy(char_type* __s1, const char_type* __s2, size_t __n)\n{\n    _LIBCPP_ASSERT(__s2 < __s1 || __s2 >= __s1+__n, \"char_traits::copy overlapped range\");\n    char_type* __r = __s1;\n    for (; __n; --__n, ++__s1, ++__s2)\n        assign(*__s1, *__s2);\n    return __r;\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nchar32_t*\nchar_traits<char32_t>::assign(char_type* __s, size_t __n, char_type __a)\n{\n    char_type* __r = __s;\n    for (; __n; --__n, ++__s)\n        assign(*__s, __a);\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n// helper fns for basic_string\n\n// __str_find\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n             _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos >= __sz)\n        return __npos;\n    const _CharT* __r = _Traits::find(__p + __pos, __sz - __pos, __c);\n    if (__r == 0)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find(const _CharT *__p, _SizeT __sz, \n       const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos > __sz || __sz - __pos < __n)\n        return __npos;\n    if (__n == 0)\n        return __pos;\n    const _CharT* __r = \n        _VSTD::__search(__p + __pos, __p + __sz,\n                        __s, __s + __n, _Traits::eq,\n                        random_access_iterator_tag(), random_access_iterator_tag());\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_rfind\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n              _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__sz < 1)\n        return __npos;\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n    {\n        if (_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_rfind(const _CharT *__p, _SizeT __sz, \n        const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    __pos = _VSTD::min(__pos, __sz);\n    if (__n < __sz - __pos)\n        __pos += __n;\n    else\n        __pos = __sz;\n    const _CharT* __r = _VSTD::__find_end(\n                  __p, __p + __pos, __s, __s + __n, _Traits::eq, \n                        random_access_iterator_tag(), random_access_iterator_tag());\n    if (__n > 0 && __r == __p + __pos)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n// __str_find_first_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_of(const _CharT *__p, _SizeT __sz,\n                const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos >= __sz || __n == 0)\n        return __npos;\n    const _CharT* __r = _VSTD::__find_first_of_ce\n        (__p + __pos, __p + __sz, __s, __s + __n, _Traits::eq );\n    if (__r == __p + __sz)\n        return __npos;\n    return static_cast<_SizeT>(__r - __p);\n}\n\n\n// __str_find_last_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY \n__str_find_last_of(const _CharT *__p, _SizeT __sz,\n               const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n    {\n    if (__n != 0)\n    {\n        if (__pos < __sz)\n            ++__pos;\n        else\n            __pos = __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        {\n            const _CharT* __r = _Traits::find(__s, __n, *--__ps);\n            if (__r)\n                return static_cast<_SizeT>(__ps - __p);\n        }\n    }\n    return __npos;\n}\n\n\n// __str_find_first_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                    const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (_Traits::find(__s, __n, *__ps) == 0)\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_first_not_of(const _CharT *__p, _SizeT __sz,\n                          _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n    {\n        const _CharT* __pe = __p + __sz;\n        for (const _CharT* __ps = __p + __pos; __ps != __pe; ++__ps)\n            if (!_Traits::eq(*__ps, __c))\n                return static_cast<_SizeT>(__ps - __p);\n    }\n    return __npos;\n}\n\n\n// __str_find_last_not_of\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                   const _CharT* __s, _SizeT __pos, _SizeT __n) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (_Traits::find(__s, __n, *--__ps) == 0)\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\n\ntemplate<class _CharT, class _SizeT, class _Traits, _SizeT __npos>\n_SizeT _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n__str_find_last_not_of(const _CharT *__p, _SizeT __sz,\n                         _CharT __c, _SizeT __pos) _NOEXCEPT\n{\n    if (__pos < __sz)\n        ++__pos;\n    else\n        __pos = __sz;\n    for (const _CharT* __ps = __p + __pos; __ps != __p;)\n        if (!_Traits::eq(*--__ps, __c))\n            return static_cast<_SizeT>(__ps - __p);\n    return __npos;\n}\n\ntemplate<class _Ptr>\nsize_t _LIBCPP_INLINE_VISIBILITY __do_string_hash(_Ptr __p, _Ptr __e)\n{\n    typedef typename iterator_traits<_Ptr>::value_type value_type;\n    return __murmur2_or_cityhash<size_t>()(__p, (__e-__p)*sizeof(value_type));\n}\n\n// basic_string\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x,\n          const basic_string<_CharT, _Traits, _Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __x, const basic_string<_CharT,_Traits,_Allocator>& __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, const _CharT* __y);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __x, _CharT __y);\n\ntemplate <bool>\nclass _LIBCPP_TYPE_VIS_ONLY __basic_string_common\n{\nprotected:\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_length_error() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw length_error(\"basic_string\");\n#else\n    assert(!\"basic_string length_error\");\n#endif\n}\n\ntemplate <bool __b>\nvoid\n__basic_string_common<__b>::__throw_out_of_range() const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    throw out_of_range(\"basic_string\");\n#else\n    assert(!\"basic_string out_of_range\");\n#endif\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231 )\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS __basic_string_common<true>)\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif // _LIBCPP_MSVC\n\n#ifdef _LIBCPP_ALTERNATE_STRING_LAYOUT\n\ntemplate <class _CharT, size_t = sizeof(_CharT)>\nstruct __padding\n{\n    unsigned char __xx[sizeof(_CharT)-1];\n};\n\ntemplate <class _CharT>\nstruct __padding<_CharT, 1>\n{\n};\n\n#endif  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nclass _LIBCPP_TYPE_VIS_ONLY basic_string\n    : private __basic_string_common<true>\n{\npublic:\n    typedef basic_string                                 __self;\n    typedef _Traits                                      traits_type;\n    typedef typename traits_type::char_type              value_type;\n    typedef _Allocator                                   allocator_type;\n    typedef allocator_traits<allocator_type>             __alloc_traits;\n    typedef typename __alloc_traits::size_type           size_type;\n    typedef typename __alloc_traits::difference_type     difference_type;\n    typedef value_type&                                  reference;\n    typedef const value_type&                            const_reference;\n    typedef typename __alloc_traits::pointer             pointer;\n    typedef typename __alloc_traits::const_pointer       const_pointer;\n\n    static_assert(is_pod<value_type>::value, \"Character type of basic_string must be a POD\");\n    static_assert((is_same<_CharT, value_type>::value),\n                  \"traits_type::char_type must be the same type as CharT\");\n    static_assert((is_same<typename allocator_type::value_type, value_type>::value),\n                  \"Allocator::value_type must be same type as value_type\");\n#if defined(_LIBCPP_RAW_ITERATORS)\n    typedef pointer                                      iterator;\n    typedef const_pointer                                const_iterator;\n#else  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef __wrap_iter<pointer>                         iterator;\n    typedef __wrap_iter<const_pointer>                   const_iterator;\n#endif  // defined(_LIBCPP_RAW_ITERATORS)\n    typedef _VSTD::reverse_iterator<iterator>             reverse_iterator;\n    typedef _VSTD::reverse_iterator<const_iterator>       const_reverse_iterator;\n\nprivate:\n\n#ifdef _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    struct __long\n    {\n        pointer   __data_;\n        size_type __size_;\n        size_type __cap_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        value_type __data_[__min_cap];\n        struct\n            : __padding<value_type>\n        {\n            unsigned char __size_;\n        };\n    };\n\n#else\n\n    struct __long\n    {\n        size_type __cap_;\n        size_type __size_;\n        pointer   __data_;\n    };\n\n#if _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x80};\n    enum {__long_mask  = ~(size_type(~0) >> 1)};\n#else  // _LIBCPP_BIG_ENDIAN\n    enum {__short_mask = 0x01};\n    enum {__long_mask  = 0x1ul};\n#endif  // _LIBCPP_BIG_ENDIAN\n\n    enum {__min_cap = (sizeof(__long) - 1)/sizeof(value_type) > 2 ?\n                      (sizeof(__long) - 1)/sizeof(value_type) : 2};\n\n    struct __short\n    {\n        union\n        {\n            unsigned char __size_;\n            value_type __lx;\n        };\n        value_type __data_[__min_cap];\n    };\n\n#endif  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    union __ulx{__long __lx; __short __lxx;};\n\n    enum {__n_words = sizeof(__ulx) / sizeof(size_type)};\n\n    struct __raw\n    {\n        size_type __words[__n_words];\n    };\n\n    struct __rep\n    {\n        union\n        {\n            __long  __l;\n            __short __s;\n            __raw   __r;\n        };\n    };\n\n    __compressed_pair<__rep, allocator_type> __r_;\n\npublic:\n    static const size_type npos = -1;\n\n    _LIBCPP_INLINE_VISIBILITY basic_string()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY explicit basic_string(const allocator_type& __a);\n    basic_string(const basic_string& __str);\n    basic_string(const basic_string& __str, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(basic_string&& __str, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY basic_string(const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(const value_type* __s, size_type __n, const allocator_type& __a);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(size_type __n, value_type __c, const allocator_type& __a);\n    basic_string(const basic_string& __str, size_type __pos, size_type __n = npos,\n                 const allocator_type& __a = allocator_type());\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last);\n    template<class _InputIterator>\n        _LIBCPP_INLINE_VISIBILITY\n        basic_string(_InputIterator __first, _InputIterator __last, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string(initializer_list<value_type> __il, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    ~basic_string();\n\n    basic_string& operator=(const basic_string& __str);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(basic_string&& __str)\n        _NOEXCEPT_(__alloc_traits::propagate_on_container_move_assignment::value &&\n                   is_nothrow_move_assignable<allocator_type>::value);\n#endif\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator=(const value_type* __s) {return assign(__s);}\n    basic_string& operator=(value_type __c);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& operator=(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(this, __get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(this, __get_pointer() + size());}\n#else\n    _LIBCPP_INLINE_VISIBILITY\n    iterator begin() _NOEXCEPT\n        {return iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin() const _NOEXCEPT\n        {return const_iterator(__get_pointer());}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator end() _NOEXCEPT\n        {return iterator(__get_pointer() + size());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end() const _NOEXCEPT\n        {return const_iterator(__get_pointer() + size());}\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rbegin() _NOEXCEPT\n        {return reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rbegin() const _NOEXCEPT\n        {return const_reverse_iterator(end());}\n    _LIBCPP_INLINE_VISIBILITY\n    reverse_iterator rend() _NOEXCEPT\n        {return reverse_iterator(begin());}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator rend() const _NOEXCEPT\n        {return const_reverse_iterator(begin());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT\n        {return begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend() const _NOEXCEPT\n        {return end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crbegin() const _NOEXCEPT\n        {return rbegin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_reverse_iterator crend() const _NOEXCEPT\n        {return rend();}\n\n    _LIBCPP_INLINE_VISIBILITY size_type size() const _NOEXCEPT\n        {return __is_long() ? __get_long_size() : __get_short_size();}\n    _LIBCPP_INLINE_VISIBILITY size_type length() const _NOEXCEPT {return size();}\n    _LIBCPP_INLINE_VISIBILITY size_type max_size() const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const _NOEXCEPT\n        {return (__is_long() ? __get_long_cap() : __min_cap) - 1;}\n\n    void resize(size_type __n, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY void resize(size_type __n) {resize(__n, value_type());}\n\n    void reserve(size_type res_arg = 0);\n    _LIBCPP_INLINE_VISIBILITY\n    void shrink_to_fit() _NOEXCEPT {reserve();}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY bool empty() const _NOEXCEPT {return size() == 0;}\n\n    _LIBCPP_INLINE_VISIBILITY const_reference operator[](size_type __pos) const;\n    _LIBCPP_INLINE_VISIBILITY reference       operator[](size_type __pos);\n\n    const_reference at(size_type __n) const;\n    reference       at(size_type __n);\n\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const basic_string& __str) {return append(__str);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(const value_type* __s)         {return append(__s);}\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(value_type __c)            {push_back(__c); return *this;}\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY basic_string& operator+=(initializer_list<value_type> __il) {return append(__il);}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(const basic_string& __str);\n    basic_string& append(const basic_string& __str, size_type __pos, size_type __n=npos);\n    basic_string& append(const value_type* __s, size_type __n);\n    basic_string& append(const value_type* __s);\n    basic_string& append(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        append(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        append(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& append(initializer_list<value_type> __il) {return append(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    void push_back(value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    void pop_back();\n    _LIBCPP_INLINE_VISIBILITY reference       front();\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const;\n    _LIBCPP_INLINE_VISIBILITY reference       back();\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(const basic_string& __str);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(basic_string&& str)\n        {*this = _VSTD::move(str); return *this;}\n#endif\n    basic_string& assign(const basic_string& __str, size_type __pos, size_type __n=npos);\n    basic_string& assign(const value_type* __s, size_type __n);\n    basic_string& assign(const value_type* __s);\n    basic_string& assign(size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        assign(_InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            basic_string&\n        >::type\n        assign(_ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& assign(initializer_list<value_type> __il) {return assign(__il.begin(), __il.size());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& insert(size_type __pos1, const basic_string& __str);\n    basic_string& insert(size_type __pos1, const basic_string& __str, size_type __pos2, size_type __n=npos);\n    basic_string& insert(size_type __pos, const value_type* __s, size_type __n);\n    basic_string& insert(size_type __pos, const value_type* __s);\n    basic_string& insert(size_type __pos, size_type __n, value_type __c);\n    iterator      insert(const_iterator __pos, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      insert(const_iterator __pos, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n             __is_input_iterator  <_InputIterator>::value &&\n            !__is_forward_iterator<_InputIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _InputIterator __first, _InputIterator __last);\n    template<class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            iterator\n        >::type\n        insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __pos, initializer_list<value_type> __il)\n                    {return insert(__pos, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    basic_string& erase(size_type __pos = 0, size_type __n = npos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __pos);\n    _LIBCPP_INLINE_VISIBILITY\n    iterator      erase(const_iterator __first, const_iterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str);\n    basic_string& replace(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2);\n    basic_string& replace(size_type __pos, size_type __n1, const value_type* __s);\n    basic_string& replace(size_type __pos, size_type __n1, size_type __n2, value_type __c);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const basic_string& __str);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, const value_type* __s);\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c);\n    template<class _InputIterator>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIterator>::value,\n            basic_string&\n        >::type\n        replace(const_iterator __i1, const_iterator __i2, _InputIterator __j1, _InputIterator __j2);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string& replace(const_iterator __i1, const_iterator __i2, initializer_list<value_type> __il)\n        {return replace(__i1, __i2, __il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    size_type copy(value_type* __s, size_type __n, size_type __pos = 0) const;\n    _LIBCPP_INLINE_VISIBILITY\n    basic_string substr(size_type __pos = 0, size_type __n = npos) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(basic_string& __str)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value);\n\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* c_str() const _NOEXCEPT {return data();}\n    _LIBCPP_INLINE_VISIBILITY\n    const value_type* data() const _NOEXCEPT  {return _VSTD::__to_raw_pointer(__get_pointer());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT {return __alloc();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    size_type find(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type rfind(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    size_type rfind(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type find_last_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const basic_string& __str, size_type __pos = 0) const _NOEXCEPT;\n    size_type find_first_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(const value_type* __s, size_type __pos = 0) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_first_not_of(value_type __c, size_type __pos = 0) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const basic_string& __str, size_type __pos = npos) const _NOEXCEPT;\n    size_type find_last_not_of(const value_type* __s, size_type __pos, size_type __n) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(const value_type* __s, size_type __pos = npos) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    size_type find_last_not_of(value_type __c, size_type __pos = npos) const _NOEXCEPT;\n\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(const basic_string& __str) const _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str) const;\n    int compare(size_type __pos1, size_type __n1, const basic_string& __str, size_type __pos2, size_type __n2=npos) const;\n    int compare(const value_type* __s) const _NOEXCEPT;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s) const;\n    int compare(size_type __pos1, size_type __n1, const value_type* __s, size_type __n2) const;\n\n    _LIBCPP_INLINE_VISIBILITY bool __invariants() const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool __is_long() const _NOEXCEPT\n        {return bool(__r_.first().__s.__size_ & __short_mask);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const;\n    bool __decrementable(const const_iterator* __i) const;\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const;\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const;\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type& __alloc() _NOEXCEPT\n        {return __r_.second();}\n    _LIBCPP_INLINE_VISIBILITY\n    const allocator_type& __alloc() const _NOEXCEPT\n        {return __r_.second();}\n\n#ifdef _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_ >> 1;}\n#   else\n        {return __r_.first().__s.__size_;}\n#   endif\n\n#else  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_short_size(size_type __s) _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {__r_.first().__s.__size_ = (unsigned char)(__s);}\n#   else\n        {__r_.first().__s.__size_ = (unsigned char)(__s << 1);}\n#   endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_short_size() const _NOEXCEPT\n#   if _LIBCPP_BIG_ENDIAN\n        {return __r_.first().__s.__size_;}\n#   else\n        {return __r_.first().__s.__size_ >> 1;}\n#   endif\n\n#endif  // _LIBCPP_ALTERNATE_STRING_LAYOUT\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_size(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__size_ = __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_size() const _NOEXCEPT\n        {return __r_.first().__l.__size_;}\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_size(size_type __s) _NOEXCEPT\n        {if (__is_long()) __set_long_size(__s); else __set_short_size(__s);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_cap(size_type __s) _NOEXCEPT\n        {__r_.first().__l.__cap_  = __long_mask | __s;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type __get_long_cap() const _NOEXCEPT\n        {return __r_.first().__l.__cap_ & size_type(~__long_mask);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __set_long_pointer(pointer __p) _NOEXCEPT\n        {__r_.first().__l.__data_ = __p;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_long_pointer() _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_long_pointer() const _NOEXCEPT\n        {return __r_.first().__l.__data_;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_short_pointer() _NOEXCEPT\n        {return pointer_traits<pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_short_pointer() const _NOEXCEPT\n        {return pointer_traits<const_pointer>::pointer_to(__r_.first().__s.__data_[0]);}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer __get_pointer() _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_pointer __get_pointer() const _NOEXCEPT\n        {return __is_long() ? __get_long_pointer() : __get_short_pointer();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __zero() _NOEXCEPT\n        {\n            size_type (&__a)[__n_words] = __r_.first().__r.__words;\n            for (unsigned __i = 0; __i < __n_words; ++__i)\n                __a[__i] = 0;\n        }\n\n    template <size_type __a> static\n        _LIBCPP_INLINE_VISIBILITY\n        size_type __align_it(size_type __s) _NOEXCEPT\n            {return __s + (__a-1) & ~(__a-1);}\n    enum {__alignment = 16};\n    static _LIBCPP_INLINE_VISIBILITY\n    size_type __recommend(size_type __s) _NOEXCEPT\n        {return (__s < __min_cap ? __min_cap :\n                 __align_it<sizeof(value_type) < __alignment ?\n                            __alignment/sizeof(value_type) : 1 > (__s+1)) - 1;}\n\n    void __init(const value_type* __s, size_type __sz, size_type __reserve);\n    void __init(const value_type* __s, size_type __sz);\n    void __init(size_type __n, value_type __c);\n\n    template <class _InputIterator>\n    typename enable_if\n    <\n         __is_input_iterator  <_InputIterator>::value &&\n        !__is_forward_iterator<_InputIterator>::value,\n        void\n    >::type\n    __init(_InputIterator __first, _InputIterator __last);\n\n    template <class _ForwardIterator>\n    typename enable_if\n    <\n        __is_forward_iterator<_ForwardIterator>::value,\n        void\n    >::type\n    __init(_ForwardIterator __first, _ForwardIterator __last);\n\n    void __grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                   size_type __n_copy,  size_type __n_del,     size_type __n_add = 0);\n    void __grow_by_and_replace(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                               size_type __n_copy,  size_type __n_del,\n                               size_type __n_add, const value_type* __p_new_stuff);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __erase_to_end(size_type __pos);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str)\n        {__copy_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_copy_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string& __str, true_type)\n        {\n            if (__alloc() != __str.__alloc())\n            {\n                clear();\n                shrink_to_fit();\n            }\n            __alloc() = __str.__alloc();\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __copy_assign_alloc(const basic_string&, false_type) _NOEXCEPT\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, false_type);\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign(basic_string& __str, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value);\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    void\n    __move_assign_alloc(basic_string& __str)\n        _NOEXCEPT_(\n            !__alloc_traits::propagate_on_container_move_assignment::value ||\n            is_nothrow_move_assignable<allocator_type>::value)\n    {__move_assign_alloc(__str, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_move_assignment::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(basic_string&, false_type)\n        _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_swap::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type& __x, allocator_type& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<allocator_type>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(allocator_type&, allocator_type&, false_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_all_iterators();\n    _LIBCPP_INLINE_VISIBILITY void __invalidate_iterators_past(size_type);\n\n    friend basic_string operator+<>(const basic_string&, const basic_string&);\n    friend basic_string operator+<>(const value_type*, const basic_string&);\n    friend basic_string operator+<>(value_type, const basic_string&);\n    friend basic_string operator+<>(const basic_string&, const value_type*);\n    friend basic_string operator+<>(const basic_string&, value_type);\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_all_iterators()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__invalidate_all(this);\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__invalidate_iterators_past(size_type\n#if _LIBCPP_DEBUG_LEVEL >= 2\n                                                                        __pos\n#endif\n                                                                      )\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __c_node* __c = __get_db()->__find_c_and_lock(this);\n    if (__c)\n    {\n        const_pointer __new_last = __get_pointer() + __pos;\n        for (__i_node** __p = __c->end_; __p != __c->beg_; )\n        {\n            --__p;\n            const_iterator* __i = static_cast<const_iterator*>((*__p)->__i_);\n            if (__i->base() > __new_last)\n            {\n                (*__p)->__c_ = nullptr;\n                if (--__c->end_ != __p)\n                    memmove(__p, __p+1, (__c->end_ - __p)*sizeof(__i_node*));\n            }\n        }\n        __get_db()->unlock();\n    }\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const allocator_type& __a)\n    : __r_(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz, size_type __reserve)\n{\n    if (__reserve > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__reserve < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__reserve);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(const value_type* __s, size_type __sz)\n{\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    traits_type::copy(_VSTD::__to_raw_pointer(__p), __s, __sz);\n    traits_type::assign(__p[__sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"basic_string(const char*, allocator) detected nullptr\");\n    __init(__s, traits_type::length(__s));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const value_type* __s, size_type __n, const allocator_type& __a)\n    : __r_(__a)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"basic_string(const char*, n, allocator) detected nullptr\");\n    __init(__s, __n);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str)\n    : __r_(__alloc_traits::select_on_container_copy_construction(__str.__alloc()))\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (!__str.__is_long())\n        __r_.first().__r = __str.__r_.first().__r;\n    else\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __r_(_VSTD::move(__str.__r_))\n{\n    __str.__zero();\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(basic_string&& __str, const allocator_type& __a)\n    : __r_(__a)\n{\n    if (__str.__is_long() && __a != __str.__alloc()) // copy, not move\n        __init(_VSTD::__to_raw_pointer(__str.__get_long_pointer()), __str.__get_long_size());\n    else\n    {\n        __r_.first().__r = __str.__r_.first().__r;\n        __str.__zero();\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    if (__is_long())\n        __get_db()->swap(this, &__str);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__init(size_type __n, value_type __c)\n{\n    if (__n > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__n < __min_cap)\n    {\n        __set_short_size(__n);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__n);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__n);\n    }\n    traits_type::assign(_VSTD::__to_raw_pointer(__p), __n, __c);\n    traits_type::assign(__p[__n], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(size_type __n, value_type __c, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__n, __c);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(const basic_string& __str, size_type __pos, size_type __n,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    size_type __str_sz = __str.size();\n    if (__pos > __str_sz)\n        this->__throw_out_of_range();\n    __init(__str.data() + __pos, _VSTD::min(__n, __str_sz - __pos));\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_InputIterator __first, _InputIterator __last)\n{\n    __zero();\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        if (__is_long())\n            __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n        throw;\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::__init(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__sz > max_size())\n        this->__throw_length_error();\n    pointer __p;\n    if (__sz < __min_cap)\n    {\n        __set_short_size(__sz);\n        __p = __get_short_pointer();\n    }\n    else\n    {\n        size_type __cap = __recommend(__sz);\n        __p = __alloc_traits::allocate(__alloc(), __cap+1);\n        __set_long_pointer(__p);\n        __set_long_cap(__cap+1);\n        __set_long_size(__sz);\n    }\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(_InputIterator __first, _InputIterator __last,\n                                                        const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__first, __last);\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>::basic_string(initializer_list<value_type> __il, const allocator_type& __a)\n    : __r_(__a)\n{\n    __init(__il.begin(), __il.end());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::~basic_string()\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__erase_c(this);\n#endif\n    if (__is_long())\n        __alloc_traits::deallocate(__alloc(), __get_long_pointer(), __get_long_cap());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by_and_replace\n    (size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n     size_type __n_copy,  size_type __n_del,     size_type __n_add, const value_type* __p_new_stuff)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap - 1)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    if (__n_add != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy, __p_new_stuff, __n_add);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del, __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n    __old_sz = __n_copy + __n_add + __sec_cp_sz;\n    __set_long_size(__old_sz);\n    traits_type::assign(__p[__old_sz], value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__grow_by(size_type __old_cap, size_type __delta_cap, size_type __old_sz,\n                                                     size_type __n_copy,  size_type __n_del,     size_type __n_add)\n{\n    size_type __ms = max_size();\n    if (__delta_cap > __ms - __old_cap)\n        this->__throw_length_error();\n    pointer __old_p = __get_pointer();\n    size_type __cap = __old_cap < __ms / 2 - __alignment ?\n                          __recommend(_VSTD::max(__old_cap + __delta_cap, 2 * __old_cap)) :\n                          __ms - 1;\n    pointer __p = __alloc_traits::allocate(__alloc(), __cap+1);\n    __invalidate_all_iterators();\n    if (__n_copy != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p),\n                          _VSTD::__to_raw_pointer(__old_p), __n_copy);\n    size_type __sec_cp_sz = __old_sz - __n_del - __n_copy;\n    if (__sec_cp_sz != 0)\n        traits_type::copy(_VSTD::__to_raw_pointer(__p) + __n_copy + __n_add,\n                          _VSTD::__to_raw_pointer(__old_p) + __n_copy + __n_del,\n                          __sec_cp_sz);\n    if (__old_cap+1 != __min_cap)\n        __alloc_traits::deallocate(__alloc(), __old_p, __old_cap+1);\n    __set_long_pointer(__p);\n    __set_long_cap(__cap+1);\n}\n\n// assign\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::assign received nullptr\");\n    size_type __cap = capacity();\n    if (__cap >= __n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        traits_type::move(__p, __s, __n);\n        traits_type::assign(__p[__n], value_type());\n        __set_size(__n);\n        __invalidate_iterators_past(__n);\n    }\n    else\n    {\n        size_type __sz = size();\n        __grow_by_and_replace(__cap, __n - __cap, __sz, 0, __sz, __n, __s);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(size_type __n, value_type __c)\n{\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n    traits_type::assign(__p, __n, __c);\n    traits_type::assign(__p[__n], value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(value_type __c)\n{\n    pointer __p;\n    if (__is_long())\n    {\n        __p = __get_long_pointer();\n        __set_long_size(1);\n    }\n    else\n    {\n        __p = __get_short_pointer();\n        __set_short_size(1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n    __invalidate_iterators_past(1);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(const basic_string& __str)\n{\n    if (this != &__str)\n    {\n        __copy_assign_alloc(__str);\n        assign(__str);\n    }\n    return *this;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, false_type)\n{\n    if (__alloc() != __str.__alloc())\n        assign(__str);\n    else\n        __move_assign(__str, true_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__move_assign(basic_string& __str, true_type)\n    _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n{\n    clear();\n    shrink_to_fit();\n    __r_.first() = __str.__r_.first();\n    __move_assign_alloc(__str);\n    __str.__zero();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::operator=(basic_string&& __str)\n    _NOEXCEPT_(__alloc_traits::propagate_on_container_move_assignment::value &&\n               is_nothrow_move_assignable<allocator_type>::value)\n{\n    __move_assign(__str, integral_constant<bool,\n          __alloc_traits::propagate_on_container_move_assignment::value>());\n    return *this;\n}\n\n#endif\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_InputIterator __first, _InputIterator __last)\n{\n    clear();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::assign(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    size_type __cap = capacity();\n    if (__cap < __n)\n    {\n        size_type __sz = size();\n        __grow_by(__cap, __n - __cap, __sz, 0, __sz);\n    }\n    else\n        __invalidate_iterators_past(__n);\n    pointer __p = __get_pointer();\n    for (; __first != __last; ++__first, ++__p)\n        traits_type::assign(*__p, *__first);\n    traits_type::assign(*__p, value_type());\n    __set_size(__n);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str)\n{\n    return assign(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return assign(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::assign(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::assign received nullptr\");\n    return assign(__s, traits_type::length(__s));\n}\n\n// append\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::append received nullptr\");\n    size_type __cap = capacity();\n    size_type __sz = size();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            traits_type::copy(__p + __sz, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __sz, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(size_type __n, value_type __c)\n{\n    if (__n)\n    {\n        size_type __cap = capacity();\n        size_type __sz = size();\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer();\n        traits_type::assign(_VSTD::__to_raw_pointer(__p) + __sz, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::push_back(value_type __c)\n{\n    bool __is_short = !__is_long();\n    size_type __cap;\n    size_type __sz;\n    if (__is_short)\n    {\n        __cap = __min_cap - 1;\n        __sz = __get_short_size();\n    }\n    else\n    {\n        __cap = __get_long_cap() - 1;\n        __sz = __get_long_size();\n    }\n    if (__sz == __cap)\n    {\n        __grow_by(__cap, 1, __sz, __sz, 0);\n        __is_short = !__is_long();\n    }\n    pointer __p;\n    if (__is_short)\n    {\n        __p = __get_short_pointer() + __sz;\n        __set_short_size(__sz+1);\n    }\n    else\n    {\n        __p = __get_long_pointer() + __sz;\n        __set_long_size(__sz+1);\n    }\n    traits_type::assign(*__p, __c);\n    traits_type::assign(*++__p, value_type());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::append(_InputIterator __first, _InputIterator __last)\n{\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::append(_ForwardIterator __first, _ForwardIterator __last)\n{\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        if (__cap - __sz < __n)\n            __grow_by(__cap, __sz + __n - __cap, __sz, __sz, 0);\n        pointer __p = __get_pointer() + __sz;\n        for (; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n        traits_type::assign(*__p, value_type());\n        __set_size(__sz + __n);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str)\n{\n    return append(__str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const basic_string& __str, size_type __pos, size_type __n)\n{\n    size_type __sz = __str.size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    return append(__str.data() + __pos, _VSTD::min(__n, __sz - __pos));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::append(const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::append received nullptr\");\n    return append(__s, traits_type::length(__s));\n}\n\n// insert\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s, size_type __n)\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::insert received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __cap = capacity();\n    if (__cap - __sz >= __n)\n    {\n        if (__n)\n        {\n            value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n            {\n                if (__p + __pos <= __s && __s < __p + __sz)\n                    __s += __n;\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n            }\n            traits_type::move(__p + __pos, __s, __n);\n            __sz += __n;\n            __set_size(__sz);\n            traits_type::assign(__p[__sz], value_type());\n        }\n    }\n    else\n        __grow_by_and_replace(__cap, __sz + __n - __cap, __sz, __pos, 0, __n, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        size_type __cap = capacity();\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __pos;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n, __p + __pos, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __pos, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        traits_type::assign(__p + __pos, __n, __c);\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n     __is_input_iterator  <_InputIterator>::value &&\n    !__is_forward_iterator<_InputIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    size_type __old_sz = size();\n    difference_type __ip = __pos - begin();\n    for (; __first != __last; ++__first)\n        push_back(*__first);\n    pointer __p = __get_pointer();\n    _VSTD::rotate(__p + __ip, __p + __old_sz, __p + size());\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    return iterator(this, __p + __ip);\n#else\n    return iterator(__p + __ip);\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    typename basic_string<_CharT, _Traits, _Allocator>::iterator\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, _ForwardIterator __first, _ForwardIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, range) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    size_type __n = static_cast<size_type>(_VSTD::distance(__first, __last));\n    if (__n)\n    {\n        value_type* __p;\n        if (__cap - __sz >= __n)\n        {\n            __p = _VSTD::__to_raw_pointer(__get_pointer());\n            size_type __n_move = __sz - __ip;\n            if (__n_move != 0)\n                traits_type::move(__p + __ip + __n, __p + __ip, __n_move);\n        }\n        else\n        {\n            __grow_by(__cap, __sz + __n - __cap, __sz, __ip, 0, __n);\n            __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n        }\n        __sz += __n;\n        __set_size(__sz);\n        traits_type::assign(__p[__sz], value_type());\n        for (__p += __ip; __first != __last; ++__p, ++__first)\n            traits_type::assign(*__p, *__first);\n    }\n    return begin() + __ip;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str)\n{\n    return insert(__pos1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos1, const basic_string& __str,\n                                                  size_type __pos2, size_type __n)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return insert(__pos1, __str.data() + __pos2, _VSTD::min(__n, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::insert(size_type __pos, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::insert received nullptr\");\n    return insert(__pos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, value_type __c)\n{\n    size_type __ip = static_cast<size_type>(__pos - begin());\n    size_type __sz = size();\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap == __sz)\n    {\n        __grow_by(__cap, 1, __sz, __ip, 0, 1);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    else\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        size_type __n_move = __sz - __ip;\n        if (__n_move != 0)\n            traits_type::move(__p + __ip + 1, __p + __ip, __n_move);\n    }\n    traits_type::assign(__p[__ip], __c);\n    traits_type::assign(__p[++__sz], value_type());\n    __set_size(__sz);\n    return begin() + static_cast<difference_type>(__ip);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::insert(const_iterator __pos, size_type __n, value_type __c)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::insert(iterator, n, value) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    difference_type __p = __pos - begin();\n    insert(static_cast<size_type>(__p), __n, __c);\n    return begin() + __p;\n}\n\n// replace\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s, size_type __n2)\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::replace received nullptr\");\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n            {\n                if (__n1 > __n2)\n                {\n                    traits_type::move(__p + __pos, __s, __n2);\n                    traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n                    goto __finish;\n                }\n                if (__p + __pos < __s && __s < __p + __sz)\n                {\n                    if (__p + __pos + __n1 <= __s)\n                        __s += __n2 - __n1;\n                    else // __p + __pos < __s < __p + __pos + __n1\n                    {\n                        traits_type::move(__p + __pos, __s, __n1);\n                        __pos += __n1;\n                        __s += __n2;\n                        __n2 -= __n1;\n                        __n1 = 0;\n                    }\n                }\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n            }\n        }\n        traits_type::move(__p + __pos, __s, __n2);\n__finish:\n        __sz += __n2 - __n1;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    else\n        __grow_by_and_replace(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2, __s);\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, size_type __n2, value_type __c)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    __n1 = _VSTD::min(__n1, __sz - __pos);\n    size_type __cap = capacity();\n    value_type* __p;\n    if (__cap - __sz + __n1 >= __n2)\n    {\n        __p = _VSTD::__to_raw_pointer(__get_pointer());\n        if (__n1 != __n2)\n        {\n            size_type __n_move = __sz - __pos - __n1;\n            if (__n_move != 0)\n                traits_type::move(__p + __pos + __n2, __p + __pos + __n1, __n_move);\n        }\n    }\n    else\n    {\n        __grow_by(__cap, __sz - __n1 + __n2 - __cap, __sz, __pos, __n1, __n2);\n        __p = _VSTD::__to_raw_pointer(__get_long_pointer());\n    }\n    traits_type::assign(__p + __pos, __n2, __c);\n    __sz += __n2 - __n1;\n    __set_size(__sz);\n    __invalidate_iterators_past(__sz);\n    traits_type::assign(__p[__sz], value_type());\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntemplate<class _InputIterator>\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value,\n    basic_string<_CharT, _Traits, _Allocator>&\n>::type\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2,\n                                                   _InputIterator __j1, _InputIterator __j2)\n{\n    for (; true; ++__i1, ++__j1)\n    {\n        if (__i1 == __i2)\n        {\n            if (__j1 != __j2)\n                insert(__i1, __j1, __j2);\n            break;\n        }\n        if (__j1 == __j2)\n        {\n            erase(__i1, __i2);\n            break;\n        }\n        traits_type::assign(const_cast<value_type&>(*__i1), *__j1);\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str)\n{\n    return replace(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos1, size_type __n1, const basic_string& __str,\n                                                   size_type __pos2, size_type __n2)\n{\n    size_type __str_sz = __str.size();\n    if (__pos2 > __str_sz)\n        this->__throw_out_of_range();\n    return replace(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2, __str_sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(size_type __pos, size_type __n1, const value_type* __s)\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::replace received nullptr\");\n    return replace(__pos, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const basic_string& __str)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1),\n                   __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s, size_type __n)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s, __n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, const value_type* __s)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __s);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::replace(const_iterator __i1, const_iterator __i2, size_type __n, value_type __c)\n{\n    return replace(static_cast<size_type>(__i1 - begin()), static_cast<size_type>(__i2 - __i1), __n, __c);\n}\n\n// erase\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>&\nbasic_string<_CharT, _Traits, _Allocator>::erase(size_type __pos, size_type __n)\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    if (__n)\n    {\n        value_type* __p = _VSTD::__to_raw_pointer(__get_pointer());\n        __n = _VSTD::min(__n, __sz - __pos);\n        size_type __n_move = __sz - __pos - __n;\n        if (__n_move != 0)\n            traits_type::move(__p + __pos, __p + __pos + __n, __n_move);\n        __sz -= __n;\n        __set_size(__sz);\n        __invalidate_iterators_past(__sz);\n        traits_type::assign(__p[__sz], value_type());\n    }\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __pos)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__pos) == this,\n        \"string::erase(iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__pos != end(),\n        \"string::erase(iterator) called with a non-dereferenceable iterator\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__pos - __b);\n    erase(__r, 1);\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::iterator\nbasic_string<_CharT, _Traits, _Allocator>::erase(const_iterator __first, const_iterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__first) == this,\n        \"string::erase(iterator,  iterator) called with an iterator not\"\n        \" referring to this string\");\n#endif\n    _LIBCPP_ASSERT(__first <= __last, \"string::erase(first, last) called with invalid range\");\n    iterator __b = begin();\n    size_type __r = static_cast<size_type>(__first - __b);\n    erase(__r, static_cast<size_type>(__last - __first));\n    return __b + static_cast<difference_type>(__r);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::pop_back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::pop_back(): string is already empty\");\n    size_type __sz;\n    if (__is_long())\n    {\n        __sz = __get_long_size() - 1;\n        __set_long_size(__sz);\n        traits_type::assign(*(__get_long_pointer() + __sz), value_type());\n    }\n    else\n    {\n        __sz = __get_short_size() - 1;\n        __set_short_size(__sz);\n        traits_type::assign(*(__get_short_pointer() + __sz), value_type());\n    }\n    __invalidate_iterators_past(__sz);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::clear() _NOEXCEPT\n{\n    __invalidate_all_iterators();\n    if (__is_long())\n    {\n        traits_type::assign(*__get_long_pointer(), value_type());\n        __set_long_size(0);\n    }\n    else\n    {\n        traits_type::assign(*__get_short_pointer(), value_type());\n        __set_short_size(0);\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::__erase_to_end(size_type __pos)\n{\n    if (__is_long())\n    {\n        traits_type::assign(*(__get_long_pointer() + __pos), value_type());\n        __set_long_size(__pos);\n    }\n    else\n    {\n        traits_type::assign(*(__get_short_pointer() + __pos), value_type());\n        __set_short_size(__pos);\n    }\n    __invalidate_iterators_past(__pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::resize(size_type __n, value_type __c)\n{\n    size_type __sz = size();\n    if (__n > __sz)\n        append(__n - __sz, __c);\n    else\n        __erase_to_end(__n);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::max_size() const _NOEXCEPT\n{\n    size_type __m = __alloc_traits::max_size(__alloc());\n#if _LIBCPP_BIG_ENDIAN\n    return (__m <= ~__long_mask ? __m : __m/2) - __alignment;\n#else\n    return __m - __alignment;\n#endif\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::reserve(size_type __res_arg)\n{\n    if (__res_arg > max_size())\n        this->__throw_length_error();\n    size_type __cap = capacity();\n    size_type __sz = size();\n    __res_arg = _VSTD::max(__res_arg, __sz);\n    __res_arg = __recommend(__res_arg);\n    if (__res_arg != __cap)\n    {\n        pointer __new_data, __p;\n        bool __was_long, __now_long;\n        if (__res_arg == __min_cap - 1)\n        {\n            __was_long = true;\n            __now_long = false;\n            __new_data = __get_short_pointer();\n            __p = __get_long_pointer();\n        }\n        else\n        {\n            if (__res_arg > __cap)\n                __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            else\n            {\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                try\n                {\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n                    __new_data = __alloc_traits::allocate(__alloc(), __res_arg+1);\n            #ifndef _LIBCPP_NO_EXCEPTIONS\n                }\n                catch (...)\n                {\n                    return;\n                }\n            #else  // _LIBCPP_NO_EXCEPTIONS\n                if (__new_data == nullptr)\n                    return;\n            #endif  // _LIBCPP_NO_EXCEPTIONS\n            }\n            __now_long = true;\n            __was_long = __is_long();\n            __p = __get_pointer();\n        }\n        traits_type::copy(_VSTD::__to_raw_pointer(__new_data),\n                          _VSTD::__to_raw_pointer(__p), size()+1);\n        if (__was_long)\n            __alloc_traits::deallocate(__alloc(), __p, __cap+1);\n        if (__now_long)\n        {\n            __set_long_cap(__res_arg+1);\n            __set_long_size(__sz);\n            __set_long_pointer(__new_data);\n        }\n        else\n            __set_short_size(__sz);\n        __invalidate_all_iterators();\n    }\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos) const\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(data() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::operator[](size_type __pos)\n{\n    _LIBCPP_ASSERT(__pos <= size(), \"string index out of bounds\");\n    return *(__get_pointer() + __pos);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n) const\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::at(size_type __n)\n{\n    if (__n >= size())\n        this->__throw_out_of_range();\n    return (*this)[__n];\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::front()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *__get_pointer();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::front() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::front(): string is empty\");\n    return *data();\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::reference\nbasic_string<_CharT, _Traits, _Allocator>::back()\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(__get_pointer() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::const_reference\nbasic_string<_CharT, _Traits, _Allocator>::back() const\n{\n    _LIBCPP_ASSERT(!empty(), \"string::back(): string is empty\");\n    return *(data() + size() - 1);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::copy(value_type* __s, size_type __n, size_type __pos) const\n{\n    size_type __sz = size();\n    if (__pos > __sz)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n, __sz - __pos);\n    traits_type::copy(__s, data() + __pos, __rlen);\n    return __rlen;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>::substr(size_type __pos, size_type __n) const\n{\n    return basic_string(*this, __pos, __n, __alloc());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_string<_CharT, _Traits, _Allocator>::swap(basic_string& __str)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value ||\n                   __is_nothrow_swappable<allocator_type>::value)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    if (!__is_long())\n        __get_db()->__invalidate_all(this);\n    if (!__str.__is_long())\n        __get_db()->__invalidate_all(&__str);\n    __get_db()->swap(this, &__str);\n#endif\n    _VSTD::swap(__r_.first(), __str.__r_.first());\n    __swap_alloc(__alloc(), __str.__alloc());\n}\n\n// find\n\ntemplate <class _Traits>\nstruct _LIBCPP_HIDDEN __traits_eq\n{\n    typedef typename _Traits::char_type char_type;\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const char_type& __x, const char_type& __y) _NOEXCEPT\n        {return _Traits::eq(__x, __y);}\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos,\n                                                size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find(): received nullptr\");\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const basic_string& __str,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(const value_type* __s,\n                                                size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find(): received nullptr\");\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find(value_type __c,\n                                                size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// rfind\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos,\n                                                 size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::rfind(): received nullptr\");\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const basic_string& __str,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(const value_type* __s,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::rfind(): received nullptr\");\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::rfind(value_type __c,\n                                                 size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_rfind<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_first_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos,\n                                                         size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_of(): received nullptr\");\n    return _VSTD::__str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const basic_string& __str,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(const value_type* __s,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_of(): received nullptr\");\n    return _VSTD::__str_find_first_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_of(value_type __c,\n                                                         size_type __pos) const _NOEXCEPT\n{\n    return find(__c, __pos);\n}\n\n// find_last_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos,\n                                                        size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_of(): received nullptr\");\n    return _VSTD::__str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const basic_string& __str,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(const value_type* __s,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_of(): received nullptr\");\n    return _VSTD::__str_find_last_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_of(value_type __c,\n                                                        size_type __pos) const _NOEXCEPT\n{\n    return rfind(__c, __pos);\n}\n\n// find_first_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos,\n                                                             size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const basic_string& __str,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(const value_type* __s,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_first_not_of(): received nullptr\");\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_first_not_of(value_type __c,\n                                                             size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_first_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// find_last_not_of\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos,\n                                                            size_type __n) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__n == 0 || __s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, __n);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const basic_string& __str,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __str.data(), __pos, __str.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(const value_type* __s,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::find_last_not_of(): received nullptr\");\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __s, __pos, traits_type::length(__s));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_string<_CharT, _Traits, _Allocator>::size_type\nbasic_string<_CharT, _Traits, _Allocator>::find_last_not_of(value_type __c,\n                                                            size_type __pos) const _NOEXCEPT\n{\n    return _VSTD::__str_find_last_not_of<value_type, size_type, traits_type, npos>\n        (data(), size(), __c, __pos);\n}\n\n// compare\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const basic_string& __str) const _NOEXCEPT\n{\n    size_t __lhs_sz = size();\n    size_t __rhs_sz = __str.size();\n    int __result = traits_type::compare(data(), __str.data(),\n                                        _VSTD::min(__lhs_sz, __rhs_sz));\n    if (__result != 0)\n        return __result;\n    if (__lhs_sz < __rhs_sz)\n        return -1;\n    if (__lhs_sz > __rhs_sz)\n        return 1;\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str) const\n{\n    return compare(__pos1, __n1, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const basic_string& __str,\n                                                   size_type __pos2,\n                                                   size_type __n2) const\n{\n    size_type __sz = __str.size();\n    if (__pos2 > __sz)\n        this->__throw_out_of_range();\n    return compare(__pos1, __n1, __str.data() + __pos2, _VSTD::min(__n2,\n                                                                  __sz - __pos2));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(const value_type* __s) const _NOEXCEPT\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(0, npos, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s) const\n{\n    _LIBCPP_ASSERT(__s != nullptr, \"string::compare(): received nullptr\");\n    return compare(__pos1, __n1, __s, traits_type::length(__s));\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nint\nbasic_string<_CharT, _Traits, _Allocator>::compare(size_type __pos1,\n                                                   size_type __n1,\n                                                   const value_type* __s,\n                                                   size_type __n2) const\n{\n    _LIBCPP_ASSERT(__n2 == 0 || __s != nullptr, \"string::compare(): received nullptr\");\n    size_type __sz = size();\n    if (__pos1 > __sz || __n2 == npos)\n        this->__throw_out_of_range();\n    size_type __rlen = _VSTD::min(__n1, __sz - __pos1);\n    int __r = traits_type::compare(data() + __pos1, __s, _VSTD::min(__rlen, __n2));\n    if (__r == 0)\n    {\n        if (__rlen < __n2)\n            __r = -1;\n        else if (__rlen > __n2)\n            __r = 1;\n    }\n    return __r;\n}\n\n// __invariants\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__invariants() const\n{\n    if (size() > capacity())\n        return false;\n    if (capacity() < __min_cap - 1)\n        return false;\n    if (data() == 0)\n        return false;\n    if (data()[size()] != value_type(0))\n        return false;\n    return true;\n}\n\n// operator==\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    return __lhs_sz == __rhs.size() && _Traits::compare(__lhs.data(),\n                                                        __rhs.data(),\n                                                        __lhs_sz) == 0;\n}\n\ntemplate<class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<char, char_traits<char>, _Allocator>& __lhs,\n           const basic_string<char, char_traits<char>, _Allocator>& __rhs) _NOEXCEPT\n{\n    size_t __lhs_sz = __lhs.size();\n    if (__lhs_sz != __rhs.size())\n        return false;\n    const char* __lp = __lhs.data();\n    const char* __rp = __rhs.data();\n    if (__lhs.__is_long())\n        return char_traits<char>::compare(__lp, __rp, __lhs_sz) == 0;\n    for (; __lhs_sz != 0; --__lhs_sz, ++__lp, ++__rp)\n        if (*__lp != *__rp)\n            return false;\n    return true;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) == 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) == 0;\n}\n\n// operator!=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT,_Traits,_Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs == __rhs);\n}\n\n// operator<\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __lhs.compare(__rhs) < 0;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator< (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs.compare(__lhs) > 0;\n}\n\n// operator>\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator> (const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return __rhs < __lhs;\n}\n\n// operator<=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator<=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__rhs < __lhs);\n}\n\n// operator>=\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n           const _CharT* __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator>=(const _CharT* __lhs,\n           const basic_string<_CharT, _Traits, _Allocator>& __rhs) _NOEXCEPT\n{\n    return !(__lhs < __rhs);\n}\n\n// operator +\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs,\n          const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = _Traits::length(__lhs);\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(__lhs, __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, const basic_string<_CharT,_Traits,_Allocator>& __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__rhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = __rhs.size();\n    __r.__init(&__lhs, 1, 1 + __rhs_sz);\n    __r.append(__rhs.data(), __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, const _CharT* __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __rhs_sz = _Traits::length(__rhs);\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + __rhs_sz);\n    __r.append(__rhs, __rhs_sz);\n    return __r;\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, _CharT __rhs)\n{\n    basic_string<_CharT, _Traits, _Allocator> __r(__lhs.get_allocator());\n    typename basic_string<_CharT, _Traits, _Allocator>::size_type __lhs_sz = __lhs.size();\n    __r.__init(__lhs.data(), __lhs_sz, __lhs_sz + 1);\n    __r.push_back(__rhs);\n    return __r;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const basic_string<_CharT, _Traits, _Allocator>& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const basic_string<_CharT, _Traits, _Allocator>& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, basic_string<_CharT, _Traits, _Allocator>&& __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(const _CharT* __lhs , basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    return _VSTD::move(__rhs.insert(0, __lhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(_CharT __lhs, basic_string<_CharT,_Traits,_Allocator>&& __rhs)\n{\n    __rhs.insert(__rhs.begin(), __lhs);\n    return _VSTD::move(__rhs);\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, const _CharT* __rhs)\n{\n    return _VSTD::move(__lhs.append(__rhs));\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_string<_CharT, _Traits, _Allocator>\noperator+(basic_string<_CharT, _Traits, _Allocator>&& __lhs, _CharT __rhs)\n{\n    __lhs.push_back(__rhs);\n    return _VSTD::move(__lhs);\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n// swap\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(basic_string<_CharT, _Traits, _Allocator>& __lhs,\n     basic_string<_CharT, _Traits, _Allocator>& __rhs)\n     _NOEXCEPT_(_NOEXCEPT_(__lhs.swap(__rhs)))\n{\n    __lhs.swap(__rhs);\n}\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntypedef basic_string<char16_t> u16string;\ntypedef basic_string<char32_t> u32string;\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\n_LIBCPP_FUNC_VIS int                stoi  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const string& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const string& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const string& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const string& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS string to_string(int __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned __val);\n_LIBCPP_FUNC_VIS string to_string(long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long __val);\n_LIBCPP_FUNC_VIS string to_string(long long __val);\n_LIBCPP_FUNC_VIS string to_string(unsigned long long __val);\n_LIBCPP_FUNC_VIS string to_string(float __val);\n_LIBCPP_FUNC_VIS string to_string(double __val);\n_LIBCPP_FUNC_VIS string to_string(long double __val);\n\n_LIBCPP_FUNC_VIS int                stoi  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long               stol  (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long      stoul (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS long long          stoll (const wstring& __str, size_t* __idx = 0, int __base = 10);\n_LIBCPP_FUNC_VIS unsigned long long stoull(const wstring& __str, size_t* __idx = 0, int __base = 10);\n\n_LIBCPP_FUNC_VIS float       stof (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS double      stod (const wstring& __str, size_t* __idx = 0);\n_LIBCPP_FUNC_VIS long double stold(const wstring& __str, size_t* __idx = 0);\n\n_LIBCPP_FUNC_VIS wstring to_wstring(int __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(unsigned long long __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(float __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(double __val);\n_LIBCPP_FUNC_VIS wstring to_wstring(long double __val);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\n    const typename basic_string<_CharT, _Traits, _Allocator>::size_type\n                   basic_string<_CharT, _Traits, _Allocator>::npos;\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<basic_string<_CharT, _Traits, _Allocator> >\n    : public unary_function<basic_string<_CharT, _Traits, _Allocator>, size_t>\n{\n    size_t\n        operator()(const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT;\n};\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nsize_t\nhash<basic_string<_CharT, _Traits, _Allocator> >::operator()(\n        const basic_string<_CharT, _Traits, _Allocator>& __val) const _NOEXCEPT\n{\n    return __do_string_hash(__val.data(), __val.data() + __val.size());\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os,\n           const basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is,\n           basic_string<_CharT, _Traits, _Allocator>& __str);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str, _CharT __dlm);\n\ntemplate<class _CharT, class _Traits, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>&\ngetline(basic_istream<_CharT, _Traits>&& __is,\n        basic_string<_CharT, _Traits, _Allocator>& __str);\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__dereferenceable(const const_iterator* __i) const\n{\n    return this->data() <= _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) < this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__decrementable(const const_iterator* __i) const\n{\n    return this->data() < _VSTD::__to_raw_pointer(__i->base()) &&\n           _VSTD::__to_raw_pointer(__i->base()) <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__addable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p <= this->data() + this->size();\n}\n\ntemplate<class _CharT, class _Traits, class _Allocator>\nbool\nbasic_string<_CharT, _Traits, _Allocator>::__subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n{\n    const value_type* __p = _VSTD::__to_raw_pointer(__i->base()) + __n;\n    return this->data() <= __p && __p < this->data() + this->size();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\n#if _LIBCPP_STD_VER > 11 \n// Literal suffixes for basic_string [basic.string.literals]\ninline namespace literals\n{\n  inline namespace string_literals\n  {\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char> operator \"\" s( const char *__str, size_t __len )\n    {\n        return basic_string<char> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<wchar_t> operator \"\" s( const wchar_t *__str, size_t __len )\n    {\n        return basic_string<wchar_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char16_t> operator \"\" s( const char16_t *__str, size_t __len )\n    {\n        return basic_string<char16_t> (__str, __len);\n    }\n\n    inline _LIBCPP_INLINE_VISIBILITY\n    basic_string<char32_t> operator \"\" s( const char32_t *__str, size_t __len )\n    {\n        return basic_string<char32_t> (__str, __len);\n    }\n  }\n}\n#endif\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_string<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_string<wchar_t>)\n_LIBCPP_EXTERN_TEMPLATE(string operator+<char, char_traits<char>, allocator<char> >(char const*, string const&))\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STRING\n","// -*- C++ -*-\n//===-------------------------- unordered_map -----------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_UNORDERED_MAP\n#define _LIBCPP_UNORDERED_MAP\n\n/*\n\n    unordered_map synopsis\n\n#include <initializer_list>\n\nnamespace std\n{\n\ntemplate <class Key, class T, class Hash = hash<Key>, class Pred = equal_to<Key>,\n          class Alloc = allocator<pair<const Key, T>>>\nclass unordered_map\n{\npublic:\n    // types\n    typedef Key                                                        key_type;\n    typedef T                                                          mapped_type;\n    typedef Hash                                                       hasher;\n    typedef Pred                                                       key_equal;\n    typedef Alloc                                                      allocator_type;\n    typedef pair<const key_type, mapped_type>                          value_type;\n    typedef value_type&                                                reference;\n    typedef const value_type&                                          const_reference;\n    typedef typename allocator_traits<allocator_type>::pointer         pointer;\n    typedef typename allocator_traits<allocator_type>::const_pointer   const_pointer;\n    typedef typename allocator_traits<allocator_type>::size_type       size_type;\n    typedef typename allocator_traits<allocator_type>::difference_type difference_type;\n\n    typedef /unspecified/ iterator;\n    typedef /unspecified/ const_iterator;\n    typedef /unspecified/ local_iterator;\n    typedef /unspecified/ const_local_iterator;\n\n    unordered_map()\n        noexcept(\n            is_nothrow_default_constructible<hasher>::value &&\n            is_nothrow_default_constructible<key_equal>::value &&\n            is_nothrow_default_constructible<allocator_type>::value);\n    explicit unordered_map(size_type n, const hasher& hf = hasher(),\n                           const key_equal& eql = key_equal(),\n                           const allocator_type& a = allocator_type());\n    template <class InputIterator>\n        unordered_map(InputIterator f, InputIterator l,\n                      size_type n = 0, const hasher& hf = hasher(),\n                      const key_equal& eql = key_equal(),\n                      const allocator_type& a = allocator_type());\n    explicit unordered_map(const allocator_type&);\n    unordered_map(const unordered_map&);\n    unordered_map(const unordered_map&, const Allocator&);\n    unordered_map(unordered_map&&)\n        noexcept(\n            is_nothrow_move_constructible<hasher>::value &&\n            is_nothrow_move_constructible<key_equal>::value &&\n            is_nothrow_move_constructible<allocator_type>::value);\n    unordered_map(unordered_map&&, const Allocator&);\n    unordered_map(initializer_list<value_type>, size_type n = 0,\n                  const hasher& hf = hasher(), const key_equal& eql = key_equal(),\n                  const allocator_type& a = allocator_type());\n    unordered_map(size_type n, const allocator_type& a)\n      : unordered_map(n, hasher(), key_equal(), a) {}  // C++14\n    unordered_map(size_type n, const hasher& hf, const allocator_type& a)\n      : unordered_map(n, hf, key_equal(), a) {}  // C++14\n    template <class InputIterator>\n      unordered_map(InputIterator f, InputIterator l, size_type n, const allocator_type& a)\n      : unordered_map(f, l, n, hasher(), key_equal(), a) {}  // C++14\n    template <class InputIterator>\n      unordered_map(InputIterator f, InputIterator l, size_type n, const hasher& hf, \n        const allocator_type& a)\n      : unordered_map(f, l, n, hf, key_equal(), a) {}  // C++14\n    unordered_map(initializer_list<value_type> il, size_type n, const allocator_type& a)\n      : unordered_map(il, n, hasher(), key_equal(), a) {}  // C++14\n    unordered_map(initializer_list<value_type> il, size_type n, const hasher& hf, \n      const allocator_type& a)\n      : unordered_map(il, n, hf, key_equal(), a) {}  // C++14\n    ~unordered_map();\n    unordered_map& operator=(const unordered_map&);\n    unordered_map& operator=(unordered_map&&)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<hasher>::value &&\n            is_nothrow_move_assignable<key_equal>::value);\n    unordered_map& operator=(initializer_list<value_type>);\n\n    allocator_type get_allocator() const noexcept;\n\n    bool      empty() const noexcept;\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n\n    iterator       begin() noexcept;\n    iterator       end() noexcept;\n    const_iterator begin()  const noexcept;\n    const_iterator end()    const noexcept;\n    const_iterator cbegin() const noexcept;\n    const_iterator cend()   const noexcept;\n\n    template <class... Args>\n        pair<iterator, bool> emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    pair<iterator, bool> insert(const value_type& obj);\n    template <class P>\n        pair<iterator, bool> insert(P&& obj);\n    iterator insert(const_iterator hint, const value_type& obj);\n    template <class P>\n        iterator insert(const_iterator hint, P&& obj);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type>);\n\n    iterator erase(const_iterator position);\n    size_type erase(const key_type& k);\n    iterator erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(unordered_map&)\n        noexcept(\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value) &&\n            __is_nothrow_swappable<hasher>::value &&\n            __is_nothrow_swappable<key_equal>::value);\n\n    hasher hash_function() const;\n    key_equal key_eq() const;\n\n    iterator       find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    size_type count(const key_type& k) const;\n    pair<iterator, iterator>             equal_range(const key_type& k);\n    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;\n\n    mapped_type& operator[](const key_type& k);\n    mapped_type& operator[](key_type&& k);\n\n    mapped_type&       at(const key_type& k);\n    const mapped_type& at(const key_type& k) const;\n\n    size_type bucket_count() const noexcept;\n    size_type max_bucket_count() const noexcept;\n\n    size_type bucket_size(size_type n) const;\n    size_type bucket(const key_type& k) const;\n\n    local_iterator       begin(size_type n);\n    local_iterator       end(size_type n);\n    const_local_iterator begin(size_type n) const;\n    const_local_iterator end(size_type n) const;\n    const_local_iterator cbegin(size_type n) const;\n    const_local_iterator cend(size_type n) const;\n\n    float load_factor() const noexcept;\n    float max_load_factor() const noexcept;\n    void max_load_factor(float z);\n    void rehash(size_type n);\n    void reserve(size_type n);\n};\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    void swap(unordered_map<Key, T, Hash, Pred, Alloc>& x,\n              unordered_map<Key, T, Hash, Pred, Alloc>& y)\n              noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    bool\n    operator==(const unordered_map<Key, T, Hash, Pred, Alloc>& x,\n               const unordered_map<Key, T, Hash, Pred, Alloc>& y);\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    bool\n    operator!=(const unordered_map<Key, T, Hash, Pred, Alloc>& x,\n               const unordered_map<Key, T, Hash, Pred, Alloc>& y);\n\ntemplate <class Key, class T, class Hash = hash<Key>, class Pred = equal_to<Key>,\n          class Alloc = allocator<pair<const Key, T>>>\nclass unordered_multimap\n{\npublic:\n    // types\n    typedef Key                                                        key_type;\n    typedef T                                                          mapped_type;\n    typedef Hash                                                       hasher;\n    typedef Pred                                                       key_equal;\n    typedef Alloc                                                      allocator_type;\n    typedef pair<const key_type, mapped_type>                          value_type;\n    typedef value_type&                                                reference;\n    typedef const value_type&                                          const_reference;\n    typedef typename allocator_traits<allocator_type>::pointer         pointer;\n    typedef typename allocator_traits<allocator_type>::const_pointer   const_pointer;\n    typedef typename allocator_traits<allocator_type>::size_type       size_type;\n    typedef typename allocator_traits<allocator_type>::difference_type difference_type;\n\n    typedef /unspecified/ iterator;\n    typedef /unspecified/ const_iterator;\n    typedef /unspecified/ local_iterator;\n    typedef /unspecified/ const_local_iterator;\n\n    unordered_multimap()\n        noexcept(\n            is_nothrow_default_constructible<hasher>::value &&\n            is_nothrow_default_constructible<key_equal>::value &&\n            is_nothrow_default_constructible<allocator_type>::value);\n    explicit unordered_multimap(size_type n, const hasher& hf = hasher(),\n                           const key_equal& eql = key_equal(),\n                           const allocator_type& a = allocator_type());\n    template <class InputIterator>\n        unordered_multimap(InputIterator f, InputIterator l,\n                      size_type n = 0, const hasher& hf = hasher(),\n                      const key_equal& eql = key_equal(),\n                      const allocator_type& a = allocator_type());\n    explicit unordered_multimap(const allocator_type&);\n    unordered_multimap(const unordered_multimap&);\n    unordered_multimap(const unordered_multimap&, const Allocator&);\n    unordered_multimap(unordered_multimap&&)\n        noexcept(\n            is_nothrow_move_constructible<hasher>::value &&\n            is_nothrow_move_constructible<key_equal>::value &&\n            is_nothrow_move_constructible<allocator_type>::value);\n    unordered_multimap(unordered_multimap&&, const Allocator&);\n    unordered_multimap(initializer_list<value_type>, size_type n = 0,\n                  const hasher& hf = hasher(), const key_equal& eql = key_equal(),\n                  const allocator_type& a = allocator_type());\n    unordered_multimap(size_type n, const allocator_type& a)\n      : unordered_multimap(n, hasher(), key_equal(), a) {}  // C++14\n    unordered_multimap(size_type n, const hasher& hf, const allocator_type& a)\n      : unordered_multimap(n, hf, key_equal(), a) {}  // C++14\n    template <class InputIterator>\n      unordered_multimap(InputIterator f, InputIterator l, size_type n, const allocator_type& a)\n      : unordered_multimap(f, l, n, hasher(), key_equal(), a) {}  // C++14\n    template <class InputIterator>\n      unordered_multimap(InputIterator f, InputIterator l, size_type n, const hasher& hf, \n        const allocator_type& a)\n      : unordered_multimap(f, l, n, hf, key_equal(), a) {}  // C++14\n    unordered_multimap(initializer_list<value_type> il, size_type n, const allocator_type& a)\n      : unordered_multimap(il, n, hasher(), key_equal(), a) {}  // C++14\n    unordered_multimap(initializer_list<value_type> il, size_type n, const hasher& hf, \n      const allocator_type& a)\n      : unordered_multimap(il, n, hf, key_equal(), a) {}  // C++14\n    ~unordered_multimap();\n    unordered_multimap& operator=(const unordered_multimap&);\n    unordered_multimap& operator=(unordered_multimap&&)\n        noexcept(\n            allocator_type::propagate_on_container_move_assignment::value &&\n            is_nothrow_move_assignable<allocator_type>::value &&\n            is_nothrow_move_assignable<hasher>::value &&\n            is_nothrow_move_assignable<key_equal>::value);\n    unordered_multimap& operator=(initializer_list<value_type>);\n\n    allocator_type get_allocator() const noexcept;\n\n    bool      empty() const noexcept;\n    size_type size() const noexcept;\n    size_type max_size() const noexcept;\n\n    iterator       begin() noexcept;\n    iterator       end() noexcept;\n    const_iterator begin()  const noexcept;\n    const_iterator end()    const noexcept;\n    const_iterator cbegin() const noexcept;\n    const_iterator cend()   const noexcept;\n\n    template <class... Args>\n        iterator emplace(Args&&... args);\n    template <class... Args>\n        iterator emplace_hint(const_iterator position, Args&&... args);\n    iterator insert(const value_type& obj);\n    template <class P>\n        iterator insert(P&& obj);\n    iterator insert(const_iterator hint, const value_type& obj);\n    template <class P>\n        iterator insert(const_iterator hint, P&& obj);\n    template <class InputIterator>\n        void insert(InputIterator first, InputIterator last);\n    void insert(initializer_list<value_type>);\n\n    iterator erase(const_iterator position);\n    size_type erase(const key_type& k);\n    iterator erase(const_iterator first, const_iterator last);\n    void clear() noexcept;\n\n    void swap(unordered_multimap&)\n        noexcept(\n            (!allocator_type::propagate_on_container_swap::value ||\n             __is_nothrow_swappable<allocator_type>::value) &&\n            __is_nothrow_swappable<hasher>::value &&\n            __is_nothrow_swappable<key_equal>::value);\n\n    hasher hash_function() const;\n    key_equal key_eq() const;\n\n    iterator       find(const key_type& k);\n    const_iterator find(const key_type& k) const;\n    size_type count(const key_type& k) const;\n    pair<iterator, iterator>             equal_range(const key_type& k);\n    pair<const_iterator, const_iterator> equal_range(const key_type& k) const;\n\n    size_type bucket_count() const noexcept;\n    size_type max_bucket_count() const noexcept;\n\n    size_type bucket_size(size_type n) const;\n    size_type bucket(const key_type& k) const;\n\n    local_iterator       begin(size_type n);\n    local_iterator       end(size_type n);\n    const_local_iterator begin(size_type n) const;\n    const_local_iterator end(size_type n) const;\n    const_local_iterator cbegin(size_type n) const;\n    const_local_iterator cend(size_type n) const;\n\n    float load_factor() const noexcept;\n    float max_load_factor() const noexcept;\n    void max_load_factor(float z);\n    void rehash(size_type n);\n    void reserve(size_type n);\n};\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    void swap(unordered_multimap<Key, T, Hash, Pred, Alloc>& x,\n              unordered_multimap<Key, T, Hash, Pred, Alloc>& y)\n              noexcept(noexcept(x.swap(y)));\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    bool\n    operator==(const unordered_multimap<Key, T, Hash, Pred, Alloc>& x,\n               const unordered_multimap<Key, T, Hash, Pred, Alloc>& y);\n\ntemplate <class Key, class T, class Hash, class Pred, class Alloc>\n    bool\n    operator!=(const unordered_multimap<Key, T, Hash, Pred, Alloc>& x,\n               const unordered_multimap<Key, T, Hash, Pred, Alloc>& y);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__hash_table>\n#include <functional>\n#include <stdexcept>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Key, class _Cp, class _Hash, bool = is_empty<_Hash>::value\n#if __has_feature(is_final)\n                                         && !__is_final(_Hash)\n#endif\n         >\nclass __unordered_map_hasher\n    : private _Hash\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_hasher()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Hash>::value)\n        : _Hash() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_hasher(const _Hash& __h)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Hash>::value)\n        : _Hash(__h) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Hash& hash_function() const _NOEXCEPT {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const _Cp& __x) const\n        {return static_cast<const _Hash&>(*this)(__x.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const _Key& __x) const\n        {return static_cast<const _Hash&>(*this)(__x);}\n};\n\ntemplate <class _Key, class _Cp, class _Hash>\nclass __unordered_map_hasher<_Key, _Cp, _Hash, false>\n{\n    _Hash __hash_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_hasher()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Hash>::value)\n        : __hash_() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_hasher(const _Hash& __h)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Hash>::value)\n        : __hash_(__h) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Hash& hash_function() const _NOEXCEPT {return __hash_;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const _Cp& __x) const\n        {return __hash_(__x.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(const _Key& __x) const\n        {return __hash_(__x);}\n};\n\ntemplate <class _Key, class _Cp, class _Pred, bool = is_empty<_Pred>::value\n#if __has_feature(is_final)\n                                         && !__is_final(_Pred)\n#endif\n         >\nclass __unordered_map_equal\n    : private _Pred\n{\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_equal()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Pred>::value)\n        : _Pred() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_equal(const _Pred& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Pred>::value)\n        : _Pred(__p) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Pred& key_eq() const _NOEXCEPT {return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Cp& __x, const _Cp& __y) const\n        {return static_cast<const _Pred&>(*this)(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Cp& __x, const _Key& __y) const\n        {return static_cast<const _Pred&>(*this)(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _Cp& __y) const\n        {return static_cast<const _Pred&>(*this)(__x, __y.__cc.first);}\n};\n\ntemplate <class _Key, class _Cp, class _Pred>\nclass __unordered_map_equal<_Key, _Cp, _Pred, false>\n{\n    _Pred __pred_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_equal()\n        _NOEXCEPT_(is_nothrow_default_constructible<_Pred>::value)\n        : __pred_() {}\n    _LIBCPP_INLINE_VISIBILITY\n    __unordered_map_equal(const _Pred& __p)\n        _NOEXCEPT_(is_nothrow_copy_constructible<_Pred>::value)\n        : __pred_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY\n    const _Pred& key_eq() const _NOEXCEPT {return __pred_;}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Cp& __x, const _Cp& __y) const\n        {return __pred_(__x.__cc.first, __y.__cc.first);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Cp& __x, const _Key& __y) const\n        {return __pred_(__x.__cc.first, __y);}\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Key& __x, const _Cp& __y) const\n        {return __pred_(__x, __y.__cc.first);}\n};\n\ntemplate <class _Alloc>\nclass __hash_map_node_destructor\n{\n    typedef _Alloc                              allocator_type;\n    typedef allocator_traits<allocator_type>    __alloc_traits;\n    typedef typename __alloc_traits::value_type::value_type value_type;\npublic:\n    typedef typename __alloc_traits::pointer    pointer;\nprivate:\n    typedef typename value_type::value_type::first_type     first_type;\n    typedef typename value_type::value_type::second_type    second_type;\n\n    allocator_type& __na_;\n\n    __hash_map_node_destructor& operator=(const __hash_map_node_destructor&);\n\npublic:\n    bool __first_constructed;\n    bool __second_constructed;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __hash_map_node_destructor(allocator_type& __na) _NOEXCEPT\n        : __na_(__na),\n          __first_constructed(false),\n          __second_constructed(false)\n        {}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_node_destructor(__hash_node_destructor<allocator_type>&& __x)\n        _NOEXCEPT\n        : __na_(__x.__na_),\n          __first_constructed(__x.__value_constructed),\n          __second_constructed(__x.__value_constructed)\n        {\n            __x.__value_constructed = false;\n        }\n#else  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_node_destructor(const __hash_node_destructor<allocator_type>& __x)\n        : __na_(__x.__na_),\n          __first_constructed(__x.__value_constructed),\n          __second_constructed(__x.__value_constructed)\n        {\n            const_cast<bool&>(__x.__value_constructed) = false;\n        }\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY\n    void operator()(pointer __p) _NOEXCEPT\n    {\n        if (__second_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.second));\n        if (__first_constructed)\n            __alloc_traits::destroy(__na_, _VSTD::addressof(__p->__value_.__cc.first));\n        if (__p)\n            __alloc_traits::deallocate(__na_, __p, 1);\n    }\n};\n\n#if __cplusplus >= 201103L\n\ntemplate <class _Key, class _Tp>\nunion __hash_value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n    typedef pair<key_type, mapped_type>              __nc_value_type;\n\n    value_type __cc;\n    __nc_value_type __nc;\n\n    template <class ..._Args>\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_value_type(_Args&& ...__args)\n        : __cc(std::forward<_Args>(__args)...) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_value_type(const __hash_value_type& __v)\n        : __cc(__v.__cc) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_value_type(__hash_value_type&& __v)\n        : __nc(std::move(__v.__nc)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_value_type& operator=(const __hash_value_type& __v)\n        {__nc = __v.__cc; return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_value_type& operator=(__hash_value_type&& __v)\n        {__nc = std::move(__v.__nc); return *this;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    ~__hash_value_type() {__cc.~value_type();}\n};\n\n#else\n\ntemplate <class _Key, class _Tp>\nstruct __hash_value_type\n{\n    typedef _Key                                     key_type;\n    typedef _Tp                                      mapped_type;\n    typedef pair<const key_type, mapped_type>        value_type;\n\n    value_type __cc;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_value_type() {}\n\n    template <class _A0>\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_value_type(const _A0& __a0)\n        : __cc(__a0) {}\n\n    template <class _A0, class _A1>\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_value_type(const _A0& __a0, const _A1& __a1)\n        : __cc(__a0, __a1) {}\n};\n\n#endif\n\ntemplate <class _HashIterator>\nclass _LIBCPP_TYPE_VIS_ONLY __hash_map_iterator\n{\n    _HashIterator __i_;\n\n    typedef pointer_traits<typename _HashIterator::pointer>      __pointer_traits;\n    typedef const typename _HashIterator::value_type::value_type::first_type key_type;\n    typedef typename _HashIterator::value_type::value_type::second_type      mapped_type;\npublic:\n    typedef forward_iterator_tag                                 iterator_category;\n    typedef pair<key_type, mapped_type>                          value_type;\n    typedef typename _HashIterator::difference_type              difference_type;\n    typedef value_type&                                          reference;\n    typedef typename __pointer_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<value_type>\n#else\n            rebind<value_type>::other\n#endif\n                                                                 pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_iterator(_HashIterator __i) _NOEXCEPT : __i_(__i) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_iterator operator++(int)\n    {\n        __hash_map_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator==(const __hash_map_iterator& __x, const __hash_map_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __hash_map_iterator& __x, const __hash_map_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY unordered_map;\n    template <class, class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY unordered_multimap;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __hash_const_iterator;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __hash_const_local_iterator;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __hash_map_const_iterator;\n};\n\ntemplate <class _HashIterator>\nclass _LIBCPP_TYPE_VIS_ONLY __hash_map_const_iterator\n{\n    _HashIterator __i_;\n\n    typedef pointer_traits<typename _HashIterator::pointer>      __pointer_traits;\n    typedef const typename _HashIterator::value_type::value_type::first_type key_type;\n    typedef typename _HashIterator::value_type::value_type::second_type      mapped_type;\npublic:\n    typedef forward_iterator_tag                                 iterator_category;\n    typedef pair<key_type, mapped_type>                          value_type;\n    typedef typename _HashIterator::difference_type              difference_type;\n    typedef const value_type&                                    reference;\n    typedef typename __pointer_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind<const value_type>\n#else\n            rebind<const value_type>::other\n#endif\n                                                                 pointer;\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_const_iterator() _NOEXCEPT {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_const_iterator(_HashIterator __i) _NOEXCEPT : __i_(__i) {}\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_const_iterator(\n            __hash_map_iterator<typename _HashIterator::__non_const_iterator> __i)\n                 _NOEXCEPT\n                : __i_(__i.__i_) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    reference operator*() const {return __i_->__cc;}\n    _LIBCPP_INLINE_VISIBILITY\n    pointer operator->() const {return pointer_traits<pointer>::pointer_to(__i_->__cc);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_const_iterator& operator++() {++__i_; return *this;}\n    _LIBCPP_INLINE_VISIBILITY\n    __hash_map_const_iterator operator++(int)\n    {\n        __hash_map_const_iterator __t(*this);\n        ++(*this);\n        return __t;\n    }\n\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator==(const __hash_map_const_iterator& __x, const __hash_map_const_iterator& __y)\n        {return __x.__i_ == __y.__i_;}\n    friend _LIBCPP_INLINE_VISIBILITY\n        bool operator!=(const __hash_map_const_iterator& __x, const __hash_map_const_iterator& __y)\n        {return __x.__i_ != __y.__i_;}\n\n    template <class, class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY unordered_map;\n    template <class, class, class, class, class> friend class _LIBCPP_TYPE_VIS_ONLY unordered_multimap;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __hash_const_iterator;\n    template <class> friend class _LIBCPP_TYPE_VIS_ONLY __hash_const_local_iterator;\n};\n\ntemplate <class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = equal_to<_Key>,\n          class _Alloc = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TYPE_VIS_ONLY unordered_map\n{\npublic:\n    // types\n    typedef _Key                                           key_type;\n    typedef _Tp                                            mapped_type;\n    typedef _Hash                                          hasher;\n    typedef _Pred                                          key_equal;\n    typedef _Alloc                                         allocator_type;\n    typedef pair<const key_type, mapped_type>              value_type;\n    typedef pair<key_type, mapped_type>                    __nc_value_type;\n    typedef value_type&                                    reference;\n    typedef const value_type&                              const_reference;\n    static_assert((is_same<value_type, typename allocator_type::value_type>::value),\n                  \"Invalid allocator::value_type\");\n\nprivate:\n    typedef __hash_value_type<key_type, mapped_type>                 __value_type;\n    typedef __unordered_map_hasher<key_type, __value_type, hasher>   __hasher;\n    typedef __unordered_map_equal<key_type, __value_type, key_equal> __key_equal;\n    typedef typename allocator_traits<allocator_type>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<__value_type>\n#else\n            rebind_alloc<__value_type>::other\n#endif\n                                                           __allocator_type;\n\n    typedef __hash_table<__value_type, __hasher,\n                         __key_equal,  __allocator_type>   __table;\n\n    __table __table_;\n\n    typedef typename __table::__node_pointer               __node_pointer;\n    typedef typename __table::__node_const_pointer         __node_const_pointer;\n    typedef typename __table::__node_traits                __node_traits;\n    typedef typename __table::__node_allocator             __node_allocator;\n    typedef typename __table::__node                       __node;\n    typedef __hash_map_node_destructor<__node_allocator>   _Dp;\n    typedef unique_ptr<__node, _Dp>                         __node_holder;\n    typedef allocator_traits<allocator_type>               __alloc_traits;\npublic:\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n\n    typedef __hash_map_iterator<typename __table::iterator>       iterator;\n    typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;\n    typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;\n    typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map()\n        _NOEXCEPT_(is_nothrow_default_constructible<__table>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    explicit unordered_map(size_type __n, const hasher& __hf = hasher(),\n                           const key_equal& __eql = key_equal());\n    unordered_map(size_type __n, const hasher& __hf,\n                  const key_equal& __eql,\n                  const allocator_type& __a);\n    template <class _InputIterator>\n        unordered_map(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        unordered_map(_InputIterator __first, _InputIterator __last,\n                      size_type __n, const hasher& __hf = hasher(),\n                      const key_equal& __eql = key_equal());\n    template <class _InputIterator>\n        unordered_map(_InputIterator __first, _InputIterator __last,\n                      size_type __n, const hasher& __hf,\n                      const key_equal& __eql,\n                      const allocator_type& __a);\n    explicit unordered_map(const allocator_type& __a);\n    unordered_map(const unordered_map& __u);\n    unordered_map(const unordered_map& __u, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unordered_map(unordered_map&& __u)\n        _NOEXCEPT_(is_nothrow_move_constructible<__table>::value);\n    unordered_map(unordered_map&& __u, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    unordered_map(initializer_list<value_type> __il);\n    unordered_map(initializer_list<value_type> __il, size_type __n,\n                  const hasher& __hf = hasher(), const key_equal& __eql = key_equal());\n    unordered_map(initializer_list<value_type> __il, size_type __n,\n                  const hasher& __hf, const key_equal& __eql,\n                  const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map(size_type __n, const allocator_type& __a)\n      : unordered_map(__n, hasher(), key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map(size_type __n, const hasher& __hf, const allocator_type& __a)\n      : unordered_map(__n, __hf, key_equal(), __a) {}\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n      unordered_map(_InputIterator __first, _InputIterator __last, size_type __n, const allocator_type& __a)\n      : unordered_map(__first, __last, __n, hasher(), key_equal(), __a) {}\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n      unordered_map(_InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf, \n        const allocator_type& __a)\n      : unordered_map(__first, __last, __n, __hf, key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)\n      : unordered_map(__il, __n, hasher(), key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map(initializer_list<value_type> __il, size_type __n, const hasher& __hf, \n      const allocator_type& __a)\n      : unordered_map(__il, __n, __hf, key_equal(), __a) {}\n#endif\n    // ~unordered_map() = default;\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_map& operator=(const unordered_map& __u)\n    {\n#if __cplusplus >= 201103L\n        __table_ = __u.__table_;\n#else\n        if (this != &__u) {\n            __table_.clear();\n            __table_.hash_function() = __u.__table_.hash_function();\n            __table_.key_eq() = __u.__table_.key_eq();\n            __table_.max_load_factor() = __u.__table_.max_load_factor();\n            __table_.__copy_assign_alloc(__u.__table_);\n            insert(__u.begin(), __u.end());\n        }\n#endif\n        return *this;\n    }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unordered_map& operator=(unordered_map&& __u)\n        _NOEXCEPT_(is_nothrow_move_assignable<__table>::value);\n#endif\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    unordered_map& operator=(initializer_list<value_type> __il);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(__table_.__node_alloc());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const _NOEXCEPT {return __table_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT  {return __table_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __table_.max_size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       begin() _NOEXCEPT        {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       end() _NOEXCEPT          {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin()  const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()    const _NOEXCEPT {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend()   const _NOEXCEPT {return __table_.end();}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args>\n        pair<iterator, bool> emplace(_Args&&... __args);\n\n    template <class... _Args>\n        _LIBCPP_INLINE_VISIBILITY\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        iterator emplace_hint(const_iterator __p, _Args&&... __args)\n        {\n            _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n                \"unordered_map::emplace_hint(const_iterator, args...) called with an iterator not\"\n                \" referring to this unordered_map\");\n            return __table_.__emplace_unique(_VSTD::forward<_Args>(__args)...).first;\n        }\n#else\n        iterator emplace_hint(const_iterator, _Args&&... __args)\n            {return emplace(_VSTD::forward<_Args>(__args)...).first;}\n#endif\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, bool> insert(const value_type& __x)\n        {return __table_.__insert_unique(__x);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        pair<iterator, bool> insert(_Pp&& __x)\n            {return __table_.__insert_unique(_VSTD::forward<_Pp>(__x));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    iterator insert(const_iterator __p, const value_type& __x)\n        {\n            _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n                \"unordered_map::insert(const_iterator, const value_type&) called with an iterator not\"\n                \" referring to this unordered_map\");\n            return insert(__x).first;\n        }\n#else\n    iterator insert(const_iterator, const value_type& __x)\n        {return insert(__x).first;}\n#endif\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n#if _LIBCPP_DEBUG_LEVEL >= 2\n        iterator insert(const_iterator __p, _Pp&& __x)\n        {\n            _LIBCPP_ASSERT(__get_const_db()->__find_c_from_i(&__p) == this,\n                \"unordered_map::insert(const_iterator, value_type&&) called with an iterator not\"\n                \" referring to this unordered_map\");\n            return insert(_VSTD::forward<_Pp>(__x)).first;\n        }\n#else\n        iterator insert(const_iterator, _Pp&& __x)\n            {return insert(_VSTD::forward<_Pp>(__x)).first;}\n#endif\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _InputIterator>\n        void insert(_InputIterator __first, _InputIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __table_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __table_.__erase_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __first, const_iterator __last)\n        {return __table_.erase(__first.__i_, __last.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__table_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(unordered_map& __u)\n        _NOEXCEPT_(__is_nothrow_swappable<__table>::value)\n        {__table_.swap(__u.__table_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    hasher hash_function() const\n        {return __table_.hash_function().hash_function();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_equal key_eq() const\n        {return __table_.key_eq().key_eq();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       find(const key_type& __k)       {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type count(const key_type& __k) const {return __table_.__count_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, iterator>             equal_range(const key_type& __k)\n        {return __table_.__equal_range_unique(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const\n        {return __table_.__equal_range_unique(__k);}\n\n    mapped_type& operator[](const key_type& __k);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    mapped_type& operator[](key_type&& __k);\n#endif\n\n    mapped_type&       at(const key_type& __k);\n    const mapped_type& at(const key_type& __k) const;\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_count() const _NOEXCEPT {return __table_.bucket_count();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_bucket_count() const _NOEXCEPT {return __table_.max_bucket_count();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_size(size_type __n) const\n        {return __table_.bucket_size(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       begin(size_type __n)        {return __table_.begin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       end(size_type __n)          {return __table_.end(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator begin(size_type __n) const  {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator end(size_type __n) const    {return __table_.cend(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cend(size_type __n) const   {return __table_.cend(__n);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    float load_factor() const _NOEXCEPT {return __table_.load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    float max_load_factor() const _NOEXCEPT {return __table_.max_load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}\n    _LIBCPP_INLINE_VISIBILITY\n    void rehash(size_type __n) {__table_.rehash(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    void reserve(size_type __n) {__table_.reserve(__n);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const\n        {return __table_.__dereferenceable(&__i->__i_);}\n    bool __decrementable(const const_iterator* __i) const\n        {return __table_.__decrementable(&__i->__i_);}\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(&__i->__i_, __n);}\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(&__i->__i_, __n);}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __node_holder __construct_node();\n    template <class _A0>\n        __node_holder\n         __construct_node(_A0&& __a0);\n    __node_holder __construct_node_with_key(key_type&& __k);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _A0, class _A1, class ..._Args>\n        __node_holder __construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __node_holder __construct_node_with_key(const key_type& __k);\n};\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        size_type __n, const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        size_type __n, const hasher& __hf, const key_equal& __eql,\n        const allocator_type& __a)\n    : __table_(__hf, __eql, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        const allocator_type& __a)\n    : __table_(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        const unordered_map& __u)\n    : __table_(__u.__table_)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        const unordered_map& __u, const allocator_type& __a)\n    : __table_(__u.__table_, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        unordered_map&& __u)\n    _NOEXCEPT_(is_nothrow_move_constructible<__table>::value)\n    : __table_(_VSTD::move(__u.__table_))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        unordered_map&& __u, const allocator_type& __a)\n    : __table_(_VSTD::move(__u.__table_), __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a != __u.get_allocator())\n    {\n        iterator __i = __u.begin();\n        while (__u.size() != 0)\n            __table_.__insert_unique(\n                _VSTD::move(__u.__table_.remove((__i++).__i_)->__value_)\n                                    );\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    else\n        __get_db()->swap(this, &__u);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_map(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(unordered_map&& __u)\n    _NOEXCEPT_(is_nothrow_move_assignable<__table>::value)\n{\n    __table_ = _VSTD::move(__u.__table_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(\n        initializer_list<value_type> __il)\n{\n    __table_.__assign_unique(__il.begin(), __il.end());\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntypename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node()\n{\n    __node_allocator& __na = __table_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_));\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _A0>\ntypename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node(_A0&& __a0)\n{\n    __node_allocator& __na = __table_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_),\n                             _VSTD::forward<_A0>(__a0));\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntypename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node_with_key(key_type&& __k)\n{\n    __node_allocator& __na = __table_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first), _VSTD::move(__k));\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _A0, class _A1, class ..._Args>\ntypename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node(_A0&& __a0,\n                                                                 _A1&& __a1,\n                                                                 _Args&&... __args)\n{\n    __node_allocator& __na = __table_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_),\n                             _VSTD::forward<_A0>(__a0), _VSTD::forward<_A1>(__a1),\n                             _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class... _Args>\npair<typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator, bool>\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::emplace(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    pair<iterator, bool> __r = __table_.__node_insert_unique(__h.get());\n    if (__r.second)\n        __h.release();\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntypename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node_with_key(const key_type& __k)\n{\n    __node_allocator& __na = __table_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.first), __k);\n    __h.get_deleter().__first_constructed = true;\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_.__cc.second));\n    __h.get_deleter().__second_constructed = true;\n    return _VSTD::move(__h);  // explicitly moved for C++03\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,\n                                                       _InputIterator __last)\n{\n    for (; __first != __last; ++__first)\n        __table_.__insert_unique(*__first);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n_Tp&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](const key_type& __k)\n{\n    iterator __i = find(__k);\n    if (__i != end())\n        return __i->second;\n    __node_holder __h = __construct_node_with_key(__k);\n    pair<iterator, bool> __r = __table_.__node_insert_unique(__h.get());\n    __h.release();\n    return __r.first->second;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n_Tp&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::operator[](key_type&& __k)\n{\n    iterator __i = find(__k);\n    if (__i != end())\n        return __i->second;\n    __node_holder __h = __construct_node_with_key(_VSTD::move(__k));\n    pair<iterator, bool> __r = __table_.__node_insert_unique(__h.get());\n    __h.release();\n    return __r.first->second;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\n_Tp&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::at(const key_type& __k)\n{\n    iterator __i = find(__k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__i == end())\n        throw out_of_range(\"unordered_map::at: key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __i->second;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nconst _Tp&\nunordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::at(const key_type& __k) const\n{\n    const_iterator __i = find(__k);\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__i == end())\n        throw out_of_range(\"unordered_map::at: key not found\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __i->second;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n     unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nbool\noperator==(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n           const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n{\n    if (__x.size() != __y.size())\n        return false;\n    typedef typename unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator\n                                                                 const_iterator;\n    for (const_iterator __i = __x.begin(), __ex = __x.end(), __ey = __y.end();\n            __i != __ex; ++__i)\n    {\n        const_iterator __j = __y.find(__i->first);\n        if (__j == __ey || !(*__i == *__j))\n            return false;\n    }\n    return true;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n           const unordered_map<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n{\n    return !(__x == __y);\n}\n\ntemplate <class _Key, class _Tp, class _Hash = hash<_Key>, class _Pred = equal_to<_Key>,\n          class _Alloc = allocator<pair<const _Key, _Tp> > >\nclass _LIBCPP_TYPE_VIS_ONLY unordered_multimap\n{\npublic:\n    // types\n    typedef _Key                                           key_type;\n    typedef _Tp                                            mapped_type;\n    typedef _Hash                                          hasher;\n    typedef _Pred                                          key_equal;\n    typedef _Alloc                                         allocator_type;\n    typedef pair<const key_type, mapped_type>              value_type;\n    typedef pair<key_type, mapped_type>                    __nc_value_type;\n    typedef value_type&                                    reference;\n    typedef const value_type&                              const_reference;\n    static_assert((is_same<value_type, typename allocator_type::value_type>::value),\n                  \"Invalid allocator::value_type\");\n\nprivate:\n    typedef __hash_value_type<key_type, mapped_type>                 __value_type;\n    typedef __unordered_map_hasher<key_type, __value_type, hasher>   __hasher;\n    typedef __unordered_map_equal<key_type, __value_type, key_equal> __key_equal;\n    typedef typename allocator_traits<allocator_type>::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<__value_type>\n#else\n            rebind_alloc<__value_type>::other\n#endif\n                                                           __allocator_type;\n\n    typedef __hash_table<__value_type, __hasher,\n                         __key_equal,  __allocator_type>   __table;\n\n    __table __table_;\n\n    typedef typename __table::__node_traits                __node_traits;\n    typedef typename __table::__node_allocator             __node_allocator;\n    typedef typename __table::__node                       __node;\n    typedef __hash_map_node_destructor<__node_allocator>   _Dp;\n    typedef unique_ptr<__node, _Dp>                         __node_holder;\n    typedef allocator_traits<allocator_type>               __alloc_traits;\npublic:\n    typedef typename __alloc_traits::pointer         pointer;\n    typedef typename __alloc_traits::const_pointer   const_pointer;\n    typedef typename __alloc_traits::size_type       size_type;\n    typedef typename __alloc_traits::difference_type difference_type;\n\n    typedef __hash_map_iterator<typename __table::iterator>       iterator;\n    typedef __hash_map_const_iterator<typename __table::const_iterator> const_iterator;\n    typedef __hash_map_iterator<typename __table::local_iterator> local_iterator;\n    typedef __hash_map_const_iterator<typename __table::const_local_iterator> const_local_iterator;\n\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap()\n        _NOEXCEPT_(is_nothrow_default_constructible<__table>::value)\n        {\n#if _LIBCPP_DEBUG_LEVEL >= 2\n            __get_db()->__insert_c(this);\n#endif\n        }\n    explicit unordered_multimap(size_type __n, const hasher& __hf = hasher(),\n                                const key_equal& __eql = key_equal());\n    unordered_multimap(size_type __n, const hasher& __hf,\n                                const key_equal& __eql,\n                                const allocator_type& __a);\n    template <class _InputIterator>\n        unordered_multimap(_InputIterator __first, _InputIterator __last);\n    template <class _InputIterator>\n        unordered_multimap(_InputIterator __first, _InputIterator __last,\n                      size_type __n, const hasher& __hf = hasher(),\n                      const key_equal& __eql = key_equal());\n    template <class _InputIterator>\n        unordered_multimap(_InputIterator __first, _InputIterator __last,\n                      size_type __n, const hasher& __hf,\n                      const key_equal& __eql,\n                      const allocator_type& __a);\n    explicit unordered_multimap(const allocator_type& __a);\n    unordered_multimap(const unordered_multimap& __u);\n    unordered_multimap(const unordered_multimap& __u, const allocator_type& __a);\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unordered_multimap(unordered_multimap&& __u)\n        _NOEXCEPT_(is_nothrow_move_constructible<__table>::value);\n    unordered_multimap(unordered_multimap&& __u, const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    unordered_multimap(initializer_list<value_type> __il);\n    unordered_multimap(initializer_list<value_type> __il, size_type __n,\n                       const hasher& __hf = hasher(),\n                       const key_equal& __eql = key_equal());\n    unordered_multimap(initializer_list<value_type> __il, size_type __n,\n                       const hasher& __hf, const key_equal& __eql,\n                       const allocator_type& __a);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n#if _LIBCPP_STD_VER > 11\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap(size_type __n, const allocator_type& __a)\n      : unordered_multimap(__n, hasher(), key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap(size_type __n, const hasher& __hf, const allocator_type& __a)\n      : unordered_multimap(__n, __hf, key_equal(), __a) {}\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n      unordered_multimap(_InputIterator __first, _InputIterator __last, size_type __n, const allocator_type& __a)\n      : unordered_multimap(__first, __last, __n, hasher(), key_equal(), __a) {}\n    template <class _InputIterator>\n    _LIBCPP_INLINE_VISIBILITY\n      unordered_multimap(_InputIterator __first, _InputIterator __last, size_type __n, const hasher& __hf, \n        const allocator_type& __a)\n      : unordered_multimap(__first, __last, __n, __hf, key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap(initializer_list<value_type> __il, size_type __n, const allocator_type& __a)\n      : unordered_multimap(__il, __n, hasher(), key_equal(), __a) {}\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap(initializer_list<value_type> __il, size_type __n, const hasher& __hf, \n      const allocator_type& __a)\n      : unordered_multimap(__il, __n, __hf, key_equal(), __a) {}\n#endif\n    // ~unordered_multimap() = default;\n    _LIBCPP_INLINE_VISIBILITY\n    unordered_multimap& operator=(const unordered_multimap& __u)\n    {\n#if __cplusplus >= 201103L\n        __table_ = __u.__table_;\n#else\n        if (this != &__u) {\n            __table_.clear();\n            __table_.hash_function() = __u.__table_.hash_function();\n            __table_.key_eq() = __u.__table_.key_eq();\n            __table_.max_load_factor() = __u.__table_.max_load_factor();\n            __table_.__copy_assign_alloc(__u.__table_);\n            insert(__u.begin(), __u.end());\n        }\n#endif\n        return *this;\n    }\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    unordered_multimap& operator=(unordered_multimap&& __u)\n        _NOEXCEPT_(is_nothrow_move_assignable<__table>::value);\n#endif\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    unordered_multimap& operator=(initializer_list<value_type> __il);\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    allocator_type get_allocator() const _NOEXCEPT\n        {return allocator_type(__table_.__node_alloc());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool      empty() const _NOEXCEPT {return __table_.size() == 0;}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type size() const _NOEXCEPT  {return __table_.size();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_size() const _NOEXCEPT {return __table_.max_size();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       begin() _NOEXCEPT        {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       end() _NOEXCEPT          {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator begin()  const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator end()    const _NOEXCEPT {return __table_.end();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cbegin() const _NOEXCEPT {return __table_.begin();}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator cend()   const _NOEXCEPT {return __table_.end();}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n    template <class... _Args>\n        iterator emplace(_Args&&... __args);\n\n    template <class... _Args>\n        iterator emplace_hint(const_iterator __p, _Args&&... __args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const value_type& __x) {return __table_.__insert_multi(__x);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(_Pp&& __x)\n            {return __table_.__insert_multi(_VSTD::forward<_Pp>(__x));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    _LIBCPP_INLINE_VISIBILITY\n    iterator insert(const_iterator __p, const value_type& __x)\n        {return __table_.__insert_multi(__p.__i_, __x);}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _Pp,\n              class = typename enable_if<is_constructible<value_type, _Pp>::value>::type>\n        _LIBCPP_INLINE_VISIBILITY\n        iterator insert(const_iterator __p, _Pp&& __x)\n            {return __table_.__insert_multi(__p.__i_, _VSTD::forward<_Pp>(__x));}\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    template <class _InputIterator>\n        void insert(_InputIterator __first, _InputIterator __last);\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n    _LIBCPP_INLINE_VISIBILITY\n    void insert(initializer_list<value_type> __il)\n        {insert(__il.begin(), __il.end());}\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __p) {return __table_.erase(__p.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type erase(const key_type& __k) {return __table_.__erase_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    iterator erase(const_iterator __first, const_iterator __last)\n        {return __table_.erase(__first.__i_, __last.__i_);}\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT {__table_.clear();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void swap(unordered_multimap& __u)\n        _NOEXCEPT_(__is_nothrow_swappable<__table>::value)\n        {__table_.swap(__u.__table_);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    hasher hash_function() const\n        {return __table_.hash_function().hash_function();}\n    _LIBCPP_INLINE_VISIBILITY\n    key_equal key_eq() const\n        {return __table_.key_eq().key_eq();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    iterator       find(const key_type& __k)       {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_iterator find(const key_type& __k) const {return __table_.find(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type count(const key_type& __k) const {return __table_.__count_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<iterator, iterator>             equal_range(const key_type& __k)\n        {return __table_.__equal_range_multi(__k);}\n    _LIBCPP_INLINE_VISIBILITY\n    pair<const_iterator, const_iterator> equal_range(const key_type& __k) const\n        {return __table_.__equal_range_multi(__k);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_count() const _NOEXCEPT {return __table_.bucket_count();}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type max_bucket_count() const _NOEXCEPT\n        {return __table_.max_bucket_count();}\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket_size(size_type __n) const\n        {return __table_.bucket_size(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    size_type bucket(const key_type& __k) const {return __table_.bucket(__k);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       begin(size_type __n)        {return __table_.begin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    local_iterator       end(size_type __n)          {return __table_.end(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator begin(size_type __n) const  {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator end(size_type __n) const    {return __table_.cend(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cbegin(size_type __n) const {return __table_.cbegin(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    const_local_iterator cend(size_type __n) const   {return __table_.cend(__n);}\n\n    _LIBCPP_INLINE_VISIBILITY\n    float load_factor() const _NOEXCEPT {return __table_.load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    float max_load_factor() const _NOEXCEPT {return __table_.max_load_factor();}\n    _LIBCPP_INLINE_VISIBILITY\n    void max_load_factor(float __mlf) {__table_.max_load_factor(__mlf);}\n    _LIBCPP_INLINE_VISIBILITY\n    void rehash(size_type __n) {__table_.rehash(__n);}\n    _LIBCPP_INLINE_VISIBILITY\n    void reserve(size_type __n) {__table_.reserve(__n);}\n\n#if _LIBCPP_DEBUG_LEVEL >= 2\n\n    bool __dereferenceable(const const_iterator* __i) const\n        {return __table_.__dereferenceable(&__i->__i_);}\n    bool __decrementable(const const_iterator* __i) const\n        {return __table_.__decrementable(&__i->__i_);}\n    bool __addable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(&__i->__i_, __n);}\n    bool __subscriptable(const const_iterator* __i, ptrdiff_t __n) const\n        {return __table_.__addable(&__i->__i_, __n);}\n\n#endif  // _LIBCPP_DEBUG_LEVEL >= 2\n\nprivate:\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __node_holder __construct_node();\n    template <class _A0>\n        __node_holder\n         __construct_node(_A0&& __a0);\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n    template <class _A0, class _A1, class ..._Args>\n        __node_holder __construct_node(_A0&& __a0, _A1&& __a1, _Args&& ...__args);\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n};\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        size_type __n, const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        size_type __n, const hasher& __hf, const key_equal& __eql,\n        const allocator_type& __a)\n    : __table_(__hf, __eql, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        _InputIterator __first, _InputIterator __last)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        _InputIterator __first, _InputIterator __last, size_type __n,\n        const hasher& __hf, const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__first, __last);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        const allocator_type& __a)\n    : __table_(__a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        const unordered_multimap& __u)\n    : __table_(__u.__table_)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        const unordered_multimap& __u, const allocator_type& __a)\n    : __table_(__u.__table_, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__u.bucket_count());\n    insert(__u.begin(), __u.end());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        unordered_multimap&& __u)\n    _NOEXCEPT_(is_nothrow_move_constructible<__table>::value)\n    : __table_(_VSTD::move(__u.__table_))\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n    __get_db()->swap(this, &__u);\n#endif\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        unordered_multimap&& __u, const allocator_type& __a)\n    : __table_(_VSTD::move(__u.__table_), __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    if (__a != __u.get_allocator())\n    {\n        iterator __i = __u.begin();\n        while (__u.size() != 0)\n        {\n            __table_.__insert_multi(\n                _VSTD::move(__u.__table_.remove((__i++).__i_)->__value_)\n                                   );\n        }\n    }\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    else\n        __get_db()->swap(this, &__u);\n#endif\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        initializer_list<value_type> __il)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql)\n    : __table_(__hf, __eql)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::unordered_multimap(\n        initializer_list<value_type> __il, size_type __n, const hasher& __hf,\n        const key_equal& __eql, const allocator_type& __a)\n    : __table_(__hf, __eql, __a)\n{\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    __get_db()->__insert_c(this);\n#endif\n    __table_.rehash(__n);\n    insert(__il.begin(), __il.end());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(unordered_multimap&& __u)\n    _NOEXCEPT_(is_nothrow_move_assignable<__table>::value)\n{\n    __table_ = _VSTD::move(__u.__table_);\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>&\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::operator=(\n        initializer_list<value_type> __il)\n{\n    __table_.__assign_multi(__il.begin(), __il.end());\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntypename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node()\n{\n    __node_allocator& __na = __table_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_));\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _A0>\ntypename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node(_A0&& __a0)\n{\n    __node_allocator& __na = __table_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_),\n                             _VSTD::forward<_A0>(__a0));\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _A0, class _A1, class ..._Args>\ntypename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::__node_holder\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::__construct_node(\n        _A0&& __a0, _A1&& __a1, _Args&&... __args)\n{\n    __node_allocator& __na = __table_.__node_alloc();\n    __node_holder __h(__node_traits::allocate(__na, 1), _Dp(__na));\n    __node_traits::construct(__na, _VSTD::addressof(__h->__value_),\n                             _VSTD::forward<_A0>(__a0), _VSTD::forward<_A1>(__a1),\n                             _VSTD::forward<_Args>(__args)...);\n    __h.get_deleter().__first_constructed = true;\n    __h.get_deleter().__second_constructed = true;\n    return __h;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class... _Args>\ntypename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::emplace(_Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __table_.__node_insert_multi(__h.get());\n    __h.release();\n    return __r;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class... _Args>\ntypename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::iterator\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::emplace_hint(\n        const_iterator __p, _Args&&... __args)\n{\n    __node_holder __h = __construct_node(_VSTD::forward<_Args>(__args)...);\n    iterator __r = __table_.__node_insert_multi(__p.__i_, __h.get());\n    __h.release();\n    return __r;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ntemplate <class _InputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nunordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::insert(_InputIterator __first,\n                                                            _InputIterator __last)\n{\n    for (; __first != __last; ++__first)\n        __table_.__insert_multi(*__first);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n     unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n    _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\nbool\noperator==(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n           const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n{\n    if (__x.size() != __y.size())\n        return false;\n    typedef typename unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>::const_iterator\n                                                                 const_iterator;\n    typedef pair<const_iterator, const_iterator> _EqRng;\n    for (const_iterator __i = __x.begin(), __ex = __x.end(); __i != __ex;)\n    {\n        _EqRng __xeq = __x.equal_range(__i->first);\n        _EqRng __yeq = __y.equal_range(__i->first);\n        if (_VSTD::distance(__xeq.first, __xeq.second) !=\n            _VSTD::distance(__yeq.first, __yeq.second) ||\n                  !_VSTD::is_permutation(__xeq.first, __xeq.second, __yeq.first))\n            return false;\n        __i = __xeq.second;\n    }\n    return true;\n}\n\ntemplate <class _Key, class _Tp, class _Hash, class _Pred, class _Alloc>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __x,\n           const unordered_multimap<_Key, _Tp, _Hash, _Pred, _Alloc>& __y)\n{\n    return !(__x == __y);\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_UNORDERED_MAP\n","// Voro++, a 3D cell-based Voronoi library\n//\n// Author   : Chris H. Rycroft (LBL / UC Berkeley)\n// Email    : chr@alum.mit.edu\n// Date     : August 30th 2011\n\n/** \\file pre_container.hh\n * \\brief Header file for the pre_container and related classes. */\n\n#ifndef VOROPP_PRE_CONTAINER_HH\n#define VOROPP_PRE_CONTAINER_HH\n\n#include <cstdio>\n\n#include \"c_loops.hh\"\n#include \"container.hh\"\n\nnamespace voro {\n\n/** \\brief A class for storing an arbitrary number of particles, prior to setting\n * up a container geometry.\n *\n * The pre_container_base class can dynamically import and store an arbitrary\n * number of particles. Once the particles have been read in, an appropriate\n * container class can be set up with the optimal grid size, and the particles\n * can be transferred.\n *\n * The pre_container_base class is not intended for direct use, but forms the\n * base of the pre_container and pre_container_poly classes, that add routines\n * depending on whether particle radii need to be tracked or not. */\nclass pre_container_base {\n\tpublic:\n\t\t/** The minimum x coordinate of the container. */\n\t\tconst double ax;\n\t\t/** The maximum x coordinate of the container. */\n\t\tconst double bx;\n\t\t/** The minimum y coordinate of the container. */\n\t\tconst double ay;\n\t\t/** The maximum y coordinate of the container. */\n\t\tconst double by;\n\t\t/** The minimum z coordinate of the container. */\n\t\tconst double az;\n\t\t/** The maximum z coordinate of the container. */\n\t\tconst double bz;\n\t\t/** A boolean value that determines if the x coordinate in\n\t\t * periodic or not. */\n\t\tconst bool xperiodic;\n\t\t/** A boolean value that determines if the y coordinate in\n\t\t * periodic or not. */\n\t\tconst bool yperiodic;\n\t\t/** A boolean value that determines if the z coordinate in\n\t\t * periodic or not. */\n\t\tconst bool zperiodic;\n\t\tvoid guess_optimal(int &nx,int &ny,int &nz);\n\t\tpre_container_base(double ax_,double bx_,double ay_,double by_,double az_,double bz_,bool xperiodic_,bool yperiodic_,bool zperiodic_,int ps_);\n\t\t~pre_container_base();\n\t\t/** Calculates and returns the total number of particles stored\n\t\t * within the class.\n\t\t * \\return The number of particles. */\n\t\tinline int total_particles() {\n\t\t\treturn (end_id-pre_id)*pre_container_chunk_size+(ch_id-*end_id);\n\t\t}\n\tprotected:\n\t\t/** The number of doubles associated with a single particle\n\t\t * (three for the standard container, four when radius\n\t\t * information is stored). */\n\t\tconst int ps;\n\t\tvoid new_chunk();\n\t\tvoid extend_chunk_index();\n\t\t/** The size of the chunk index. */\n\t\tint index_sz;\n\t\t/** A pointer to the chunk index to store the integer particle\n\t\t * IDs. */\n\t\tint **pre_id;\n\t\t/** A pointer to the last allocated integer ID chunk. */\n\t\tint **end_id;\n\t\t/** A pointer to the end of the integer ID chunk index, used to\n\t\t * determine when the chunk index is full. */\n\t\tint **l_id;\n\t\t/** A pointer to the next available slot on the current\n\t\t * particle ID chunk. */\n\t\tint *ch_id;\n\t\t/** A pointer to the end of the current integer chunk. */\n\t\tint *e_id;\n\t\t/** A pointer to the chunk index to store the floating point\n\t\t * information associated with particles. */\n\t\tdouble **pre_p;\n\t\t/** A pointer to the last allocated chunk of floating point\n\t\t * information. */\n\t\tdouble **end_p;\n\t\t/** A pointer to the next available slot on the current\n\t\t * floating point chunk. */\n\t\tdouble *ch_p;\n};\n\n/** \\brief A class for storing an arbitrary number of particles without radius\n * information, prior to setting up a container geometry.\n *\n * The pre_container class is an extension of the pre_container_base class for\n * cases when no particle radius information is available. */\nclass pre_container : public pre_container_base {\n\tpublic:\n\t\t/** The class constructor sets up the geometry of container,\n\t\t * initializing the minimum and maximum coordinates in each\n\t\t * direction.\n\t\t * \\param[in] (ax_,bx_) the minimum and maximum x coordinates.\n\t\t * \\param[in] (ay_,by_) the minimum and maximum y coordinates.\n\t\t * \\param[in] (az_,bz_) the minimum and maximum z coordinates.\n\t\t * \\param[in] (xperiodic_,yperiodic_,zperiodic_ ) flags setting whether the\n\t\t *                                                container is periodic in\n\t\t *                                                each coordinate direction. */\n\t\tpre_container(double ax_,double bx_,double ay_,double by_,double az_,double bz_,\n\t\t\t\tbool xperiodic_,bool yperiodic_,bool zperiodic_)\n\t\t\t: pre_container_base(ax_,bx_,ay_,by_,az_,bz_,xperiodic_,yperiodic_,zperiodic_,3) {};\n\t\tvoid put(int n,double x,double y,double z);\n\t\tvoid import(FILE *fp=stdin);\n\t\t/** Imports particles from a file.\n\t\t * \\param[in] filename the name of the file to read from. */\n\t\tinline void import(const char* filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"r\");\n\t\t\timport(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\tvoid setup(container &con);\n\t\tvoid setup(particle_order &vo,container &con);\n};\n\n/** \\brief A class for storing an arbitrary number of particles with radius\n * information, prior to setting up a container geometry.\n *\n * The pre_container_poly class is an extension of the pre_container_base class\n * for cases when particle radius information is available. */\nclass pre_container_poly : public pre_container_base {\n\tpublic:\n\t\t/** The class constructor sets up the geometry of container,\n\t\t * initializing the minimum and maximum coordinates in each\n\t\t * direction.\n\t\t * \\param[in] (ax_,bx_) the minimum and maximum x coordinates.\n\t\t * \\param[in] (ay_,by_) the minimum and maximum y coordinates.\n\t\t * \\param[in] (az_,bz_) the minimum and maximum z coordinates.\n\t\t * \\param[in] (xperiodic_,yperiodic_,zperiodic_ ) flags setting whether the\n\t\t *                                                container is periodic in\n\t\t *                                                each coordinate direction. */\n\t\tpre_container_poly(double ax_,double bx_,double ay_,double by_,double az_,double bz_,\n\t\t\t\tbool xperiodic_,bool yperiodic_,bool zperiodic_)\n\t\t\t: pre_container_base(ax_,bx_,ay_,by_,az_,bz_,xperiodic_,yperiodic_,zperiodic_,4) {};\n\t\tvoid put(int n,double x,double y,double z,double r);\n\t\tvoid import(FILE *fp=stdin);\n\t\t/** Imports particles from a file.\n\t\t * \\param[in] filename the name of the file to read from. */\n\t\tinline void import(const char* filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"r\");\n\t\t\timport(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\tvoid setup(container_poly &con);\n\t\tvoid setup(particle_order &vo,container_poly &con);\n};\n\n}\n\n#endif\n","// Voro++, a 3D cell-based Voronoi library\n//\n// Author   : Chris H. Rycroft (LBL / UC Berkeley)\n// Email    : chr@alum.mit.edu\n// Date     : August 30th 2011\n\n/** \\file c_loops.hh\n * \\brief Header file for the loop classes. */\n\n#ifndef VOROPP_C_LOOPS_HH\n#define VOROPP_C_LOOPS_HH\n\n#include \"config.hh\"\n\nnamespace voro {\n\n/** A type associated with a c_loop_subset class, determining what type of\n * geometrical region to loop over. */\nenum c_loop_subset_mode {\n\tsphere,\n\tbox,\n\tno_check\n};\n\n/** \\brief A class for storing ordering information when particles are added to\n * a container.\n *\n * When particles are added to a container class, they are sorted into an\n * internal computational grid of blocks. The particle_order class provides a\n * mechanism for remembering which block particles were sorted into. The import\n * and put routines in the container class have variants that also take a\n * particle_order class. Each time they are called, they will store the block\n * that the particle was sorted into, plus the position of the particle within\n * the block. The particle_order class can used by the c_loop_order class to\n * specifically loop over the particles that have their information stored\n * within it. */\nclass particle_order {\n\tpublic:\n\t\t/** A pointer to the array holding the ordering. */\n\t\tint *o;\n\t\t/** A pointer to the next position in the ordering array in\n\t\t * which to store an entry. */\n\t\tint *op;\n\t\t/** The current memory allocation for the class, set to the\n\t\t * number of entries which can be stored. */\n\t\tint size;\n\t\t/** The particle_order constructor allocates memory to store the\n\t\t * ordering information.\n\t\t * \\param[in] init_size the initial amount of memory to\n\t\t *                      allocate. */\n\t\tparticle_order(int init_size=init_ordering_size)\n\t\t\t: o(new int[init_size<<1]),op(o),size(init_size) {}\n\t\t/** The particle_order destructor frees the dynamically allocated\n\t\t * memory used to store the ordering information. */\n\t\t~particle_order() {\n\t\t\tdelete [] o;\n\t\t}\n\t\t/** Adds a record to the order, corresponding to the memory\n\t\t * address of where a particle was placed into the container.\n\t\t * \\param[in] ijk the block into which the particle was placed.\n\t\t * \\param[in] q the position within the block where the\n\t\t * \t\tparticle was placed. */\n\t\tinline void add(int ijk,int q) {\n\t\t\tif(op==o+size) add_ordering_memory();\n\t\t\t*(op++)=ijk;*(op++)=q;\n\t\t}\n\tprivate:\n\t\tvoid add_ordering_memory();\n};\n\n/** \\brief Base class for looping over particles in a container.\n *\n * This class forms the base of all classes that can loop over a subset of\n * particles in a contaner in some order. When initialized, it stores constants\n * about the corresponding container geometry. It also contains a number of\n * routines for interrogating which particle currently being considered by the\n * loop, which are common between all of the derived classes. */\nclass c_loop_base {\n\tpublic:\n\t\t/** The number of blocks in the x direction. */\n\t\tconst int nx;\n\t\t/** The number of blocks in the y direction. */\n\t\tconst int ny;\n\t\t/** The number of blocks in the z direction. */\n\t\tconst int nz;\n\t\t/** A constant, set to the value of nx multiplied by ny, which\n\t\t * is used in the routines that step through blocks in\n\t\t * sequence. */\n\t\tconst int nxy;\n\t\t/** A constant, set to the value of nx*ny*nz, which is used in\n\t\t * the routines that step through blocks in sequence. */\n\t\tconst int nxyz;\n\t\t/** The number of floating point numbers per particle in the\n\t\t * associated container data structure. */\n\t\tconst int ps;\n\t\t/** A pointer to the particle position information in the\n\t\t * associated container data structure. */\n\t\tdouble **p;\n\t\t/** A pointer to the particle ID information in the associated\n\t\t * container data structure. */\n\t\tint **id;\n\t\t/** A pointer to the particle counts in the associated\n\t\t * container data structure. */\n\t\tint *co;\n\t\t/** The current x-index of the block under consideration by the\n\t\t * loop. */\n\t\tint i;\n\t\t/** The current y-index of the block under consideration by the\n\t\t * loop. */\n\t\tint j;\n\t\t/** The current z-index of the block under consideration by the\n\t\t * loop. */\n\t\tint k;\n\t\t/** The current index of the block under consideration by the\n\t\t * loop. */\n\t\tint ijk;\n\t\t/** The index of the particle under consideration within the current\n\t\t * block. */\n\t\tint q;\n\t\t/** The constructor copies several necessary constants from the\n\t\t * base container class.\n\t\t * \\param[in] con the container class to use. */\n\t\ttemplate<class c_class>\n\t\tc_loop_base(c_class &con) : nx(con.nx), ny(con.ny), nz(con.nz),\n\t\t\t\t\t    nxy(con.nxy), nxyz(con.nxyz), ps(con.ps),\n\t\t\t\t\t    p(con.p), id(con.id), co(con.co) {}\n\t\t/** Returns the position vector of the particle currently being\n\t\t * considered by the loop.\n\t\t * \\param[out] (x,y,z) the position vector of the particle. */\n\t\tinline void pos(double &x,double &y,double &z) {\n\t\t\tdouble *pp=p[ijk]+ps*q;\n\t\t\tx=*(pp++);y=*(pp++);z=*pp;\n\t\t}\n\t\t/** Returns the ID, position vector, and radius of the particle\n\t\t * currently being considered by the loop.\n\t\t * \\param[out] pid the particle ID.\n\t\t * \\param[out] (x,y,z) the position vector of the particle.\n\t\t * \\param[out] r the radius of the particle. If no radius\n\t\t * \t\t information is available the default radius\n\t\t * \t\t value is returned. */\n\t\tinline void pos(int &pid,double &x,double &y,double &z,double &r) {\n\t\t\tpid=id[ijk][q];\n\t\t\tdouble *pp=p[ijk]+ps*q;\n\t\t\tx=*(pp++);y=*(pp++);z=*pp;\n\t\t\tr=ps==3?default_radius:*(++pp);\n\t\t}\n\t\t/** Returns the x position of the particle currently being\n\t\t * considered by the loop. */\n\t\tinline double x() {return p[ijk][ps*q];}\n\t\t/** Returns the y position of the particle currently being\n\t\t * considered by the loop. */\n\t\tinline double y() {return p[ijk][ps*q+1];}\n\t\t/** Returns the z position of the particle currently being\n\t\t * considered by the loop. */\n\t\tinline double z() {return p[ijk][ps*q+2];}\n\t\t/** Returns the ID of the particle currently being considered\n\t\t * by the loop. */\n\t\tinline int pid() {return id[ijk][q];}\n};\n\n/** \\brief Class for looping over all of the particles in a container.\n *\n * This is one of the simplest loop classes, that scans the computational\n * blocks in order, and scans all the particles within each block in order. */\nclass c_loop_all : public c_loop_base {\n\tpublic:\n\t\t/** The constructor copies several necessary constants from the\n\t\t * base container class.\n\t\t * \\param[in] con the container class to use. */\n\t\ttemplate<class c_class>\n\t\tc_loop_all(c_class &con) : c_loop_base(con) {}\n\t\t/** Sets the class to consider the first particle.\n\t\t * \\return True if there is any particle to consider, false\n\t\t * otherwise. */\n\t\tinline bool start() {\n\t\t\ti=j=k=ijk=q=0;\n\t\t\twhile(co[ijk]==0) if(!next_block()) return false;\n\t\t\treturn true;\n\t\t}\n\t\t/** Finds the next particle to test.\n\t\t * \\return True if there is another particle, false if no more\n\t\t * particles are available. */\n\t\tinline bool inc() {\n\t\t\tq++;\n\t\t\tif(q>=co[ijk]) {\n\t\t\t\tq=0;\n\t\t\t\tdo {\n\t\t\t\t\tif(!next_block()) return false;\n\t\t\t\t} while(co[ijk]==0);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\tprivate:\n\t\t/** Updates the internal variables to find the next\n\t\t * computational block with any particles.\n\t\t * \\return True if another block is found, false if there are\n\t\t * no more blocks. */\n\t\tinline bool next_block() {\n\t\t\tijk++;\n\t\t\ti++;\n\t\t\tif(i==nx) {\n\t\t\t\ti=0;j++;\n\t\t\t\tif(j==ny) {\n\t\t\t\t\tj=0;k++;\n\t\t\t\t\tif(ijk==nxyz) return false;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n};\n\n/** \\brief Class for looping over a subset of particles in a container.\n *\n * This class can loop over a subset of particles in a certain geometrical\n * region within the container. The class can be set up to loop over a\n * rectangular box or sphere. It can also rectangular group of internal\n * computational blocks. */\nclass c_loop_subset : public c_loop_base {\n\tpublic:\n\t\t/** The current mode of operation, determining whether tests\n\t\t * should be applied to particles to ensure they are within a\n\t\t * certain geometrical object. */\n\t\tc_loop_subset_mode mode;\n\t\t/** The constructor copies several necessary constants from the\n\t\t * base container class.\n\t\t * \\param[in] con the container class to use. */\n\t\ttemplate<class c_class>\n\t\tc_loop_subset(c_class &con) : c_loop_base(con), ax(con.ax), ay(con.ay), az(con.az),\n\t\t\tsx(con.bx-ax), sy(con.by-ay), sz(con.bz-az), xsp(con.xsp), ysp(con.ysp), zsp(con.zsp),\n\t\t\txperiodic(con.xperiodic), yperiodic(con.yperiodic), zperiodic(con.zperiodic) {}\n\t\tvoid setup_sphere(double vx,double vy,double vz,double r,bool bounds_test=true);\n\t\tvoid setup_box(double xmin,double xmax,double ymin,double ymax,double zmin,double zmax,bool bounds_test=true);\n\t\tvoid setup_intbox(int ai_,int bi_,int aj_,int bj_,int ak_,int bk_);\n\t\tbool start();\n\t\t/** Finds the next particle to test.\n\t\t * \\return True if there is another particle, false if no more\n\t\t * particles are available. */\n\t\tinline bool inc() {\n\t\t\tdo {\n\t\t\t\tq++;\n\t\t\t\twhile(q>=co[ijk]) {q=0;if(!next_block()) return false;}\n\t\t\t} while(mode!=no_check&&out_of_bounds());\n\t\t\treturn true;\n\t\t}\n\tprivate:\n\t\tconst double ax,ay,az,sx,sy,sz,xsp,ysp,zsp;\n\t\tconst bool xperiodic,yperiodic,zperiodic;\n\t\tdouble px,py,pz,apx,apy,apz;\n\t\tdouble v0,v1,v2,v3,v4,v5;\n\t\tint ai,bi,aj,bj,ak,bk;\n\t\tint ci,cj,ck,di,dj,dk,inc1,inc2;\n\t\tinline int step_mod(int a,int b) {return a>=0?a%b:b-1-(b-1-a)%b;}\n\t\tinline int step_div(int a,int b) {return a>=0?a/b:-1+(a+1)/b;}\n\t\tinline int step_int(double a) {return a<0?int(a)-1:int(a);}\n\t\tvoid setup_common();\n\t\tbool next_block();\n\t\tbool out_of_bounds();\n};\n\n/** \\brief Class for looping over all of the particles specified in a\n * pre-assembled particle_order class.\n *\n * The particle_order class can be used to create a specific order of particles\n * within the container. This class can then loop over these particles in this\n * order. The class is particularly useful in cases where the ordering of the\n * output must match the ordering of particles as they were inserted into the\n * container. */\nclass c_loop_order : public c_loop_base {\n\tpublic:\n\t\t/** A reference to the ordering class to use. */\n\t\tparticle_order &vo;\n\t\t/** A pointer to the current position in the ordering class. */\n\t\tint *cp;\n\t\t/** A pointer to the end position in the ordering class. */\n\t\tint *op;\n\t\t/** The constructor copies several necessary constants from the\n\t\t * base class, and sets up a reference to the ordering class to\n\t\t * use.\n\t\t * \\param[in] con the container class to use.\n\t\t * \\param[in] vo_ the ordering class to use. */\n\t\ttemplate<class c_class>\n\t\tc_loop_order(c_class &con,particle_order &vo_)\n\t\t: c_loop_base(con), vo(vo_), nx(con.nx), nxy(con.nxy) {}\n\t\t/** Sets the class to consider the first particle.\n\t\t * \\return True if there is any particle to consider, false\n\t\t * otherwise. */\n\t\tinline bool start() {\n\t\t\tcp=vo.o;op=vo.op;\n\t\t\tif(cp!=op) {\n\t\t\t\tijk=*(cp++);decode();\n\t\t\t\tq=*(cp++);\n\t\t\t\treturn true;\n\t\t\t} else return false;\n\t\t}\n\t\t/** Finds the next particle to test.\n\t\t * \\return True if there is another particle, false if no more\n\t\t * particles are available. */\n\t\tinline bool inc() {\n\t\t\tif(cp==op) return false;\n\t\t\tijk=*(cp++);decode();\n\t\t\tq=*(cp++);\n\t\t\treturn true;\n\t\t}\n\tprivate:\n\t\t/** The number of computational blocks in the x direction. */\n\t\tconst int nx;\n\t\t/** The number of computational blocks in a z-slice. */\n\t\tconst int nxy;\n\t\t/** Takes the current block index and computes indices in the\n\t\t * x, y, and z directions. */\n\t\tinline void decode() {\n\t\t\tk=ijk/nxy;\n\t\t\tint ijkt=ijk-nxy*k;\n\t\t\tj=ijkt/nx;\n\t\t\ti=ijkt-j*nx;\n\t\t}\n};\n\n/** \\brief A class for looping over all particles in a container_periodic or\n * container_periodic_poly class.\n *\n * Since the container_periodic and container_periodic_poly classes have a\n * fundamentally different memory organization, the regular loop classes cannot\n * be used with them. */\nclass c_loop_all_periodic : public c_loop_base {\n\tpublic:\n\t\t/** The constructor copies several necessary constants from the\n\t\t * base periodic container class.\n\t\t * \\param[in] con the periodic container class to use. */\n\t\ttemplate<class c_class>\n\t\tc_loop_all_periodic(c_class &con) : c_loop_base(con), ey(con.ey), ez(con.ez), wy(con.wy), wz(con.wz),\n\t\t\tijk0(nx*(ey+con.oy*ez)), inc2(2*nx*con.ey+1) {}\n\t\t/** Sets the class to consider the first particle.\n\t\t * \\return True if there is any particle to consider, false\n\t\t * otherwise. */\n\t\tinline bool start() {\n\t\t\ti=0;\n\t\t\tj=ey;\n\t\t\tk=ez;\n\t\t\tijk=ijk0;\n\t\t\tq=0;\n\t\t\twhile(co[ijk]==0) if(!next_block()) return false;\n\t\t\treturn true;\n\t\t}\n\t\t/** Finds the next particle to test.\n\t\t * \\return True if there is another particle, false if no more\n\t\t * particles are available. */\n\t\tinline bool inc() {\n\t\t\tq++;\n\t\t\tif(q>=co[ijk]) {\n\t\t\t\tq=0;\n\t\t\t\tdo {\n\t\t\t\t\tif(!next_block()) return false;\n\t\t\t\t} while(co[ijk]==0);\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\tprivate:\n\t\t/** The lower y index (inclusive) of the primary domain within\n\t\t * the block structure. */\n\t\tint ey;\n\t\t/** The lower y index (inclusive) of the primary domain within\n\t\t * the block structure. */\n\t\tint ez;\n\t\t/** The upper y index (exclusive) of the primary domain within\n\t\t * the block structure. */\n\t\tint wy;\n\t\t/** The upper z index (exclusive) of the primary domain within\n\t\t * the block structure. */\n\t\tint wz;\n\t\t/** The index of the (0,0,0) block within the block structure.\n\t\t */\n\t\tint ijk0;\n\t\t/** A value to increase ijk by when the z index is increased.\n\t\t */\n\t\tint inc2;\n\t\t/** Updates the internal variables to find the next\n\t\t * computational block with any particles.\n\t\t * \\return True if another block is found, false if there are\n\t\t * no more blocks. */\n\t\tinline bool next_block() {\n\t\t\ti++;\n\t\t\tif(i==nx) {\n\t\t\t\ti=0;j++;\n\t\t\t\tif(j==wy) {\n\t\t\t\t\tj=ey;k++;\n\t\t\t\t\tif(k==wz) return false;\n\t\t\t\t\tijk+=inc2;\n\t\t\t\t} else ijk++;\n\t\t\t} else ijk++;\n\t\t\treturn true;\n\t\t}\n};\n\n/** \\brief Class for looping over all of the particles specified in a\n * pre-assembled particle_order class, for use with container_periodic classes.\n *\n * The particle_order class can be used to create a specific order of particles\n * within the container. This class can then loop over these particles in this\n * order. The class is particularly useful in cases where the ordering of the\n * output must match the ordering of particles as they were inserted into the\n * container. */\nclass c_loop_order_periodic : public c_loop_base {\n\tpublic:\n\t\t/** A reference to the ordering class to use. */\n\t\tparticle_order &vo;\n\t\t/** A pointer to the current position in the ordering class. */\n\t\tint *cp;\n\t\t/** A pointer to the end position in the ordering class. */\n\t\tint *op;\n\t\t/** The constructor copies several necessary constants from the\n\t\t * base class, and sets up a reference to the ordering class to\n\t\t * use.\n\t\t * \\param[in] con the container class to use.\n\t\t * \\param[in] vo_ the ordering class to use. */\n\t\ttemplate<class c_class>\n\t\tc_loop_order_periodic(c_class &con,particle_order &vo_)\n\t\t: c_loop_base(con), vo(vo_), nx(con.nx), oxy(con.nx*con.oy) {}\n\t\t/** Sets the class to consider the first particle.\n\t\t * \\return True if there is any particle to consider, false\n\t\t * otherwise. */\n\t\tinline bool start() {\n\t\t\tcp=vo.o;op=vo.op;\n\t\t\tif(cp!=op) {\n\t\t\t\tijk=*(cp++);decode();\n\t\t\t\tq=*(cp++);\n\t\t\t\treturn true;\n\t\t\t} else return false;\n\t\t}\n\t\t/** Finds the next particle to test.\n\t\t * \\return True if there is another particle, false if no more\n\t\t * particles are available. */\n\t\tinline bool inc() {\n\t\t\tif(cp==op) return false;\n\t\t\tijk=*(cp++);decode();\n\t\t\tq=*(cp++);\n\t\t\treturn true;\n\t\t}\n\tprivate:\n\t\t/** The number of computational blocks in the x direction. */\n\t\tconst int nx;\n\t\t/** The number of computational blocks in a z-slice. */\n\t\tconst int oxy;\n\t\t/** Takes the current block index and computes indices in the\n\t\t * x, y, and z directions. */\n\t\tinline void decode() {\n\t\t\tk=ijk/oxy;\n\t\t\tint ijkt=ijk-oxy*k;\n\t\t\tj=ijkt/nx;\n\t\t\ti=ijkt-j*nx;\n\t\t}\n};\n\n}\n\n#endif\n","// Voro++, a 3D cell-based Voronoi library\n//\n// Author   : Chris H. Rycroft (LBL / UC Berkeley)\n// Email    : chr@alum.mit.edu\n// Date     : August 30th 2011\n\n/** \\file v_compute.hh\n * \\brief Header file for the voro_compute template and related classes. */\n\n#ifndef VOROPP_V_COMPUTE_HH\n#define VOROPP_V_COMPUTE_HH\n\n#include \"config.hh\"\n#include \"worklist.hh\"\n#include \"cell.hh\"\n\nnamespace voro {\n\n/** \\brief Structure for holding information about a particle.\n *\n * This small structure holds information about a single particle, and is used\n * by several of the routines in the voro_compute template for passing\n * information by reference between functions. */\nstruct particle_record {\n\t/** The index of the block that the particle is within. */\n\tint ijk;\n\t/** The number of particle within its block. */\n\tint l;\n\t/** The x-index of the block. */\n\tint di;\n\t/** The y-index of the block. */\n\tint dj;\n\t/** The z-index of the block. */\n\tint dk;\n};\n\n/** \\brief Template for carrying out Voronoi cell computations. */\ntemplate <class c_class>\nclass voro_compute {\n\tpublic:\n\t\t/** A reference to the container class on which to carry out*/\n\t\tc_class &con;\n\t\t/** The size of an internal computational block in the x\n\t\t * direction. */\n\t\tconst double boxx;\n\t\t/** The size of an internal computational block in the y\n\t\t * direction. */\n\t\tconst double boxy;\n\t\t/** The size of an internal computational block in the z\n\t\t * direction. */\n\t\tconst double boxz;\n\t\t/** The inverse box length in the x direction, set to\n\t\t * nx/(bx-ax). */\n\t\tconst double xsp;\n\t\t/** The inverse box length in the y direction, set to\n\t\t * ny/(by-ay). */\n\t\tconst double ysp;\n\t\t/** The inverse box length in the z direction, set to\n\t\t * nz/(bz-az). */\n\t\tconst double zsp;\n\t\t/** The number of boxes in the x direction for the searching mask. */\n\t\tconst int hx;\n\t\t/** The number of boxes in the y direction for the searching mask. */\n\t\tconst int hy;\n\t\t/** The number of boxes in the z direction for the searching mask. */\n\t\tconst int hz;\n\t\t/** A constant, set to the value of hx multiplied by hy, which\n\t\t * is used in the routines which step through mask boxes in\n\t\t * sequence. */\n\t\tconst int hxy;\n\t\t/** A constant, set to the value of hx*hy*hz, which is used in\n\t\t * the routines which step through mask boxes in sequence. */\n\t\tconst int hxyz;\n\t\t/** The number of floating point entries to store for each\n\t\t * particle. */\n\t\tconst int ps;\n\t\t/** This array holds the numerical IDs of each particle in each\n\t\t * computational box. */\n\t\tint **id;\n\t\t/** A two dimensional array holding particle positions. For the\n\t\t * derived container_poly class, this also holds particle\n\t\t * radii. */\n\t\tdouble **p;\n\t\t/** An array holding the number of particles within each\n\t\t * computational box of the container. */\n\t\tint *co;\n\t\tvoro_compute(c_class &con_,int hx_,int hy_,int hz_);\n\t\t/** The class destructor frees the dynamically allocated memory\n\t\t * for the mask and queue. */\n\t\t~voro_compute() {\n\t\t\tdelete [] qu;\n\t\t\tdelete [] mask;\n\t\t}\n\t\ttemplate<class v_cell>\n\t\tbool compute_cell(v_cell &c,int ijk,int s,int ci,int cj,int ck);\n\t\tvoid find_voronoi_cell(double x,double y,double z,int ci,int cj,int ck,int ijk,particle_record &w,double &mrs);\n\tprivate:\n\t\t/** A constant set to boxx*boxx+boxy*boxy+boxz*boxz, which is\n\t\t * frequently used in the computation. */\n\t\tconst double bxsq;\n\t\t/** This sets the current value being used to mark tested blocks\n\t\t * in the mask. */\n\t\tunsigned int mv;\n\t\t/** The current size of the search list. */\n\t\tint qu_size;\n\t\t/** A pointer to the array of worklists. */\n\t\tconst unsigned int *wl;\n\t\t/** An pointer to the array holding the minimum distances\n\t\t * associated with the worklists. */\n\t\tdouble *mrad;\n\t\t/** This array is used during the cell computation to determine\n\t\t * which blocks have been considered. */\n\t\tunsigned int *mask;\n\t\t/** An array is used to store the queue of blocks to test\n\t\t * during the Voronoi cell computation. */\n\t\tint *qu;\n\t\t/** A pointer to the end of the queue array, used to determine\n\t\t * when the queue is full. */\n\t\tint *qu_l;\n\t\ttemplate<class v_cell>\n\t\tbool corner_test(v_cell &c,double xl,double yl,double zl,double xh,double yh,double zh);\n\t\ttemplate<class v_cell>\n\t\tinline bool edge_x_test(v_cell &c,double x0,double yl,double zl,double x1,double yh,double zh);\n\t\ttemplate<class v_cell>\n\t\tinline bool edge_y_test(v_cell &c,double xl,double y0,double zl,double xh,double y1,double zh);\n\t\ttemplate<class v_cell>\n\t\tinline bool edge_z_test(v_cell &c,double xl,double yl,double z0,double xh,double yh,double z1);\n\t\ttemplate<class v_cell>\n\t\tinline bool face_x_test(v_cell &c,double xl,double y0,double z0,double y1,double z1);\n\t\ttemplate<class v_cell>\n\t\tinline bool face_y_test(v_cell &c,double x0,double yl,double z0,double x1,double z1);\n\t\ttemplate<class v_cell>\n\t\tinline bool face_z_test(v_cell &c,double x0,double y0,double zl,double x1,double y1);\n\t\tbool compute_min_max_radius(int di,int dj,int dk,double fx,double fy,double fz,double gx,double gy,double gz,double& crs,double mrs);\n\t\tbool compute_min_radius(int di,int dj,int dk,double fx,double fy,double fz,double mrs);\n\t\tinline void add_to_mask(int ei,int ej,int ek,int *&qu_e);\n\t\tinline void scan_bits_mask_add(unsigned int q,unsigned int *mijk,int ei,int ej,int ek,int *&qu_e);\n\t\tinline void scan_all(int ijk,double x,double y,double z,int di,int dj,int dk,particle_record &w,double &mrs);\n\t\tvoid add_list_memory(int*& qu_s,int*& qu_e);\n\t\t/** Resets the mask in cases where the mask counter wraps\n\t\t * around. */\n\t\tinline void reset_mask() {\n\t\t\tfor(unsigned int *mp(mask);mp<mask+hxyz;mp++) *mp=0;\n\t\t}\n};\n\n}\n\n#endif\n","// -*- C++ -*-\n//===-------------------------- algorithm ---------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_ALGORITHM\n#define _LIBCPP_ALGORITHM\n\n/*\n    algorithm synopsis\n\n#include <initializer_list>\n\nnamespace std\n{\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    all_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    any_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    none_of(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator, class Function>\n    Function\n    for_each(InputIterator first, InputIterator last, Function f);\n\ntemplate <class InputIterator, class T>\n    InputIterator\n    find(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    InputIterator\n    find_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate<class InputIterator, class Predicate>\n    InputIterator\n    find_if_not(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_end(ForwardIterator1 first1, ForwardIterator1 last1,\n             ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    find_first_of(ForwardIterator1 first1, ForwardIterator1 last1,\n                  ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    adjacent_find(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class T>\n    typename iterator_traits<InputIterator>::difference_type\n    count(InputIterator first, InputIterator last, const T& value);\n\ntemplate <class InputIterator, class Predicate>\n    typename iterator_traits<InputIterator>::difference_type\n    count_if(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1, \n             InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    pair<InputIterator1, InputIterator2>\n    mismatch(InputIterator1 first1, InputIterator1 last1,\n             InputIterator2 first2, InputIterator2 last2,\n             BinaryPredicate pred); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1, \n          InputIterator2 first2, InputIterator2 last2); // **C++14**\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, BinaryPredicate pred);\n\ntemplate <class InputIterator1, class InputIterator2, class BinaryPredicate>\n    bool\n    equal(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2,\n          BinaryPredicate pred); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2);\n\ntemplate<class ForwardIterator1, class ForwardIterator2>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2); // **C++14**\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, BinaryPredicate pred);\n\ntemplate<class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    bool\n    is_permutation(ForwardIterator1 first1, ForwardIterator1 last1,\n                   ForwardIterator2 first2, ForwardIterator2 last2,\n                   BinaryPredicate pred);  // **C++14**\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2, class BinaryPredicate>\n    ForwardIterator1\n    search(ForwardIterator1 first1, ForwardIterator1 last1,\n           ForwardIterator2 first2, ForwardIterator2 last2, BinaryPredicate pred);\n\ntemplate <class ForwardIterator, class Size, class T>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last, Size count, const T& value);\n\ntemplate <class ForwardIterator, class Size, class T, class BinaryPredicate>\n    ForwardIterator\n    search_n(ForwardIterator first, ForwardIterator last,\n             Size count, const T& value, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate<class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    copy_if(InputIterator first, InputIterator last,\n            OutputIterator result, Predicate pred);\n\ntemplate<class InputIterator, class Size, class OutputIterator>\n    OutputIterator\n    copy_n(InputIterator first, Size n, OutputIterator result);\n\ntemplate <class BidirectionalIterator1, class BidirectionalIterator2>\n    BidirectionalIterator2\n    copy_backward(BidirectionalIterator1 first, BidirectionalIterator1 last,\n                  BidirectionalIterator2 result);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    ForwardIterator2\n    swap_ranges(ForwardIterator1 first1, ForwardIterator1 last1, ForwardIterator2 first2);\n\ntemplate <class ForwardIterator1, class ForwardIterator2>\n    void\n    iter_swap(ForwardIterator1 a, ForwardIterator2 b);\n\ntemplate <class InputIterator, class OutputIterator, class UnaryOperation>\n    OutputIterator\n    transform(InputIterator first, InputIterator last, OutputIterator result, UnaryOperation op);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class BinaryOperation>\n    OutputIterator\n    transform(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2,\n              OutputIterator result, BinaryOperation binary_op);\n\ntemplate <class ForwardIterator, class T>\n    void\n    replace(ForwardIterator first, ForwardIterator last, const T& old_value, const T& new_value);\n\ntemplate <class ForwardIterator, class Predicate, class T>\n    void\n    replace_if(ForwardIterator first, ForwardIterator last, Predicate pred, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    replace_copy(InputIterator first, InputIterator last, OutputIterator result,\n                 const T& old_value, const T& new_value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate, class T>\n    OutputIterator\n    replace_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred, const T& new_value);\n\ntemplate <class ForwardIterator, class T>\n    void\n    fill(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class OutputIterator, class Size, class T>\n    OutputIterator\n    fill_n(OutputIterator first, Size n, const T& value);\n\ntemplate <class ForwardIterator, class Generator>\n    void\n    generate(ForwardIterator first, ForwardIterator last, Generator gen);\n\ntemplate <class OutputIterator, class Size, class Generator>\n    OutputIterator\n    generate_n(OutputIterator first, Size n, Generator gen);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    remove(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    remove_if(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator, class T>\n    OutputIterator\n    remove_copy(InputIterator first, InputIterator last, OutputIterator result, const T& value);\n\ntemplate <class InputIterator, class OutputIterator, class Predicate>\n    OutputIterator\n    remove_copy_if(InputIterator first, InputIterator last, OutputIterator result, Predicate pred);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class BinaryPredicate>\n    ForwardIterator\n    unique(ForwardIterator first, ForwardIterator last, BinaryPredicate pred);\n\ntemplate <class InputIterator, class OutputIterator>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result);\n\ntemplate <class InputIterator, class OutputIterator, class BinaryPredicate>\n    OutputIterator\n    unique_copy(InputIterator first, InputIterator last, OutputIterator result, BinaryPredicate pred);\n\ntemplate <class BidirectionalIterator>\n    void\n    reverse(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class OutputIterator>\n    OutputIterator\n    reverse_copy(BidirectionalIterator first, BidirectionalIterator last, OutputIterator result);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    rotate(ForwardIterator first, ForwardIterator middle, ForwardIterator last);\n\ntemplate <class ForwardIterator, class OutputIterator>\n    OutputIterator\n    rotate_copy(ForwardIterator first, ForwardIterator middle, ForwardIterator last, OutputIterator result);\n\ntemplate <class RandomAccessIterator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last); // deprecated in C++14\n\ntemplate <class RandomAccessIterator, class RandomNumberGenerator>\n    void\n    random_shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                   RandomNumberGenerator& rand);  // deprecated in C++14\n\ntemplate<class RandomAccessIterator, class UniformRandomNumberGenerator>\n    void shuffle(RandomAccessIterator first, RandomAccessIterator last,\n                 UniformRandomNumberGenerator&& g);\n\ntemplate <class InputIterator, class Predicate>\n    bool\n    is_partitioned(InputIterator first, InputIterator last, Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class InputIterator, class OutputIterator1,\n          class OutputIterator2, class Predicate>\n    pair<OutputIterator1, OutputIterator2>\n    partition_copy(InputIterator first, InputIterator last,\n                   OutputIterator1 out_true, OutputIterator2 out_false,\n                   Predicate pred);\n\ntemplate <class ForwardIterator, class Predicate>\n    ForwardIterator\n    stable_partition(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate<class ForwardIterator, class Predicate>\n    ForwardIterator\n    partition_point(ForwardIterator first, ForwardIterator last, Predicate pred);\n\ntemplate <class ForwardIterator>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    bool\n    is_sorted(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate<class ForwardIterator>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    is_sorted_until(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    stable_sort(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    partial_sort(RandomAccessIterator first, RandomAccessIterator middle, RandomAccessIterator last, Compare comp);\n\ntemplate <class InputIterator, class RandomAccessIterator>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last);\n\ntemplate <class InputIterator, class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    partial_sort_copy(InputIterator first, InputIterator last,\n                      RandomAccessIterator result_first, RandomAccessIterator result_last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    nth_element(RandomAccessIterator first, RandomAccessIterator nth, RandomAccessIterator last, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    lower_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    ForwardIterator\n    upper_bound(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    equal_range(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class ForwardIterator, class T>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value);\n\ntemplate <class ForwardIterator, class T, class Compare>\n    bool\n    binary_search(ForwardIterator first, ForwardIterator last, const T& value, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    merge(InputIterator1 first1, InputIterator1 last1,\n          InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    void\n    inplace_merge(BidirectionalIterator first, BidirectionalIterator middle, BidirectionalIterator last, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    includes(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_union(InputIterator1 first1, InputIterator1 last1,\n              InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_intersection(InputIterator1 first1, InputIterator1 last1,\n                     InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_difference(InputIterator1 first1, InputIterator1 last1,\n                   InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result);\n\ntemplate <class InputIterator1, class InputIterator2, class OutputIterator, class Compare>\n    OutputIterator\n    set_symmetric_difference(InputIterator1 first1, InputIterator1 last1,\n                             InputIterator2 first2, InputIterator2 last2, OutputIterator result, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    push_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    pop_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    make_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    void\n    sort_heap(RandomAccessIterator first, RandomAccessIterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    bool\n    is_heap(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class RandomAccessIterator>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last);\n\ntemplate <class RandomAccessIterator, class Compare>\n    RandomAccessIterator\n    is_heap_until(RandomAccessIterator first, RandomAccessiterator last, Compare comp);\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    min_element(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class T>\n    const T&\n    min(const T& a, const T& b);  // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    min(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    min(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    min(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate <class ForwardIterator>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last);\n\ntemplate <class ForwardIterator, class Compare>\n    ForwardIterator\n    max_element(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate <class T>\n    const T&\n    max(const T& a, const T& b); // constexpr in C++14\n\ntemplate <class T, class Compare>\n    const T&\n    max(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    T\n    max(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    T\n    max(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate<class ForwardIterator>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last);\n\ntemplate<class ForwardIterator, class Compare>\n    pair<ForwardIterator, ForwardIterator>\n    minmax_element(ForwardIterator first, ForwardIterator last, Compare comp);\n\ntemplate<class T>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<const T&, const T&>\n    minmax(const T& a, const T& b, Compare comp);  // constexpr in C++14\n\ntemplate<class T>\n    pair<T, T>\n    minmax(initializer_list<T> t);  // constexpr in C++14\n\ntemplate<class T, class Compare>\n    pair<T, T>\n    minmax(initializer_list<T> t, Compare comp);  // constexpr in C++14\n\ntemplate <class InputIterator1, class InputIterator2>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, InputIterator2 last2);\n\ntemplate <class InputIterator1, class InputIterator2, class Compare>\n    bool\n    lexicographical_compare(InputIterator1 first1, InputIterator1 last1,\n                            InputIterator2 first2, InputIterator2 last2, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    next_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\ntemplate <class BidirectionalIterator>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last);\n\ntemplate <class BidirectionalIterator, class Compare>\n    bool\n    prev_permutation(BidirectionalIterator first, BidirectionalIterator last, Compare comp);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <initializer_list>\n#include <type_traits>\n#include <cstring>\n#include <utility>\n#include <memory>\n#include <iterator>\n#include <cstddef>\n\n#if defined(__IBMCPP__)\n#include \"support/ibm/support.h\"\n#endif\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n#include \"support/win32/support.h\"\n#endif\n\n#include <__undef_min_max>\n\n#include <__debug>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// I'd like to replace these with _VSTD::equal_to<void>, but can't because:\n//   * That only works with C++14 and later, and\n//   * We haven't included <functional> here.\ntemplate <class _T1, class _T2 = _T1>\nstruct __equal_to\n{\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T1& __x, const _T2& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T1& __y) const {return __x == __y;}\n    _LIBCPP_INLINE_VISIBILITY bool operator()(const _T2& __x, const _T2& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1>\nstruct __equal_to<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x == __y;}\n};\n\ntemplate <class _T1, class _T2 = _T1>\nstruct __less\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11 \n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T2& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T1& __y) const {return __x < __y;}\n\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T2& __x, const _T2& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<const _T1, _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _T1>\nstruct __less<_T1, const _T1>\n{\n    _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n    bool operator()(const _T1& __x, const _T1& __y) const {return __x < __y;}\n};\n\ntemplate <class _Predicate>\nclass __negate\n{\nprivate:\n    _Predicate __p_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY __negate() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __negate(_Predicate __p) : __p_(__p) {}\n\n    template <class _T1>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x) {return !__p_(__x);}\n\n    template <class _T1, class _T2>\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _T1& __x, const _T2& __y) {return !__p_(__x, __y);}\n};\n\n#ifdef _LIBCPP_DEBUG\n\ntemplate <class _Compare>\nstruct __debug_less\n{\n    _Compare __comp_;\n    __debug_less(_Compare& __c) : __comp_(__c) {}\n    template <class _Tp, class _Up>\n    bool operator()(const _Tp& __x, const _Up& __y)\n    {\n        bool __r = __comp_(__x, __y);\n        if (__r)\n            _LIBCPP_ASSERT(!__comp_(__y, __x), \"Comparator does not induce a strict weak ordering\");\n        return __r;\n    }\n};\n\n#endif  // _LIBCPP_DEBUG\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__ctz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_ctz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__ctz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_ctzl(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__ctz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_ctzll(__x));\n}\n\n// Precondition:  __x != 0\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned\n__clz(unsigned __x)\n{\n    return static_cast<unsigned>(__builtin_clz(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long\n__clz(unsigned long __x)\n{\n    return static_cast<unsigned long>(__builtin_clzl (__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY\nunsigned long long\n__clz(unsigned long long __x)\n{\n    return static_cast<unsigned long long>(__builtin_clzll(__x));\n}\n\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned           __x) {return __builtin_popcount  (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned      long __x) {return __builtin_popcountl (__x);}\ninline _LIBCPP_INLINE_VISIBILITY int __pop_count(unsigned long long __x) {return __builtin_popcountll(__x);}\n\n// all_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nall_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            return false;\n    return true;\n}\n\n// any_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nany_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return true;\n    return false;\n}\n\n// none_of\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnone_of(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// for_each\n\ntemplate <class _InputIterator, class _Function>\ninline _LIBCPP_INLINE_VISIBILITY\n_Function\nfor_each(_InputIterator __first, _InputIterator __last, _Function __f)\n{\n    for (; __first != __last; ++__first)\n        __f(*__first);\n    return _VSTD::move(__f);  // explicitly moved for (emulated) C++03\n}\n\n// find\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            break;\n    return __first;\n}\n\n// find_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_if_not\n\ntemplate<class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_InputIterator\nfind_if_not(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    return __first;\n}\n\n// find_end\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\n_ForwardIterator1\n__find_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n           _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n           forward_iterator_tag, forward_iterator_tag)\n{\n    // modeled after search algorithm\n    _ForwardIterator1 __r = __last1;  // __last1 is the \"default\" answer\n    if (__first2 == __last2)\n        return __r;\n    while (true)\n    {\n        while (true)\n        {\n            if (__first1 == __last1)         // if source exhausted return last correct answer\n                return __r;                  //    (or __last1 if never found)\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)\n            {                         // Pattern exhaused, record answer and search for another one\n                __r = __first1;\n                ++__first1;\n                break;\n            }\n            if (++__m1 == __last1)     // Source exhausted, return last answer\n                return __r;\n            if (!__pred(*__m1, *__m2))  // mismatch, restart with a new __first\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _BidirectionalIterator1, class _BidirectionalIterator2>\n_BidirectionalIterator1\n__find_end(_BidirectionalIterator1 __first1, _BidirectionalIterator1 __last1,\n           _BidirectionalIterator2 __first2, _BidirectionalIterator2 __last2, _BinaryPredicate __pred,\n           bidirectional_iterator_tag, bidirectional_iterator_tag)\n{\n    // modeled after search algorithm (in reverse)\n    if (__first2 == __last2)\n        return __last1;  // Everything matches an empty sequence\n    _BidirectionalIterator1 __l1 = __last1;\n    _BidirectionalIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        // Find last element in sequence 1 that matchs *(__last2-1), with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __l1)  // return __last1 if no element matches *__first2\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        // *__l1 matches *__l2, now match elements before here\n        _BidirectionalIterator1 __m1 = __l1;\n        _BidirectionalIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)  // If pattern exhausted, __m1 is the answer (works for 1 element pattern)\n                return __m1;\n            if (__m1 == __first1)  // Otherwise if source exhaused, pattern not found\n                return __last1;\n            if (!__pred(*--__m1, *--__m2))  // if there is a mismatch, restart with a new __l1\n            {\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _RandomAccessIterator1\n__find_end(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    typename iterator_traits<_RandomAccessIterator2>::difference_type __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return __last1;\n    typename iterator_traits<_RandomAccessIterator1>::difference_type __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return __last1;\n    const _RandomAccessIterator1 __s = __first1 + (__len2 - 1);  // End of pattern match can't go before here\n    _RandomAccessIterator1 __l1 = __last1;\n    _RandomAccessIterator2 __l2 = __last2;\n    --__l2;\n    while (true)\n    {\n        while (true)\n        {\n            if (__s == __l1)\n                return __last1;\n            if (__pred(*--__l1, *__l2))\n                break;\n        }\n        _RandomAccessIterator1 __m1 = __l1;\n        _RandomAccessIterator2 __m2 = __l2;\n        while (true)\n        {\n            if (__m2 == __first2)\n                return __m1;\n                                 // no need to check range on __m1 because __s guarantees we have enough source\n            if (!__pred(*--__m1, *--__m2))\n            {\n                break;\n            }\n        }\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_end<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_end(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::find_end(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// find_first_of\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _ForwardIterator1\n__find_first_of_ce(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1)\n        for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n            if (__pred(*__first1, *__j))\n                return __first1;\n    return __last1;\n}\n\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __pred);\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nfind_first_of(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n              _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__find_first_of_ce(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// adjacent_find\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__first, *__i))\n                return __first;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nadjacent_find(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::adjacent_find(__first, __last, __equal_to<__v>());\n}\n\n// count\n\ntemplate <class _InputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount(_InputIterator __first, _InputIterator __last, const _Tp& __value_)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (*__first == __value_)\n            ++__r;\n    return __r;\n}\n\n// count_if\n\ntemplate <class _InputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename iterator_traits<_InputIterator>::difference_type\ncount_if(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    typename iterator_traits<_InputIterator>::difference_type __r(0);\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            ++__r;\n    return __r;\n}\n\n// mismatch\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2,\n         _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, (void) ++__first2)\n        if (!__pred(*__first1, *__first2))\n            break;\n    return pair<_InputIterator1, _InputIterator2>(__first1, __first2);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_InputIterator1, _InputIterator2>\nmismatch(_InputIterator1 __first1, _InputIterator1 __last1,\n         _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::mismatch(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n#endif\n\n// equal\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _BinaryPredicate __pred)\n{\n    for (; __first1 != __last1; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::equal(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _BinaryPredicate, class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_InputIterator1 __first1, _InputIterator1 __last1, \n        _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred,\n        input_iterator_tag, input_iterator_tag )\n{\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            return false;\n    return __first1 == __last1 && __first2 == __last2;\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__equal(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1, \n        _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred, \n      random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::equal<_RandomAccessIterator1, _RandomAccessIterator2,\n                        typename add_lvalue_reference<_BinaryPredicate>::type>\n                       (__first1, __last1, __first2, __pred );\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, \n      _InputIterator2 __first2, _InputIterator2 __last2, _BinaryPredicate __pred )\n{\n    return _VSTD::__equal<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred, \n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nequal(_InputIterator1 __first1, _InputIterator1 __last1, \n      _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return _VSTD::__equal(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>(),\n        typename iterator_traits<_InputIterator1>::iterator_category(),\n        typename iterator_traits<_InputIterator2>::iterator_category());\n}\n#endif\n\n// is_permutation\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _BinaryPredicate __pred)\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return true;\n__not_done:\n    // __first1 != __last1 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n    if (__l1 == _D1(1))\n        return false;\n    _ForwardIterator2 __last2 = _VSTD::next(__first2, __l1);\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::is_permutation(__first1, __last1, __first2, __equal_to<__v1, __v2>());\n}\n\n#if _LIBCPP_STD_VER > 11\ntemplate<class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\nbool\n__is_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n                 _ForwardIterator2 __first2, _ForwardIterator2 __last2, \n                 _BinaryPredicate __pred,\n                 forward_iterator_tag, forward_iterator_tag )\n{\n    // shorten sequences as much as possible by lopping of any equal parts\n    for (; __first1 != __last1 && __first2 != __last2; ++__first1, ++__first2)\n        if (!__pred(*__first1, *__first2))\n            goto __not_done;\n    return __first1 == __last1 && __first2 == __last2;\n__not_done:\n    // __first1 != __last1 && __first2 != __last2 && *__first1 != *__first2\n    typedef typename iterator_traits<_ForwardIterator1>::difference_type _D1;\n    _D1 __l1 = _VSTD::distance(__first1, __last1);\n\n    typedef typename iterator_traits<_ForwardIterator2>::difference_type _D2;\n    _D2 __l2 = _VSTD::distance(__first2, __last2);\n    if (__l1 != __l2)\n        return false;\n\n    // For each element in [f1, l1) see if there are the same number of\n    //    equal elements in [f2, l2)\n    for (_ForwardIterator1 __i = __first1; __i != __last1; ++__i)\n    {\n        // Have we already counted the number of *__i in [f1, l1)?\n        for (_ForwardIterator1 __j = __first1; __j != __i; ++__j)\n            if (__pred(*__j, *__i))\n                goto __next_iter;\n        {\n            // Count number of *__i in [f2, l2)\n            _D1 __c2 = 0;\n            for (_ForwardIterator2 __j = __first2; __j != __last2; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c2;\n            if (__c2 == 0)\n                return false;\n            // Count number of *__i in [__i, l1) (we can start with 1)\n            _D1 __c1 = 1;\n            for (_ForwardIterator1 __j = _VSTD::next(__i); __j != __last1; ++__j)\n                if (__pred(*__i, *__j))\n                    ++__c1;\n            if (__c1 != __c2)\n                return false;\n        }\n__next_iter:;\n    }\n    return true;\n}\n\ntemplate<class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\nbool\n__is_permutation(_RandomAccessIterator1 __first1, _RandomAccessIterator2 __last1,\n               _RandomAccessIterator1 __first2, _RandomAccessIterator2 __last2, \n               _BinaryPredicate __pred,\n               random_access_iterator_tag, random_access_iterator_tag )\n{\n    if ( _VSTD::distance(__first1, __last1) != _VSTD::distance(__first2, __last2))\n        return false;\n    return _VSTD::is_permutation<_RandomAccessIterator1, _RandomAccessIterator2,\n                                 typename add_lvalue_reference<_BinaryPredicate>::type>\n                                (__first1, __last1, __first2, __pred );\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2,\n               _BinaryPredicate __pred )\n{\n    return _VSTD::__is_permutation<typename add_lvalue_reference<_BinaryPredicate>::type>\n       (__first1, __last1, __first2, __last2, __pred,\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate<class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_permutation(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n               _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::__is_permutation(__first1, __last1, __first2, __last2,\n        __equal_to<__v1, __v2>(),\n        typename iterator_traits<_ForwardIterator1>::iterator_category(),\n        typename iterator_traits<_ForwardIterator2>::iterator_category());\n}\n#endif\n\n// search\n\ntemplate <class _BinaryPredicate, class _ForwardIterator1, class _ForwardIterator2>\n_ForwardIterator1\n__search(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n         _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred,\n         forward_iterator_tag, forward_iterator_tag)\n{\n    if (__first2 == __last2)\n        return __first1;  // Everything matches an empty sequence\n    while (true)\n    {\n        // Find first element in sequence 1 that matchs *__first2, with a mininum of loop checks\n        while (true)\n        {\n            if (__first1 == __last1)  // return __last1 if no element matches *__first2\n                return __last1;\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n        // *__first1 matches *__first2, now match elements after here\n        _ForwardIterator1 __m1 = __first1;\n        _ForwardIterator2 __m2 = __first2;\n        while (true)\n        {\n            if (++__m2 == __last2)  // If pattern exhausted, __first1 is the answer (works for 1 element pattern)\n                return __first1;\n            if (++__m1 == __last1)  // Otherwise if source exhaused, pattern not found\n                return __last1;\n            if (!__pred(*__m1, *__m2))  // if there is a mismatch, restart with a new __first1\n            {\n                ++__first1;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator1, class _RandomAccessIterator2>\n_LIBCPP_CONSTEXPR_AFTER_CXX11 _RandomAccessIterator1\n__search(_RandomAccessIterator1 __first1, _RandomAccessIterator1 __last1,\n           _RandomAccessIterator2 __first2, _RandomAccessIterator2 __last2, _BinaryPredicate __pred,\n           random_access_iterator_tag, random_access_iterator_tag)\n{\n    typedef typename std::iterator_traits<_RandomAccessIterator1>::difference_type _D1;\n    typedef typename std::iterator_traits<_RandomAccessIterator2>::difference_type _D2;\n    // Take advantage of knowing source and pattern lengths.  Stop short when source is smaller than pattern\n    _D2 __len2 = __last2 - __first2;\n    if (__len2 == 0)\n        return __first1;\n    _D1 __len1 = __last1 - __first1;\n    if (__len1 < __len2)\n        return __last1;\n    const _RandomAccessIterator1 __s = __last1 - (__len2 - 1);  // Start of pattern match can't go beyond here\n    while (true)\n    {\n#if !_LIBCPP_UNROLL_LOOPS\n        while (true)\n        {\n            if (__first1 == __s)\n                return __last1;\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        }\n#else  // !_LIBCPP_UNROLL_LOOPS\n        for (_D1 __loop_unroll = (__s - __first1) / 4; __loop_unroll > 0; --__loop_unroll)\n        {\n            if (__pred(*__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            if (__pred(*++__first1, *__first2))\n                goto __phase2;\n            ++__first1;\n        }\n        switch (__s - __first1)\n        {\n        case 3:\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        case 2:\n            if (__pred(*__first1, *__first2))\n                break;\n            ++__first1;\n        case 1:\n            if (__pred(*__first1, *__first2))\n                break;\n        case 0:\n            return __last1;\n        }\n    __phase2:\n#endif  // !_LIBCPP_UNROLL_LOOPS\n        _RandomAccessIterator1 __m1 = __first1;\n        _RandomAccessIterator2 __m2 = __first2;\n#if !_LIBCPP_UNROLL_LOOPS\n         while (true)\n         {\n             if (++__m2 == __last2)\n                 return __first1;\n             ++__m1;          // no need to check range on __m1 because __s guarantees we have enough source\n             if (!__pred(*__m1, *__m2))\n             {\n                 ++__first1;\n                 break;\n             }\n         }\n#else  // !_LIBCPP_UNROLL_LOOPS\n        ++__m2;\n        ++__m1;\n        for (_D2 __loop_unroll = (__last2 - __m2) / 4; __loop_unroll > 0; --__loop_unroll)\n        {\n            if (!__pred(*__m1, *__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            if (!__pred(*++__m1, *++__m2))\n                goto __continue;\n            ++__m1;\n            ++__m2;\n        }\n        switch (__last2 - __m2)\n        {\n        case 3:\n            if (!__pred(*__m1, *__m2))\n                break;\n            ++__m1;\n            ++__m2;\n        case 2:\n            if (!__pred(*__m1, *__m2))\n                break;\n            ++__m1;\n            ++__m2;\n        case 1:\n            if (!__pred(*__m1, *__m2))\n                break;\n        case 0:\n            return __first1;\n        }\n    __continue:\n        ++__first1;\n#endif  // !_LIBCPP_UNROLL_LOOPS\n    }\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2, _BinaryPredicate __pred)\n{\n    return _VSTD::__search<typename add_lvalue_reference<_BinaryPredicate>::type>\n                         (__first1, __last1, __first2, __last2, __pred,\n                          typename std::iterator_traits<_ForwardIterator1>::iterator_category(),\n                          typename std::iterator_traits<_ForwardIterator2>::iterator_category());\n}\n\ntemplate <class _ForwardIterator1, class _ForwardIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator1\nsearch(_ForwardIterator1 __first1, _ForwardIterator1 __last1,\n       _ForwardIterator2 __first2, _ForwardIterator2 __last2)\n{\n    typedef typename std::iterator_traits<_ForwardIterator1>::value_type __v1;\n    typedef typename std::iterator_traits<_ForwardIterator2>::value_type __v2;\n    return _VSTD::search(__first1, __last1, __first2, __last2, __equal_to<__v1, __v2>());\n}\n\n// search_n\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _Size, class _Tp>\n_ForwardIterator\n__search_n(_ForwardIterator __first, _ForwardIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, forward_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first == __last)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _ForwardIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n            if (++__m == __last)  // Otherwise if source exhaused, pattern not found\n                return __last;\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _BinaryPredicate, class _RandomAccessIterator, class _Size, class _Tp>\n_RandomAccessIterator\n__search_n(_RandomAccessIterator __first, _RandomAccessIterator __last,\n           _Size __count, const _Tp& __value_, _BinaryPredicate __pred, random_access_iterator_tag)\n{\n    if (__count <= 0)\n        return __first;\n    _Size __len = static_cast<_Size>(__last - __first);\n    if (__len < __count)\n        return __last;\n    const _RandomAccessIterator __s = __last - (__count - 1);  // Start of pattern match can't go beyond here\n    while (true)\n    {\n        // Find first element in sequence that matchs __value_, with a mininum of loop checks\n        while (true)\n        {\n            if (__first >= __s)  // return __last if no element matches __value_\n                return __last;\n            if (__pred(*__first, __value_))\n                break;\n            ++__first;\n        }\n        // *__first matches __value_, now match elements after here\n        _RandomAccessIterator __m = __first;\n        _Size __c(0);\n        while (true)\n        {\n            if (++__c == __count)  // If pattern exhausted, __first is the answer (works for 1 element pattern)\n                return __first;\n             ++__m;          // no need to check range on __m because __s guarantees we have enough source\n            if (!__pred(*__m, __value_))  // if there is a mismatch, restart with a new __first\n            {\n                __first = __m;\n                ++__first;\n                break;\n            }  // else there is a match, check next elements\n        }\n    }\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last,\n         _Size __count, const _Tp& __value_, _BinaryPredicate __pred)\n{\n    return _VSTD::__search_n<typename add_lvalue_reference<_BinaryPredicate>::type>\n           (__first, __last, __count, __value_, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\ntemplate <class _ForwardIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nsearch_n(_ForwardIterator __first, _ForwardIterator __last, _Size __count, const _Tp& __value_)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::search_n(__first, __last, __count, __value_, __equal_to<__v, _Tp>());\n}\n\n// copy\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator\n{\n    static const bool value = is_pointer<_Iter>::value;\n};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<move_iterator<_Iter> >\n{\n    static const bool value = is_pointer<_Iter>::value;\n};\n\ntemplate <class _Iter>\nstruct __libcpp_is_trivial_iterator<__wrap_iter<_Iter> >\n{\n    static const bool value = is_pointer<_Iter>::value;\n};\n\ntemplate <class _Iter>\ninline _LIBCPP_INLINE_VISIBILITY\n_Iter\n__unwrap_iter(_Iter __i)\n{\n    return __i;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(move_iterator<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#if _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_trivially_copy_assignable<_Tp>::value,\n    _Tp*\n>::type\n__unwrap_iter(__wrap_iter<_Tp*> __i)\n{\n    return __i.base();\n}\n\n#endif  // _LIBCPP_DEBUG_LEVEL < 2\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, ++__result)\n        *__result = *__first;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__copy(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// copy_backward\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__copy_backward(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = *--__last;\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__copy_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    __result -= __n;\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\ncopy_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__copy_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// copy_if\n\ntemplate<class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ncopy_if(_InputIterator __first, _InputIterator __last,\n        _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// copy_n\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_input_iterator<_InputIterator>::value &&\n   !__is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __n, _OutputIterator __result)\n{\n    if (__n > 0)\n    {\n        *__result = *__first;\n        ++__result;\n        for (--__n; __n > 0; --__n)\n        {\n            ++__first;\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\ntemplate<class _InputIterator, class _Size, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    __is_random_access_iterator<_InputIterator>::value,\n    _OutputIterator\n>::type\ncopy_n(_InputIterator __first, _Size __n, _OutputIterator __result)\n{\n    return _VSTD::copy(__first, __first + __n, __result);\n}\n\n// move\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__first, ++__result)\n        *__result = _VSTD::move(*__first);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result + __n;\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmove(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    return _VSTD::__move(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// move_backward\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__move_backward(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    while (__first != __last)\n        *--__result = _VSTD::move(*--__last);\n    return __result;\n}\n\ntemplate <class _Tp, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_same<typename remove_const<_Tp>::type, _Up>::value &&\n    is_trivially_copy_assignable<_Up>::value,\n    _Up*\n>::type\n__move_backward(_Tp* __first, _Tp* __last, _Up* __result)\n{\n    const size_t __n = static_cast<size_t>(__last - __first);\n    __result -= __n;\n    _VSTD::memmove(__result, __first, __n * sizeof(_Up));\n    return __result;\n}\n\ntemplate <class _BidirectionalIterator1, class _BidirectionalIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator2\nmove_backward(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n              _BidirectionalIterator2 __result)\n{\n    return _VSTD::__move_backward(__unwrap_iter(__first), __unwrap_iter(__last), __unwrap_iter(__result));\n}\n\n// iter_swap\n\n// moved to <type_traits> for better swap / noexcept support\n\n// transform\n\ntemplate <class _InputIterator, class _OutputIterator, class _UnaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _UnaryOperation __op)\n{\n    for (; __first != __last; ++__first, ++__result)\n        *__result = __op(*__first);\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _BinaryOperation>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ntransform(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2,\n          _OutputIterator __result, _BinaryOperation __binary_op)\n{\n    for (; __first1 != __last1; ++__first1, ++__first2, ++__result)\n        *__result = __binary_op(*__first1, *__first2);\n    return __result;\n}\n\n// replace\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (*__first == __old_value)\n            *__first = __new_value;\n}\n\n// replace_if\n\ntemplate <class _ForwardIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreplace_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            *__first = __new_value;\n}\n\n// replace_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n             const _Tp& __old_value, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, ++__result)\n        if (*__first == __old_value)\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// replace_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreplace_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result,\n                _Predicate __pred, const _Tp& __new_value)\n{\n    for (; __first != __last; ++__first, ++__result)\n        if (__pred(*__first))\n            *__result = __new_value;\n        else\n            *__result = *__first;\n    return __result;\n}\n\n// fill_n\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\n__fill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n    for (; __n > 0; ++__first, --__n)\n        *__first = __value_;\n    return __first;\n}\n\ntemplate <class _Tp, class _Size, class _Up>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value && sizeof(_Tp) == 1 &&\n    !is_same<_Tp, bool>::value &&\n    is_integral<_Up>::value && sizeof(_Up) == 1,\n    _Tp*\n>::type\n__fill_n(_Tp* __first, _Size __n,_Up __value_)\n{\n    if (__n > 0)\n        _VSTD::memset(__first, (unsigned char)__value_, (size_t)(__n));\n    return __first + __n;\n}\n\ntemplate <class _OutputIterator, class _Size, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nfill_n(_OutputIterator __first, _Size __n, const _Tp& __value_)\n{\n   return _VSTD::__fill_n(__first, __n, __value_);\n}\n\n// fill\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, forward_iterator_tag)\n{\n    for (; __first != __last; ++__first)\n        *__first = __value_;\n}\n\ntemplate <class _RandomAccessIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__fill(_RandomAccessIterator __first, _RandomAccessIterator __last, const _Tp& __value_, random_access_iterator_tag)\n{\n    _VSTD::fill_n(__first, __last - __first, __value_);\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nfill(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    _VSTD::__fill(__first, __last, __value_, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// generate\n\ntemplate <class _ForwardIterator, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ngenerate(_ForwardIterator __first, _ForwardIterator __last, _Generator __gen)\n{\n    for (; __first != __last; ++__first)\n        *__first = __gen();\n}\n\n// generate_n\n\ntemplate <class _OutputIterator, class _Size, class _Generator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\ngenerate_n(_OutputIterator __first, _Size __n, _Generator __gen)\n{\n    for (; __n > 0; ++__first, --__n)\n        *__first = __gen();\n    return __first;\n}\n\n// remove\n\ntemplate <class _ForwardIterator, class _Tp>\n_ForwardIterator\nremove(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    __first = _VSTD::find(__first, __last, __value_);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!(*__i == __value_))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_if\n\ntemplate <class _ForwardIterator, class _Predicate>\n_ForwardIterator\nremove_if(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    __first = _VSTD::find_if<_ForwardIterator, typename add_lvalue_reference<_Predicate>::type>\n                           (__first, __last, __pred);\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (!__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n        }\n    }\n    return __first;\n}\n\n// remove_copy\n\ntemplate <class _InputIterator, class _OutputIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, const _Tp& __value_)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!(*__first == __value_))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// remove_copy_if\n\ntemplate <class _InputIterator, class _OutputIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nremove_copy_if(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (!__pred(*__first))\n        {\n            *__result = *__first;\n            ++__result;\n        }\n    }\n    return __result;\n}\n\n// unique\n\ntemplate <class _ForwardIterator, class _BinaryPredicate>\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last, _BinaryPredicate __pred)\n{\n    __first = _VSTD::adjacent_find<_ForwardIterator, typename add_lvalue_reference<_BinaryPredicate>::type>\n                                 (__first, __last, __pred);\n    if (__first != __last)\n    {\n        // ...  a  a  ?  ...\n        //      f     i\n        _ForwardIterator __i = __first;\n        for (++__i; ++__i != __last;)\n            if (!__pred(*__first, *__i))\n                *++__first = _VSTD::move(*__i);\n        ++__first;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nunique(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type __v;\n    return _VSTD::unique(__first, __last, __equal_to<__v>());\n}\n\n// unique_copy\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        typename iterator_traits<_InputIterator>::value_type __t(*__first);\n        *__result = __t;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(__t, *__first))\n            {\n                __t = *__first;\n                *__result = __t;\n                ++__result;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _ForwardIterator, class _OutputIterator>\n_OutputIterator\n__unique_copy(_ForwardIterator __first, _ForwardIterator __last, _OutputIterator __result, _BinaryPredicate __pred,\n              forward_iterator_tag, output_iterator_tag)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        *__result = *__i;\n        ++__result;\n        while (++__first != __last)\n        {\n            if (!__pred(*__i, *__first))\n            {\n                *__result = *__first;\n                ++__result;\n                __i = __first;\n            }\n        }\n    }\n    return __result;\n}\n\ntemplate <class _BinaryPredicate, class _InputIterator, class _ForwardIterator>\n_ForwardIterator\n__unique_copy(_InputIterator __first, _InputIterator __last, _ForwardIterator __result, _BinaryPredicate __pred,\n              input_iterator_tag, forward_iterator_tag)\n{\n    if (__first != __last)\n    {\n        *__result = *__first;\n        while (++__first != __last)\n            if (!__pred(*__result, *__first))\n                *++__result = *__first;\n        ++__result;\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator, class _OutputIterator, class _BinaryPredicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result, _BinaryPredicate __pred)\n{\n    return _VSTD::__unique_copy<typename add_lvalue_reference<_BinaryPredicate>::type>\n                              (__first, __last, __result, __pred,\n                               typename iterator_traits<_InputIterator>::iterator_category(),\n                               typename iterator_traits<_OutputIterator>::iterator_category());\n}\n\ntemplate <class _InputIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nunique_copy(_InputIterator __first, _InputIterator __last, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type __v;\n    return _VSTD::unique_copy(__first, __last, __result, __equal_to<__v>());\n}\n\n// reverse\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_BidirectionalIterator __first, _BidirectionalIterator __last, bidirectional_iterator_tag)\n{\n    while (__first != __last)\n    {\n        if (__first == --__last)\n            break;\n        swap(*__first, *__last);\n        ++__first;\n    }\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__reverse(_RandomAccessIterator __first, _RandomAccessIterator __last, random_access_iterator_tag)\n{\n    if (__first != __last)\n        for (; __first < --__last; ++__first)\n            swap(*__first, *__last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nreverse(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    _VSTD::__reverse(__first, __last, typename iterator_traits<_BidirectionalIterator>::iterator_category());\n}\n\n// reverse_copy\n\ntemplate <class _BidirectionalIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nreverse_copy(_BidirectionalIterator __first, _BidirectionalIterator __last, _OutputIterator __result)\n{\n    for (; __first != __last; ++__result)\n        *__result = *--__last;\n    return __result;\n}\n\n// rotate\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_left(_ForwardIterator __first, _ForwardIterator __last)\n{\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    value_type __tmp = _VSTD::move(*__first);\n    _ForwardIterator __lm1 = _VSTD::move(_VSTD::next(__first), __last, __first);\n    *__lm1 = _VSTD::move(__tmp);\n    return __lm1;\n}\n\ntemplate <class _BidirectionalIterator>\n_BidirectionalIterator\n__rotate_right(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    _BidirectionalIterator __lm1 = _VSTD::prev(__last);\n    value_type __tmp = _VSTD::move(*__lm1);\n    _BidirectionalIterator __fp1 = _VSTD::move_backward(__first, __lm1, __last);\n    *__first = _VSTD::move(__tmp);\n    return __fp1;\n}\n\ntemplate <class _ForwardIterator>\n_ForwardIterator\n__rotate_forward(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    _ForwardIterator __i = __middle;\n    while (true)\n    {\n        swap(*__first, *__i);\n        ++__first;\n        if (++__i == __last)\n            break;\n        if (__first == __middle)\n            __middle = __i;\n    }\n    _ForwardIterator __r = __first;\n    if (__first != __middle)\n    {\n        __i = __middle;\n        while (true)\n        {\n            swap(*__first, *__i);\n            ++__first;\n            if (++__i == __last)\n            {\n                if (__first == __middle)\n                    break;\n                __i = __middle;\n            }\n            else if (__first == __middle)\n                __middle = __i;\n        }\n    }\n    return __r;\n}\n\ntemplate<typename _Integral>\ninline _LIBCPP_INLINE_VISIBILITY\n_Integral\n__gcd(_Integral __x, _Integral __y)\n{\n    do\n    {\n        _Integral __t = __x % __y;\n        __x = __y;\n        __y = __t;\n    } while (__y);\n    return __x;\n}\n\ntemplate<typename _RandomAccessIterator>\n_RandomAccessIterator\n__rotate_gcd(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n\n    const difference_type __m1 = __middle - __first;\n    const difference_type __m2 = __last - __middle;\n    if (__m1 == __m2)\n    {\n        _VSTD::swap_ranges(__first, __middle, __middle);\n        return __middle;\n    }\n    const difference_type __g = _VSTD::__gcd(__m1, __m2);\n    for (_RandomAccessIterator __p = __first + __g; __p != __first;)\n    {\n        value_type __t(_VSTD::move(*--__p));\n        _RandomAccessIterator __p1 = __p;\n        _RandomAccessIterator __p2 = __p1 + __m1;\n        do\n        {\n            *__p1 = _VSTD::move(*__p2);\n            __p1 = __p2;\n            const difference_type __d = __last - __p2;\n            if (__m1 < __d)\n                __p2 += __m1;\n            else\n                __p2 = __first + (__m1 - __d);\n        } while (__p2 != __p);\n        *__p1 = _VSTD::move(__t);\n    }\n    return __first + __m2;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\n__rotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last,\n         _VSTD::forward_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_ForwardIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_BidirectionalIterator\n__rotate(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n         _VSTD::bidirectional_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_BidirectionalIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\n__rotate(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n         _VSTD::random_access_iterator_tag)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (_VSTD::is_trivially_move_assignable<value_type>::value)\n    {\n        if (_VSTD::next(__first) == __middle)\n            return _VSTD::__rotate_left(__first, __last);\n        if (_VSTD::next(__middle) == __last)\n            return _VSTD::__rotate_right(__first, __last);\n        return _VSTD::__rotate_gcd(__first, __middle, __last);\n    }\n    return _VSTD::__rotate_forward(__first, __middle, __last);\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nrotate(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last)\n{\n    if (__first == __middle)\n        return __last;\n    if (__middle == __last)\n        return __first;\n    return _VSTD::__rotate(__first, __middle, __last,\n                           typename _VSTD::iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// rotate_copy\n\ntemplate <class _ForwardIterator, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nrotate_copy(_ForwardIterator __first, _ForwardIterator __middle, _ForwardIterator __last, _OutputIterator __result)\n{\n    return _VSTD::copy(__first, __middle, _VSTD::copy(__middle, __last, __result));\n}\n\n// min_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\n__min_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__i, *__first))\n                __first = __i;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    return __min_element(__first, __last, __comp);\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmin_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return __min_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// min\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmin(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::min(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *__min_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmin(initializer_list<_Tp> __t)\n{\n    return *__min_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// max_element\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_ForwardIterator\n__max_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n            if (__comp(*__first, *__i))\n                __first = __i;\n    }\n    return __first;\n}\n\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    return __max_element(__first, __last, __comp);\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return __max_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// max\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__a, __b) ? __b : __a;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\nconst _Tp&\nmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::max(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    return *__max_element(__t.begin(), __t.end(), __comp);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\n_Tp\nmax(initializer_list<_Tp> __t)\n{\n    return *__max_element(__t.begin(), __t.end(), __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// minmax_element\n\ntemplate <class _ForwardIterator, class _Compare>\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n  std::pair<_ForwardIterator, _ForwardIterator> __result(__first, __first);\n  if (__first != __last)\n  {\n      if (++__first != __last)\n      {\n          if (__comp(*__first, *__result.first))\n              __result.first = __first;\n          else\n              __result.second = __first;\n          while (++__first != __last)\n          {\n              _ForwardIterator __i = __first;\n              if (++__first == __last)\n              {\n                  if (__comp(*__i, *__result.first))\n                      __result.first = __i;\n                  else if (!__comp(*__i, *__result.second))\n                      __result.second = __i;\n                  break;\n              }\n              else\n              {\n                  if (__comp(*__first, *__i))\n                  {\n                      if (__comp(*__first, *__result.first))\n                          __result.first = __first;\n                      if (!__comp(*__i, *__result.second))\n                          __result.second = __i;\n                  }\n                  else\n                  {\n                      if (__comp(*__i, *__result.first))\n                          __result.first = __i;\n                      if (!__comp(*__first, *__result.second))\n                          __result.second = __first;\n                  }\n              }\n          }\n      }\n  }\n  return __result;\n}\n\ntemplate <class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nstd::pair<_ForwardIterator, _ForwardIterator>\nminmax_element(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::minmax_element(__first, __last,\n              __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// minmax\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b, _Compare __comp)\n{\n    return __comp(__b, __a) ? pair<const _Tp&, const _Tp&>(__b, __a) :\n                              pair<const _Tp&, const _Tp&>(__a, __b);\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<const _Tp&, const _Tp&>\nminmax(const _Tp& __a, const _Tp& __b)\n{\n    return _VSTD::minmax(__a, __b, __less<_Tp>());\n}\n\n#ifndef _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\ntemplate<class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t, _Compare __comp)\n{\n    typedef typename initializer_list<_Tp>::const_iterator _Iter;\n    _Iter __first = __t.begin();\n    _Iter __last  = __t.end();\n    std::pair<_Tp, _Tp> __result ( *__first, *__first );\n\n    ++__first;\n    if (__t.size() % 2 == 0)\n    {\n        if (__comp(*__first,  __result.first))\n            __result.first  = *__first;\n        else\n            __result.second = *__first;\n        ++__first;\n    }\n    \n    while (__first != __last)\n    {\n        _Tp __prev = *__first++;\n        if (__comp(__prev, *__first)) {\n            if (__comp(__prev, __result.first))    __result.first  = __prev;\n            if (__comp(__result.second, *__first)) __result.second = *__first;\n            }\n        else {\n            if (__comp(*__first, __result.first)) __result.first  = *__first;\n            if (__comp(__result.second, __prev))  __result.second = __prev;\n            }\n                \n        __first++;\n    }\n    return __result;\n}\n\ntemplate<class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY _LIBCPP_CONSTEXPR_AFTER_CXX11\npair<_Tp, _Tp>\nminmax(initializer_list<_Tp> __t)\n{\n    return _VSTD::minmax(__t, __less<_Tp>());\n}\n\n#endif  // _LIBCPP_HAS_NO_GENERALIZED_INITIALIZERS\n\n// random_shuffle\n\n// __independent_bits_engine\n\ntemplate <unsigned long long _Xp, size_t _Rp>\nstruct __log2_imp\n{\n    static const size_t value = _Xp & ((unsigned long long)(1) << _Rp) ? _Rp\n                                           : __log2_imp<_Xp, _Rp - 1>::value;\n};\n\ntemplate <unsigned long long _Xp>\nstruct __log2_imp<_Xp, 0>\n{\n    static const size_t value = 0;\n};\n\ntemplate <size_t _Rp>\nstruct __log2_imp<0, _Rp>\n{\n    static const size_t value = _Rp + 1;\n};\n\ntemplate <class _UI, _UI _Xp>\nstruct __log2\n{\n    static const size_t value = __log2_imp<_Xp,\n                                         sizeof(_UI) * __CHAR_BIT__ - 1>::value;\n};\n\ntemplate<class _Engine, class _UIntType>\nclass __independent_bits_engine\n{\npublic:\n    // types\n    typedef _UIntType result_type;\n\nprivate:\n    typedef typename _Engine::result_type _Engine_result_type;\n    typedef typename conditional\n        <\n            sizeof(_Engine_result_type) <= sizeof(result_type),\n                result_type,\n                _Engine_result_type\n        >::type _Working_result_type;\n\n    _Engine& __e_;\n    size_t __w_;\n    size_t __w0_;\n    size_t __n_;\n    size_t __n0_;\n    _Working_result_type __y0_;\n    _Working_result_type __y1_;\n    _Engine_result_type __mask0_;\n    _Engine_result_type __mask1_;\n\n#ifdef _LIBCPP_HAS_NO_CONSTEXPR\n    static const _Working_result_type _Rp = _Engine::_Max - _Engine::_Min\n                                          + _Working_result_type(1);\n#else\n    static _LIBCPP_CONSTEXPR const _Working_result_type _Rp = _Engine::max() - _Engine::min()\n                                                      + _Working_result_type(1);\n#endif\n    static _LIBCPP_CONSTEXPR const size_t __m = __log2<_Working_result_type, _Rp>::value;\n    static _LIBCPP_CONSTEXPR const size_t _WDt = numeric_limits<_Working_result_type>::digits;\n    static _LIBCPP_CONSTEXPR const size_t _EDt = numeric_limits<_Engine_result_type>::digits;\n\npublic:\n    // constructors and seeding functions\n    __independent_bits_engine(_Engine& __e, size_t __w);\n\n    // generating functions\n    result_type operator()() {return __eval(integral_constant<bool, _Rp != 0>());}\n\nprivate:\n    result_type __eval(false_type);\n    result_type __eval(true_type);\n};\n\ntemplate<class _Engine, class _UIntType>\n__independent_bits_engine<_Engine, _UIntType>\n    ::__independent_bits_engine(_Engine& __e, size_t __w)\n        : __e_(__e),\n          __w_(__w)\n{\n    __n_ = __w_ / __m + (__w_ % __m != 0);\n    __w0_ = __w_ / __n_;\n    if (_Rp == 0)\n        __y0_ = _Rp;\n    else if (__w0_ < _WDt)\n        __y0_ = (_Rp >> __w0_) << __w0_;\n    else\n        __y0_ = 0;\n    if (_Rp - __y0_ > __y0_ / __n_)\n    {\n        ++__n_;\n        __w0_ = __w_ / __n_;\n        if (__w0_ < _WDt)\n            __y0_ = (_Rp >> __w0_) << __w0_;\n        else\n            __y0_ = 0;\n    }\n    __n0_ = __n_ - __w_ % __n_;\n    if (__w0_ < _WDt - 1)\n        __y1_ = (_Rp >> (__w0_ + 1)) << (__w0_ + 1);\n    else\n        __y1_ = 0;\n    __mask0_ = __w0_ > 0 ? _Engine_result_type(~0) >> (_EDt - __w0_) :\n                          _Engine_result_type(0);\n    __mask1_ = __w0_ < _EDt - 1 ?\n                               _Engine_result_type(~0) >> (_EDt - (__w0_ + 1)) :\n                               _Engine_result_type(~0);\n}\n\ntemplate<class _Engine, class _UIntType>\ninline\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(false_type)\n{\n    return static_cast<result_type>(__e_() & __mask0_);\n}\n\ntemplate<class _Engine, class _UIntType>\n_UIntType\n__independent_bits_engine<_Engine, _UIntType>::__eval(true_type)\n{\n    result_type _Sp = 0;\n    for (size_t __k = 0; __k < __n0_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y0_);\n        if (__w0_ < _WDt)\n            _Sp <<= __w0_;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask0_;\n    }\n    for (size_t __k = __n0_; __k < __n_; ++__k)\n    {\n        _Engine_result_type __u;\n        do\n        {\n            __u = __e_() - _Engine::min();\n        } while (__u >= __y1_);\n        if (__w0_ < _WDt - 1)\n            _Sp <<= __w0_ + 1;\n        else\n            _Sp = 0;\n        _Sp += __u & __mask1_;\n    }\n    return _Sp;\n}\n\n// uniform_int_distribution\n\ntemplate<class _IntType = int>\nclass uniform_int_distribution\n{\npublic:\n    // types\n    typedef _IntType result_type;\n\n    class param_type\n    {\n        result_type __a_;\n        result_type __b_;\n    public:\n        typedef uniform_int_distribution distribution_type;\n\n        explicit param_type(result_type __a = 0,\n                            result_type __b = numeric_limits<result_type>::max())\n            : __a_(__a), __b_(__b) {}\n\n        result_type a() const {return __a_;}\n        result_type b() const {return __b_;}\n\n        friend bool operator==(const param_type& __x, const param_type& __y)\n            {return __x.__a_ == __y.__a_ && __x.__b_ == __y.__b_;}\n        friend bool operator!=(const param_type& __x, const param_type& __y)\n            {return !(__x == __y);}\n    };\n\nprivate:\n    param_type __p_;\n\npublic:\n    // constructors and reset functions\n    explicit uniform_int_distribution(result_type __a = 0,\n                                      result_type __b = numeric_limits<result_type>::max())\n        : __p_(param_type(__a, __b)) {}\n    explicit uniform_int_distribution(const param_type& __p) : __p_(__p) {}\n    void reset() {}\n\n    // generating functions\n    template<class _URNG> result_type operator()(_URNG& __g)\n        {return (*this)(__g, __p_);}\n    template<class _URNG> result_type operator()(_URNG& __g, const param_type& __p);\n\n    // property functions\n    result_type a() const {return __p_.a();}\n    result_type b() const {return __p_.b();}\n\n    param_type param() const {return __p_;}\n    void param(const param_type& __p) {__p_ = __p;}\n\n    result_type min() const {return a();}\n    result_type max() const {return b();}\n\n    friend bool operator==(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n        {return __x.__p_ == __y.__p_;}\n    friend bool operator!=(const uniform_int_distribution& __x,\n                           const uniform_int_distribution& __y)\n            {return !(__x == __y);}\n};\n\ntemplate<class _IntType>\ntemplate<class _URNG>\ntypename uniform_int_distribution<_IntType>::result_type\nuniform_int_distribution<_IntType>::operator()(_URNG& __g, const param_type& __p)\n{\n    typedef typename conditional<sizeof(result_type) <= sizeof(uint32_t),\n                                            uint32_t, uint64_t>::type _UIntType;\n    const _UIntType _Rp = __p.b() - __p.a() + _UIntType(1);\n    if (_Rp == 1)\n        return __p.a();\n    const size_t _Dt = numeric_limits<_UIntType>::digits;\n    typedef __independent_bits_engine<_URNG, _UIntType> _Eng;\n    if (_Rp == 0)\n        return static_cast<result_type>(_Eng(__g, _Dt)());\n    size_t __w = _Dt - __clz(_Rp) - 1;\n    if ((_Rp & (_UIntType(~0) >> (_Dt - __w))) != 0)\n        ++__w;\n    _Eng __e(__g, __w);\n    _UIntType __u;\n    do\n    {\n        __u = __e();\n    } while (__u >= _Rp);\n    return static_cast<result_type>(__u + __p.a());\n}\n\nclass _LIBCPP_TYPE_VIS __rs_default;\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\nclass _LIBCPP_TYPE_VIS __rs_default\n{\n    static unsigned __c_;\n\n    __rs_default();\npublic:\n    typedef uint_fast32_t result_type;\n\n    static const result_type _Min = 0;\n    static const result_type _Max = 0xFFFFFFFF;\n\n    __rs_default(const __rs_default&);\n    ~__rs_default();\n\n    result_type operator()();\n\n    static _LIBCPP_CONSTEXPR result_type min() {return _Min;}\n    static _LIBCPP_CONSTEXPR result_type max() {return _Max;}\n\n    friend _LIBCPP_FUNC_VIS __rs_default __rs_get();\n};\n\n_LIBCPP_FUNC_VIS __rs_default __rs_get();\n\ntemplate <class _RandomAccessIterator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        __rs_default __g = __rs_get();\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _RandomNumberGenerator>\nvoid\nrandom_shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n               _RandomNumberGenerator&& __rand)\n#else\n               _RandomNumberGenerator& __rand)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        for (--__last; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __rand(__d);\n            swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate<class _RandomAccessIterator, class _UniformRandomNumberGenerator>\n    void shuffle(_RandomAccessIterator __first, _RandomAccessIterator __last,\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n                 _UniformRandomNumberGenerator&& __g)\n#else\n                 _UniformRandomNumberGenerator& __g)\n#endif\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef uniform_int_distribution<ptrdiff_t> _Dp;\n    typedef typename _Dp::param_type _Pp;\n    difference_type __d = __last - __first;\n    if (__d > 1)\n    {\n        _Dp __uid;\n        for (--__last, --__d; __first < __last; ++__first, --__d)\n        {\n            difference_type __i = __uid(__g, _Pp(0, __d));\n            if (__i != difference_type(0))\n                swap(*__first, *(__first + __i));\n        }\n    }\n}\n\ntemplate <class _InputIterator, class _Predicate>\nbool\nis_partitioned(_InputIterator __first, _InputIterator __last, _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n        if (!__pred(*__first))\n            break;\n    for (; __first != __last; ++__first)\n        if (__pred(*__first))\n            return false;\n    return true;\n}\n\n// partition\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred, forward_iterator_tag)\n{\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    for (_ForwardIterator __p = __first; ++__p != __last;)\n    {\n        if (__pred(*__p))\n        {\n            swap(*__first, *__p);\n            ++__first;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n            bidirectional_iterator_tag)\n{\n    while (true)\n    {\n        while (true)\n        {\n            if (__first == __last)\n                return __first;\n            if (!__pred(*__first))\n                break;\n            ++__first;\n        }\n        do\n        {\n            if (__first == --__last)\n                return __first;\n        } while (!__pred(*__last));\n        swap(*__first, *__last);\n        ++__first;\n    }\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\npartition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return _VSTD::__partition<typename add_lvalue_reference<_Predicate>::type>\n                            (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// partition_copy\n\ntemplate <class _InputIterator, class _OutputIterator1,\n          class _OutputIterator2, class _Predicate>\npair<_OutputIterator1, _OutputIterator2>\npartition_copy(_InputIterator __first, _InputIterator __last,\n               _OutputIterator1 __out_true, _OutputIterator2 __out_false,\n               _Predicate __pred)\n{\n    for (; __first != __last; ++__first)\n    {\n        if (__pred(*__first))\n        {\n            *__out_true = *__first;\n            ++__out_true;\n        }\n        else\n        {\n            *__out_false = *__first;\n            ++__out_false;\n        }\n    }\n    return pair<_OutputIterator1, _OutputIterator2>(__out_true, __out_false);\n}\n\n// partition_point\n\ntemplate<class _ForwardIterator, class _Predicate>\n_ForwardIterator\npartition_point(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__pred(*__m))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\n// stable_partition\n\ntemplate <class _Predicate, class _ForwardIterator, class _Distance, class _Pair>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, forward_iterator_tag __fit)\n{\n    // *__first is known to be false\n    // __len >= 1\n    if (__len == 1)\n        return __first;\n    if (__len == 2)\n    {\n        _ForwardIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            return __m;\n        }\n        return __first;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        __i = __first;\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 3\n    _ForwardIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m), *__first know to be false\n    // F?????????????????\n    // f       m         l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    _ForwardIterator __first_false = __stable_partition<_PredRef>(__first, __m, __pred, __len2, __p, __fit);\n    // TTTFFFFF??????????\n    // f  ff   m         l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    _ForwardIterator __m1 = __m;\n    _ForwardIterator __second_false = __last;\n    _Distance __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF??????\n    // f  ff   m  m1     l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __fit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf   l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\nstruct __return_temporary_buffer\n{\n    template <class _Tp>\n    _LIBCPP_INLINE_VISIBILITY void operator()(_Tp* __p) const {_VSTD::return_temporary_buffer(__p);}\n};\n\ntemplate <class _Predicate, class _ForwardIterator>\n_ForwardIterator\n__stable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred,\n                   forward_iterator_tag)\n{\n    const unsigned __alloc_limit = 3;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // We now have a reduced range [__first, __last)\n    // *__first is known to be false\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_ForwardIterator>::value_type value_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, forward_iterator_tag());\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator, class _Distance, class _Pair>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   _Distance __len, _Pair __p, bidirectional_iterator_tag __bit)\n{\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    if (__len == 2)\n    {\n        swap(*__first, *__last);\n        return __last;\n    }\n    if (__len == 3)\n    {\n        _BidirectionalIterator __m = __first;\n        if (__pred(*++__m))\n        {\n            swap(*__first, *__m);\n            swap(*__m, *__last);\n            return __last;\n        }\n        swap(*__m, *__last);\n        swap(*__first, *__m);\n        return __m;\n    }\n    if (__len <= __p.second)\n    {   // The buffer is big enough to use\n        typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__p.first, __d);\n        // Move the falses into the temporary buffer, and the trues to the front of the line\n        // Update __first to always point to the end of the trues\n        value_type* __t = __p.first;\n        ::new(__t) value_type(_VSTD::move(*__first));\n        __d.__incr((value_type*)0);\n        ++__t;\n        _BidirectionalIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__pred(*__i))\n            {\n                *__first = _VSTD::move(*__i);\n                ++__first;\n            }\n            else\n            {\n                ::new(__t) value_type(_VSTD::move(*__i));\n                __d.__incr((value_type*)0);\n                ++__t;\n            }\n        }\n        // move *__last, known to be true\n        *__first = _VSTD::move(*__i);\n        __i = ++__first;\n        // All trues now at start of range, all falses in buffer\n        // Move falses back into range, but don't mess up __first which points to first false\n        for (value_type* __t2 = __p.first; __t2 < __t; ++__t2, ++__i)\n            *__i = _VSTD::move(*__t2);\n        // __h destructs moved-from values out of the temp buffer, but doesn't deallocate buffer\n        return __first;\n    }\n    // Else not enough buffer, do in place\n    // __len >= 4\n    _BidirectionalIterator __m = __first;\n    _Distance __len2 = __len / 2;  // __len2 >= 2\n    _VSTD::advance(__m, __len2);\n    // recurse on [__first, __m-1], except reduce __m-1 until *(__m-1) is true, *__first know to be false\n    // F????????????????T\n    // f       m        l\n    _BidirectionalIterator __m1 = __m;\n    _BidirectionalIterator __first_false = __first;\n    _Distance __len_half = __len2;\n    while (!__pred(*--__m1))\n    {\n        if (__m1 == __first)\n            goto __first_half_done;\n        --__len_half;\n    }\n    // F???TFFF?????????T\n    // f   m1  m        l\n    typedef typename add_lvalue_reference<_Predicate>::type _PredRef;\n    __first_false = __stable_partition<_PredRef>(__first, __m1, __pred, __len_half, __p, __bit);\n__first_half_done:\n    // TTTFFFFF?????????T\n    // f  ff   m        l\n    // recurse on [__m, __last], except increase __m until *(__m) is false, *__last know to be true\n    __m1 = __m;\n    _BidirectionalIterator __second_false = __last;\n    ++__second_false;\n    __len_half = __len - __len2;\n    while (__pred(*__m1))\n    {\n        if (++__m1 == __last)\n            goto __second_half_done;\n        --__len_half;\n    }\n    // TTTFFFFFTTTF?????T\n    // f  ff   m  m1    l\n    __second_false = __stable_partition<_PredRef>(__m1, __last, __pred, __len_half, __p, __bit);\n__second_half_done:\n    // TTTFFFFFTTTTTFFFFF\n    // f  ff   m    sf  l\n    return _VSTD::rotate(__first_false, __m, __second_false);\n    // TTTTTTTTFFFFFFFFFF\n    //         |\n}\n\ntemplate <class _Predicate, class _BidirectionalIterator>\n_BidirectionalIterator\n__stable_partition(_BidirectionalIterator __first, _BidirectionalIterator __last, _Predicate __pred,\n                   bidirectional_iterator_tag)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    const difference_type __alloc_limit = 4;  // might want to make this a function of trivial assignment\n    // Either prove all true and return __first or point to first false\n    while (true)\n    {\n        if (__first == __last)\n            return __first;\n        if (!__pred(*__first))\n            break;\n        ++__first;\n    }\n    // __first points to first false, everything prior to __first is already set.\n    // Either prove [__first, __last) is all false and return __first, or point __last to last true\n    do\n    {\n        if (__first == --__last)\n            return __first;\n    } while (!__pred(*__last));\n    // We now have a reduced range [__first, __last]\n    // *__first is known to be false\n    // *__last is known to be true\n    // __len >= 2\n    difference_type __len = _VSTD::distance(__first, __last) + 1;\n    pair<value_type*, ptrdiff_t> __p(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len >= __alloc_limit)\n    {\n        __p = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__p.first);\n    }\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, __len, __p, bidirectional_iterator_tag());\n}\n\ntemplate <class _ForwardIterator, class _Predicate>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nstable_partition(_ForwardIterator __first, _ForwardIterator __last, _Predicate __pred)\n{\n    return __stable_partition<typename add_lvalue_reference<_Predicate>::type>\n                             (__first, __last, __pred, typename iterator_traits<_ForwardIterator>::iterator_category());\n}\n\n// is_sorted_until\n\ntemplate <class _ForwardIterator, class _Compare>\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    if (__first != __last)\n    {\n        _ForwardIterator __i = __first;\n        while (++__i != __last)\n        {\n            if (__comp(*__i, *__first))\n                return __i;\n            __first = __i;\n        }\n    }\n    return __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nis_sorted_until(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted_until(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// is_sorted\n\ntemplate <class _ForwardIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last, _Compare __comp)\n{\n    return _VSTD::is_sorted_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _ForwardIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_sorted(_ForwardIterator __first, _ForwardIterator __last)\n{\n    return _VSTD::is_sorted(__first, __last, __less<typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// sort\n\n// stable, 2-3 compares, 0-2 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort3(_ForwardIterator __x, _ForwardIterator __y, _ForwardIterator __z, _Compare __c)\n{\n    unsigned __r = 0;\n    if (!__c(*__y, *__x))          // if x <= y\n    {\n        if (!__c(*__z, *__y))      // if y <= z\n            return __r;            // x <= y && y <= z\n                                   // x <= y && y > z\n        swap(*__y, *__z);          // x <= z && y < z\n        __r = 1;\n        if (__c(*__y, *__x))       // if x > y\n        {\n            swap(*__x, *__y);      // x < y && y <= z\n            __r = 2;\n        }\n        return __r;                // x <= y && y < z\n    }\n    if (__c(*__z, *__y))           // x > y, if y > z\n    {\n        swap(*__x, *__z);          // x < y && y < z\n        __r = 1;\n        return __r;\n    }\n    swap(*__x, *__y);              // x > y && y <= z\n    __r = 1;                       // x < y && x <= z\n    if (__c(*__z, *__y))           // if y > z\n    {\n        swap(*__y, *__z);          // x <= y && y < z\n        __r = 2;\n    }\n    return __r;\n}                                  // x <= y && y <= z\n\n// stable, 3-6 compares, 0-5 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort4(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _Compare __c)\n{\n    unsigned __r = __sort3<_Compare>(__x1, __x2, __x3, __c);\n    if (__c(*__x4, *__x3))\n    {\n        swap(*__x3, *__x4);\n        ++__r;\n        if (__c(*__x3, *__x2))\n        {\n            swap(*__x2, *__x3);\n            ++__r;\n            if (__c(*__x2, *__x1))\n            {\n                swap(*__x1, *__x2);\n                ++__r;\n            }\n        }\n    }\n    return __r;\n}\n\n// stable, 4-10 compares, 0-9 swaps\n\ntemplate <class _Compare, class _ForwardIterator>\nunsigned\n__sort5(_ForwardIterator __x1, _ForwardIterator __x2, _ForwardIterator __x3,\n            _ForwardIterator __x4, _ForwardIterator __x5, _Compare __c)\n{\n    unsigned __r = __sort4<_Compare>(__x1, __x2, __x3, __x4, __c);\n    if (__c(*__x5, *__x4))\n    {\n        swap(*__x4, *__x5);\n        ++__r;\n        if (__c(*__x4, *__x3))\n        {\n            swap(*__x3, *__x4);\n            ++__r;\n            if (__c(*__x3, *__x2))\n            {\n                swap(*__x2, *__x3);\n                ++__r;\n                if (__c(*__x2, *__x1))\n                {\n                    swap(*__x1, *__x2);\n                    ++__r;\n                }\n            }\n        }\n    }\n    return __r;\n}\n\n// Assumes size > 0\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__selection_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    _BirdirectionalIterator __lm1 = __last;\n    for (--__lm1; __first != __lm1; ++__first)\n    {\n        _BirdirectionalIterator __i = _VSTD::min_element<_BirdirectionalIterator,\n                                                        typename add_lvalue_reference<_Compare>::type>\n                                                       (__first, __last, __comp);\n        if (__i != __first)\n            swap(*__first, *__i);\n    }\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort(_BirdirectionalIterator __first, _BirdirectionalIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first != __last)\n    {\n        _BirdirectionalIterator __i = __first;\n        for (++__i; __i != __last; ++__i)\n        {\n            _BirdirectionalIterator __j = __i;\n            value_type __t(_VSTD::move(*__j));\n            for (_BirdirectionalIterator __k = __i; __k != __first && __comp(__t,  *--__k); --__j)\n                *__j = _VSTD::move(*__k);\n            *__j = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__insertion_sort_3(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n        }\n        __j = __i;\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nbool\n__insertion_sort_incomplete(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    switch (__last - __first)\n    {\n    case 0:\n    case 1:\n        return true;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return true;\n    case 3:\n        _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n        return true;\n    case 4:\n        _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n        return true;\n    case 5:\n        _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n        return true;\n    }\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    _RandomAccessIterator __j = __first+2;\n    __sort3<_Compare>(__first, __first+1, __j, __comp);\n    const unsigned __limit = 8;\n    unsigned __count = 0;\n    for (_RandomAccessIterator __i = __j+1; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__j))\n        {\n            value_type __t(_VSTD::move(*__i));\n            _RandomAccessIterator __k = __j;\n            __j = __i;\n            do\n            {\n                *__j = _VSTD::move(*__k);\n                __j = __k;\n            } while (__j != __first && __comp(__t, *--__k));\n            *__j = _VSTD::move(__t);\n            if (++__count == __limit)\n                return ++__i == __last;\n        }\n        __j = __i;\n    }\n    return true;\n}\n\ntemplate <class _Compare, class _BirdirectionalIterator>\nvoid\n__insertion_sort_move(_BirdirectionalIterator __first1, _BirdirectionalIterator __last1,\n                      typename iterator_traits<_BirdirectionalIterator>::value_type* __first2, _Compare __comp)\n{\n    typedef typename iterator_traits<_BirdirectionalIterator>::value_type value_type;\n    if (__first1 != __last1)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h(__first2, __d);\n        value_type* __last2 = __first2;\n        ::new(__last2) value_type(_VSTD::move(*__first1));\n        __d.__incr((value_type*)0);\n        for (++__last2; ++__first1 != __last1; ++__last2)\n        {\n            value_type* __j2 = __last2;\n            value_type* __i2 = __j2;\n            if (__comp(*__first1, *--__i2))\n            {\n                ::new(__j2) value_type(_VSTD::move(*__i2));\n                __d.__incr((value_type*)0);\n                for (--__j2; __i2 != __first2 && __comp(*__first1,  *--__i2); --__j2)\n                    *__j2 = _VSTD::move(*__i2);\n                *__j2 = _VSTD::move(*__first1);\n            }\n            else\n            {\n                ::new(__j2) value_type(_VSTD::move(*__first1));\n                __d.__incr((value_type*)0);\n            }\n        }\n        __h.release();\n    }\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    const difference_type __limit = is_trivially_copy_constructible<value_type>::value &&\n                                    is_trivially_copy_assignable<value_type>::value ? 30 : 6;\n    while (true)\n    {\n    __restart:\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            _VSTD::__sort3<_Compare>(__first, __first+1, --__last, __comp);\n            return;\n        case 4:\n            _VSTD::__sort4<_Compare>(__first, __first+1, __first+2, --__last, __comp);\n            return;\n        case 5:\n            _VSTD::__sort5<_Compare>(__first, __first+1, __first+2, __first+3, --__last, __comp);\n            return;\n        }\n        if (__len <= __limit)\n        {\n            _VSTD::__insertion_sort_3<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > 5\n        _RandomAccessIterator __m = __first;\n        _RandomAccessIterator __lm1 = __last;\n        --__lm1;\n        unsigned __n_swaps;\n        {\n        difference_type __delta;\n        if (__len >= 1000)\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __delta /= 2;\n            __n_swaps = _VSTD::__sort5<_Compare>(__first, __first + __delta, __m, __m+__delta, __lm1, __comp);\n        }\n        else\n        {\n            __delta = __len/2;\n            __m += __delta;\n            __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, __lm1, __comp);\n        }\n        }\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted, sort the secod part\n                    // _VSTD::__sort<_Compare>(__i, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        // It is known that *__i < *__m\n        ++__i;\n        // j points beyond range to be tested, *__m is known to be <= *__lm1\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            // known that __i <= __m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i > __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        // If we were given a perfect partition, see if insertion sort is quick...\n        if (__n_swaps == 0)\n        {\n            bool __fs = _VSTD::__insertion_sort_incomplete<_Compare>(__first, __i, __comp);\n            if (_VSTD::__insertion_sort_incomplete<_Compare>(__i+1, __last, __comp))\n            {\n                if (__fs)\n                    return;\n                __last = __i;\n                continue;\n            }\n            else\n            {\n                if (__fs)\n                {\n                    __first = ++__i;\n                    continue;\n                }\n            }\n        }\n        // sort smaller range with recursive call and larger with tail recursion elimination\n        if (__i - __first < __last - __i)\n        {\n            _VSTD::__sort<_Compare>(__first, __i, __comp);\n            // _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            __first = ++__i;\n        }\n        else\n        {\n            _VSTD::__sort<_Compare>(__i+1, __last, __comp);\n            // _VSTD::__sort<_Compare>(__first, __i, __comp);\n            __last = __i;\n        }\n    }\n}\n\n// This forwarder keeps the top call and the recursive calls using the same instantiation, forcing a reference _Compare\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(_Tp** __first, _Tp** __last)\n{\n    _VSTD::sort((size_t*)__first, (size_t*)__last, __less<size_t>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last)\n{\n    _VSTD::sort(__first.base(), __last.base());\n}\n\ntemplate <class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort(__wrap_iter<_Tp*> __first, __wrap_iter<_Tp*> __last, _Compare __comp)\n{\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    _VSTD::sort<_Tp*, _Comp_ref>(__first.base(), __last.base(), __comp);\n}\n\n#ifdef _LIBCPP_MSVC\n#pragma warning( push )\n#pragma warning( disable: 4231)\n#endif // _LIBCPP_MSVC\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS void __sort<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<char>&, char*>(char*, char*, __less<char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<wchar_t>&, wchar_t*>(wchar_t*, wchar_t*, __less<wchar_t>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<signed char>&, signed char*>(signed char*, signed char*, __less<signed char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned char>&, unsigned char*>(unsigned char*, unsigned char*, __less<unsigned char>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<short>&, short*>(short*, short*, __less<short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned short>&, unsigned short*>(unsigned short*, unsigned short*, __less<unsigned short>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<int>&, int*>(int*, int*, __less<int>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned>&, unsigned*>(unsigned*, unsigned*, __less<unsigned>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long>&, long*>(long*, long*, __less<long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long>&, unsigned long*>(unsigned long*, unsigned long*, __less<unsigned long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long long>&, long long*>(long long*, long long*, __less<long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<unsigned long long>&, unsigned long long*>(unsigned long long*, unsigned long long*, __less<unsigned long long>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<float>&, float*>(float*, float*, __less<float>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<double>&, double*>(double*, double*, __less<double>&))\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS bool __insertion_sort_incomplete<__less<long double>&, long double*>(long double*, long double*, __less<long double>&))\n\n_LIBCPP_EXTERN_TEMPLATE(_LIBCPP_FUNC_VIS unsigned __sort5<__less<long double>&, long double*>(long double*, long double*, long double*, long double*, long double*, __less<long double>&))\n#ifdef _LIBCPP_MSVC\n#pragma warning( pop )\n#endif  // _LIBCPP_MSVC\n\n// lower_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__lower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else\n            __len = __l2;\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lower_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nlower_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::lower_bound(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// upper_bound\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\n_ForwardIterator\n__upper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(__value_, *__m))\n            __len = __l2;\n        else\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n    }\n    return __first;\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __upper_bound<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_ForwardIterator\nupper_bound(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::upper_bound(__first, __last, __value_,\n                             __less<_Tp, typename iterator_traits<_ForwardIterator>::value_type>());\n}\n\n// equal_range\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\npair<_ForwardIterator, _ForwardIterator>\n__equal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    typedef typename iterator_traits<_ForwardIterator>::difference_type difference_type;\n    difference_type __len = _VSTD::distance(__first, __last);\n    while (__len != 0)\n    {\n        difference_type __l2 = __len / 2;\n        _ForwardIterator __m = __first;\n        _VSTD::advance(__m, __l2);\n        if (__comp(*__m, __value_))\n        {\n            __first = ++__m;\n            __len -= __l2 + 1;\n        }\n        else if (__comp(__value_, *__m))\n        {\n            __last = __m;\n            __len = __l2;\n        }\n        else\n        {\n            _ForwardIterator __mp1 = __m;\n            return pair<_ForwardIterator, _ForwardIterator>\n                   (\n                      __lower_bound<_Compare>(__first, __m, __value_, __comp),\n                      __upper_bound<_Compare>(++__mp1, __last, __value_, __comp)\n                   );\n        }\n    }\n    return pair<_ForwardIterator, _ForwardIterator>(__first, __first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __equal_range<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\npair<_ForwardIterator, _ForwardIterator>\nequal_range(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::equal_range(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// binary_search\n\ntemplate <class _Compare, class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\n__binary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n    __first = __lower_bound<_Compare>(__first, __last, __value_, __comp);\n    return __first != __last && !__comp(__value_, *__first);\n}\n\ntemplate <class _ForwardIterator, class _Tp, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __binary_search<_Comp_ref>(__first, __last, __value_, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _ForwardIterator, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nbinary_search(_ForwardIterator __first, _ForwardIterator __last, const _Tp& __value_)\n{\n    return _VSTD::binary_search(__first, __last, __value_,\n                             __less<typename iterator_traits<_ForwardIterator>::value_type, _Tp>());\n}\n\n// merge\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__merge(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__merge<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nmerge(_InputIterator1 __first1, _InputIterator1 __last1,\n      _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type __v1;\n    typedef typename iterator_traits<_InputIterator2>::value_type __v2;\n    return merge(__first1, __last1, __first2, __last2, __result, __less<__v1, __v2>());\n}\n\n// inplace_merge\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__buffered_inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::pointer pointer;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n    if (__len1 <= __len2)\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __first; __i != __middle; __d.__incr((value_type*)0), ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        __merge<_Compare>(move_iterator<value_type*>(__buff),\n                          move_iterator<value_type*>(__p),\n                          move_iterator<_BidirectionalIterator>(__middle),\n                          move_iterator<_BidirectionalIterator>(__last),\n                          __first, __comp);\n    }\n    else\n    {\n        value_type* __p = __buff;\n        for (_BidirectionalIterator __i = __middle; __i != __last; __d.__incr((value_type*)0), ++__i, ++__p)\n            ::new(__p) value_type(_VSTD::move(*__i));\n        typedef reverse_iterator<_BidirectionalIterator> _RBi;\n        typedef reverse_iterator<value_type*> _Rv;\n        __merge(move_iterator<_RBi>(_RBi(__middle)), move_iterator<_RBi>(_RBi(__first)),\n                move_iterator<_Rv>(_Rv(__p)), move_iterator<_Rv>(_Rv(__buff)),\n                _RBi(__last), __negate<_Compare>(__comp));\n    }\n}\n\ntemplate <class _Compare, class _BidirectionalIterator>\nvoid\n__inplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n                _Compare __comp, typename iterator_traits<_BidirectionalIterator>::difference_type __len1,\n                                 typename iterator_traits<_BidirectionalIterator>::difference_type __len2,\n                typename iterator_traits<_BidirectionalIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    while (true)\n    {\n        // if __middle == __last, we're done\n        if (__len2 == 0)\n            return;\n        // shrink [__first, __middle) as much as possible (with no moves), returning if it shrinks to 0\n        for (; true; ++__first, --__len1)\n        {\n            if (__len1 == 0)\n                return;\n            if (__comp(*__middle, *__first))\n                break;\n        }\n        if (__len1 <= __buff_size || __len2 <= __buff_size)\n        {\n            __buffered_inplace_merge<_Compare>(__first, __middle, __last, __comp, __len1, __len2, __buff);\n            return;\n        }\n        // __first < __middle < __last\n        // *__first > *__middle\n        // partition [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last) such that\n        //     all elements in:\n        //         [__first, __m1)  <= [__middle, __m2)\n        //         [__middle, __m2) <  [__m1, __middle)\n        //         [__m1, __middle) <= [__m2, __last)\n        //     and __m1 or __m2 is in the middle of its range\n        _BidirectionalIterator __m1;  // \"median\" of [__first, __middle)\n        _BidirectionalIterator __m2;  // \"median\" of [__middle, __last)\n        difference_type __len11;      // distance(__first, __m1)\n        difference_type __len21;      // distance(__middle, __m2)\n        // binary search smaller range\n        if (__len1 < __len2)\n        {   // __len >= 1, __len2 >= 2\n            __len21 = __len2 / 2;\n            __m2 = __middle;\n            _VSTD::advance(__m2, __len21);\n            __m1 = __upper_bound<_Compare>(__first, __middle, *__m2, __comp);\n            __len11 = _VSTD::distance(__first, __m1);\n        }\n        else\n        {\n            if (__len1 == 1)\n            {   // __len1 >= __len2 && __len2 > 0, therefore __len2 == 1\n                // It is known *__first > *__middle\n                swap(*__first, *__middle);\n                return;\n            }\n            // __len1 >= 2, __len2 >= 1\n            __len11 = __len1 / 2;\n            __m1 = __first;\n            _VSTD::advance(__m1, __len11);\n            __m2 = __lower_bound<_Compare>(__middle, __last, *__m1, __comp);\n            __len21 = _VSTD::distance(__middle, __m2);\n        }\n        difference_type __len12 = __len1 - __len11;  // distance(__m1, __middle)\n        difference_type __len22 = __len2 - __len21;  // distance(__m2, __last)\n        // [__first, __m1) [__m1, __middle) [__middle, __m2) [__m2, __last)\n        // swap middle two partitions\n        __middle = _VSTD::rotate(__m1, __middle, __m2);\n        // __len12 and __len21 now have swapped meanings\n        // merge smaller range with recurisve call and larger with tail recursion elimination\n        if (__len11 + __len21 < __len12 + __len22)\n        {\n            __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n            __first = __middle;\n            __middle = __m2;\n            __len1 = __len12;\n            __len2 = __len22;\n        }\n        else\n        {\n            __inplace_merge<_Compare>(__middle, __m2, __last, __comp, __len12, __len22, __buff, __buff_size);\n//          __inplace_merge<_Compare>(__first, __m1, __middle, __comp, __len11, __len21, __buff, __buff_size);\n            __last = __middle;\n            __middle = __m1;\n            __len1 = __len11;\n            __len2 = __len21;\n        }\n    }\n}\n\ntemplate <class _Tp>\nstruct __inplace_merge_switch\n{\n    static const unsigned value = is_trivially_copy_assignable<_Tp>::value;\n};\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last,\n              _Compare __comp)\n{\n    typedef typename iterator_traits<_BidirectionalIterator>::value_type value_type;\n    typedef typename iterator_traits<_BidirectionalIterator>::difference_type difference_type;\n    difference_type __len1 = _VSTD::distance(__first, __middle);\n    difference_type __len2 = _VSTD::distance(__middle, __last);\n    difference_type __buf_size = _VSTD::min(__len1, __len2);\n    pair<value_type*, ptrdiff_t> __buf(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__inplace_merge_switch<value_type>::value && __buf_size > 8)\n    {\n        __buf = _VSTD::get_temporary_buffer<value_type>(__buf_size);\n        __h.reset(__buf.first);\n    }\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __c, __len1, __len2,\n                                            __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return _VSTD::__inplace_merge<_Comp_ref>(__first, __middle, __last, __comp, __len1, __len2,\n                                            __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\ninplace_merge(_BidirectionalIterator __first, _BidirectionalIterator __middle, _BidirectionalIterator __last)\n{\n    _VSTD::inplace_merge(__first, __middle, __last,\n                        __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// stable_sort\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nvoid\n__merge_move_construct(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        typename iterator_traits<_InputIterator1>::value_type* __result, _Compare __comp)\n{\n    typedef typename iterator_traits<_InputIterator1>::value_type value_type;\n    __destruct_n __d(0);\n    unique_ptr<value_type, __destruct_n&> __h(__result, __d);\n    for (; true; ++__result)\n    {\n        if (__first1 == __last1)\n        {\n            for (; __first2 != __last2; ++__first2, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first2));\n            __h.release();\n            return;\n        }\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result, __d.__incr((value_type*)0))\n                ::new (__result) value_type(_VSTD::move(*__first1));\n            __h.release();\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            ::new (__result) value_type(_VSTD::move(*__first2));\n            __d.__incr((value_type*)0);\n            ++__first2;\n        }\n        else\n        {\n            ::new (__result) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first1;\n        }\n    }\n}\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\nvoid\n__merge_move_assign(_InputIterator1 __first1, _InputIterator1 __last1,\n        _InputIterator2 __first2, _InputIterator2 __last2,\n        _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n        {\n            for (; __first1 != __last1; ++__first1, ++__result)\n                *__result = _VSTD::move(*__first1);\n            return;\n        }\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = _VSTD::move(*__first2);\n            ++__first2;\n        }\n        else\n        {\n            *__result = _VSTD::move(*__first1);\n            ++__first1;\n        }\n    }\n    for (; __first2 != __last2; ++__first2, ++__result)\n        *__result = _VSTD::move(*__first2);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size);\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort_move(_RandomAccessIterator __first1, _RandomAccessIterator __last1, _Compare __comp,\n                   typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n                   typename iterator_traits<_RandomAccessIterator>::value_type* __first2)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    switch (__len)\n    {\n    case 0:\n        return;\n    case 1:\n        ::new(__first2) value_type(_VSTD::move(*__first1));\n        return;\n    case 2:\n       __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__first2, __d);\n         if (__comp(*--__last1, *__first1))\n        {\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n        }\n        else\n        {\n            ::new(__first2) value_type(_VSTD::move(*__first1));\n            __d.__incr((value_type*)0);\n            ++__first2;\n            ::new(__first2) value_type(_VSTD::move(*__last1));\n        }\n        __h2.release();\n        return;\n    }\n    if (__len <= 8)\n    {\n        __insertion_sort_move<_Compare>(__first1, __last1, __first2, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first1 + __l2;\n    __stable_sort<_Compare>(__first1, __m, __comp, __l2, __first2, __l2);\n    __stable_sort<_Compare>(__m, __last1, __comp, __len - __l2, __first2 + __l2, __len - __l2);\n    __merge_move_construct<_Compare>(__first1, __m, __m, __last1, __first2, __comp);\n}\n\ntemplate <class _Tp>\nstruct __stable_sort_switch\n{\n    static const unsigned value = 128*is_trivially_copy_assignable<_Tp>::value;\n};\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__stable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n              typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n              typename iterator_traits<_RandomAccessIterator>::value_type* __buff, ptrdiff_t __buff_size)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    switch (__len)\n    {\n    case 0:\n    case 1:\n        return;\n    case 2:\n        if (__comp(*--__last, *__first))\n            swap(*__first, *__last);\n        return;\n    }\n    if (__len <= static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __insertion_sort<_Compare>(__first, __last, __comp);\n        return;\n    }\n    typename iterator_traits<_RandomAccessIterator>::difference_type __l2 = __len / 2;\n    _RandomAccessIterator __m = __first + __l2;\n    if (__len <= __buff_size)\n    {\n        __destruct_n __d(0);\n        unique_ptr<value_type, __destruct_n&> __h2(__buff, __d);\n        __stable_sort_move<_Compare>(__first, __m, __comp, __l2, __buff);\n        __d.__set(__l2, (value_type*)0);\n        __stable_sort_move<_Compare>(__m, __last, __comp, __len - __l2, __buff + __l2);\n        __d.__set(__len, (value_type*)0);\n        __merge_move_assign<_Compare>(__buff, __buff + __l2, __buff + __l2, __buff + __len, __first, __comp);\n//         __merge<_Compare>(move_iterator<value_type*>(__buff),\n//                           move_iterator<value_type*>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __l2),\n//                           move_iterator<_RandomAccessIterator>(__buff + __len),\n//                           __first, __comp);\n        return;\n    }\n    __stable_sort<_Compare>(__first, __m, __comp, __l2, __buff, __buff_size);\n    __stable_sort<_Compare>(__m, __last, __comp, __len - __l2, __buff, __buff_size);\n    __inplace_merge<_Compare>(__first, __m, __last, __comp, __l2, __len - __l2, __buff, __buff_size);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    pair<value_type*, ptrdiff_t> __buf(0, 0);\n    unique_ptr<value_type, __return_temporary_buffer> __h;\n    if (__len > static_cast<difference_type>(__stable_sort_switch<value_type>::value))\n    {\n        __buf = _VSTD::get_temporary_buffer<value_type>(__len);\n        __h.reset(__buf.first);\n    }\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __stable_sort<_Comp_ref>(__first, __last, __c, __len, __buf.first, __buf.second);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __stable_sort<_Comp_ref>(__first, __last, __comp, __len, __buf.first, __buf.second);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nstable_sort(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::stable_sort(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap_until\n\ntemplate <class _RandomAccessIterator, class _Compare>\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename _VSTD::iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __len = __last - __first;\n    difference_type __p = 0;\n    difference_type __c = 1;\n    _RandomAccessIterator __pp = __first;\n    while (__c < __len)\n    {\n        _RandomAccessIterator __cp = __first + __c;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__c;\n        ++__cp;\n        if (__c == __len)\n            return __last;\n        if (__comp(*__pp, *__cp))\n            return __cp;\n        ++__p;\n        ++__pp;\n        __c = 2 * __p + 1;\n    }\n    return __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\nis_heap_until(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap_until(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// is_heap\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    return _VSTD::is_heap_until(__first, __last, __comp) == __last;\n}\n\ntemplate<class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nis_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    return _VSTD::is_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// push_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_up(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n          typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    if (__len > 1)\n    {\n        __len = (__len - 2) / 2;\n        _RandomAccessIterator __ptr = __first + __len;\n        if (__comp(*__ptr, *--__last))\n        {\n            value_type __t(_VSTD::move(*__last));\n            do\n            {\n                *__last = _VSTD::move(*__ptr);\n                __last = __ptr;\n                if (__len == 0)\n                    break;\n                __len = (__len - 1) / 2;\n                __ptr = __first + __len;\n            } while (__comp(*__ptr, __t));\n            *__last = _VSTD::move(__t);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sift_up<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sift_up<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npush_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::push_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// pop_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sift_down(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n            typename iterator_traits<_RandomAccessIterator>::difference_type __len,\n            _RandomAccessIterator __start)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    typedef typename iterator_traits<_RandomAccessIterator>::value_type value_type;\n    // left-child of __start is at 2 * __start + 1\n    // right-child of __start is at 2 * __start + 2\n    difference_type __child = __start - __first;\n\n    if (__len < 2 || (__len - 2) / 2 < __child)\n        return;\n\n    __child = 2 * __child + 1;\n    _RandomAccessIterator __child_i = __first + __child;\n\n    if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n        // right-child exists and is greater than left-child\n        ++__child_i;\n        ++__child;\n    }\n\n    // check if we are in heap-order\n    if (__comp(*__child_i, *__start))\n        // we are, __start is larger than it's largest child\n        return;\n\n    value_type __top(_VSTD::move(*__start));\n    do\n    {\n        // we are not in heap-order, swap the parent with it's largest child\n        *__start = _VSTD::move(*__child_i);\n        __start = __child_i;\n\n        if ((__len - 2) / 2 < __child)\n            break;\n\n        // recompute the child based off of the updated parent\n        __child = 2 * __child + 1;\n        __child_i = __first + __child;\n\n        if ((__child + 1) < __len && __comp(*__child_i, *(__child_i + 1))) {\n            // right-child exists and is greater than left-child\n            ++__child_i;\n            ++__child;\n        }\n\n        // check if we are in heap-order\n    } while (!__comp(*__child_i, __top));\n    *__start = _VSTD::move(__top);\n}\n\ntemplate <class _Compare, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__pop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp,\n           typename iterator_traits<_RandomAccessIterator>::difference_type __len)\n{\n    if (__len > 1)\n    {\n        swap(*__first, *--__last);\n        __sift_down<_Compare>(__first, __last, __comp, __len - 1, __first);\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __pop_heap<_Comp_ref>(__first, __last, __c, __last - __first);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __pop_heap<_Comp_ref>(__first, __last, __comp, __last - __first);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npop_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::pop_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// make_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__make_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    difference_type __n = __last - __first;\n    if (__n > 1)\n    {\n        // start from the first parent, there is no need to consider children\n        for (difference_type __start = (__n - 2) / 2; __start >= 0; --__start)\n        {\n            __sift_down<_Compare>(__first, __last, __comp, __n, __first + __start);\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __make_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __make_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nmake_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::make_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// sort_heap\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__sort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    for (difference_type __n = __last - __first; __n > 1; --__last, --__n)\n        __pop_heap<_Compare>(__first, __last, __comp, __n);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __sort_heap<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __sort_heap<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nsort_heap(_RandomAccessIterator __first, _RandomAccessIterator __last)\n{\n    _VSTD::sort_heap(__first, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__partial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n    __make_heap<_Compare>(__first, __middle, __comp);\n    typename iterator_traits<_RandomAccessIterator>::difference_type __len = __middle - __first;\n    for (_RandomAccessIterator __i = __middle; __i != __last; ++__i)\n    {\n        if (__comp(*__i, *__first))\n        {\n            swap(*__i, *__first);\n            __sift_down<_Compare>(__first, __middle, __comp, __len, __first);\n        }\n    }\n    __sort_heap<_Compare>(__first, __middle, __comp);\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last,\n             _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __partial_sort<_Comp_ref>(__first, __middle, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\npartial_sort(_RandomAccessIterator __first, _RandomAccessIterator __middle, _RandomAccessIterator __last)\n{\n    _VSTD::partial_sort(__first, __middle, __last,\n                       __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// partial_sort_copy\n\ntemplate <class _Compare, class _InputIterator, class _RandomAccessIterator>\n_RandomAccessIterator\n__partial_sort_copy(_InputIterator __first, _InputIterator __last,\n                    _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n    _RandomAccessIterator __r = __result_first;\n    if (__r != __result_last)\n    {\n        for (; __first != __last && __r != __result_last; ++__first, ++__r)\n            *__r = *__first;\n        __make_heap<_Compare>(__result_first, __r, __comp);\n        typename iterator_traits<_RandomAccessIterator>::difference_type __len = __r - __result_first;\n        for (; __first != __last; ++__first)\n            if (__comp(*__first, *__result_first))\n            {\n                *__result_first = *__first;\n                __sift_down<_Compare>(__result_first, __r, __comp, __len, __result_first);\n            }\n        __sort_heap<_Compare>(__result_first, __r, __comp);\n    }\n    return __r;\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __partial_sort_copy<_Comp_ref>(__first, __last, __result_first, __result_last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator, class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_RandomAccessIterator\npartial_sort_copy(_InputIterator __first, _InputIterator __last,\n                  _RandomAccessIterator __result_first, _RandomAccessIterator __result_last)\n{\n    return _VSTD::partial_sort_copy(__first, __last, __result_first, __result_last,\n                                   __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// nth_element\n\ntemplate <class _Compare, class _RandomAccessIterator>\nvoid\n__nth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n    // _Compare is known to be a reference type\n    typedef typename iterator_traits<_RandomAccessIterator>::difference_type difference_type;\n    const difference_type __limit = 7;\n    while (true)\n    {\n    __restart:\n        if (__nth == __last)\n            return;\n        difference_type __len = __last - __first;\n        switch (__len)\n        {\n        case 0:\n        case 1:\n            return;\n        case 2:\n            if (__comp(*--__last, *__first))\n                swap(*__first, *__last);\n            return;\n        case 3:\n            {\n            _RandomAccessIterator __m = __first;\n            _VSTD::__sort3<_Compare>(__first, ++__m, --__last, __comp);\n            return;\n            }\n        }\n        if (__len <= __limit)\n        {\n            __selection_sort<_Compare>(__first, __last, __comp);\n            return;\n        }\n        // __len > __limit >= 3\n        _RandomAccessIterator __m = __first + __len/2;\n        _RandomAccessIterator __lm1 = __last;\n        unsigned __n_swaps = _VSTD::__sort3<_Compare>(__first, __m, --__lm1, __comp);\n        // *__m is median\n        // partition [__first, __m) < *__m and *__m <= [__m, __last)\n        // (this inhibits tossing elements equivalent to __m around unnecessarily)\n        _RandomAccessIterator __i = __first;\n        _RandomAccessIterator __j = __lm1;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // The search going up is known to be guarded but the search coming down isn't.\n        // Prime the downward search with a guard.\n        if (!__comp(*__i, *__m))  // if *__first == *__m\n        {\n            // *__first == *__m, *__first doesn't go in first part\n            // manually guard downward moving __j against __i\n            while (true)\n            {\n                if (__i == --__j)\n                {\n                    // *__first == *__m, *__m <= all other elements\n                    // Parition instead into [__first, __i) == *__first and *__first < [__i, __last)\n                    ++__i;  // __first + 1\n                    __j = __last;\n                    if (!__comp(*__first, *--__j))  // we need a guard if *__first == *(__last-1)\n                    {\n                        while (true)\n                        {\n                            if (__i == __j)\n                                return;  // [__first, __last) all equivalent elements\n                            if (__comp(*__first, *__i))\n                            {\n                                swap(*__i, *__j);\n                                ++__n_swaps;\n                                ++__i;\n                                break;\n                            }\n                            ++__i;\n                        }\n                    }\n                    // [__first, __i) == *__first and *__first < [__j, __last) and __j == __last - 1\n                    if (__i == __j)\n                        return;\n                    while (true)\n                    {\n                        while (!__comp(*__first, *__i))\n                            ++__i;\n                        while (__comp(*__first, *--__j))\n                            ;\n                        if (__i >= __j)\n                            break;\n                        swap(*__i, *__j);\n                        ++__n_swaps;\n                        ++__i;\n                    }\n                    // [__first, __i) == *__first and *__first < [__i, __last)\n                    // The first part is sorted,\n                    if (__nth < __i)\n                        return;\n                    // __nth_element the secod part\n                    // __nth_element<_Compare>(__i, __nth, __last, __comp);\n                    __first = __i;\n                    goto __restart;\n                }\n                if (__comp(*__j, *__m))\n                {\n                    swap(*__i, *__j);\n                    ++__n_swaps;\n                    break;  // found guard for downward moving __j, now use unguarded partition\n                }\n            }\n        }\n        ++__i;\n        // j points beyond range to be tested, *__lm1 is known to be <= *__m\n        // if not yet partitioned...\n        if (__i < __j)\n        {\n            // known that *(__i - 1) < *__m\n            while (true)\n            {\n                // __m still guards upward moving __i\n                while (__comp(*__i, *__m))\n                    ++__i;\n                // It is now known that a guard exists for downward moving __j\n                while (!__comp(*--__j, *__m))\n                    ;\n                if (__i >= __j)\n                    break;\n                swap(*__i, *__j);\n                ++__n_swaps;\n                // It is known that __m != __j\n                // If __m just moved, follow it\n                if (__m == __i)\n                    __m = __j;\n                ++__i;\n            }\n        }\n        // [__first, __i) < *__m and *__m <= [__i, __last)\n        if (__i != __m && __comp(*__m, *__i))\n        {\n            swap(*__i, *__m);\n            ++__n_swaps;\n        }\n        // [__first, __i) < *__i and *__i <= [__i+1, __last)\n        if (__nth == __i)\n            return;\n        if (__n_swaps == 0)\n        {\n            // We were given a perfectly partitioned sequence.  Coincidence?\n            if (__nth < __i)\n            {\n                // Check for [__first, __i) already sorted\n                __j = __m = __first;\n                while (++__j != __i)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__first, __i) sorted\n                return;\n            }\n            else\n            {\n                // Check for [__i, __last) already sorted\n                __j = __m = __i;\n                while (++__j != __last)\n                {\n                    if (__comp(*__j, *__m))\n                        // not yet sorted, so sort\n                        goto not_sorted;\n                    __m = __j;\n                }\n                // [__i, __last) sorted\n                return;\n            }\n        }\nnot_sorted:\n        // __nth_element on range containing __nth\n        if (__nth < __i)\n        {\n            // __nth_element<_Compare>(__first, __nth, __i, __comp);\n            __last = __i;\n        }\n        else\n        {\n            // __nth_element<_Compare>(__i+1, __nth, __last, __comp);\n            __first = ++__i;\n        }\n    }\n}\n\ntemplate <class _RandomAccessIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    __nth_element<_Comp_ref>(__first, __nth, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    __nth_element<_Comp_ref>(__first, __nth, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _RandomAccessIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nnth_element(_RandomAccessIterator __first, _RandomAccessIterator __nth, _RandomAccessIterator __last)\n{\n    _VSTD::nth_element(__first, __nth, __last, __less<typename iterator_traits<_RandomAccessIterator>::value_type>());\n}\n\n// includes\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__includes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n           _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1)\n    {\n        if (__first1 == __last1 || __comp(*__first2, *__first1))\n            return false;\n        if (!__comp(*__first1, *__first2))\n            ++__first2;\n    }\n    return true;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2,\n         _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __includes<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nincludes(_InputIterator1 __first1, _InputIterator1 __last1, _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::includes(__first1, __last1, __first2, __last2,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_union\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_union(_InputIterator1 __first1, _InputIterator1 __last1,\n            _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    for (; __first1 != __last1; ++__result)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first2, *__first1))\n        {\n            *__result = *__first2;\n            ++__first2;\n        }\n        else\n        {\n            *__result = *__first1;\n            if (!__comp(*__first1, *__first2))\n                ++__first2;\n            ++__first1;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_union<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_union(_InputIterator1 __first1, _InputIterator1 __last1,\n          _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_union(__first1, __last1, __first2, __last2, __result,\n                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_intersection\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                   _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1 && __first2 != __last2)\n    {\n        if (__comp(*__first1, *__first2))\n            ++__first1;\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n            {\n                *__result = *__first1;\n                ++__result;\n                ++__first1;\n            }\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_intersection<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_intersection(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_intersection(__first1, __last1, __first2, __last2, __result,\n                                  __less<typename iterator_traits<_InputIterator1>::value_type,\n                                         typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                 _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (!__comp(*__first2, *__first1))\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return __result;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n               _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_difference(__first1, __last1, __first2, __last2, __result,\n                                __less<typename iterator_traits<_InputIterator1>::value_type,\n                                       typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// set_symmetric_difference\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2, class _OutputIterator>\n_OutputIterator\n__set_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                           _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n    while (__first1 != __last1)\n    {\n        if (__first2 == __last2)\n            return _VSTD::copy(__first1, __last1, __result);\n        if (__comp(*__first1, *__first2))\n        {\n            *__result = *__first1;\n            ++__result;\n            ++__first1;\n        }\n        else\n        {\n            if (__comp(*__first2, *__first1))\n            {\n                *__result = *__first2;\n                ++__result;\n            }\n            else\n                ++__first1;\n            ++__first2;\n        }\n    }\n    return _VSTD::copy(__first2, __last2, __result);\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __set_symmetric_difference<_Comp_ref>(__first1, __last1, __first2, __last2, __result, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _OutputIterator>\ninline _LIBCPP_INLINE_VISIBILITY\n_OutputIterator\nset_symmetric_difference(_InputIterator1 __first1, _InputIterator1 __last1,\n                         _InputIterator2 __first2, _InputIterator2 __last2, _OutputIterator __result)\n{\n    return _VSTD::set_symmetric_difference(__first1, __last1, __first2, __last2, __result,\n                                          __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                 typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// lexicographical_compare\n\ntemplate <class _Compare, class _InputIterator1, class _InputIterator2>\nbool\n__lexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                          _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n    for (; __first2 != __last2; ++__first1, ++__first2)\n    {\n        if (__first1 == __last1 || __comp(*__first1, *__first2))\n            return true;\n        if (__comp(*__first2, *__first1))\n            return false;\n    }\n    return false;\n}\n\ntemplate <class _InputIterator1, class _InputIterator2, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __lexicographical_compare<_Comp_ref>(__first1, __last1, __first2, __last2, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _InputIterator1, class _InputIterator2>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nlexicographical_compare(_InputIterator1 __first1, _InputIterator1 __last1,\n                        _InputIterator2 __first2, _InputIterator2 __last2)\n{\n    return _VSTD::lexicographical_compare(__first1, __last1, __first2, __last2,\n                                         __less<typename iterator_traits<_InputIterator1>::value_type,\n                                                typename iterator_traits<_InputIterator2>::value_type>());\n}\n\n// next_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__next_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*--__i, *__ip1))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*__i, *--__j))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __next_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __next_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nnext_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::next_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\n// prev_permutation\n\ntemplate <class _Compare, class _BidirectionalIterator>\nbool\n__prev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n    _BidirectionalIterator __i = __last;\n    if (__first == __last || __first == --__i)\n        return false;\n    while (true)\n    {\n        _BidirectionalIterator __ip1 = __i;\n        if (__comp(*__ip1, *--__i))\n        {\n            _BidirectionalIterator __j = __last;\n            while (!__comp(*--__j, *__i))\n                ;\n            swap(*__i, *__j);\n            _VSTD::reverse(__ip1, __last);\n            return true;\n        }\n        if (__i == __first)\n        {\n            _VSTD::reverse(__first, __last);\n            return false;\n        }\n    }\n}\n\ntemplate <class _BidirectionalIterator, class _Compare>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last, _Compare __comp)\n{\n#ifdef _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<__debug_less<_Compare> >::type _Comp_ref;\n    __debug_less<_Compare> __c(__comp);\n    return __prev_permutation<_Comp_ref>(__first, __last, __c);\n#else  // _LIBCPP_DEBUG\n    typedef typename add_lvalue_reference<_Compare>::type _Comp_ref;\n    return __prev_permutation<_Comp_ref>(__first, __last, __comp);\n#endif  // _LIBCPP_DEBUG\n}\n\ntemplate <class _BidirectionalIterator>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\nprev_permutation(_BidirectionalIterator __first, _BidirectionalIterator __last)\n{\n    return _VSTD::prev_permutation(__first, __last,\n                                  __less<typename iterator_traits<_BidirectionalIterator>::value_type>());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value,\n    _Tp\n>::type\n__rotate_left(_Tp __t, _Tp __n = 1)\n{\n    const unsigned __bits = static_cast<unsigned>(sizeof(_Tp) * __CHAR_BIT__ - 1);\n    __n &= __bits;\n    return static_cast<_Tp>((__t << __n) | (static_cast<typename make_unsigned<_Tp>::type>(__t) >> (__bits - __n)));\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_integral<_Tp>::value,\n    _Tp\n>::type\n__rotate_right(_Tp __t, _Tp __n = 1)\n{\n    const unsigned __bits = static_cast<unsigned>(sizeof(_Tp) * __CHAR_BIT__ - 1);\n    __n &= __bits;\n    return static_cast<_Tp>((__t << (__bits - __n)) | (static_cast<typename make_unsigned<_Tp>::type>(__t) >> __n));\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_ALGORITHM\n","// -*- C++ -*-\n#ifndef _LIBCPP_SPLIT_BUFFER\n#define _LIBCPP_SPLIT_BUFFER\n\n#include <__config>\n#include <type_traits>\n#include <algorithm>\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <bool>\nclass __split_buffer_common\n{\nprotected:\n    void __throw_length_error() const;\n    void __throw_out_of_range() const;\n};\n\ntemplate <class _Tp, class _Allocator = allocator<_Tp> >\nstruct __split_buffer\n    : private __split_buffer_common<true>\n{\nprivate:\n    __split_buffer(const __split_buffer&);\n    __split_buffer& operator=(const __split_buffer&);\npublic:\n    typedef _Tp                                             value_type;\n    typedef _Allocator                                      allocator_type;\n    typedef typename remove_reference<allocator_type>::type __alloc_rr;\n    typedef allocator_traits<__alloc_rr>                    __alloc_traits;\n    typedef value_type&                                     reference;\n    typedef const value_type&                               const_reference;\n    typedef typename __alloc_traits::size_type              size_type;\n    typedef typename __alloc_traits::difference_type        difference_type;\n    typedef typename __alloc_traits::pointer                pointer;\n    typedef typename __alloc_traits::const_pointer          const_pointer;\n    typedef pointer                                         iterator;\n    typedef const_pointer                                   const_iterator;\n\n    pointer                                         __first_;\n    pointer                                         __begin_;\n    pointer                                         __end_;\n    __compressed_pair<pointer, allocator_type> __end_cap_;\n\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_ref;\n    typedef typename add_lvalue_reference<allocator_type>::type __alloc_const_ref;\n\n    _LIBCPP_INLINE_VISIBILITY __alloc_rr&           __alloc() _NOEXCEPT         {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY const __alloc_rr&     __alloc() const _NOEXCEPT   {return __end_cap_.second();}\n    _LIBCPP_INLINE_VISIBILITY pointer&              __end_cap() _NOEXCEPT       {return __end_cap_.first();}\n    _LIBCPP_INLINE_VISIBILITY const pointer&        __end_cap() const _NOEXCEPT {return __end_cap_.first();}\n\n    __split_buffer()\n        _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value);\n    explicit __split_buffer(__alloc_rr& __a);\n    explicit __split_buffer(const __alloc_rr& __a);\n    __split_buffer(size_type __cap, size_type __start, __alloc_rr& __a);\n    ~__split_buffer();\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    __split_buffer(__split_buffer&& __c)\n        _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value);\n    __split_buffer(__split_buffer&& __c, const __alloc_rr& __a);\n    __split_buffer& operator=(__split_buffer&& __c)\n        _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value);\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n    _LIBCPP_INLINE_VISIBILITY       iterator begin() _NOEXCEPT       {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator begin() const _NOEXCEPT {return __begin_;}\n    _LIBCPP_INLINE_VISIBILITY       iterator end() _NOEXCEPT         {return __end_;}\n    _LIBCPP_INLINE_VISIBILITY const_iterator end() const _NOEXCEPT   {return __end_;}\n\n    _LIBCPP_INLINE_VISIBILITY\n    void clear() _NOEXCEPT\n        {__destruct_at_end(__begin_);}\n    _LIBCPP_INLINE_VISIBILITY size_type size() const {return static_cast<size_type>(__end_ - __begin_);}\n    _LIBCPP_INLINE_VISIBILITY bool empty()     const {return __end_ == __begin_;}\n    _LIBCPP_INLINE_VISIBILITY size_type capacity() const {return static_cast<size_type>(__end_cap() - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __front_spare() const {return static_cast<size_type>(__begin_ - __first_);}\n    _LIBCPP_INLINE_VISIBILITY size_type __back_spare() const {return static_cast<size_type>(__end_cap() - __end_);}\n\n    _LIBCPP_INLINE_VISIBILITY       reference front()       {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY const_reference front() const {return *__begin_;}\n    _LIBCPP_INLINE_VISIBILITY       reference back()        {return *(__end_ - 1);}\n    _LIBCPP_INLINE_VISIBILITY const_reference back() const  {return *(__end_ - 1);}\n\n    void reserve(size_type __n);\n    void shrink_to_fit() _NOEXCEPT;\n    void push_front(const_reference __x);\n    _LIBCPP_INLINE_VISIBILITY void push_back(const_reference __x);\n#if !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n    void push_front(value_type&& __x);\n    void push_back(value_type&& __x);\n#if !defined(_LIBCPP_HAS_NO_VARIADICS)\n    template <class... _Args>\n        void emplace_back(_Args&&... __args);\n#endif  // !defined(_LIBCPP_HAS_NO_VARIADICS)\n#endif  // !defined(_LIBCPP_HAS_NO_RVALUE_REFERENCES)\n\n    _LIBCPP_INLINE_VISIBILITY void pop_front() {__destruct_at_begin(__begin_+1);}\n    _LIBCPP_INLINE_VISIBILITY void pop_back() {__destruct_at_end(__end_-1);}\n\n    void __construct_at_end(size_type __n);\n    void __construct_at_end(size_type __n, const_reference __x);\n    template <class _InputIter>\n        typename enable_if\n        <\n            __is_input_iterator<_InputIter>::value &&\n           !__is_forward_iterator<_InputIter>::value,\n            void\n        >::type\n        __construct_at_end(_InputIter __first, _InputIter __last);\n    template <class _ForwardIterator>\n        typename enable_if\n        <\n            __is_forward_iterator<_ForwardIterator>::value,\n            void\n        >::type\n        __construct_at_end(_ForwardIterator __first, _ForwardIterator __last);\n\n    _LIBCPP_INLINE_VISIBILITY void __destruct_at_begin(pointer __new_begin)\n        {__destruct_at_begin(__new_begin, is_trivially_destructible<value_type>());}\n        void __destruct_at_begin(pointer __new_begin, false_type);\n        void __destruct_at_begin(pointer __new_begin, true_type);\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __destruct_at_end(pointer __new_last) _NOEXCEPT\n        {__destruct_at_end(__new_last, false_type());}\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, false_type) _NOEXCEPT;\n    _LIBCPP_INLINE_VISIBILITY\n        void __destruct_at_end(pointer __new_last, true_type) _NOEXCEPT;\n\n    void swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value);\n\n    bool __invariants() const;\n\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer& __c, true_type)\n        _NOEXCEPT_(is_nothrow_move_assignable<allocator_type>::value)\n        {\n            __alloc() = _VSTD::move(__c.__alloc());\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    void __move_assign_alloc(__split_buffer&, false_type) _NOEXCEPT\n        {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__alloc_rr& __x, __alloc_rr& __y)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value)\n        {__swap_alloc(__x, __y, integral_constant<bool,\n                      __alloc_traits::propagate_on_container_swap::value>());}\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__alloc_rr& __x, __alloc_rr& __y, true_type)\n        _NOEXCEPT_(__is_nothrow_swappable<__alloc_rr>::value)\n        {\n            using _VSTD::swap;\n            swap(__x, __y);\n        }\n\n    _LIBCPP_INLINE_VISIBILITY\n    static void __swap_alloc(__alloc_rr&, __alloc_rr&, false_type) _NOEXCEPT\n        {}\n};\n\ntemplate <class _Tp, class _Allocator>\nbool\n__split_buffer<_Tp, _Allocator>::__invariants() const\n{\n    if (__first_ == nullptr)\n    {\n        if (__begin_ != nullptr)\n            return false;\n        if (__end_ != nullptr)\n            return false;\n        if (__end_cap() != nullptr)\n            return false;\n    }\n    else\n    {\n        if (__begin_ < __first_)\n            return false;\n        if (__end_ < __begin_)\n            return false;\n        if (__end_cap() < __end_)\n            return false;\n    }\n    return true;\n}\n\n//  Default constructs __n objects starting at __end_\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == size() + __n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_));\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\n//  Copy constructs __n objects starting at __end_ from __x\n//  throws if construction throws\n//  Precondition:  __n > 0\n//  Precondition:  size() + __n <= capacity()\n//  Postcondition:  size() == old size() + __n\n//  Postcondition:  [i] == __x for all i in [size() - __n, __n)\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::__construct_at_end(size_type __n, const_reference __x)\n{\n    __alloc_rr& __a = this->__alloc();\n    do\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), __x);\n        ++this->__end_;\n        --__n;\n    } while (__n > 0);\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _InputIter>\ntypename enable_if\n<\n     __is_input_iterator<_InputIter>::value &&\n    !__is_forward_iterator<_InputIter>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_InputIter __first, _InputIter __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        if (__end_ == __end_cap())\n        {\n            size_type __old_cap = __end_cap() - __first_;\n            size_type __new_cap = _VSTD::max<size_type>(2 * __old_cap, 8);\n            __split_buffer __buf(__new_cap, 0, __a);\n            for (pointer __p = __begin_; __p != __end_; ++__p, ++__buf.__end_)\n                __alloc_traits::construct(__buf.__alloc(),\n                        _VSTD::__to_raw_pointer(__buf.__end_), _VSTD::move(*__p));\n            swap(__buf);\n        }\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class _ForwardIterator>\ntypename enable_if\n<\n    __is_forward_iterator<_ForwardIterator>::value,\n    void\n>::type\n__split_buffer<_Tp, _Allocator>::__construct_at_end(_ForwardIterator __first, _ForwardIterator __last)\n{\n    __alloc_rr& __a = this->__alloc();\n    for (; __first != __last; ++__first)\n    {\n        __alloc_traits::construct(__a, _VSTD::__to_raw_pointer(this->__end_), *__first);\n        ++this->__end_;\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, false_type)\n{\n    while (__begin_ != __new_begin)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(__begin_++));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_begin(pointer __new_begin, true_type)\n{\n    __begin_ = __new_begin;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, false_type) _NOEXCEPT\n{\n    while (__new_last != __end_)\n        __alloc_traits::destroy(__alloc(), __to_raw_pointer(--__end_));\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::__destruct_at_end(pointer __new_last, true_type) _NOEXCEPT\n{\n    __end_ = __new_last;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(size_type __cap, size_type __start, __alloc_rr& __a)\n    : __end_cap_(nullptr, __a)\n{\n    __first_ = __cap != 0 ? __alloc_traits::allocate(__alloc(), __cap) : nullptr;\n    __begin_ = __end_ = __first_ + __start;\n    __end_cap() = __first_ + __cap;\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__split_buffer<_Tp, _Allocator>::__split_buffer()\n    _NOEXCEPT_(is_nothrow_default_constructible<allocator_type>::value)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__split_buffer<_Tp, _Allocator>::__split_buffer(__alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\n__split_buffer<_Tp, _Allocator>::__split_buffer(const __alloc_rr& __a)\n    : __first_(nullptr), __begin_(nullptr), __end_(nullptr), __end_cap_(nullptr, __a)\n{\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::~__split_buffer()\n{\n    clear();\n    if (__first_)\n        __alloc_traits::deallocate(__alloc(), __first_, capacity());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c)\n    _NOEXCEPT_(is_nothrow_move_constructible<allocator_type>::value)\n    : __first_(_VSTD::move(__c.__first_)),\n      __begin_(_VSTD::move(__c.__begin_)),\n      __end_(_VSTD::move(__c.__end_)),\n      __end_cap_(_VSTD::move(__c.__end_cap_))\n{\n    __c.__first_ = nullptr;\n    __c.__begin_ = nullptr;\n    __c.__end_ = nullptr;\n    __c.__end_cap() = nullptr;\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>::__split_buffer(__split_buffer&& __c, const __alloc_rr& __a)\n    : __end_cap_(__a)\n{\n    if (__a == __c.__alloc())\n    {\n        __first_ = __c.__first_;\n        __begin_ = __c.__begin_;\n        __end_ = __c.__end_;\n        __end_cap() = __c.__end_cap();\n        __c.__first_ = nullptr;\n        __c.__begin_ = nullptr;\n        __c.__end_ = nullptr;\n        __c.__end_cap() = nullptr;\n    }\n    else\n    {\n        size_type __cap = __c.size();\n        __first_ = __alloc_traits::allocate(__alloc(), __cap);\n        __begin_ = __end_ = __first_;\n        __end_cap() = __first_ + __cap;\n        typedef move_iterator<iterator> _Ip;\n        __construct_at_end(_Ip(__c.begin()), _Ip(__c.end()));\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\n__split_buffer<_Tp, _Allocator>&\n__split_buffer<_Tp, _Allocator>::operator=(__split_buffer&& __c)\n    _NOEXCEPT_((__alloc_traits::propagate_on_container_move_assignment::value &&\n                is_nothrow_move_assignable<allocator_type>::value) ||\n               !__alloc_traits::propagate_on_container_move_assignment::value)\n{\n    clear();\n    shrink_to_fit();\n    __first_ = __c.__first_;\n    __begin_ = __c.__begin_;\n    __end_ = __c.__end_;\n    __end_cap() = __c.__end_cap();\n    __move_assign_alloc(__c,\n        integral_constant<bool,\n                          __alloc_traits::propagate_on_container_move_assignment::value>());\n    __c.__first_ = __c.__begin_ = __c.__end_ = __c.__end_cap() = nullptr;\n    return *this;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::swap(__split_buffer& __x)\n        _NOEXCEPT_(!__alloc_traits::propagate_on_container_swap::value||\n                   __is_nothrow_swappable<__alloc_rr>::value)\n{\n    _VSTD::swap(__first_, __x.__first_);\n    _VSTD::swap(__begin_, __x.__begin_);\n    _VSTD::swap(__end_, __x.__end_);\n    _VSTD::swap(__end_cap(), __x.__end_cap());\n    __swap_alloc(__alloc(), __x.__alloc());\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::reserve(size_type __n)\n{\n    if (__n < capacity())\n    {\n        __split_buffer<value_type, __alloc_rr&> __t(__n, 0, __alloc());\n        __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                               move_iterator<pointer>(__end_));\n        _VSTD::swap(__first_, __t.__first_);\n        _VSTD::swap(__begin_, __t.__begin_);\n        _VSTD::swap(__end_, __t.__end_);\n        _VSTD::swap(__end_cap(), __t.__end_cap());\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::shrink_to_fit() _NOEXCEPT\n{\n    if (capacity() > size())\n    {\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        try\n        {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n            __split_buffer<value_type, __alloc_rr&> __t(size(), 0, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            __t.__end_ = __t.__begin_ + (__end_ - __begin_);\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n#ifndef _LIBCPP_NO_EXCEPTIONS\n        }\n        catch (...)\n        {\n        }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    }\n}\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(const_reference __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1), __x);\n    --__begin_;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_front(value_type&& __x)\n{\n    if (__begin_ == __first_)\n    {\n        if (__end_ < __end_cap())\n        {\n            difference_type __d = __end_cap() - __end_;\n            __d = (__d + 1) / 2;\n            __begin_ = _VSTD::move_backward(__begin_, __end_, __end_ + __d);\n            __end_ += __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, (__c + 3) / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__begin_-1),\n            _VSTD::move(__x));\n    --__begin_;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(const_reference __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_), __x);\n    ++__end_;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\nvoid\n__split_buffer<_Tp, _Allocator>::push_back(value_type&& __x)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n            _VSTD::move(__x));\n    ++__end_;\n}\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp, class _Allocator>\ntemplate <class... _Args>\nvoid\n__split_buffer<_Tp, _Allocator>::emplace_back(_Args&&... __args)\n{\n    if (__end_ == __end_cap())\n    {\n        if (__begin_ > __first_)\n        {\n            difference_type __d = __begin_ - __first_;\n            __d = (__d + 1) / 2;\n            __end_ = _VSTD::move(__begin_, __end_, __begin_ - __d);\n            __begin_ -= __d;\n        }\n        else\n        {\n            size_type __c = max<size_type>(2 * static_cast<size_t>(__end_cap() - __first_), 1);\n            __split_buffer<value_type, __alloc_rr&> __t(__c, __c / 4, __alloc());\n            __t.__construct_at_end(move_iterator<pointer>(__begin_),\n                                   move_iterator<pointer>(__end_));\n            _VSTD::swap(__first_, __t.__first_);\n            _VSTD::swap(__begin_, __t.__begin_);\n            _VSTD::swap(__end_, __t.__end_);\n            _VSTD::swap(__end_cap(), __t.__end_cap());\n        }\n    }\n    __alloc_traits::construct(__alloc(), _VSTD::__to_raw_pointer(__end_),\n                              _VSTD::forward<_Args>(__args)...);\n    ++__end_;\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate <class _Tp, class _Allocator>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(__split_buffer<_Tp, _Allocator>& __x, __split_buffer<_Tp, _Allocator>& __y)\n        _NOEXCEPT_(_NOEXCEPT_(__x.swap(__y)))\n{\n    __x.swap(__y);\n}\n\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_SPLIT_BUFFER\n","// -*- C++ -*-\n//===----------------------------- new ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_NEW\n#define _LIBCPP_NEW\n\n/*\n    new synopsis\n\nnamespace std\n{\n\nclass bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() noexcept;\n    bad_alloc(const bad_alloc&) noexcept;\n    bad_alloc& operator=(const bad_alloc&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_array_length : public bad_alloc // C++14\n{\npublic:\n    bad_array_length() noexcept;\n};\n\nclass bad_array_new_length : public bad_alloc\n{\npublic:\n    bad_array_new_length() noexcept;\n};\n\nstruct nothrow_t {};\nextern const nothrow_t nothrow;\ntypedef void (*new_handler)();\nnew_handler set_new_handler(new_handler new_p) noexcept;\nnew_handler get_new_handler() noexcept;\n\n}  // std\n\nvoid* operator new(std::size_t size);                                   // replaceable\nvoid* operator new(std::size_t size, const std::nothrow_t&) noexcept;   // replaceable\nvoid  operator delete(void* ptr) noexcept;                              // replaceable\nvoid  operator delete(void* ptr, const std::nothrow_t&) noexcept;       // replaceable\n\nvoid* operator new[](std::size_t size);                                 // replaceable\nvoid* operator new[](std::size_t size, const std::nothrow_t&) noexcept; // replaceable\nvoid  operator delete[](void* ptr) noexcept;                            // replaceable\nvoid  operator delete[](void* ptr, const std::nothrow_t&) noexcept;     // replaceable\n\nvoid* operator new  (std::size_t size, void* ptr) noexcept;\nvoid* operator new[](std::size_t size, void* ptr) noexcept;\nvoid  operator delete  (void* ptr, void*) noexcept;\nvoid  operator delete[](void* ptr, void*) noexcept;\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI bad_alloc\n    : public exception\n{\npublic:\n    bad_alloc() _NOEXCEPT;\n    virtual ~bad_alloc() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_new_length\n    : public bad_alloc\n{\npublic:\n    bad_array_new_length() _NOEXCEPT;\n    virtual ~bad_array_new_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n#if defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\nclass _LIBCPP_EXCEPTION_ABI bad_array_length\n    : public bad_alloc\n{\npublic:\n    bad_array_length() _NOEXCEPT;\n    virtual ~bad_array_length() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n#define _LIBCPP_BAD_ARRAY_LENGTH_DEFINED\n\n#endif  // defined(_LIBCPP_BUILDING_NEW) || (_LIBCPP_STD_VER > 11)\n\n_LIBCPP_FUNC_VIS void __throw_bad_alloc();  // not in C++ spec\n\nstruct _LIBCPP_TYPE_VIS nothrow_t {};\nextern _LIBCPP_FUNC_VIS const nothrow_t nothrow;\ntypedef void (*new_handler)();\n_LIBCPP_FUNC_VIS new_handler set_new_handler(new_handler) _NOEXCEPT;\n_LIBCPP_FUNC_VIS new_handler get_new_handler() _NOEXCEPT;\n\n}  // std\n\n#if defined(_WIN32) && !defined(cxx_EXPORTS)\n# define _LIBCPP_NEW_DELETE_VIS _LIBCPP_FUNC_VIS_ONLY\n#else\n# define _LIBCPP_NEW_DELETE_VIS _LIBCPP_FUNC_VIS\n#endif\n\n_LIBCPP_NEW_DELETE_VIS void* operator new(std::size_t __sz)\n#if !__has_feature(cxx_noexcept)\n    throw(std::bad_alloc)\n#endif\n;\n_LIBCPP_NEW_DELETE_VIS void* operator new(std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_NEW_DELETE_VIS void  operator delete(void* __p) _NOEXCEPT;\n_LIBCPP_NEW_DELETE_VIS void  operator delete(void* __p, const std::nothrow_t&) _NOEXCEPT;\n\n_LIBCPP_NEW_DELETE_VIS void* operator new[](std::size_t __sz)\n#if !__has_feature(cxx_noexcept)\n    throw(std::bad_alloc)\n#endif\n;\n_LIBCPP_NEW_DELETE_VIS void* operator new[](std::size_t __sz, const std::nothrow_t&) _NOEXCEPT _NOALIAS;\n_LIBCPP_NEW_DELETE_VIS void  operator delete[](void* __p) _NOEXCEPT;\n_LIBCPP_NEW_DELETE_VIS void  operator delete[](void* __p, const std::nothrow_t&) _NOEXCEPT;\n\ninline _LIBCPP_INLINE_VISIBILITY void* operator new  (std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void* operator new[](std::size_t, void* __p) _NOEXCEPT {return __p;}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete  (void*, void*) _NOEXCEPT {}\ninline _LIBCPP_INLINE_VISIBILITY void  operator delete[](void*, void*) _NOEXCEPT {}\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ninline _LIBCPP_INLINE_VISIBILITY void *__allocate(size_t __size) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  return ::operator new(__size);\n#else\n  return __builtin_operator_new(__size);\n#endif\n}\n\ninline _LIBCPP_INLINE_VISIBILITY void __deallocate(void *__ptr) {\n#ifdef _LIBCPP_HAS_NO_BUILTIN_OPERATOR_NEW_DELETE\n  ::operator delete(__ptr);\n#else\n  __builtin_operator_delete(__ptr);\n#endif\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_NEW\n","// -*- C++ -*-\n//===----------------------------------------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FUNCTIONAL_BASE\n#define _LIBCPP_FUNCTIONAL_BASE\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <exception>\n#include <new>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _Arg, class _Result>\nstruct _LIBCPP_TYPE_VIS_ONLY unary_function\n{\n    typedef _Arg    argument_type;\n    typedef _Result result_type;\n};\n\ntemplate <class _Arg1, class _Arg2, class _Result>\nstruct _LIBCPP_TYPE_VIS_ONLY binary_function\n{\n    typedef _Arg1   first_argument_type;\n    typedef _Arg2   second_argument_type;\n    typedef _Result result_type;\n};\n\ntemplate <class _Tp> struct _LIBCPP_TYPE_VIS_ONLY hash;\n\ntemplate <class _Tp>\nstruct __has_result_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::result_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY less : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY \n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x < __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY less<void>\n{\n    template <class _T1, class _T2> \n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) < _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n// addressof\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp*\naddressof(_Tp& __x) _NOEXCEPT\n{\n    return (_Tp*)&reinterpret_cast<const volatile char&>(__x);\n}\n\n#if defined(_LIBCPP_HAS_OBJC_ARC) && !defined(_LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF)\n// Objective-C++ Automatic Reference Counting uses qualified pointers\n// that require special addressof() signatures. When\n// _LIBCPP_PREDEFINED_OBJC_ARC_ADDRESSOF is defined, the compiler\n// itself is providing these definitions. Otherwise, we provide them.\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__strong _Tp*\naddressof(__strong _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\n#ifdef _LIBCPP_HAS_OBJC_ARC_WEAK\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__weak _Tp*\naddressof(__weak _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__autoreleasing _Tp*\naddressof(__autoreleasing _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__unsafe_unretained _Tp*\naddressof(__unsafe_unretained _Tp& __x) _NOEXCEPT\n{\n  return &__x;\n}\n#endif\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\n#include <__functional_base_03>\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\n// __weak_result_type\n\ntemplate <class _Tp>\nstruct __derives_from_unary_function\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    static __two __test(...);\n    template <class _Ap, class _Rp>\n        static unary_function<_Ap, _Rp>\n        __test(const volatile unary_function<_Ap, _Rp>*);\npublic:\n    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;\n    typedef decltype(__test((_Tp*)0)) type;\n};\n\ntemplate <class _Tp>\nstruct __derives_from_binary_function\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    static __two __test(...);\n    template <class _A1, class _A2, class _Rp>\n        static binary_function<_A1, _A2, _Rp>\n        __test(const volatile binary_function<_A1, _A2, _Rp>*);\npublic:\n    static const bool value = !is_same<decltype(__test((_Tp*)0)), __two>::value;\n    typedef decltype(__test((_Tp*)0)) type;\n};\n\ntemplate <class _Tp, bool = __derives_from_unary_function<_Tp>::value>\nstruct __maybe_derive_from_unary_function  // bool is true\n    : public __derives_from_unary_function<_Tp>::type\n{\n};\n\ntemplate <class _Tp>\nstruct __maybe_derive_from_unary_function<_Tp, false>\n{\n};\n\ntemplate <class _Tp, bool = __derives_from_binary_function<_Tp>::value>\nstruct __maybe_derive_from_binary_function  // bool is true\n    : public __derives_from_binary_function<_Tp>::type\n{\n};\n\ntemplate <class _Tp>\nstruct __maybe_derive_from_binary_function<_Tp, false>\n{\n};\n\ntemplate <class _Tp, bool = __has_result_type<_Tp>::value>\nstruct __weak_result_type_imp // bool is true\n    : public __maybe_derive_from_unary_function<_Tp>,\n      public __maybe_derive_from_binary_function<_Tp>\n{\n    typedef typename _Tp::result_type result_type;\n};\n\ntemplate <class _Tp>\nstruct __weak_result_type_imp<_Tp, false>\n    : public __maybe_derive_from_unary_function<_Tp>,\n      public __maybe_derive_from_binary_function<_Tp>\n{\n};\n\ntemplate <class _Tp>\nstruct __weak_result_type\n    : public __weak_result_type_imp<_Tp>\n{\n};\n\n// 0 argument case\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp ()>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp (&)()>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp>\nstruct __weak_result_type<_Rp (*)()>\n{\n    typedef _Rp result_type;\n};\n\n// 1 argument case\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (&)(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1>\nstruct __weak_result_type<_Rp (*)(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)()>\n    : public unary_function<_Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() const>\n    : public unary_function<const _Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() volatile>\n    : public unary_function<volatile _Cp*, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp>\nstruct __weak_result_type<_Rp (_Cp::*)() const volatile>\n    : public unary_function<const volatile _Cp*, _Rp>\n{\n};\n\n// 2 argument case\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (*)(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _A1, class _A2>\nstruct __weak_result_type<_Rp (&)(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1)>\n    : public binary_function<_Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const>\n    : public binary_function<const _Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) volatile>\n    : public binary_function<volatile _Cp*, _A1, _Rp>\n{\n};\n\ntemplate <class _Rp, class _Cp, class _A1>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1) const volatile>\n    : public binary_function<const volatile _Cp*, _A1, _Rp>\n{\n};\n\n// 3 or more arguments\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (&)(_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _A1, class _A2, class _A3, class ..._A4>\nstruct __weak_result_type<_Rp (*)(_A1, _A2, _A3, _A4...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...)>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) volatile>\n{\n    typedef _Rp result_type;\n};\n\ntemplate <class _Rp, class _Cp, class _A1, class _A2, class ..._A3>\nstruct __weak_result_type<_Rp (_Cp::*)(_A1, _A2, _A3...) const volatile>\n{\n    typedef _Rp result_type;\n};\n\n// __invoke\n\n// bullets 1 and 2\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype((_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...))\n{\n    return (_VSTD::forward<_A0>(__a0).*__f)(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Fp, class _A0, class ..._Args,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0, _Args&& ...__args)\n    -> decltype(((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...))\n{\n    return ((*_VSTD::forward<_A0>(__a0)).*__f)(_VSTD::forward<_Args>(__args)...);\n}\n\n// bullets 3 and 4\n\ntemplate <class _Fp, class _A0,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype(_VSTD::forward<_A0>(__a0).*__f)\n{\n    return _VSTD::forward<_A0>(__a0).*__f;\n}\n\ntemplate <class _Fp, class _A0,\n            class>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _A0&& __a0)\n    -> decltype((*_VSTD::forward<_A0>(__a0)).*__f)\n{\n    return (*_VSTD::forward<_A0>(__a0)).*__f;\n}\n\n// bullet 5\n\ntemplate <class _Fp, class ..._Args>\ninline _LIBCPP_INLINE_VISIBILITY\nauto\n__invoke(_Fp&& __f, _Args&& ...__args)\n    -> decltype(_VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...))\n{\n    return _VSTD::forward<_Fp>(__f)(_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp, class ..._Args>\nstruct __invoke_return\n{\n    typedef decltype(__invoke(_VSTD::declval<_Tp>(), _VSTD::declval<_Args>()...)) type;\n};\n\ntemplate <class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY reference_wrapper\n    : public __weak_result_type<_Tp>\n{\npublic:\n    // types\n    typedef _Tp type;\nprivate:\n    type* __f_;\n\npublic:\n    // construct/copy/destroy\n    _LIBCPP_INLINE_VISIBILITY reference_wrapper(type& __f) _NOEXCEPT\n        : __f_(_VSTD::addressof(__f)) {}\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    private: reference_wrapper(type&&); public: // = delete; // do not bind to temps\n#endif\n\n    // access\n    _LIBCPP_INLINE_VISIBILITY operator type&    () const _NOEXCEPT {return *__f_;}\n    _LIBCPP_INLINE_VISIBILITY          type& get() const _NOEXCEPT {return *__f_;}\n\n    // invoke\n    template <class... _ArgTypes>\n       _LIBCPP_INLINE_VISIBILITY\n       typename __invoke_of<type&, _ArgTypes...>::type\n          operator() (_ArgTypes&&... __args) const\n          {\n              return __invoke(get(), _VSTD::forward<_ArgTypes>(__args)...);\n          }\n};\n\ntemplate <class _Tp> struct __is_reference_wrapper_impl : public false_type {};\ntemplate <class _Tp> struct __is_reference_wrapper_impl<reference_wrapper<_Tp> > : public true_type {};\ntemplate <class _Tp> struct __is_reference_wrapper\n    : public __is_reference_wrapper_impl<typename remove_cv<_Tp>::type> {};\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<_Tp>\nref(_Tp& __t) _NOEXCEPT\n{\n    return reference_wrapper<_Tp>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<_Tp>\nref(reference_wrapper<_Tp> __t) _NOEXCEPT\n{\n    return ref(__t.get());\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<const _Tp>\ncref(const _Tp& __t) _NOEXCEPT\n{\n    return reference_wrapper<const _Tp>(__t);\n}\n\ntemplate <class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nreference_wrapper<const _Tp>\ncref(reference_wrapper<_Tp> __t) _NOEXCEPT\n{\n    return cref(__t.get());\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n#ifndef _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\ntemplate <class _Tp> void ref(const _Tp&&) = delete;\ntemplate <class _Tp> void cref(const _Tp&&) = delete;\n\n#else  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\ntemplate <class _Tp> void ref(const _Tp&&);// = delete;\ntemplate <class _Tp> void cref(const _Tp&&);// = delete;\n\n#endif  // _LIBCPP_HAS_NO_DELETED_FUNCTIONS\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp1, class _Tp2 = void>\nstruct __is_transparent\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::is_transparent* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp1>(0)) == 1;\n};\n#endif\n\n// allocator_arg_t\n\nstruct _LIBCPP_TYPE_VIS_ONLY allocator_arg_t { };\n\n#if defined(_LIBCPP_HAS_NO_CONSTEXPR) || defined(_LIBCPP_BUILDING_MEMORY)\nextern const allocator_arg_t allocator_arg;\n#else\nconstexpr allocator_arg_t allocator_arg = allocator_arg_t();\n#endif\n\n// uses_allocator\n\ntemplate <class _Tp>\nstruct __has_allocator_type\n{\nprivate:\n    struct __two {char __lx; char __lxx;};\n    template <class _Up> static __two __test(...);\n    template <class _Up> static char __test(typename _Up::allocator_type* = 0);\npublic:\n    static const bool value = sizeof(__test<_Tp>(0)) == 1;\n};\n\ntemplate <class _Tp, class _Alloc, bool = __has_allocator_type<_Tp>::value>\nstruct __uses_allocator\n    : public integral_constant<bool,\n        is_convertible<_Alloc, typename _Tp::allocator_type>::value>\n{\n};\n\ntemplate <class _Tp, class _Alloc>\nstruct __uses_allocator<_Tp, _Alloc, false>\n    : public false_type\n{\n};\n\ntemplate <class _Tp, class _Alloc>\nstruct _LIBCPP_TYPE_VIS_ONLY uses_allocator\n    : public __uses_allocator<_Tp, _Alloc>\n{\n};\n\n#ifndef _LIBCPP_HAS_NO_VARIADICS\n\n// allocator construction\n\ntemplate <class _Tp, class _Alloc, class ..._Args>\nstruct __uses_alloc_ctor_imp\n{\n    static const bool __ua = uses_allocator<_Tp, _Alloc>::value;\n    static const bool __ic =\n        is_constructible<_Tp, allocator_arg_t, _Alloc, _Args...>::value;\n    static const int value = __ua ? 2 - __ic : 0;\n};\n\ntemplate <class _Tp, class _Alloc, class ..._Args>\nstruct __uses_alloc_ctor\n    : integral_constant<int, __uses_alloc_ctor_imp<_Tp, _Alloc, _Args...>::value>\n    {};\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 0>, _Tp *__storage, const _Allocator &, _Args &&... __args )\n{\n    new (__storage) _Tp (_VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 1>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )\n{\n    new (__storage) _Tp (allocator_arg, __a, _VSTD::forward<_Args>(__args)...);\n}\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct_impl (integral_constant<int, 2>, _Tp *__storage, const _Allocator &__a, _Args &&... __args )\n{\n    new (__storage) _Tp (_VSTD::forward<_Args>(__args)..., __a);\n}\n\ntemplate <class _Tp, class _Allocator, class... _Args>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid __user_alloc_construct (_Tp *__storage, const _Allocator &__a, _Args &&... __args)\n{ \n    __user_alloc_construct_impl( \n             __uses_alloc_ctor<_Tp, _Allocator>(), \n             __storage, __a, _VSTD::forward<_Args>(__args)...\n        );\n}\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FUNCTIONAL_BASE\n","// -*- C++ -*-\n//===------------------------ functional ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_FUNCTIONAL\n#define _LIBCPP_FUNCTIONAL\n\n/*\n    functional synopsis\n\nnamespace std\n{\n\ntemplate <class Arg, class Result>\nstruct unary_function\n{\n    typedef Arg    argument_type;\n    typedef Result result_type;\n};\n\ntemplate <class Arg1, class Arg2, class Result>\nstruct binary_function\n{\n    typedef Arg1   first_argument_type;\n    typedef Arg2   second_argument_type;\n    typedef Result result_type;\n};\n\ntemplate <class T>\nclass reference_wrapper\n    : public unary_function<T1, R> // if wrapping a unary functor\n    : public binary_function<T1, T2, R> // if wraping a binary functor\n{\npublic:\n    // types\n    typedef T type;\n    typedef see below result_type; // Not always defined\n\n    // construct/copy/destroy\n    reference_wrapper(T&) noexcept;\n    reference_wrapper(T&&) = delete; // do not bind to temps\n    reference_wrapper(const reference_wrapper<T>& x) noexcept;\n\n    // assignment\n    reference_wrapper& operator=(const reference_wrapper<T>& x) noexcept;\n\n    // access\n    operator T& () const noexcept;\n    T& get() const noexcept;\n\n    // invoke\n    template <class... ArgTypes>\n      typename result_of<T&(ArgTypes&&...)>::type\n          operator() (ArgTypes&&...) const;\n};\n\ntemplate <class T> reference_wrapper<T> ref(T& t) noexcept;\ntemplate <class T> void ref(const T&& t) = delete;\ntemplate <class T> reference_wrapper<T> ref(reference_wrapper<T>t) noexcept;\n\ntemplate <class T> reference_wrapper<const T> cref(const T& t) noexcept;\ntemplate <class T> void cref(const T&& t) = delete;\ntemplate <class T> reference_wrapper<const T> cref(reference_wrapper<T> t) noexcept;\n\ntemplate <class T> // <class T=void> in C++14\nstruct plus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct minus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct multiplies : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct divides : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct modulus : binary_function<T, T, T>\n{\n    T operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct negate : unary_function<T, T>\n{\n    T operator()(const T& x) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct equal_to : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct not_equal_to : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct greater : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct less : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct greater_equal : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct less_equal : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_and : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_or : binary_function<T, T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct logical_not : unary_function<T, bool>\n{\n    bool operator()(const T& x) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_and : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_or : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T> // <class T=void> in C++14\nstruct bit_xor : unary_function<T, bool>\n{\n    bool operator()(const T& x, const T& y) const;\n};\n\ntemplate <class T=void> // C++14\nstruct bit_xor : unary_function<T, bool>\n{\n    bool operator()(const T& x) const;\n};\n\ntemplate <class Predicate>\nclass unary_negate\n    : public unary_function<typename Predicate::argument_type, bool>\n{\npublic:\n    explicit unary_negate(const Predicate& pred);\n    bool operator()(const typename Predicate::argument_type& x) const;\n};\n\ntemplate <class Predicate> unary_negate<Predicate> not1(const Predicate& pred);\n\ntemplate <class Predicate>\nclass binary_negate\n    : public binary_function<typename Predicate::first_argument_type,\n                             typename Predicate::second_argument_type,\n                             bool>\n{\npublic:\n    explicit binary_negate(const Predicate& pred);\n    bool operator()(const typename Predicate::first_argument_type& x,\n                    const typename Predicate::second_argument_type& y) const;\n};\n\ntemplate <class Predicate> binary_negate<Predicate> not2(const Predicate& pred);\n\ntemplate<class T> struct is_bind_expression;\ntemplate<class T> struct is_placeholder;\n\ntemplate<class Fn, class... BoundArgs>\n  unspecified bind(Fn&&, BoundArgs&&...);\ntemplate<class R, class Fn, class... BoundArgs>\n  unspecified bind(Fn&&, BoundArgs&&...);\n\nnamespace placeholders {\n  // M is the implementation-defined number of placeholders\n  extern unspecified _1;\n  extern unspecified _2;\n  .\n  .\n  .\n  extern unspecified _Mp;\n}\n\ntemplate <class Operation>\nclass binder1st\n    : public unary_function<typename Operation::second_argument_type,\n                            typename Operation::result_type>\n{\nprotected:\n    Operation                               op;\n    typename Operation::first_argument_type value;\npublic:\n    binder1st(const Operation& x, const typename Operation::first_argument_type y);\n    typename Operation::result_type operator()(      typename Operation::second_argument_type& x) const;\n    typename Operation::result_type operator()(const typename Operation::second_argument_type& x) const;\n};\n\ntemplate <class Operation, class T>\nbinder1st<Operation> bind1st(const Operation& op, const T& x);\n\ntemplate <class Operation>\nclass binder2nd\n    : public unary_function<typename Operation::first_argument_type,\n                            typename Operation::result_type>\n{\nprotected:\n    Operation                                op;\n    typename Operation::second_argument_type value;\npublic:\n    binder2nd(const Operation& x, const typename Operation::second_argument_type y);\n    typename Operation::result_type operator()(      typename Operation::first_argument_type& x) const;\n    typename Operation::result_type operator()(const typename Operation::first_argument_type& x) const;\n};\n\ntemplate <class Operation, class T>\nbinder2nd<Operation> bind2nd(const Operation& op, const T& x);\n\ntemplate <class Arg, class Result>\nclass pointer_to_unary_function : public unary_function<Arg, Result>\n{\npublic:\n    explicit pointer_to_unary_function(Result (*f)(Arg));\n    Result operator()(Arg x) const;\n};\n\ntemplate <class Arg, class Result>\npointer_to_unary_function<Arg,Result> ptr_fun(Result (*f)(Arg));\n\ntemplate <class Arg1, class Arg2, class Result>\nclass pointer_to_binary_function : public binary_function<Arg1, Arg2, Result>\n{\npublic:\n    explicit pointer_to_binary_function(Result (*f)(Arg1, Arg2));\n    Result operator()(Arg1 x, Arg2 y) const;\n};\n\ntemplate <class Arg1, class Arg2, class Result>\npointer_to_binary_function<Arg1,Arg2,Result> ptr_fun(Result (*f)(Arg1,Arg2));\n\ntemplate<class S, class T>\nclass mem_fun_t : public unary_function<T*, S>\n{\npublic:\n    explicit mem_fun_t(S (T::*p)());\n    S operator()(T* p) const;\n};\n\ntemplate<class S, class T, class A>\nclass mem_fun1_t : public binary_function<T*, A, S>\n{\npublic:\n    explicit mem_fun1_t(S (T::*p)(A));\n    S operator()(T* p, A x) const;\n};\n\ntemplate<class S, class T>          mem_fun_t<S,T>    mem_fun(S (T::*f)());\ntemplate<class S, class T, class A> mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A));\n\ntemplate<class S, class T>\nclass mem_fun_ref_t : public unary_function<T, S>\n{\npublic:\n    explicit mem_fun_ref_t(S (T::*p)());\n    S operator()(T& p) const;\n};\n\ntemplate<class S, class T, class A>\nclass mem_fun1_ref_t : public binary_function<T, A, S>\n{\npublic:\n    explicit mem_fun1_ref_t(S (T::*p)(A));\n    S operator()(T& p, A x) const;\n};\n\ntemplate<class S, class T>          mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)());\ntemplate<class S, class T, class A> mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A));\n\ntemplate <class S, class T>\nclass const_mem_fun_t : public unary_function<const T*, S>\n{\npublic:\n    explicit const_mem_fun_t(S (T::*p)() const);\n    S operator()(const T* p) const;\n};\n\ntemplate <class S, class T, class A>\nclass const_mem_fun1_t : public binary_function<const T*, A, S>\n{\npublic:\n    explicit const_mem_fun1_t(S (T::*p)(A) const);\n    S operator()(const T* p, A x) const;\n};\n\ntemplate <class S, class T>          const_mem_fun_t<S,T>    mem_fun(S (T::*f)() const);\ntemplate <class S, class T, class A> const_mem_fun1_t<S,T,A> mem_fun(S (T::*f)(A) const);\n\ntemplate <class S, class T>\nclass const_mem_fun_ref_t : public unary_function<T, S>\n{\npublic:\n    explicit const_mem_fun_ref_t(S (T::*p)() const);\n    S operator()(const T& p) const;\n};\n\ntemplate <class S, class T, class A>\nclass const_mem_fun1_ref_t : public binary_function<T, A, S>\n{\npublic:\n    explicit const_mem_fun1_ref_t(S (T::*p)(A) const);\n    S operator()(const T& p, A x) const;\n};\n\ntemplate <class S, class T>          const_mem_fun_ref_t<S,T>    mem_fun_ref(S (T::*f)() const);\ntemplate <class S, class T, class A> const_mem_fun1_ref_t<S,T,A> mem_fun_ref(S (T::*f)(A) const);\n\ntemplate<class R, class T> unspecified mem_fn(R T::*);\n\nclass bad_function_call\n    : public exception\n{\n};\n\ntemplate<class> class function; // undefined\n\ntemplate<class R, class... ArgTypes>\nclass function<R(ArgTypes...)>\n  : public unary_function<T1, R>      // iff sizeof...(ArgTypes) == 1 and\n                                      // ArgTypes contains T1\n  : public binary_function<T1, T2, R> // iff sizeof...(ArgTypes) == 2 and\n                                      // ArgTypes contains T1 and T2\n{\npublic:\n    typedef R result_type;\n\n    // construct/copy/destroy:\n    function() noexcept;\n    function(nullptr_t) noexcept;\n    function(const function&);\n    function(function&&) noexcept;\n    template<class F>\n      function(F);\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&) noexcept;\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, nullptr_t) noexcept;\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, const function&);\n    template<Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, function&&);\n    template<class F, Allocator Alloc>\n      function(allocator_arg_t, const Alloc&, F);\n\n    function& operator=(const function&);\n    function& operator=(function&&) noexcept;\n    function& operator=(nullptr_t) noexcept;\n    template<class F>\n      function& operator=(F&&);\n    template<class F>\n      function& operator=(reference_wrapper<F>) noexcept;\n\n    ~function();\n\n    // function modifiers:\n    void swap(function&) noexcept;\n    template<class F, class Alloc>\n      void assign(F&&, const Alloc&);\n\n    // function capacity:\n    explicit operator bool() const noexcept;\n\n    // function invocation:\n    R operator()(ArgTypes...) const;\n\n    // function target access:\n    const std::type_info& target_type() const noexcept;\n    template <typename T>       T* target() noexcept;\n    template <typename T> const T* target() const noexcept;\n};\n\n// Null pointer comparisons:\ntemplate <class R, class ... ArgTypes>\n  bool operator==(const function<R(ArgTypes...)>&, nullptr_t) noexcept;\n\ntemplate <class R, class ... ArgTypes>\n  bool operator==(nullptr_t, const function<R(ArgTypes...)>&) noexcept;\n\ntemplate <class R, class ... ArgTypes>\n  bool operator!=(const function<R(ArgTypes...)>&, nullptr_t) noexcept;\n\ntemplate <class  R, class ... ArgTypes>\n  bool operator!=(nullptr_t, const function<R(ArgTypes...)>&) noexcept;\n\n// specialized algorithms:\ntemplate <class  R, class ... ArgTypes>\n  void swap(function<R(ArgTypes...)>&, function<R(ArgTypes...)>&) noexcept;\n\ntemplate <class T> struct hash;\n\ntemplate <> struct hash<bool>;\ntemplate <> struct hash<char>;\ntemplate <> struct hash<signed char>;\ntemplate <> struct hash<unsigned char>;\ntemplate <> struct hash<char16_t>;\ntemplate <> struct hash<char32_t>;\ntemplate <> struct hash<wchar_t>;\ntemplate <> struct hash<short>;\ntemplate <> struct hash<unsigned short>;\ntemplate <> struct hash<int>;\ntemplate <> struct hash<unsigned int>;\ntemplate <> struct hash<long>;\ntemplate <> struct hash<long long>;\ntemplate <> struct hash<unsigned long>;\ntemplate <> struct hash<unsigned long long>;\n\ntemplate <> struct hash<float>;\ntemplate <> struct hash<double>;\ntemplate <> struct hash<long double>;\n\ntemplate<class T> struct hash<T*>;\n\n}  // std\n\nPOLICY:  For non-variadic implementations, the number of arguments is limited\n         to 3.  It is hoped that the need for non-variadic implementations\n         will be minimal.\n\n*/\n\n#include <__config>\n#include <type_traits>\n#include <typeinfo>\n#include <exception>\n#include <memory>\n#include <tuple>\n\n#include <__functional_base>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY plus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x + __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY plus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) + _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY minus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x - __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY minus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) - _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY multiplies : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x * __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY multiplies<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) * _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY divides : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x / __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY divides<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) / _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY modulus : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x % __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY modulus<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) % _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY negate : unary_function<_Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x) const\n        {return -__x;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY negate<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n        { return -_VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY equal_to : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x == __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY equal_to<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) == _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY not_equal_to : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x != __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY not_equal_to<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) != _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY greater : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x > __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY greater<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) > _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n// less in <__functional_base>\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY greater_equal : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x >= __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY greater_equal<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) >= _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY less_equal : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x <= __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY less_equal<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) <= _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY logical_and : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x && __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY logical_and<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) && _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY logical_or : binary_function<_Tp, _Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x || __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY logical_or<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) || _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY logical_not : unary_function<_Tp, bool>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const _Tp& __x) const\n        {return !__x;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY logical_not<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n        { return !_VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY bit_and : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x & __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_and<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) & _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY bit_or : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x | __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_or<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) | _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\n#else\ntemplate <class _Tp>\n#endif\nstruct _LIBCPP_TYPE_VIS_ONLY bit_xor : binary_function<_Tp, _Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x, const _Tp& __y) const\n        {return __x ^ __y;}\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_xor<void>\n{\n    template <class _T1, class _T2>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_T1&& __t, _T2&& __u) const\n        { return _VSTD::forward<_T1>(__t) ^ _VSTD::forward<_T2>(__u); }\n    typedef void is_transparent;\n};\n#endif\n\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp = void>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_not : unary_function<_Tp, _Tp>\n{\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    _Tp operator()(const _Tp& __x) const\n        {return ~__x;}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY bit_not<void>\n{\n    template <class _Tp>\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    auto operator()(_Tp&& __x) const\n        { return ~_VSTD::forward<_Tp>(__x); }\n    typedef void is_transparent;\n};\n#endif\n\ntemplate <class _Predicate>\nclass _LIBCPP_TYPE_VIS_ONLY unary_negate\n    : public unary_function<typename _Predicate::argument_type, bool>\n{\n    _Predicate __pred_;\npublic:\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    explicit unary_negate(const _Predicate& __pred)\n        : __pred_(__pred) {}\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const typename _Predicate::argument_type& __x) const\n        {return !__pred_(__x);}\n};\n\ntemplate <class _Predicate>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nunary_negate<_Predicate>\nnot1(const _Predicate& __pred) {return unary_negate<_Predicate>(__pred);}\n\ntemplate <class _Predicate>\nclass _LIBCPP_TYPE_VIS_ONLY binary_negate\n    : public binary_function<typename _Predicate::first_argument_type,\n                             typename _Predicate::second_argument_type,\n                             bool>\n{\n    _Predicate __pred_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit _LIBCPP_CONSTEXPR_AFTER_CXX11 \n    binary_negate(const _Predicate& __pred) : __pred_(__pred) {}\n\n    _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\n    bool operator()(const typename _Predicate::first_argument_type& __x,\n                    const typename _Predicate::second_argument_type& __y) const\n        {return !__pred_(__x, __y);}\n};\n\ntemplate <class _Predicate>\ninline _LIBCPP_CONSTEXPR_AFTER_CXX11 _LIBCPP_INLINE_VISIBILITY\nbinary_negate<_Predicate>\nnot2(const _Predicate& __pred) {return binary_negate<_Predicate>(__pred);}\n\ntemplate <class __Operation>\nclass _LIBCPP_TYPE_VIS_ONLY binder1st\n    : public unary_function<typename __Operation::second_argument_type,\n                            typename __Operation::result_type>\n{\nprotected:\n    __Operation                               op;\n    typename __Operation::first_argument_type value;\npublic:\n    _LIBCPP_INLINE_VISIBILITY binder1st(const __Operation& __x,\n                               const typename __Operation::first_argument_type __y)\n        : op(__x), value(__y) {}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (typename __Operation::second_argument_type& __x) const\n            {return op(value, __x);}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (const typename __Operation::second_argument_type& __x) const\n            {return op(value, __x);}\n};\n\ntemplate <class __Operation, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbinder1st<__Operation>\nbind1st(const __Operation& __op, const _Tp& __x)\n    {return binder1st<__Operation>(__op, __x);}\n\ntemplate <class __Operation>\nclass _LIBCPP_TYPE_VIS_ONLY binder2nd\n    : public unary_function<typename __Operation::first_argument_type,\n                            typename __Operation::result_type>\n{\nprotected:\n    __Operation                                op;\n    typename __Operation::second_argument_type value;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    binder2nd(const __Operation& __x, const typename __Operation::second_argument_type __y)\n        : op(__x), value(__y) {}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (      typename __Operation::first_argument_type& __x) const\n            {return op(__x, value);}\n    _LIBCPP_INLINE_VISIBILITY typename __Operation::result_type operator()\n        (const typename __Operation::first_argument_type& __x) const\n            {return op(__x, value);}\n};\n\ntemplate <class __Operation, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nbinder2nd<__Operation>\nbind2nd(const __Operation& __op, const _Tp& __x)\n    {return binder2nd<__Operation>(__op, __x);}\n\ntemplate <class _Arg, class _Result>\nclass _LIBCPP_TYPE_VIS_ONLY pointer_to_unary_function\n    : public unary_function<_Arg, _Result>\n{\n    _Result (*__f_)(_Arg);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_unary_function(_Result (*__f)(_Arg))\n        : __f_(__f) {}\n    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg __x) const\n        {return __f_(__x);}\n};\n\ntemplate <class _Arg, class _Result>\ninline _LIBCPP_INLINE_VISIBILITY\npointer_to_unary_function<_Arg,_Result>\nptr_fun(_Result (*__f)(_Arg))\n    {return pointer_to_unary_function<_Arg,_Result>(__f);}\n\ntemplate <class _Arg1, class _Arg2, class _Result>\nclass _LIBCPP_TYPE_VIS_ONLY pointer_to_binary_function\n    : public binary_function<_Arg1, _Arg2, _Result>\n{\n    _Result (*__f_)(_Arg1, _Arg2);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit pointer_to_binary_function(_Result (*__f)(_Arg1, _Arg2))\n        : __f_(__f) {}\n    _LIBCPP_INLINE_VISIBILITY _Result operator()(_Arg1 __x, _Arg2 __y) const\n        {return __f_(__x, __y);}\n};\n\ntemplate <class _Arg1, class _Arg2, class _Result>\ninline _LIBCPP_INLINE_VISIBILITY\npointer_to_binary_function<_Arg1,_Arg2,_Result>\nptr_fun(_Result (*__f)(_Arg1,_Arg2))\n    {return pointer_to_binary_function<_Arg1,_Arg2,_Result>(__f);}\n\ntemplate<class _Sp, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY mem_fun_t : public unary_function<_Tp*, _Sp>\n{\n    _Sp (_Tp::*__p_)();\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_t(_Sp (_Tp::*__p)())\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p) const\n        {return (__p->*__p_)();}\n};\n\ntemplate<class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TYPE_VIS_ONLY mem_fun1_t : public binary_function<_Tp*, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_t(_Sp (_Tp::*__p)(_Ap))\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp* __p, _Ap __x) const\n        {return (__p->*__p_)(__x);}\n};\n\ntemplate<class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun_t<_Sp,_Tp>\nmem_fun(_Sp (_Tp::*__f)())\n    {return mem_fun_t<_Sp,_Tp>(__f);}\n\ntemplate<class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun1_t<_Sp,_Tp,_Ap>\nmem_fun(_Sp (_Tp::*__f)(_Ap))\n    {return mem_fun1_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate<class _Sp, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY mem_fun_ref_t : public unary_function<_Tp, _Sp>\n{\n    _Sp (_Tp::*__p_)();\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun_ref_t(_Sp (_Tp::*__p)())\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p) const\n        {return (__p.*__p_)();}\n};\n\ntemplate<class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TYPE_VIS_ONLY mem_fun1_ref_t : public binary_function<_Tp, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap);\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap))\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(_Tp& __p, _Ap __x) const\n        {return (__p.*__p_)(__x);}\n};\n\ntemplate<class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun_ref_t<_Sp,_Tp>\nmem_fun_ref(_Sp (_Tp::*__f)())\n    {return mem_fun_ref_t<_Sp,_Tp>(__f);}\n\ntemplate<class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nmem_fun1_ref_t<_Sp,_Tp,_Ap>\nmem_fun_ref(_Sp (_Tp::*__f)(_Ap))\n    {return mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate <class _Sp, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY const_mem_fun_t : public unary_function<const _Tp*, _Sp>\n{\n    _Sp (_Tp::*__p_)() const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_t(_Sp (_Tp::*__p)() const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p) const\n        {return (__p->*__p_)();}\n};\n\ntemplate <class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TYPE_VIS_ONLY const_mem_fun1_t : public binary_function<const _Tp*, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap) const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_t(_Sp (_Tp::*__p)(_Ap) const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp* __p, _Ap __x) const\n        {return (__p->*__p_)(__x);}\n};\n\ntemplate <class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun_t<_Sp,_Tp>\nmem_fun(_Sp (_Tp::*__f)() const)\n    {return const_mem_fun_t<_Sp,_Tp>(__f);}\n\ntemplate <class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun1_t<_Sp,_Tp,_Ap>\nmem_fun(_Sp (_Tp::*__f)(_Ap) const)\n    {return const_mem_fun1_t<_Sp,_Tp,_Ap>(__f);}\n\ntemplate <class _Sp, class _Tp>\nclass _LIBCPP_TYPE_VIS_ONLY const_mem_fun_ref_t : public unary_function<_Tp, _Sp>\n{\n    _Sp (_Tp::*__p_)() const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun_ref_t(_Sp (_Tp::*__p)() const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p) const\n        {return (__p.*__p_)();}\n};\n\ntemplate <class _Sp, class _Tp, class _Ap>\nclass _LIBCPP_TYPE_VIS_ONLY const_mem_fun1_ref_t\n    : public binary_function<_Tp, _Ap, _Sp>\n{\n    _Sp (_Tp::*__p_)(_Ap) const;\npublic:\n    _LIBCPP_INLINE_VISIBILITY explicit const_mem_fun1_ref_t(_Sp (_Tp::*__p)(_Ap) const)\n        : __p_(__p) {}\n    _LIBCPP_INLINE_VISIBILITY _Sp operator()(const _Tp& __p, _Ap __x) const\n        {return (__p.*__p_)(__x);}\n};\n\ntemplate <class _Sp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun_ref_t<_Sp,_Tp>\nmem_fun_ref(_Sp (_Tp::*__f)() const)\n    {return const_mem_fun_ref_t<_Sp,_Tp>(__f);}\n\ntemplate <class _Sp, class _Tp, class _Ap>\ninline _LIBCPP_INLINE_VISIBILITY\nconst_mem_fun1_ref_t<_Sp,_Tp,_Ap>\nmem_fun_ref(_Sp (_Tp::*__f)(_Ap) const)\n    {return const_mem_fun1_ref_t<_Sp,_Tp,_Ap>(__f);}\n\n#ifdef _LIBCPP_HAS_NO_VARIADICS\n\n#include <__functional_03>\n\n#else  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <class _Tp>\nclass __mem_fn\n    : public __weak_result_type<_Tp>\n{\npublic:\n    // types\n    typedef _Tp type;\nprivate:\n    type __f_;\n\npublic:\n    _LIBCPP_INLINE_VISIBILITY __mem_fn(type __f) : __f_(__f) {}\n\n    // invoke\n    template <class... _ArgTypes>\n       _LIBCPP_INLINE_VISIBILITY\n       typename __invoke_return<type, _ArgTypes...>::type\n          operator() (_ArgTypes&&... __args) const\n          {\n              return __invoke(__f_, _VSTD::forward<_ArgTypes>(__args)...);\n          }\n};\n\ntemplate<class _Rp, class _Tp>\ninline _LIBCPP_INLINE_VISIBILITY\n__mem_fn<_Rp _Tp::*>\nmem_fn(_Rp _Tp::* __pm)\n{\n    return __mem_fn<_Rp _Tp::*>(__pm);\n}\n\n// bad_function_call\n\nclass _LIBCPP_EXCEPTION_ABI bad_function_call\n    : public exception\n{\n};\n\ntemplate<class _Fp> class _LIBCPP_TYPE_VIS_ONLY function; // undefined\n\nnamespace __function\n{\n\ntemplate<class _Rp, class ..._ArgTypes>\nstruct __maybe_derive_from_unary_function\n{\n};\n\ntemplate<class _Rp, class _A1>\nstruct __maybe_derive_from_unary_function<_Rp(_A1)>\n    : public unary_function<_A1, _Rp>\n{\n};\n\ntemplate<class _Rp, class ..._ArgTypes>\nstruct __maybe_derive_from_binary_function\n{\n};\n\ntemplate<class _Rp, class _A1, class _A2>\nstruct __maybe_derive_from_binary_function<_Rp(_A1, _A2)>\n    : public binary_function<_A1, _A2, _Rp>\n{\n};\n\ntemplate<class _Fp> class __base;\n\ntemplate<class _Rp, class ..._ArgTypes>\nclass __base<_Rp(_ArgTypes...)>\n{\n    __base(const __base&);\n    __base& operator=(const __base&);\npublic:\n    _LIBCPP_INLINE_VISIBILITY __base() {}\n    _LIBCPP_INLINE_VISIBILITY virtual ~__base() {}\n    virtual __base* __clone() const = 0;\n    virtual void __clone(__base*) const = 0;\n    virtual void destroy() _NOEXCEPT = 0;\n    virtual void destroy_deallocate() _NOEXCEPT = 0;\n    virtual _Rp operator()(_ArgTypes&& ...) = 0;\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* target(const type_info&) const _NOEXCEPT = 0;\n    virtual const std::type_info& target_type() const _NOEXCEPT = 0;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _FD, class _Alloc, class _FB> class __func;\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nclass __func<_Fp, _Alloc, _Rp(_ArgTypes...)>\n    : public  __base<_Rp(_ArgTypes...)>\n{\n    __compressed_pair<_Fp, _Alloc> __f_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(_Fp&& __f)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)),\n                                    _VSTD::forward_as_tuple()) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(const _Fp& __f, const _Alloc& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f),\n                                    _VSTD::forward_as_tuple(__a)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(const _Fp& __f, _Alloc&& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(__f),\n                                    _VSTD::forward_as_tuple(_VSTD::move(__a))) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __func(_Fp&& __f, _Alloc&& __a)\n        : __f_(piecewise_construct, _VSTD::forward_as_tuple(_VSTD::move(__f)),\n                                    _VSTD::forward_as_tuple(_VSTD::move(__a))) {}\n    virtual __base<_Rp(_ArgTypes...)>* __clone() const;\n    virtual void __clone(__base<_Rp(_ArgTypes...)>*) const;\n    virtual void destroy() _NOEXCEPT;\n    virtual void destroy_deallocate() _NOEXCEPT;\n    virtual _Rp operator()(_ArgTypes&& ... __arg);\n#ifndef _LIBCPP_NO_RTTI\n    virtual const void* target(const type_info&) const _NOEXCEPT;\n    virtual const std::type_info& target_type() const _NOEXCEPT;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\n__base<_Rp(_ArgTypes...)>*\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone() const\n{\n    typedef typename _Alloc::template rebind<__func>::other _Ap;\n    _Ap __a(__f_.second());\n    typedef __allocator_destructor<_Ap> _Dp;\n    unique_ptr<__func, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n    ::new (__hold.get()) __func(__f_.first(), _Alloc(__a));\n    return __hold.release();\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::__clone(__base<_Rp(_ArgTypes...)>* __p) const\n{\n    ::new (__p) __func(__f_.first(), __f_.second());\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy() _NOEXCEPT\n{\n    __f_.~__compressed_pair<_Fp, _Alloc>();\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nvoid\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::destroy_deallocate() _NOEXCEPT\n{\n    typedef typename _Alloc::template rebind<__func>::other _Ap;\n    _Ap __a(__f_.second());\n    __f_.~__compressed_pair<_Fp, _Alloc>();\n    __a.deallocate(this, 1);\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\n_Rp\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::operator()(_ArgTypes&& ... __arg)\n{\n    return __invoke(__f_.first(), _VSTD::forward<_ArgTypes>(__arg)...);\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nconst void*\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target(const type_info& __ti) const _NOEXCEPT\n{\n    if (__ti == typeid(_Fp))\n        return &__f_.first();\n    return (const void*)0;\n}\n\ntemplate<class _Fp, class _Alloc, class _Rp, class ..._ArgTypes>\nconst std::type_info&\n__func<_Fp, _Alloc, _Rp(_ArgTypes...)>::target_type() const _NOEXCEPT\n{\n    return typeid(_Fp);\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\n}  // __function\n\ntemplate<class _Rp, class ..._ArgTypes>\nclass _LIBCPP_TYPE_VIS_ONLY function<_Rp(_ArgTypes...)>\n    : public __function::__maybe_derive_from_unary_function<_Rp(_ArgTypes...)>,\n      public __function::__maybe_derive_from_binary_function<_Rp(_ArgTypes...)>\n{\n    typedef __function::__base<_Rp(_ArgTypes...)> __base;\n    typename aligned_storage<3*sizeof(void*)>::type __buf_;\n    __base* __f_;\n\n    template <class _Fp>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(const _Fp&) {return true;}\n    template <class _R2, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(_R2 (*__p)(_Ap...)) {return __p;}\n    template <class _R2, class _Cp, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(_R2 (_Cp::*__p)(_Ap...)) {return __p;}\n    template <class _R2, class _Cp, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(_R2 (_Cp::*__p)(_Ap...) const) {return __p;}\n    template <class _R2, class _Cp, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(_R2 (_Cp::*__p)(_Ap...) volatile) {return __p;}\n    template <class _R2, class _Cp, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(_R2 (_Cp::*__p)(_Ap...) const volatile) {return __p;}\n    template <class _R2, class ..._Ap>\n        _LIBCPP_INLINE_VISIBILITY\n        static bool __not_null(const function<_R2(_Ap...)>& __p) {return !!__p;}\n\n    template <class _Fp, bool = !is_same<_Fp, function>::value &&\n                                __invokable<_Fp&, _ArgTypes...>::value>\n        struct __callable;\n    template <class _Fp>\n        struct __callable<_Fp, true>\n        {\n            static const bool value =\n                is_convertible<typename __invoke_of<_Fp&, _ArgTypes...>::type,\n                               _Rp>::value;\n        };\n    template <class _Fp>\n        struct __callable<_Fp, false>\n        {\n            static const bool value = false;\n        };\npublic:\n    typedef _Rp result_type;\n\n    // construct/copy/destroy:\n    _LIBCPP_INLINE_VISIBILITY\n    function() _NOEXCEPT : __f_(0) {}\n    _LIBCPP_INLINE_VISIBILITY\n    function(nullptr_t) _NOEXCEPT : __f_(0) {}\n    function(const function&);\n    function(function&&) _NOEXCEPT;\n    template<class _Fp>\n      function(_Fp, typename enable_if\n                                     <\n                                        __callable<_Fp>::value &&\n                                        !is_same<_Fp, function>::value\n                                      >::type* = 0);\n\n    template<class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      function(allocator_arg_t, const _Alloc&) _NOEXCEPT : __f_(0) {}\n    template<class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      function(allocator_arg_t, const _Alloc&, nullptr_t) _NOEXCEPT : __f_(0) {}\n    template<class _Alloc>\n      function(allocator_arg_t, const _Alloc&, const function&);\n    template<class _Alloc>\n      function(allocator_arg_t, const _Alloc&, function&&);\n    template<class _Fp, class _Alloc>\n      function(allocator_arg_t, const _Alloc& __a, _Fp __f,\n               typename enable_if<__callable<_Fp>::value>::type* = 0);\n\n    function& operator=(const function&);\n    function& operator=(function&&) _NOEXCEPT;\n    function& operator=(nullptr_t) _NOEXCEPT;\n    template<class _Fp>\n      typename enable_if\n      <\n        __callable<typename decay<_Fp>::type>::value &&\n        !is_same<typename remove_reference<_Fp>::type, function>::value,\n        function&\n      >::type\n      operator=(_Fp&&);\n\n    ~function();\n\n    // function modifiers:\n    void swap(function&) _NOEXCEPT;\n    template<class _Fp, class _Alloc>\n      _LIBCPP_INLINE_VISIBILITY\n      void assign(_Fp&& __f, const _Alloc& __a)\n        {function(allocator_arg, __a, _VSTD::forward<_Fp>(__f)).swap(*this);}\n\n    // function capacity:\n    _LIBCPP_INLINE_VISIBILITY\n        _LIBCPP_EXPLICIT operator bool() const _NOEXCEPT {return __f_;}\n\n    // deleted overloads close possible hole in the type system\n    template<class _R2, class... _ArgTypes2>\n      bool operator==(const function<_R2(_ArgTypes2...)>&) const = delete;\n    template<class _R2, class... _ArgTypes2>\n      bool operator!=(const function<_R2(_ArgTypes2...)>&) const = delete;\npublic:\n    // function invocation:\n    _Rp operator()(_ArgTypes...) const;\n\n#ifndef _LIBCPP_NO_RTTI\n    // function target access:\n    const std::type_info& target_type() const _NOEXCEPT;\n    template <typename _Tp> _Tp* target() _NOEXCEPT;\n    template <typename _Tp> const _Tp* target() const _NOEXCEPT;\n#endif  // _LIBCPP_NO_RTTI\n};\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::function(const function& __f)\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if (__f.__f_ == (const __base*)&__f.__buf_)\n    {\n        __f_ = (__base*)&__buf_;\n        __f.__f_->__clone(__f_);\n    }\n    else\n        __f_ = __f.__f_->__clone();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Alloc>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,\n                                     const function& __f)\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if (__f.__f_ == (const __base*)&__f.__buf_)\n    {\n        __f_ = (__base*)&__buf_;\n        __f.__f_->__clone(__f_);\n    }\n    else\n        __f_ = __f.__f_->__clone();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::function(function&& __f) _NOEXCEPT\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if (__f.__f_ == (__base*)&__f.__buf_)\n    {\n        __f_ = (__base*)&__buf_;\n        __f.__f_->__clone(__f_);\n    }\n    else\n    {\n        __f_ = __f.__f_;\n        __f.__f_ = 0;\n    }\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Alloc>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc&,\n                                     function&& __f)\n{\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if (__f.__f_ == (__base*)&__f.__buf_)\n    {\n        __f_ = (__base*)&__buf_;\n        __f.__f_->__clone(__f_);\n    }\n    else\n    {\n        __f_ = __f.__f_;\n        __f.__f_ = 0;\n    }\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp>\nfunction<_Rp(_ArgTypes...)>::function(_Fp __f,\n                                     typename enable_if\n                                     <\n                                        __callable<_Fp>::value &&\n                                        !is_same<_Fp, function>::value\n                                     >::type*)\n    : __f_(0)\n{\n    if (__not_null(__f))\n    {\n        typedef __function::__func<_Fp, allocator<_Fp>, _Rp(_ArgTypes...)> _FF;\n        if (sizeof(_FF) <= sizeof(__buf_) && is_nothrow_copy_constructible<_Fp>::value)\n        {\n            __f_ = (__base*)&__buf_;\n            ::new (__f_) _FF(_VSTD::move(__f));\n        }\n        else\n        {\n            typedef allocator<_FF> _Ap;\n            _Ap __a;\n            typedef __allocator_destructor<_Ap> _Dp;\n            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n            ::new (__hold.get()) _FF(_VSTD::move(__f), allocator<_Fp>(__a));\n            __f_ = __hold.release();\n        }\n    }\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp, class _Alloc>\nfunction<_Rp(_ArgTypes...)>::function(allocator_arg_t, const _Alloc& __a0, _Fp __f,\n                                     typename enable_if<__callable<_Fp>::value>::type*)\n    : __f_(0)\n{\n    typedef allocator_traits<_Alloc> __alloc_traits;\n    if (__not_null(__f))\n    {\n        typedef __function::__func<_Fp, _Alloc, _Rp(_ArgTypes...)> _FF;\n        typedef typename __alloc_traits::template\n#ifndef _LIBCPP_HAS_NO_TEMPLATE_ALIASES\n            rebind_alloc<_FF>\n#else\n            rebind_alloc<_FF>::other\n#endif\n            _Ap;\n        _Ap __a(__a0);\n        if (sizeof(_FF) <= sizeof(__buf_) && \n            is_nothrow_copy_constructible<_Fp>::value && is_nothrow_copy_constructible<_Ap>::value)\n        {\n            __f_ = (__base*)&__buf_;\n            ::new (__f_) _FF(_VSTD::move(__f), _Alloc(__a));\n        }\n        else\n        {\n            typedef __allocator_destructor<_Ap> _Dp;\n            unique_ptr<__base, _Dp> __hold(__a.allocate(1), _Dp(__a, 1));\n            ::new (__hold.get()) _FF(_VSTD::move(__f), _Alloc(__a));\n            __f_ = __hold.release();\n        }\n    }\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(const function& __f)\n{\n    function(__f).swap(*this);\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(function&& __f) _NOEXCEPT\n{\n    if (__f_ == (__base*)&__buf_)\n        __f_->destroy();\n    else if (__f_)\n        __f_->destroy_deallocate();\n    __f_ = 0;\n    if (__f.__f_ == 0)\n        __f_ = 0;\n    else if (__f.__f_ == (__base*)&__f.__buf_)\n    {\n        __f_ = (__base*)&__buf_;\n        __f.__f_->__clone(__f_);\n    }\n    else\n    {\n        __f_ = __f.__f_;\n        __f.__f_ = 0;\n    }\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>&\nfunction<_Rp(_ArgTypes...)>::operator=(nullptr_t) _NOEXCEPT\n{\n    if (__f_ == (__base*)&__buf_)\n        __f_->destroy();\n    else if (__f_)\n        __f_->destroy_deallocate();\n    __f_ = 0;\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <class _Fp>\ntypename enable_if\n<\n    function<_Rp(_ArgTypes...)>::template __callable<typename decay<_Fp>::type>::value &&\n    !is_same<typename remove_reference<_Fp>::type, function<_Rp(_ArgTypes...)>>::value,\n    function<_Rp(_ArgTypes...)>&\n>::type\nfunction<_Rp(_ArgTypes...)>::operator=(_Fp&& __f)\n{\n    function(_VSTD::forward<_Fp>(__f)).swap(*this);\n    return *this;\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nfunction<_Rp(_ArgTypes...)>::~function()\n{\n    if (__f_ == (__base*)&__buf_)\n        __f_->destroy();\n    else if (__f_)\n        __f_->destroy_deallocate();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\nvoid\nfunction<_Rp(_ArgTypes...)>::swap(function& __f) _NOEXCEPT\n{\n    if (__f_ == (__base*)&__buf_ && __f.__f_ == (__base*)&__f.__buf_)\n    {\n        typename aligned_storage<sizeof(__buf_)>::type __tempbuf;\n        __base* __t = (__base*)&__tempbuf;\n        __f_->__clone(__t);\n        __f_->destroy();\n        __f_ = 0;\n        __f.__f_->__clone((__base*)&__buf_);\n        __f.__f_->destroy();\n        __f.__f_ = 0;\n        __f_ = (__base*)&__buf_;\n        __t->__clone((__base*)&__f.__buf_);\n        __t->destroy();\n        __f.__f_ = (__base*)&__f.__buf_;\n    }\n    else if (__f_ == (__base*)&__buf_)\n    {\n        __f_->__clone((__base*)&__f.__buf_);\n        __f_->destroy();\n        __f_ = __f.__f_;\n        __f.__f_ = (__base*)&__f.__buf_;\n    }\n    else if (__f.__f_ == (__base*)&__f.__buf_)\n    {\n        __f.__f_->__clone((__base*)&__buf_);\n        __f.__f_->destroy();\n        __f.__f_ = __f_;\n        __f_ = (__base*)&__buf_;\n    }\n    else\n        _VSTD::swap(__f_, __f.__f_);\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\n_Rp\nfunction<_Rp(_ArgTypes...)>::operator()(_ArgTypes... __arg) const\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__f_ == 0)\n        throw bad_function_call();\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return (*__f_)(_VSTD::forward<_ArgTypes>(__arg)...);\n}\n\n#ifndef _LIBCPP_NO_RTTI\n\ntemplate<class _Rp, class ..._ArgTypes>\nconst std::type_info&\nfunction<_Rp(_ArgTypes...)>::target_type() const _NOEXCEPT\n{\n    if (__f_ == 0)\n        return typeid(void);\n    return __f_->target_type();\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <typename _Tp>\n_Tp*\nfunction<_Rp(_ArgTypes...)>::target() _NOEXCEPT\n{\n    if (__f_ == 0)\n        return (_Tp*)0;\n    return (_Tp*)__f_->target(typeid(_Tp));\n}\n\ntemplate<class _Rp, class ..._ArgTypes>\ntemplate <typename _Tp>\nconst _Tp*\nfunction<_Rp(_ArgTypes...)>::target() const _NOEXCEPT\n{\n    if (__f_ == 0)\n        return (const _Tp*)0;\n    return (const _Tp*)__f_->target(typeid(_Tp));\n}\n\n#endif  // _LIBCPP_NO_RTTI\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return !__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator==(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return !__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(const function<_Rp(_ArgTypes...)>& __f, nullptr_t) _NOEXCEPT {return (bool)__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nbool\noperator!=(nullptr_t, const function<_Rp(_ArgTypes...)>& __f) _NOEXCEPT {return (bool)__f;}\n\ntemplate <class _Rp, class... _ArgTypes>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nswap(function<_Rp(_ArgTypes...)>& __x, function<_Rp(_ArgTypes...)>& __y) _NOEXCEPT\n{return __x.swap(__y);}\n\ntemplate<class _Tp> struct __is_bind_expression : public false_type {};\ntemplate<class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_bind_expression\n    : public __is_bind_expression<typename remove_cv<_Tp>::type> {};\n\ntemplate<class _Tp> struct __is_placeholder : public integral_constant<int, 0> {};\ntemplate<class _Tp> struct _LIBCPP_TYPE_VIS_ONLY is_placeholder\n    : public __is_placeholder<typename remove_cv<_Tp>::type> {};\n\nnamespace placeholders\n{\n\ntemplate <int _Np> struct __ph {};\n\n_LIBCPP_FUNC_VIS extern __ph<1>   _1;\n_LIBCPP_FUNC_VIS extern __ph<2>   _2;\n_LIBCPP_FUNC_VIS extern __ph<3>   _3;\n_LIBCPP_FUNC_VIS extern __ph<4>   _4;\n_LIBCPP_FUNC_VIS extern __ph<5>   _5;\n_LIBCPP_FUNC_VIS extern __ph<6>   _6;\n_LIBCPP_FUNC_VIS extern __ph<7>   _7;\n_LIBCPP_FUNC_VIS extern __ph<8>   _8;\n_LIBCPP_FUNC_VIS extern __ph<9>   _9;\n_LIBCPP_FUNC_VIS extern __ph<10> _10;\n\n}  // placeholders\n\ntemplate<int _Np>\nstruct __is_placeholder<placeholders::__ph<_Np> >\n    : public integral_constant<int, _Np> {};\n\ntemplate <class _Tp, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\n_Tp&\n__mu(reference_wrapper<_Tp> __t, _Uj&)\n{\n    return __t.get();\n}\n\ntemplate <class _Ti, class ..._Uj, size_t ..._Indx>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __invoke_of<_Ti&, _Uj...>::type\n__mu_expand(_Ti& __ti, tuple<_Uj...>& __uj, __tuple_indices<_Indx...>)\n{\n    return __ti(_VSTD::forward<_Uj>(_VSTD::get<_Indx>(__uj))...);\n}\n\ntemplate <class _Ti, class ..._Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_bind_expression<_Ti>::value,\n    typename __invoke_of<_Ti&, _Uj...>::type\n>::type\n__mu(_Ti& __ti, tuple<_Uj...>& __uj)\n{\n    typedef typename __make_tuple_indices<sizeof...(_Uj)>::type __indices;\n    return  __mu_expand(__ti, __uj, __indices());\n}\n\ntemplate <bool IsPh, class _Ti, class _Uj>\nstruct __mu_return2 {};\n\ntemplate <class _Ti, class _Uj>\nstruct __mu_return2<true, _Ti, _Uj>\n{\n    typedef typename tuple_element<is_placeholder<_Ti>::value - 1, _Uj>::type type;\n};\n\ntemplate <class _Ti, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    0 < is_placeholder<_Ti>::value,\n    typename __mu_return2<0 < is_placeholder<_Ti>::value, _Ti, _Uj>::type\n>::type\n__mu(_Ti&, _Uj& __uj)\n{\n    const size_t _Indx = is_placeholder<_Ti>::value - 1;\n    return _VSTD::forward<typename tuple_element<_Indx, _Uj>::type>(_VSTD::get<_Indx>(__uj));\n}\n\ntemplate <class _Ti, class _Uj>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    !is_bind_expression<_Ti>::value &&\n    is_placeholder<_Ti>::value == 0 &&\n    !__is_reference_wrapper<_Ti>::value,\n    _Ti&\n>::type\n__mu(_Ti& __ti, _Uj&)\n{\n    return __ti;\n}\n\ntemplate <class _Ti, bool IsReferenceWrapper, bool IsBindEx, bool IsPh,\n          class _TupleUj>\nstruct ____mu_return;\n\ntemplate <bool _Invokable, class _Ti, class ..._Uj>\nstruct ____mu_return_invokable  // false\n{\n    typedef __nat type;\n};\n\ntemplate <class _Ti, class ..._Uj>\nstruct ____mu_return_invokable<true, _Ti, _Uj...>\n{\n    typedef typename __invoke_of<_Ti&, _Uj...>::type type;\n};\n\ntemplate <class _Ti, class ..._Uj>\nstruct ____mu_return<_Ti, false, true, false, tuple<_Uj...> >\n    : public ____mu_return_invokable<__invokable<_Ti&, _Uj...>::value, _Ti, _Uj...>\n{\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct ____mu_return<_Ti, false, false, true, _TupleUj>\n{\n    typedef typename tuple_element<is_placeholder<_Ti>::value - 1,\n                                   _TupleUj>::type&& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct ____mu_return<_Ti, true, false, false, _TupleUj>\n{\n    typedef typename _Ti::type& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct ____mu_return<_Ti, false, false, false, _TupleUj>\n{\n    typedef _Ti& type;\n};\n\ntemplate <class _Ti, class _TupleUj>\nstruct __mu_return\n    : public ____mu_return<_Ti,\n                           __is_reference_wrapper<_Ti>::value,\n                           is_bind_expression<_Ti>::value,\n                           0 < is_placeholder<_Ti>::value &&\n                           is_placeholder<_Ti>::value <= tuple_size<_TupleUj>::value,\n                           _TupleUj>\n{\n};\n\ntemplate <class _Fp, class _BoundArgs, class _TupleUj>\nstruct _is_valid_bind_return\n{\n    static const bool value = false;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct _is_valid_bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj>\n{\n    static const bool value = __invokable<_Fp,\n                    typename __mu_return<_BoundArgs, _TupleUj>::type...>::value;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct _is_valid_bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj>\n{\n    static const bool value = __invokable<_Fp,\n                    typename __mu_return<const _BoundArgs, _TupleUj>::type...>::value;\n};\n\ntemplate <class _Fp, class _BoundArgs, class _TupleUj,\n          bool = _is_valid_bind_return<_Fp, _BoundArgs, _TupleUj>::value>\nstruct __bind_return;\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __bind_return<_Fp, tuple<_BoundArgs...>, _TupleUj, true>\n{\n    typedef typename __invoke_of\n    <\n        _Fp&,\n        typename __mu_return\n        <\n            _BoundArgs,\n            _TupleUj\n        >::type...\n    >::type type;\n};\n\ntemplate <class _Fp, class ..._BoundArgs, class _TupleUj>\nstruct __bind_return<_Fp, const tuple<_BoundArgs...>, _TupleUj, true>\n{\n    typedef typename __invoke_of\n    <\n        _Fp&,\n        typename __mu_return\n        <\n            const _BoundArgs,\n            _TupleUj\n        >::type...\n    >::type type;\n};\n\ntemplate <class _Fp, class _BoundArgs, size_t ..._Indx, class _Args>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename __bind_return<_Fp, _BoundArgs, _Args>::type\n__apply_functor(_Fp& __f, _BoundArgs& __bound_args, __tuple_indices<_Indx...>,\n                _Args&& __args)\n{\n    return __invoke(__f, __mu(_VSTD::get<_Indx>(__bound_args), __args)...);\n}\n\ntemplate<class _Fp, class ..._BoundArgs>\nclass __bind\n    : public __weak_result_type<typename decay<_Fp>::type>\n{\nprotected:\n    typedef typename decay<_Fp>::type _Fd;\n    typedef tuple<typename decay<_BoundArgs>::type...> _Td;\nprivate:\n    _Fd __f_;\n    _Td __bound_args_;\n\n    typedef typename __make_tuple_indices<sizeof...(_BoundArgs)>::type __indices;\npublic:\n#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind(const __bind& __b)\n        : __f_(__b.__f_),\n          __bound_args_(__b.__bound_args_) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind& operator=(const __bind& __b)\n    {\n        __f_ = __b.__f_;\n        __bound_args_ = __b.__bound_args_;\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind(__bind&& __b)\n        : __f_(_VSTD::move(__b.__f_)),\n          __bound_args_(_VSTD::move(__b.__bound_args_)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind& operator=(__bind&& __b)\n    {\n        __f_ = _VSTD::move(__b.__f_);\n        __bound_args_ = _VSTD::move(__b.__bound_args_);\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    template <class _Gp, class ..._BA,\n              class = typename enable_if\n                               <\n                                  is_constructible<_Fd, _Gp>::value &&\n                                  !is_same<typename remove_reference<_Gp>::type,\n                                           __bind>::value\n                               >::type>\n      _LIBCPP_INLINE_VISIBILITY\n      explicit __bind(_Gp&& __f, _BA&& ...__bound_args)\n        : __f_(_VSTD::forward<_Gp>(__f)),\n          __bound_args_(_VSTD::forward<_BA>(__bound_args)...) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type\n        operator()(_Args&& ...__args)\n        {\n            return __apply_functor(__f_, __bound_args_, __indices(),\n                                  tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));\n        }\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type\n        operator()(_Args&& ...__args) const\n        {\n            return __apply_functor(__f_, __bound_args_, __indices(),\n                                   tuple<_Args&&...>(_VSTD::forward<_Args>(__args)...));\n        }\n};\n\ntemplate<class _Fp, class ..._BoundArgs>\nstruct __is_bind_expression<__bind<_Fp, _BoundArgs...> > : public true_type {};\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\nclass __bind_r\n    : public __bind<_Fp, _BoundArgs...>\n{\n    typedef __bind<_Fp, _BoundArgs...> base;\n    typedef typename base::_Fd _Fd;\n    typedef typename base::_Td _Td;\npublic:\n    typedef _Rp result_type;\n\n#ifdef _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind_r(const __bind_r& __b)\n        : base(_VSTD::forward<const base&>(__b)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind_r& operator=(const __bind_r& __b)\n    {\n        base::operator=(_VSTD::forward<const base&>(__b));\n        return *this;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind_r(__bind_r&& __b)\n        : base(_VSTD::forward<base>(__b)) {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    __bind_r& operator=(__bind_r&& __b)\n    {\n        base::operator=(_VSTD::forward<base>(__b));\n        return *this;\n    }\n\n#endif  // _LIBCPP_HAS_NO_DEFAULTED_FUNCTIONS\n\n    template <class _Gp, class ..._BA,\n              class = typename enable_if\n                               <\n                                  is_constructible<_Fd, _Gp>::value &&\n                                  !is_same<typename remove_reference<_Gp>::type,\n                                           __bind_r>::value\n                               >::type>\n      _LIBCPP_INLINE_VISIBILITY\n      explicit __bind_r(_Gp&& __f, _BA&& ...__bound_args)\n        : base(_VSTD::forward<_Gp>(__f),\n               _VSTD::forward<_BA>(__bound_args)...) {}\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            is_convertible<typename __bind_return<_Fd, _Td, tuple<_Args&&...> >::type,\n                           result_type>::value,\n            result_type\n        >::type\n        operator()(_Args&& ...__args)\n        {\n            return base::operator()(_VSTD::forward<_Args>(__args)...);\n        }\n\n    template <class ..._Args>\n        _LIBCPP_INLINE_VISIBILITY\n        typename enable_if\n        <\n            is_convertible<typename __bind_return<const _Fd, const _Td, tuple<_Args&&...> >::type,\n                           result_type>::value,\n            result_type\n        >::type\n        operator()(_Args&& ...__args) const\n        {\n            return base::operator()(_VSTD::forward<_Args>(__args)...);\n        }\n};\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\nstruct __is_bind_expression<__bind_r<_Rp, _Fp, _BoundArgs...> > : public true_type {};\n\ntemplate<class _Fp, class ..._BoundArgs>\ninline _LIBCPP_INLINE_VISIBILITY\n__bind<_Fp, _BoundArgs...>\nbind(_Fp&& __f, _BoundArgs&&... __bound_args)\n{\n    typedef __bind<_Fp, _BoundArgs...> type;\n    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);\n}\n\ntemplate<class _Rp, class _Fp, class ..._BoundArgs>\ninline _LIBCPP_INLINE_VISIBILITY\n__bind_r<_Rp, _Fp, _BoundArgs...>\nbind(_Fp&& __f, _BoundArgs&&... __bound_args)\n{\n    typedef __bind_r<_Rp, _Fp, _BoundArgs...> type;\n    return type(_VSTD::forward<_Fp>(__f), _VSTD::forward<_BoundArgs>(__bound_args)...);\n}\n\n#endif  // _LIBCPP_HAS_NO_VARIADICS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<bool>\n    : public unary_function<bool, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(bool __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<char>\n    : public unary_function<char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<signed char>\n    : public unary_function<signed char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(signed char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned char>\n    : public unary_function<unsigned char, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned char __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\n#ifndef _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<char16_t>\n    : public unary_function<char16_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char16_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<char32_t>\n    : public unary_function<char32_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(char32_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\n#endif  // _LIBCPP_HAS_NO_UNICODE_CHARS\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<wchar_t>\n    : public unary_function<wchar_t, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(wchar_t __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<short>\n    : public unary_function<short, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(short __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned short>\n    : public unary_function<unsigned short, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned short __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<int>\n    : public unary_function<int, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(int __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned int>\n    : public unary_function<unsigned int, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned int __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<long>\n    : public unary_function<long, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(long __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned long>\n    : public unary_function<unsigned long, size_t>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(unsigned long __v) const _NOEXCEPT {return static_cast<size_t>(__v);}\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<long long>\n    : public __scalar_hash<long long>\n{\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<unsigned long long>\n    : public __scalar_hash<unsigned long long>\n{\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<float>\n    : public __scalar_hash<float>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(float __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n       if (__v == 0)\n           return 0;\n        return __scalar_hash<float>::operator()(__v);\n    }\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<double>\n    : public __scalar_hash<double>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(double __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n       if (__v == 0)\n           return 0;\n        return __scalar_hash<double>::operator()(__v);\n    }\n};\n\ntemplate <>\nstruct _LIBCPP_TYPE_VIS_ONLY hash<long double>\n    : public __scalar_hash<long double>\n{\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(long double __v) const _NOEXCEPT\n    {\n        // -0.0 and 0.0 should return same hash\n        if (__v == 0)\n            return 0;\n#if defined(__i386__)\n        // Zero out padding bits\n        union\n        {\n            long double __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n                size_t __c;\n                size_t __d;\n            };\n        } __u;\n        __u.__a = 0;\n        __u.__b = 0;\n        __u.__c = 0;\n        __u.__d = 0;\n        __u.__t = __v;\n        return __u.__a ^ __u.__b ^ __u.__c ^ __u.__d;\n#elif defined(__x86_64__)\n        // Zero out padding bits\n        union\n        {\n            long double __t;\n            struct\n            {\n                size_t __a;\n                size_t __b;\n            };\n        } __u;\n        __u.__a = 0;\n        __u.__b = 0;\n        __u.__t = __v;\n        return __u.__a ^ __u.__b;\n#else\n        return __scalar_hash<long double>::operator()(__v);\n#endif\n    }\n};\n\n#if _LIBCPP_STD_VER > 11\ntemplate <class _Tp>\nstruct _LIBCPP_TYPE_VIS_ONLY hash\n    : public unary_function<_Tp, size_t>\n{\n    static_assert(is_enum<_Tp>::value, \"This hash only works for enumeration types\");\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t operator()(_Tp __v) const _NOEXCEPT\n    {\n        typedef typename underlying_type<_Tp>::type type;\n        return hash<type>{}(static_cast<type>(__v));\n    }\n};\n#endif\n\n// struct hash<T*> in <memory>\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_FUNCTIONAL\n","// -*- C++ -*-\n//===---------------------------- cmath -----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_CMATH\n#define _LIBCPP_CMATH\n\n/*\n    cmath synopsis\n\nMacros:\n\n    HUGE_VAL\n    HUGE_VALF               // C99\n    HUGE_VALL               // C99\n    INFINITY                // C99\n    NAN                     // C99\n    FP_INFINITE             // C99\n    FP_NAN                  // C99\n    FP_NORMAL               // C99\n    FP_SUBNORMAL            // C99\n    FP_ZERO                 // C99\n    FP_FAST_FMA             // C99\n    FP_FAST_FMAF            // C99\n    FP_FAST_FMAL            // C99\n    FP_ILOGB0               // C99\n    FP_ILOGBNAN             // C99\n    MATH_ERRNO              // C99\n    MATH_ERREXCEPT          // C99\n    math_errhandling        // C99\n\nnamespace std\n{\n\nTypes:\n\n    float_t                 // C99\n    double_t                // C99\n\n// C90\n\nfloating_point abs(floating_point x);\n\nfloating_point acos (arithmetic x);\nfloat          acosf(float x);\nlong double    acosl(long double x);\n\nfloating_point asin (arithmetic x);\nfloat          asinf(float x);\nlong double    asinl(long double x);\n\nfloating_point atan (arithmetic x);\nfloat          atanf(float x);\nlong double    atanl(long double x);\n\nfloating_point atan2 (arithmetic y, arithmetic x);\nfloat          atan2f(float y, float x);\nlong double    atan2l(long double y, long double x);\n\nfloating_point ceil (arithmetic x);\nfloat          ceilf(float x);\nlong double    ceill(long double x);\n\nfloating_point cos (arithmetic x);\nfloat          cosf(float x);\nlong double    cosl(long double x);\n\nfloating_point cosh (arithmetic x);\nfloat          coshf(float x);\nlong double    coshl(long double x);\n\nfloating_point exp (arithmetic x);\nfloat          expf(float x);\nlong double    expl(long double x);\n\nfloating_point fabs (arithmetic x);\nfloat          fabsf(float x);\nlong double    fabsl(long double x);\n\nfloating_point floor (arithmetic x);\nfloat          floorf(float x);\nlong double    floorl(long double x);\n\nfloating_point fmod (arithmetic x, arithmetic y);\nfloat          fmodf(float x, float y);\nlong double    fmodl(long double x, long double y);\n\nfloating_point frexp (arithmetic value, int* exp);\nfloat          frexpf(float value, int* exp);\nlong double    frexpl(long double value, int* exp);\n\nfloating_point ldexp (arithmetic value, int exp);\nfloat          ldexpf(float value, int exp);\nlong double    ldexpl(long double value, int exp);\n\nfloating_point log (arithmetic x);\nfloat          logf(float x);\nlong double    logl(long double x);\n\nfloating_point log10 (arithmetic x);\nfloat          log10f(float x);\nlong double    log10l(long double x);\n\nfloating_point modf (floating_point value, floating_point* iptr);\nfloat          modff(float value, float* iptr);\nlong double    modfl(long double value, long double* iptr);\n\nfloating_point pow (arithmetic x, arithmetic y);\nfloat          powf(float x, float y);\nlong double    powl(long double x, long double y);\n\nfloating_point sin (arithmetic x);\nfloat          sinf(float x);\nlong double    sinl(long double x);\n\nfloating_point sinh (arithmetic x);\nfloat          sinhf(float x);\nlong double    sinhl(long double x);\n\nfloating_point sqrt (arithmetic x);\nfloat          sqrtf(float x);\nlong double    sqrtl(long double x);\n\nfloating_point tan (arithmetic x);\nfloat          tanf(float x);\nlong double    tanl(long double x);\n\nfloating_point tanh (arithmetic x);\nfloat          tanhf(float x);\nlong double    tanhl(long double x);\n\n//  C99\n\nbool signbit(arithmetic x);\n\nint fpclassify(arithmetic x);\n\nbool isfinite(arithmetic x);\nbool isinf(arithmetic x);\nbool isnan(arithmetic x);\nbool isnormal(arithmetic x);\n\nbool isgreater(arithmetic x, arithmetic y);\nbool isgreaterequal(arithmetic x, arithmetic y);\nbool isless(arithmetic x, arithmetic y);\nbool islessequal(arithmetic x, arithmetic y);\nbool islessgreater(arithmetic x, arithmetic y);\nbool isunordered(arithmetic x, arithmetic y);\n\nfloating_point acosh (arithmetic x);\nfloat          acoshf(float x);\nlong double    acoshl(long double x);\n\nfloating_point asinh (arithmetic x);\nfloat          asinhf(float x);\nlong double    asinhl(long double x);\n\nfloating_point atanh (arithmetic x);\nfloat          atanhf(float x);\nlong double    atanhl(long double x);\n\nfloating_point cbrt (arithmetic x);\nfloat          cbrtf(float x);\nlong double    cbrtl(long double x);\n\nfloating_point copysign (arithmetic x, arithmetic y);\nfloat          copysignf(float x, float y);\nlong double    copysignl(long double x, long double y);\n\nfloating_point erf (arithmetic x);\nfloat          erff(float x);\nlong double    erfl(long double x);\n\nfloating_point erfc (arithmetic x);\nfloat          erfcf(float x);\nlong double    erfcl(long double x);\n\nfloating_point exp2 (arithmetic x);\nfloat          exp2f(float x);\nlong double    exp2l(long double x);\n\nfloating_point expm1 (arithmetic x);\nfloat          expm1f(float x);\nlong double    expm1l(long double x);\n\nfloating_point fdim (arithmetic x, arithmetic y);\nfloat          fdimf(float x, float y);\nlong double    fdiml(long double x, long double y);\n\nfloating_point fma (arithmetic x, arithmetic y, arithmetic z);\nfloat          fmaf(float x, float y, float z);\nlong double    fmal(long double x, long double y, long double z);\n\nfloating_point fmax (arithmetic x, arithmetic y);\nfloat          fmaxf(float x, float y);\nlong double    fmaxl(long double x, long double y);\n\nfloating_point fmin (arithmetic x, arithmetic y);\nfloat          fminf(float x, float y);\nlong double    fminl(long double x, long double y);\n\nfloating_point hypot (arithmetic x, arithmetic y);\nfloat          hypotf(float x, float y);\nlong double    hypotl(long double x, long double y);\n\nint ilogb (arithmetic x);\nint ilogbf(float x);\nint ilogbl(long double x);\n\nfloating_point lgamma (arithmetic x);\nfloat          lgammaf(float x);\nlong double    lgammal(long double x);\n\nlong long llrint (arithmetic x);\nlong long llrintf(float x);\nlong long llrintl(long double x);\n\nlong long llround (arithmetic x);\nlong long llroundf(float x);\nlong long llroundl(long double x);\n\nfloating_point log1p (arithmetic x);\nfloat          log1pf(float x);\nlong double    log1pl(long double x);\n\nfloating_point log2 (arithmetic x);\nfloat          log2f(float x);\nlong double    log2l(long double x);\n\nfloating_point logb (arithmetic x);\nfloat          logbf(float x);\nlong double    logbl(long double x);\n\nlong lrint (arithmetic x);\nlong lrintf(float x);\nlong lrintl(long double x);\n\nlong lround (arithmetic x);\nlong lroundf(float x);\nlong lroundl(long double x);\n\ndouble      nan (const char* str);\nfloat       nanf(const char* str);\nlong double nanl(const char* str);\n\nfloating_point nearbyint (arithmetic x);\nfloat          nearbyintf(float x);\nlong double    nearbyintl(long double x);\n\nfloating_point nextafter (arithmetic x, arithmetic y);\nfloat          nextafterf(float x, float y);\nlong double    nextafterl(long double x, long double y);\n\nfloating_point nexttoward (arithmetic x, long double y);\nfloat          nexttowardf(float x, long double y);\nlong double    nexttowardl(long double x, long double y);\n\nfloating_point remainder (arithmetic x, arithmetic y);\nfloat          remainderf(float x, float y);\nlong double    remainderl(long double x, long double y);\n\nfloating_point remquo (arithmetic x, arithmetic y, int* pquo);\nfloat          remquof(float x, float y, int* pquo);\nlong double    remquol(long double x, long double y, int* pquo);\n\nfloating_point rint (arithmetic x);\nfloat          rintf(float x);\nlong double    rintl(long double x);\n\nfloating_point round (arithmetic x);\nfloat          roundf(float x);\nlong double    roundl(long double x);\n\nfloating_point scalbln (arithmetic x, long ex);\nfloat          scalblnf(float x, long ex);\nlong double    scalblnl(long double x, long ex);\n\nfloating_point scalbn (arithmetic x, int ex);\nfloat          scalbnf(float x, int ex);\nlong double    scalbnl(long double x, int ex);\n\nfloating_point tgamma (arithmetic x);\nfloat          tgammaf(float x);\nlong double    tgammal(long double x);\n\nfloating_point trunc (arithmetic x);\nfloat          truncf(float x);\nlong double    truncl(long double x);\n\n}  // std\n\n*/\n\n#include <__config>\n#include <math.h>\n#include <type_traits>\n\n#ifdef _LIBCPP_MSVCRT\n#include \"support/win32/math_win32.h\"\n#endif\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n// signbit\n\n#ifdef signbit\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_signbit(_A1 __lcpp_x) _NOEXCEPT\n{\n    return signbit(__lcpp_x);\n}\n\n#undef signbit\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nsignbit(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_signbit((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // signbit\n\n// fpclassify\n\n#ifdef fpclassify\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nint\n__libcpp_fpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n    return fpclassify(__lcpp_x);\n}\n\n#undef fpclassify\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, int>::type\nfpclassify(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_fpclassify((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // fpclassify\n\n// isfinite\n\n#ifdef isfinite\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isfinite(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isfinite(__lcpp_x);\n}\n\n#undef isfinite\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisfinite(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isfinite((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isfinite\n\n// isinf\n\n#ifdef isinf\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isinf(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isinf(__lcpp_x);\n}\n\n#undef isinf\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisinf(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isinf((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isinf\n\n// isnan\n\n#ifdef isnan\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isnan(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isnan(__lcpp_x);\n}\n\n#undef isnan\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisnan(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isnan((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isnan\n\n// isnormal\n\n#ifdef isnormal\n\ntemplate <class _A1>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isnormal(_A1 __lcpp_x) _NOEXCEPT\n{\n    return isnormal(__lcpp_x);\n}\n\n#undef isnormal\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if<std::is_arithmetic<_A1>::value, bool>::type\nisnormal(_A1 __lcpp_x) _NOEXCEPT\n{\n    return __libcpp_isnormal((typename std::__promote<_A1>::type)__lcpp_x);\n}\n\n#endif  // isnormal\n\n// isgreater\n\n#ifdef isgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isgreater(__lcpp_x, __lcpp_y);\n}\n\n#undef isgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreater((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isgreater\n\n// isgreaterequal\n\n#ifdef isgreaterequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isgreaterequal(__lcpp_x, __lcpp_y);\n}\n\n#undef isgreaterequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisgreaterequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isgreaterequal((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isgreaterequal\n\n// isless\n\n#ifdef isless\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isless(__lcpp_x, __lcpp_y);\n}\n\n#undef isless\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisless(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isless((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isless\n\n// islessequal\n\n#ifdef islessequal\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_islessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return islessequal(__lcpp_x, __lcpp_y);\n}\n\n#undef islessequal\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessequal(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessequal((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // islessequal\n\n// islessgreater\n\n#ifdef islessgreater\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_islessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return islessgreater(__lcpp_x, __lcpp_y);\n}\n\n#undef islessgreater\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nislessgreater(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_islessgreater((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // islessgreater\n\n// isunordered\n\n#ifdef isunordered\n\ntemplate <class _A1, class _A2>\n_LIBCPP_ALWAYS_INLINE\nbool\n__libcpp_isunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    return isunordered(__lcpp_x, __lcpp_y);\n}\n\n#undef isunordered\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename std::enable_if\n<\n    std::is_arithmetic<_A1>::value &&\n    std::is_arithmetic<_A2>::value,\n    bool\n>::type\nisunordered(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename std::__promote<_A1, _A2>::type type;\n    return __libcpp_isunordered((type)__lcpp_x, (type)__lcpp_y);\n}\n\n#endif  // isunordered\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\nusing ::signbit;\nusing ::fpclassify;\nusing ::isfinite;\nusing ::isinf;\nusing ::isnan;\nusing ::isnormal;\nusing ::isgreater;\nusing ::isgreaterequal;\nusing ::isless;\nusing ::islessequal;\nusing ::islessgreater;\nusing ::isunordered;\nusing ::isunordered;\n\nusing ::float_t;\nusing ::double_t;\n\n// abs\n\n#if !defined(_AIX)\ninline _LIBCPP_INLINE_VISIBILITY\nfloat\nabs(float __lcpp_x) _NOEXCEPT {return fabsf(__lcpp_x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\ndouble\nabs(double __lcpp_x) _NOEXCEPT {return fabs(__lcpp_x);}\n\ninline _LIBCPP_INLINE_VISIBILITY\nlong double\nabs(long double __lcpp_x) _NOEXCEPT {return fabsl(__lcpp_x);}\n#endif // !defined(_AIX)\n\n#ifndef __sun__\n\n// acos\n\nusing ::acos;\nusing ::acosf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       acos(float __lcpp_x) _NOEXCEPT       {return acosf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acos(long double __lcpp_x) _NOEXCEPT {return acosl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nacos(_A1 __lcpp_x) _NOEXCEPT {return acos((double)__lcpp_x);}\n\n// asin\n\nusing ::asin;\nusing ::asinf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       asin(float __lcpp_x) _NOEXCEPT       {return asinf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asin(long double __lcpp_x) _NOEXCEPT {return asinl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nasin(_A1 __lcpp_x) _NOEXCEPT {return asin((double)__lcpp_x);}\n\n// atan\n\nusing ::atan;\nusing ::atanf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       atan(float __lcpp_x) _NOEXCEPT       {return atanf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan(long double __lcpp_x) _NOEXCEPT {return atanl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\natan(_A1 __lcpp_x) _NOEXCEPT {return atan((double)__lcpp_x);}\n\n// atan2\n\nusing ::atan2;\nusing ::atan2f;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       atan2(float __lcpp_y, float __lcpp_x) _NOEXCEPT             {return atan2f(__lcpp_y, __lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atan2(long double __lcpp_y, long double __lcpp_x) _NOEXCEPT {return atan2l(__lcpp_y, __lcpp_x);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\natan2(_A1 __lcpp_y, _A2 __lcpp_x) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return atan2((__result_type)__lcpp_y, (__result_type)__lcpp_x);\n}\n\n// ceil\n\nusing ::ceil;\nusing ::ceilf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       ceil(float __lcpp_x) _NOEXCEPT       {return ceilf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double ceil(long double __lcpp_x) _NOEXCEPT {return ceill(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nceil(_A1 __lcpp_x) _NOEXCEPT {return ceil((double)__lcpp_x);}\n\n// cos\n\nusing ::cos;\nusing ::cosf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       cos(float __lcpp_x) _NOEXCEPT       {return cosf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cos(long double __lcpp_x) _NOEXCEPT {return cosl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ncos(_A1 __lcpp_x) _NOEXCEPT {return cos((double)__lcpp_x);}\n\n// cosh\n\nusing ::cosh;\nusing ::coshf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       cosh(float __lcpp_x) _NOEXCEPT       {return coshf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cosh(long double __lcpp_x) _NOEXCEPT {return coshl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ncosh(_A1 __lcpp_x) _NOEXCEPT {return cosh((double)__lcpp_x);}\n\n#endif // __sun__\n// exp\n\nusing ::exp;\nusing ::expf;\n\n#ifndef __sun__\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       exp(float __lcpp_x) _NOEXCEPT       {return expf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp(long double __lcpp_x) _NOEXCEPT {return expl(__lcpp_x);}\n#endif\n\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nexp(_A1 __lcpp_x) _NOEXCEPT {return exp((double)__lcpp_x);}\n\n// fabs\n\nusing ::fabs;\nusing ::fabsf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       fabs(float __lcpp_x) _NOEXCEPT       {return fabsf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double fabs(long double __lcpp_x) _NOEXCEPT {return fabsl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nfabs(_A1 __lcpp_x) _NOEXCEPT {return fabs((double)__lcpp_x);}\n\n// floor\n\nusing ::floor;\nusing ::floorf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       floor(float __lcpp_x) _NOEXCEPT       {return floorf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double floor(long double __lcpp_x) _NOEXCEPT {return floorl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nfloor(_A1 __lcpp_x) _NOEXCEPT {return floor((double)__lcpp_x);}\n\n// fmod\n\n#endif //__sun__\nusing ::fmod;\nusing ::fmodf;\n#ifndef __sun__\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       fmod(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fmodf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmod(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fmodl(__lcpp_x, __lcpp_y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nfmod(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return fmod((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n\n// frexp\n\nusing ::frexp;\nusing ::frexpf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       frexp(float __lcpp_x, int* __lcpp_e) _NOEXCEPT       {return frexpf(__lcpp_x, __lcpp_e);}\ninline _LIBCPP_INLINE_VISIBILITY long double frexp(long double __lcpp_x, int* __lcpp_e) _NOEXCEPT {return frexpl(__lcpp_x, __lcpp_e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nfrexp(_A1 __lcpp_x, int* __lcpp_e) _NOEXCEPT {return frexp((double)__lcpp_x, __lcpp_e);}\n\n// ldexp\n\nusing ::ldexp;\nusing ::ldexpf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       ldexp(float __lcpp_x, int __lcpp_e) _NOEXCEPT       {return ldexpf(__lcpp_x, __lcpp_e);}\ninline _LIBCPP_INLINE_VISIBILITY long double ldexp(long double __lcpp_x, int __lcpp_e) _NOEXCEPT {return ldexpl(__lcpp_x, __lcpp_e);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nldexp(_A1 __lcpp_x, int __lcpp_e) _NOEXCEPT {return ldexp((double)__lcpp_x, __lcpp_e);}\n\n// log\n\n#endif // __sun__\nusing ::log;\nusing ::logf;\n#ifndef __sun__\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       log(float __lcpp_x) _NOEXCEPT       {return logf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log(long double __lcpp_x) _NOEXCEPT {return logl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlog(_A1 __lcpp_x) _NOEXCEPT {return log((double)__lcpp_x);}\n\n\n// log10\n\nusing ::log10;\nusing ::log10f;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       log10(float __lcpp_x) _NOEXCEPT       {return log10f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log10(long double __lcpp_x) _NOEXCEPT {return log10l(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlog10(_A1 __lcpp_x) _NOEXCEPT {return log10((double)__lcpp_x);}\n\n// modf\n\nusing ::modf;\nusing ::modff;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       modf(float __lcpp_x, float* __lcpp_y) _NOEXCEPT             {return modff(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double modf(long double __lcpp_x, long double* __lcpp_y) _NOEXCEPT {return modfl(__lcpp_x, __lcpp_y);}\n#endif\n\n// pow\n\n#endif // __sun__ \nusing ::pow;\nusing ::powf;\n\n#ifndef __sun__\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       pow(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return powf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double pow(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return powl(__lcpp_x, __lcpp_y);}\n#endif\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\npow(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return pow((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// sin\n\nusing ::sin;\nusing ::sinf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       sin(float __lcpp_x) _NOEXCEPT       {return sinf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sin(long double __lcpp_x) _NOEXCEPT {return sinl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nsin(_A1 __lcpp_x) _NOEXCEPT {return sin((double)__lcpp_x);}\n\n// sinh\n\nusing ::sinh;\nusing ::sinhf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       sinh(float __lcpp_x) _NOEXCEPT       {return sinhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sinh(long double __lcpp_x) _NOEXCEPT {return sinhl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nsinh(_A1 __lcpp_x) _NOEXCEPT {return sinh((double)__lcpp_x);}\n\n// sqrt\n\n#endif // __sun__\nusing ::sqrt;\nusing ::sqrtf;\n\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(__sun__) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       sqrt(float __lcpp_x) _NOEXCEPT       {return sqrtf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double sqrt(long double __lcpp_x) _NOEXCEPT {return sqrtl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nsqrt(_A1 __lcpp_x) _NOEXCEPT {return sqrt((double)__lcpp_x);}\n\n// tan\n\nusing ::tan;\nusing ::tanf;\n#ifndef __sun__\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       tan(float __lcpp_x) _NOEXCEPT       {return tanf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tan(long double __lcpp_x) _NOEXCEPT {return tanl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ntan(_A1 __lcpp_x) _NOEXCEPT {return tan((double)__lcpp_x);}\n\n// tanh\n\nusing ::tanh;\nusing ::tanhf;\n\n#if !(defined(_LIBCPP_MSVCRT) || defined(_AIX))\ninline _LIBCPP_INLINE_VISIBILITY float       tanh(float __lcpp_x) _NOEXCEPT       {return tanhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tanh(long double __lcpp_x) _NOEXCEPT {return tanhl(__lcpp_x);}\n#endif\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ntanh(_A1 __lcpp_x) _NOEXCEPT {return tanh((double)__lcpp_x);}\n\n// acosh\n\n#ifndef _LIBCPP_MSVCRT\nusing ::acosh;\nusing ::acoshf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       acosh(float __lcpp_x) _NOEXCEPT       {return acoshf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double acosh(long double __lcpp_x) _NOEXCEPT {return acoshl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nacosh(_A1 __lcpp_x) _NOEXCEPT {return acosh((double)__lcpp_x);}\n#endif\n\n// asinh\n\n#ifndef _LIBCPP_MSVCRT\nusing ::asinh;\nusing ::asinhf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       asinh(float __lcpp_x) _NOEXCEPT       {return asinhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double asinh(long double __lcpp_x) _NOEXCEPT {return asinhl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nasinh(_A1 __lcpp_x) _NOEXCEPT {return asinh((double)__lcpp_x);}\n#endif\n\n// atanh\n\n#ifndef _LIBCPP_MSVCRT\nusing ::atanh;\nusing ::atanhf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       atanh(float __lcpp_x) _NOEXCEPT       {return atanhf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double atanh(long double __lcpp_x) _NOEXCEPT {return atanhl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\natanh(_A1 __lcpp_x) _NOEXCEPT {return atanh((double)__lcpp_x);}\n#endif\n\n// cbrt\n\n#ifndef _LIBCPP_MSVCRT\nusing ::cbrt;\nusing ::cbrtf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       cbrt(float __lcpp_x) _NOEXCEPT       {return cbrtf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double cbrt(long double __lcpp_x) _NOEXCEPT {return cbrtl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ncbrt(_A1 __lcpp_x) _NOEXCEPT {return cbrt((double)__lcpp_x);}\n#endif\n\n// copysign\n\nusing ::copysign;\nusing ::copysignf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       copysign(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return copysignf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double copysign(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return copysignl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\ncopysign(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return copysign((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n#ifndef _LIBCPP_MSVCRT\n\n// erf\n\nusing ::erf;\nusing ::erff;\n\ninline _LIBCPP_INLINE_VISIBILITY float       erf(float __lcpp_x) _NOEXCEPT       {return erff(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erf(long double __lcpp_x) _NOEXCEPT {return erfl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nerf(_A1 __lcpp_x) _NOEXCEPT {return erf((double)__lcpp_x);}\n\n// erfc\n\nusing ::erfc;\nusing ::erfcf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       erfc(float __lcpp_x) _NOEXCEPT       {return erfcf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double erfc(long double __lcpp_x) _NOEXCEPT {return erfcl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nerfc(_A1 __lcpp_x) _NOEXCEPT {return erfc((double)__lcpp_x);}\n\n// exp2\n\nusing ::exp2;\nusing ::exp2f;\n\ninline _LIBCPP_INLINE_VISIBILITY float       exp2(float __lcpp_x) _NOEXCEPT       {return exp2f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double exp2(long double __lcpp_x) _NOEXCEPT {return exp2l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nexp2(_A1 __lcpp_x) _NOEXCEPT {return exp2((double)__lcpp_x);}\n\n// expm1\n\nusing ::expm1;\nusing ::expm1f;\n\ninline _LIBCPP_INLINE_VISIBILITY float       expm1(float __lcpp_x) _NOEXCEPT       {return expm1f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double expm1(long double __lcpp_x) _NOEXCEPT {return expm1l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nexpm1(_A1 __lcpp_x) _NOEXCEPT {return expm1((double)__lcpp_x);}\n\n// fdim\n\nusing ::fdim;\nusing ::fdimf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       fdim(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fdimf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fdim(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fdiml(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nfdim(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return fdim((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// fma\n\nusing ::fmaf;\nusing ::fma;\n\ninline _LIBCPP_INLINE_VISIBILITY float       fma(float __lcpp_x, float __lcpp_y, float __lcpp_z) _NOEXCEPT                   {return fmaf(__lcpp_x, __lcpp_y, __lcpp_z);}\ninline _LIBCPP_INLINE_VISIBILITY long double fma(long double __lcpp_x, long double __lcpp_y, long double __lcpp_z) _NOEXCEPT {return fmal(__lcpp_x, __lcpp_y, __lcpp_z);}\n\ntemplate <class _A1, class _A2, class _A3>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value &&\n    is_arithmetic<_A3>::value,\n    typename __promote<_A1, _A2, _A3>::type\n>::type\nfma(_A1 __lcpp_x, _A2 __lcpp_y, _A3 __lcpp_z) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2, _A3>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value &&\n                      is_same<_A3, __result_type>::value)), \"\");\n    return fma((__result_type)__lcpp_x, (__result_type)__lcpp_y, (__result_type)__lcpp_z);\n}\n\n// fmax\n\nusing ::fmax;\nusing ::fmaxf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmax(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fmaxf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmax(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fmaxl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nfmax(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return fmax((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// fmin\n\nusing ::fmin;\nusing ::fminf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       fmin(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return fminf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double fmin(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return fminl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nfmin(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return fmin((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// hypot\n\nusing ::hypot;\nusing ::hypotf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       hypot(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return hypotf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double hypot(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return hypotl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nhypot(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return hypot((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// ilogb\n\nusing ::ilogb;\nusing ::ilogbf;\n\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(float __lcpp_x) _NOEXCEPT       {return ilogbf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY int ilogb(long double __lcpp_x) _NOEXCEPT {return ilogbl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, int>::type\nilogb(_A1 __lcpp_x) _NOEXCEPT {return ilogb((double)__lcpp_x);}\n\n// lgamma\n\nusing ::lgamma;\nusing ::lgammaf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       lgamma(float __lcpp_x) _NOEXCEPT       {return lgammaf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double lgamma(long double __lcpp_x) _NOEXCEPT {return lgammal(__lcpp_x);}\n\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlgamma(_A1 __lcpp_x) _NOEXCEPT {return lgamma((double)__lcpp_x);}\n\n\n// llrint\n\nusing ::llrint;\nusing ::llrintf;\n\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(float __lcpp_x) _NOEXCEPT       {return llrintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llrint(long double __lcpp_x) _NOEXCEPT {return llrintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, long long>::type\nllrint(_A1 __lcpp_x) _NOEXCEPT {return llrint((double)__lcpp_x);}\n\n// llround\n\nusing ::llround;\nusing ::llroundf;\n\ninline _LIBCPP_INLINE_VISIBILITY long long llround(float __lcpp_x) _NOEXCEPT       {return llroundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long long llround(long double __lcpp_x) _NOEXCEPT {return llroundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, long long>::type\nllround(_A1 __lcpp_x) _NOEXCEPT {return llround((double)__lcpp_x);}\n\n// log1p\n\nusing ::log1p;\nusing ::log1pf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       log1p(float __lcpp_x) _NOEXCEPT       {return log1pf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log1p(long double __lcpp_x) _NOEXCEPT {return log1pl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlog1p(_A1 __lcpp_x) _NOEXCEPT {return log1p((double)__lcpp_x);}\n\n// log2\n\nusing ::log2;\nusing ::log2f;\n\ninline _LIBCPP_INLINE_VISIBILITY float       log2(float __lcpp_x) _NOEXCEPT       {return log2f(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double log2(long double __lcpp_x) _NOEXCEPT {return log2l(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlog2(_A1 __lcpp_x) _NOEXCEPT {return log2((double)__lcpp_x);}\n\n// logb\n\nusing ::logb;\nusing ::logbf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       logb(float __lcpp_x) _NOEXCEPT       {return logbf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double logb(long double __lcpp_x) _NOEXCEPT {return logbl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nlogb(_A1 __lcpp_x) _NOEXCEPT {return logb((double)__lcpp_x);}\n\n// lrint\n\nusing ::lrint;\nusing ::lrintf;\n\ninline _LIBCPP_INLINE_VISIBILITY long lrint(float __lcpp_x) _NOEXCEPT       {return lrintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long lrint(long double __lcpp_x) _NOEXCEPT {return lrintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, long>::type\nlrint(_A1 __lcpp_x) _NOEXCEPT {return lrint((double)__lcpp_x);}\n\n// lround\n\nusing ::lround;\nusing ::lroundf;\n\ninline _LIBCPP_INLINE_VISIBILITY long lround(float __lcpp_x) _NOEXCEPT       {return lroundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long lround(long double __lcpp_x) _NOEXCEPT {return lroundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, long>::type\nlround(_A1 __lcpp_x) _NOEXCEPT {return lround((double)__lcpp_x);}\n\n#endif // _LIBCPP_MSVCRT\n#endif // __sun__\n\n// nan\n\n#ifndef _LIBCPP_MSVCRT\nusing ::nan;\nusing ::nanf;\n#endif // _LIBCPP_MSVCRT\n\n#ifndef __sun__\n#ifndef _LIBCPP_MSVCRT\n\n// nearbyint\n\nusing ::nearbyint;\nusing ::nearbyintf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       nearbyint(float __lcpp_x) _NOEXCEPT       {return nearbyintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double nearbyint(long double __lcpp_x) _NOEXCEPT {return nearbyintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nnearbyint(_A1 __lcpp_x) _NOEXCEPT {return nearbyint((double)__lcpp_x);}\n\n// nextafter\n\nusing ::nextafter;\nusing ::nextafterf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       nextafter(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return nextafterf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nextafter(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nextafterl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nnextafter(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return nextafter((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// nexttoward\n\nusing ::nexttoward;\nusing ::nexttowardf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       nexttoward(float __lcpp_x, long double __lcpp_y) _NOEXCEPT       {return nexttowardf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double nexttoward(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nexttowardl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nnexttoward(_A1 __lcpp_x, long double __lcpp_y) _NOEXCEPT {return nexttoward((double)__lcpp_x, __lcpp_y);}\n\n// remainder\n\nusing ::remainder;\nusing ::remainderf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       remainder(float __lcpp_x, float __lcpp_y) _NOEXCEPT             {return remainderf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double remainder(long double __lcpp_x, long double __lcpp_y) _NOEXCEPT {return remainderl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nremainder(_A1 __lcpp_x, _A2 __lcpp_y) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return remainder((__result_type)__lcpp_x, (__result_type)__lcpp_y);\n}\n\n// remquo\n\nusing ::remquo;\nusing ::remquof;\n\ninline _LIBCPP_INLINE_VISIBILITY float       remquo(float __lcpp_x, float __lcpp_y, int* __lcpp_z) _NOEXCEPT             {return remquof(__lcpp_x, __lcpp_y, __lcpp_z);}\ninline _LIBCPP_INLINE_VISIBILITY long double remquo(long double __lcpp_x, long double __lcpp_y, int* __lcpp_z) _NOEXCEPT {return remquol(__lcpp_x, __lcpp_y, __lcpp_z);}\n\ntemplate <class _A1, class _A2>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if\n<\n    is_arithmetic<_A1>::value &&\n    is_arithmetic<_A2>::value,\n    typename __promote<_A1, _A2>::type\n>::type\nremquo(_A1 __lcpp_x, _A2 __lcpp_y, int* __lcpp_z) _NOEXCEPT\n{\n    typedef typename __promote<_A1, _A2>::type __result_type;\n    static_assert((!(is_same<_A1, __result_type>::value &&\n                      is_same<_A2, __result_type>::value)), \"\");\n    return remquo((__result_type)__lcpp_x, (__result_type)__lcpp_y, __lcpp_z);\n}\n\n// rint\n\nusing ::rint;\nusing ::rintf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       rint(float __lcpp_x) _NOEXCEPT       {return rintf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double rint(long double __lcpp_x) _NOEXCEPT {return rintl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nrint(_A1 __lcpp_x) _NOEXCEPT {return rint((double)__lcpp_x);}\n\n// round\n\nusing ::round;\nusing ::roundf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       round(float __lcpp_x) _NOEXCEPT       {return roundf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double round(long double __lcpp_x) _NOEXCEPT {return roundl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nround(_A1 __lcpp_x) _NOEXCEPT {return round((double)__lcpp_x);}\n\n// scalbln\n\nusing ::scalbln;\nusing ::scalblnf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbln(float __lcpp_x, long __lcpp_y) _NOEXCEPT       {return scalblnf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbln(long double __lcpp_x, long __lcpp_y) _NOEXCEPT {return scalblnl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nscalbln(_A1 __lcpp_x, long __lcpp_y) _NOEXCEPT {return scalbln((double)__lcpp_x, __lcpp_y);}\n\n// scalbn\n\nusing ::scalbn;\nusing ::scalbnf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       scalbn(float __lcpp_x, int __lcpp_y) _NOEXCEPT       {return scalbnf(__lcpp_x, __lcpp_y);}\ninline _LIBCPP_INLINE_VISIBILITY long double scalbn(long double __lcpp_x, int __lcpp_y) _NOEXCEPT {return scalbnl(__lcpp_x, __lcpp_y);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\nscalbn(_A1 __lcpp_x, int __lcpp_y) _NOEXCEPT {return scalbn((double)__lcpp_x, __lcpp_y);}\n\n// tgamma\n\nusing ::tgamma;\nusing ::tgammaf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       tgamma(float __lcpp_x) _NOEXCEPT       {return tgammaf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double tgamma(long double __lcpp_x) _NOEXCEPT {return tgammal(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ntgamma(_A1 __lcpp_x) _NOEXCEPT {return tgamma((double)__lcpp_x);}\n\n// trunc\n\nusing ::trunc;\nusing ::truncf;\n\ninline _LIBCPP_INLINE_VISIBILITY float       trunc(float __lcpp_x) _NOEXCEPT       {return truncf(__lcpp_x);}\ninline _LIBCPP_INLINE_VISIBILITY long double trunc(long double __lcpp_x) _NOEXCEPT {return truncl(__lcpp_x);}\n\ntemplate <class _A1>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename enable_if<is_integral<_A1>::value, double>::type\ntrunc(_A1 __lcpp_x) _NOEXCEPT {return trunc((double)__lcpp_x);}\n\n#endif // !_LIBCPP_MSVCRT\n\nusing ::acosl;\nusing ::asinl;\nusing ::atanl;\nusing ::atan2l;\nusing ::ceill;\nusing ::cosl;\nusing ::coshl;\nusing ::expl;\nusing ::fabsl;\nusing ::floorl;\nusing ::fmodl;\nusing ::frexpl;\nusing ::ldexpl;\nusing ::logl;\nusing ::log10l;\nusing ::modfl;\nusing ::powl;\nusing ::sinl;\nusing ::sinhl;\nusing ::sqrtl;\nusing ::tanl;\n#ifndef _LIBCPP_MSVCRT\nusing ::tanhl;\nusing ::acoshl;\nusing ::asinhl;\nusing ::atanhl;\nusing ::cbrtl;\n#endif  // !_LIBCPP_MSVCRT\nusing ::copysignl;\n#ifndef _LIBCPP_MSVCRT\nusing ::erfl;\nusing ::erfcl;\nusing ::exp2l;\nusing ::expm1l;\nusing ::fdiml;\nusing ::fmal;\nusing ::fmaxl;\nusing ::fminl;\nusing ::hypotl;\nusing ::ilogbl;\nusing ::lgammal;\nusing ::llrintl;\nusing ::llroundl;\nusing ::log1pl;\nusing ::log2l;\nusing ::logbl;\nusing ::lrintl;\nusing ::lroundl;\nusing ::nanl;\nusing ::nearbyintl;\nusing ::nextafterl;\nusing ::nexttowardl;\nusing ::remainderl;\nusing ::remquol;\nusing ::rintl;\nusing ::roundl;\nusing ::scalblnl;\nusing ::scalbnl;\nusing ::tgammal;\nusing ::truncl;\n#endif // !_LIBCPP_MSVCRT\n\n#else \nusing ::lgamma;\nusing ::lgammaf;\n#endif // __sun__\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_CMATH\n","#pragma once\n\n#include <stdint.h> // uintptr_t\n#include <emscripten/wire.h>\n#include <array>\n#include <vector>\n\n\nnamespace emscripten {\n\n    class val;\n\n    namespace internal {\n\n        template<typename WrapperType>\n        val wrapped_extend(const std::string&, const val&);\n\n        // Implemented in JavaScript.  Don't call these directly.\n        extern \"C\" {\n            void _emval_register_symbol(const char*);\n\n            enum {\n                _EMVAL_UNDEFINED = 1,\n                _EMVAL_NULL = 2,\n                _EMVAL_TRUE = 3,\n                _EMVAL_FALSE = 4\n            };\n\n            typedef struct _EM_VAL* EM_VAL;\n            typedef struct _EM_DESTRUCTORS* EM_DESTRUCTORS;\n            typedef struct _EM_METHOD_CALLER* EM_METHOD_CALLER;\n            typedef double EM_GENERIC_WIRE_TYPE;\n            typedef const void* EM_VAR_ARGS;\n\n            void _emval_incref(EM_VAL value);\n            void _emval_decref(EM_VAL value);\n\n            void _emval_run_destructors(EM_DESTRUCTORS handle);\n\n            EM_VAL _emval_new_array();\n            EM_VAL _emval_new_object();\n            EM_VAL _emval_new_cstring(const char*);\n\n            EM_VAL _emval_take_value(TYPEID type, EM_VAR_ARGS argv);\n\n            EM_VAL _emval_new(\n                EM_VAL value,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                EM_VAR_ARGS argv);\n\n            EM_VAL _emval_get_global(const char* name);\n            EM_VAL _emval_get_module_property(const char* name);\n            EM_VAL _emval_get_property(EM_VAL object, EM_VAL key);\n            void _emval_set_property(EM_VAL object, EM_VAL key, EM_VAL value);\n            EM_GENERIC_WIRE_TYPE _emval_as(EM_VAL value, TYPEID returnType, EM_DESTRUCTORS* destructors);\n\n            bool _emval_equals(EM_VAL first, EM_VAL second);\n            bool _emval_strictly_equals(EM_VAL first, EM_VAL second);\n\n            EM_VAL _emval_call(\n                EM_VAL value,\n                unsigned argCount,\n                const TYPEID argTypes[],\n                EM_VAR_ARGS argv);\n\n            // DO NOT call this more than once per signature. It will\n            // leak generated function objects!\n            EM_METHOD_CALLER _emval_get_method_caller(\n                unsigned argCount, // including return value\n                const TYPEID argTypes[]);\n            EM_GENERIC_WIRE_TYPE _emval_call_method(\n                EM_METHOD_CALLER caller,\n                EM_VAL handle,\n                const char* methodName,\n                EM_DESTRUCTORS* destructors,\n                EM_VAR_ARGS argv);\n            void _emval_call_void_method(\n                EM_METHOD_CALLER caller,\n                EM_VAL handle,\n                const char* methodName,\n                EM_VAR_ARGS argv);\n            EM_VAL _emval_typeof(EM_VAL value);\n        }\n\n        template<const char* address> \n        struct symbol_registrar {\n            symbol_registrar() {\n                internal::_emval_register_symbol(address);\n            }\n        };\n\n        template<typename ReturnType, typename... Args>\n        struct Signature {\n            /*\n            typedef typename BindingType<ReturnType>::WireType (*MethodCaller)(\n                EM_VAL value,\n                const char* methodName,\n                EM_DESTRUCTORS* destructors,\n                typename BindingType<Args>::WireType...);\n            */\n\n            static EM_METHOD_CALLER get_method_caller() {\n                static EM_METHOD_CALLER mc = init_method_caller();\n                return mc;\n            }\n\n        private:\n            static EM_METHOD_CALLER init_method_caller() {\n                WithPolicies<>::ArgTypeList<ReturnType, Args...> args;\n                return _emval_get_method_caller(args.getCount(), args.getTypes());\n            }\n        };\n\n        struct DestructorsRunner {\n        public:\n            explicit DestructorsRunner(EM_DESTRUCTORS d)\n                : destructors(d)\n            {}\n            ~DestructorsRunner() {\n                _emval_run_destructors(destructors);\n            }\n\n            DestructorsRunner(const DestructorsRunner&) = delete;\n            void operator=(const DestructorsRunner&) = delete;\n\n        private:\n            EM_DESTRUCTORS destructors;\n        };\n\n        template<typename WireType>\n        struct GenericWireTypeConverter {\n            static WireType from(double wt) {\n                return static_cast<WireType>(wt);\n            }\n        };\n\n        template<typename Pointee>\n        struct GenericWireTypeConverter<Pointee*> {\n            static Pointee* from(double wt) {\n                return reinterpret_cast<Pointee*>(static_cast<uintptr_t>(wt));\n            }\n        };\n\n        template<typename T>\n        T fromGenericWireType(double g) {\n            typedef typename BindingType<T>::WireType WireType;\n            WireType wt = GenericWireTypeConverter<WireType>::from(g);\n            return BindingType<T>::fromWireType(wt);\n        }\n\n        template<typename... Args>\n        struct PackSize;\n\n        template<>\n        struct PackSize<> {\n            static constexpr size_t value = 0;\n        };\n\n        template<typename Arg, typename... Args>\n        struct PackSize<Arg, Args...> {\n            static constexpr size_t value = (sizeof(typename BindingType<Arg>::WireType) + 7) / 8 + PackSize<Args...>::value;\n        };\n\n        union GenericWireType {\n            union {\n                unsigned u;\n                float f;\n                const void* p;\n            } w[2];\n            double d;\n        };\n        static_assert(sizeof(GenericWireType) == 8, \"GenericWireType must be 8 bytes\");\n        static_assert(alignof(GenericWireType) == 8, \"GenericWireType must be 8-byte-aligned\");\n\n        inline void writeGenericWireType(GenericWireType*& cursor, float wt) {\n            cursor->w[0].f = wt;\n            ++cursor;\n        }\n\n        inline void writeGenericWireType(GenericWireType*& cursor, double wt) {\n            cursor->d = wt;\n            ++cursor;\n        }\n\n        template<typename T>\n        void writeGenericWireType(GenericWireType*& cursor, T* wt) {\n            cursor->w[0].p = wt;\n            ++cursor;\n        }\n\n        template<typename ElementType>\n        inline void writeGenericWireType(GenericWireType*& cursor, const memory_view<ElementType>& wt) {\n            cursor->w[0].u = wt.size;\n            cursor->w[1].p = wt.data;\n            ++cursor;\n        }\n\n        template<typename T>\n        void writeGenericWireType(GenericWireType*& cursor, T wt) {\n            cursor->w[0].u = static_cast<unsigned>(wt);\n            ++cursor;\n        }\n\n        inline void writeGenericWireTypes(GenericWireType*&) {\n        }\n\n        template<typename First, typename... Rest>\n        EMSCRIPTEN_ALWAYS_INLINE void writeGenericWireTypes(GenericWireType*& cursor, First&& first, Rest&&... rest) {\n            writeGenericWireType(cursor, BindingType<First>::toWireType(std::forward<First>(first)));\n            writeGenericWireTypes(cursor, std::forward<Rest>(rest)...);\n        }\n\n        template<typename... Args>\n        struct WireTypePack {\n            WireTypePack(Args&&... args) {\n                GenericWireType* cursor = elements.data();\n                writeGenericWireTypes(cursor, std::forward<Args>(args)...);\n            }\n\n            operator EM_VAR_ARGS() const {\n                return elements.data();\n            }\n\n        private:\n            std::array<GenericWireType, PackSize<Args...>::value> elements;\n        };\n\n        template<typename ReturnType, typename... Args>\n        struct MethodCaller {\n            static ReturnType call(EM_VAL handle, const char* methodName, Args&&... args) {\n                auto caller = Signature<ReturnType, Args...>::get_method_caller();\n\n                WireTypePack<Args...> argv(std::forward<Args>(args)...);\n                EM_DESTRUCTORS destructors;\n                EM_GENERIC_WIRE_TYPE result = _emval_call_method(\n                    caller,\n                    handle,\n                    methodName,\n                    &destructors,\n                    argv);\n                DestructorsRunner rd(destructors);\n                return fromGenericWireType<ReturnType>(result);\n            }\n        };\n\n        template<typename... Args>\n        struct MethodCaller<void, Args...> {\n            static void call(EM_VAL handle, const char* methodName, Args&&... args) {\n                auto caller = Signature<void, Args...>::get_method_caller();\n\n                WireTypePack<Args...> argv(std::forward<Args>(args)...);\n                _emval_call_void_method(\n                    caller,\n                    handle,\n                    methodName,\n                    argv);\n            }\n        };\n    }\n\n#define EMSCRIPTEN_SYMBOL(name)                                         \\\n    static const char name##_symbol[] = #name;                          \\\n    static const ::emscripten::internal::symbol_registrar<name##_symbol> name##_registrar\n\n    class val {\n    public:\n        // missing operators:\n        // * delete\n        // * in\n        // * instanceof\n        // * ! ~ - + ++ --\n        // * * / %\n        // * + -\n        // * << >> >>>\n        // * < <= > >=\n        // * == != === !==\n        // * & ^ | && || ?:\n        //\n        // exposing void, comma, and conditional is unnecessary\n        // same with: = += -= *= /= %= <<= >>= >>>= &= ^= |=\n\n        static val array() {\n            return val(internal::_emval_new_array());\n        }\n\n        static val object() {\n            return val(internal::_emval_new_object());\n        }\n\n        static val undefined() {\n            return val(internal::EM_VAL(internal::_EMVAL_UNDEFINED));\n        }\n\n        static val null() {\n            return val(internal::EM_VAL(internal::_EMVAL_NULL));\n        }\n\n        static val take_ownership(internal::EM_VAL e) {\n            return val(e);\n        }\n\n        static val global(const char* name = 0) {\n            return val(internal::_emval_get_global(name));\n        }\n\n        static val module_property(const char* name) {\n            return val(internal::_emval_get_module_property(name));\n        }\n\n        template<typename T>\n        explicit val(T&& value) {\n            using namespace internal;\n\n            typedef internal::BindingType<T> BT;\n            WireTypePack<T> argv(std::forward<T>(value));\n            handle = _emval_take_value(\n                internal::TypeID<T>::get(),\n                argv);\n        }\n\n        val() = delete;\n\n        explicit val(const char* v)\n            : handle(internal::_emval_new_cstring(v))\n        {}\n\n        val(val&& v)\n            : handle(v.handle)\n        {\n            v.handle = 0;\n        }\n\n        val(const val& v)\n            : handle(v.handle)\n        {\n            internal::_emval_incref(handle);\n        }\n\n        ~val() {\n            internal::_emval_decref(handle);\n        }\n\n        val& operator=(val&& v) {\n            internal::_emval_decref(handle);\n            handle = v.handle;\n            v.handle = 0;\n            return *this;\n        }\n\n        val& operator=(const val& v) {\n            internal::_emval_incref(v.handle);\n            internal::_emval_decref(handle);\n            handle = v.handle;\n            return *this;\n        }\n\n        bool hasOwnProperty(const char* key) const {\n            return val::global(\"Object\")[\"prototype\"][\"hasOwnProperty\"].call<bool>(\"call\", *this, val(key));\n        }\n\n        bool isNull() const {\n            return handle == internal::EM_VAL(internal::_EMVAL_NULL);\n        }\n\n        bool isUndefined() const {\n            return handle == internal::EM_VAL(internal::_EMVAL_UNDEFINED);\n        }\n\n        bool isTrue() const {\n            return handle == internal::EM_VAL(internal::_EMVAL_TRUE);\n        }\n\n        bool isFalse() const {\n            return handle == internal::EM_VAL(internal::_EMVAL_FALSE);\n        }\n\n        bool equals(const val& v) const {\n            return internal::_emval_equals(handle, v.handle);\n        }\n\n        bool strictlyEquals(const val& v) const {\n            return internal::_emval_strictly_equals(handle, v.handle);\n        }\n\n        template<typename... Args>\n        val new_(Args&&... args) const {\n            return internalCall(internal::_emval_new,std::forward<Args>(args)...);\n        }\n\n        template<typename T>\n        val operator[](const T& key) const {\n            return val(internal::_emval_get_property(handle, val(key).handle));\n        }\n\n        template<typename K>\n        void set(const K& key, const val& v) {\n            internal::_emval_set_property(handle, val(key).handle, v.handle);\n        }\n\n        template<typename K, typename V>\n        void set(const K& key, const V& value) {\n            internal::_emval_set_property(handle, val(key).handle, val(value).handle);\n        }\n\n        template<typename... Args>\n        val operator()(Args&&... args) {\n            return internalCall(internal::_emval_call, std::forward<Args>(args)...);\n        }\n\n        template<typename ReturnValue, typename... Args>\n        ReturnValue call(const char* name, Args&&... args) const {\n            using namespace internal;\n\n            return MethodCaller<ReturnValue, Args...>::call(handle, name, std::forward<Args>(args)...);\n        }\n\n        template<typename T>\n        T as() const {\n            using namespace internal;\n\n            typedef BindingType<T> BT;\n\n            EM_DESTRUCTORS destructors;\n            EM_GENERIC_WIRE_TYPE result = _emval_as(\n                handle,\n                TypeID<T>::get(),\n                &destructors);\n            DestructorsRunner dr(destructors);\n            return fromGenericWireType<T>(result);\n        }\n\n        val typeof() const {\n            return val(_emval_typeof(handle));\n        }\n\n    private:\n        // takes ownership, assumes handle already incref'd\n        explicit val(internal::EM_VAL handle)\n            : handle(handle)\n        {}\n\n        template<typename WrapperType>\n        friend val internal::wrapped_extend(const std::string& , const val& );\n\n        internal::EM_VAL __get_handle() const {\n            return handle;\n        }\n\n        template<typename Implementation, typename... Args>\n        val internalCall(Implementation impl, Args&&... args)const {\n            using namespace internal;\n\n            WithPolicies<>::ArgTypeList<Args...> argList;\n            WireTypePack<Args...> argv(std::forward<Args>(args)...);\n            return val(\n                impl(\n                    handle,\n                    argList.getCount(),\n                    argList.getTypes(),\n                    argv));\n        }\n\n        internal::EM_VAL handle;\n\n        friend struct internal::BindingType<val>;\n    };\n\n    namespace internal {\n        template<>\n        struct BindingType<val> {\n            typedef internal::EM_VAL WireType;\n            static WireType toWireType(const val& v) {\n                _emval_incref(v.handle);\n                return v.handle;\n            }\n            static val fromWireType(WireType v) {\n                return val::take_ownership(v);\n            }\n        };\n    }\n\n    template<typename T>\n    std::vector<T> vecFromJSArray(val v) {\n        auto l = v[\"length\"].as<unsigned>();\n\n        std::vector<T> rv;\n        for(unsigned i = 0; i < l; ++i) {\n            rv.push_back(v[i].as<T>());\n        }\n\n        return rv;\n    };\n}\n","///////////////////////////////////////////////////////////////////////////////////\r\n/// OpenGL Mathematics (glm.g-truc.net)\r\n///\r\n/// Copyright (c) 2005 - 2015 G-Truc Creation (www.g-truc.net)\r\n/// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n/// of this software and associated documentation files (the \"Software\"), to deal\r\n/// in the Software without restriction, including without limitation the rights\r\n/// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n/// copies of the Software, and to permit persons to whom the Software is\r\n/// furnished to do so, subject to the following conditions:\r\n/// \r\n/// The above copyright notice and this permission notice shall be included in\r\n/// all copies or substantial portions of the Software.\r\n/// \r\n/// Restrictions:\r\n///\t\tBy making use of the Software for military purposes, you choose to make\r\n///\t\ta Bunny unhappy.\r\n/// \r\n/// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n/// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n/// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n/// THE SOFTWARE.\r\n///\r\n/// @ref core\r\n/// @file glm/detail/type_tvec3.inl\r\n/// @date 2008-08-22 / 2011-06-15\r\n/// @author Christophe Riccio\r\n///////////////////////////////////////////////////////////////////////////////////\r\n\r\nnamespace glm\r\n{\r\n\t// -- Implicit basic constructors --\r\n\r\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS || !defined(GLM_FORCE_NO_CTOR_INIT)\r\n\t\ttemplate <typename T, precision P>\r\n\t\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3()\r\n#\t\t\tifndef GLM_FORCE_NO_CTOR_INIT \r\n\t\t\t\t: x(0), y(0), z(0)\r\n#\t\t\tendif\r\n\t\t{}\r\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\r\n\r\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS\r\n\t\ttemplate <typename T, precision P>\r\n\t\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3(tvec3<T, P> const & v)\r\n\t\t\t: x(v.x), y(v.y), z(v.z)\r\n\t\t{}\r\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <precision Q>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3(tvec3<T, Q> const & v)\r\n\t\t: x(v.x), y(v.y), z(v.z)\r\n\t{}\r\n\r\n\t// -- Explicit basic constructors --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3(ctor)\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3(T const & scalar)\r\n\t\t: x(scalar), y(scalar), z(scalar)\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3(T const & a, T const & b, T const & c)\r\n\t\t: x(a), y(b), z(c)\r\n\t{}\r\n\r\n\t// -- Conversion scalar constructors --\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename A, typename B, typename C>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3(A const & a, B const & b, C const & c) :\r\n\t\tx(static_cast<T>(a)),\r\n\t\ty(static_cast<T>(b)),\r\n\t\tz(static_cast<T>(c))\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename A, typename B, typename C>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3(tvec1<A, P> const & a, tvec1<B, P> const & b, tvec1<C, P> const & c) :\r\n\t\tx(static_cast<T>(a)),\r\n\t\ty(static_cast<T>(b)),\r\n\t\tz(static_cast<T>(c))\r\n\t{}\r\n\r\n\t// -- Conversion vector constructors --\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename A, typename B, precision Q>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3(tvec2<A, Q> const & a, B const & b) :\r\n\t\tx(static_cast<T>(a.x)),\r\n\t\ty(static_cast<T>(a.y)),\r\n\t\tz(static_cast<T>(b))\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename A, typename B, precision Q>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3(tvec2<A, Q> const & a, tvec1<B, Q> const & b) :\r\n\t\tx(static_cast<T>(a.x)),\r\n\t\ty(static_cast<T>(a.y)),\r\n\t\tz(static_cast<T>(b.x))\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename A, typename B, precision Q>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3(A const & a, tvec2<B, Q> const & b) :\r\n\t\tx(static_cast<T>(a)),\r\n\t\ty(static_cast<T>(b.x)),\r\n\t\tz(static_cast<T>(b.y))\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename A, typename B, precision Q>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3(tvec1<A, Q> const & a, tvec2<B, Q> const & b) :\r\n\t\tx(static_cast<T>(a.x)),\r\n\t\ty(static_cast<T>(b.x)),\r\n\t\tz(static_cast<T>(b.y))\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U, precision Q>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3(tvec3<U, Q> const & v) :\r\n\t\tx(static_cast<T>(v.x)),\r\n\t\ty(static_cast<T>(v.y)),\r\n\t\tz(static_cast<T>(v.z))\r\n\t{}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U, precision Q>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P>::tvec3(tvec4<U, Q> const & v) :\r\n\t\tx(static_cast<T>(v.x)),\r\n\t\ty(static_cast<T>(v.y)),\r\n\t\tz(static_cast<T>(v.z))\r\n\t{}\r\n\r\n\t// -- Component accesses --\r\n\r\n#\tifdef GLM_FORCE_SIZE_FUNC\r\n\t\ttemplate <typename T, precision P>\r\n\t\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR typename tvec3<T, P>::size_type tvec3<T, P>::size() const\r\n\t\t{\r\n\t\t\treturn 3;\r\n\t\t}\r\n\r\n\t\ttemplate <typename T, precision P>\r\n\t\tGLM_FUNC_QUALIFIER T & tvec3<T, P>::operator[](typename tvec3<T, P>::size_type i)\r\n\t\t{\r\n\t\t\tassert(i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this));\r\n\t\t\treturn (&x)[i];\r\n\t\t}\r\n\r\n\t\ttemplate <typename T, precision P>\r\n\t\tGLM_FUNC_QUALIFIER T const & tvec3<T, P>::operator[](typename tvec3<T, P>::size_type i) const\r\n\t\t{\r\n\t\t\tassert(i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this));\r\n\t\t\treturn (&x)[i];\r\n\t\t}\r\n#\telse\r\n\t\ttemplate <typename T, precision P>\r\n\t\tGLM_FUNC_QUALIFIER GLM_CONSTEXPR typename tvec3<T, P>::length_type tvec3<T, P>::length() const\r\n\t\t{\r\n\t\t\treturn 3;\r\n\t\t}\r\n\r\n\t\ttemplate <typename T, precision P>\r\n\t\tGLM_FUNC_QUALIFIER T & tvec3<T, P>::operator[](typename tvec3<T, P>::length_type i)\r\n\t\t{\r\n\t\t\tassert(i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this));\r\n\t\t\treturn (&x)[i];\r\n\t\t}\r\n\r\n\t\ttemplate <typename T, precision P>\r\n\t\tGLM_FUNC_QUALIFIER T const & tvec3<T, P>::operator[](typename tvec3<T, P>::length_type i) const\r\n\t\t{\r\n\t\t\tassert(i >= 0 && static_cast<detail::component_count_t>(i) < detail::component_count(*this));\r\n\t\t\treturn (&x)[i];\r\n\t\t}\r\n#\tendif//GLM_FORCE_SIZE_FUNC\r\n\r\n\t// -- Unary arithmetic operators --\r\n\r\n#\tif !GLM_HAS_DEFAULTED_FUNCTIONS\r\n\t\ttemplate <typename T, precision P>\r\n\t\tGLM_FUNC_QUALIFIER tvec3<T, P>& tvec3<T, P>::operator=(tvec3<T, P> const & v)\r\n\t\t{\r\n\t\t\tthis->x = v.x;\r\n\t\t\tthis->y = v.y;\r\n\t\t\tthis->z = v.z;\r\n\t\t\treturn *this;\r\n\t\t}\r\n#\tendif//!GLM_HAS_DEFAULTED_FUNCTIONS\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P>& tvec3<T, P>::operator=(tvec3<U, P> const & v)\r\n\t{\r\n\t\tthis->x = static_cast<T>(v.x);\r\n\t\tthis->y = static_cast<T>(v.y);\r\n\t\tthis->z = static_cast<T>(v.z);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator+=(U scalar)\r\n\t{\r\n\t\tthis->x += static_cast<T>(scalar);\r\n\t\tthis->y += static_cast<T>(scalar);\r\n\t\tthis->z += static_cast<T>(scalar);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator+=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x += static_cast<T>(v.x);\r\n\t\tthis->y += static_cast<T>(v.x);\r\n\t\tthis->z += static_cast<T>(v.x);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator+=(tvec3<U, P> const & v)\r\n\t{\r\n\t\tthis->x += static_cast<T>(v.x);\r\n\t\tthis->y += static_cast<T>(v.y);\r\n\t\tthis->z += static_cast<T>(v.z);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator-=(U scalar)\r\n\t{\r\n\t\tthis->x -= static_cast<T>(scalar);\r\n\t\tthis->y -= static_cast<T>(scalar);\r\n\t\tthis->z -= static_cast<T>(scalar);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator-=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x -= static_cast<T>(v.x);\r\n\t\tthis->y -= static_cast<T>(v.x);\r\n\t\tthis->z -= static_cast<T>(v.x);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator-=(tvec3<U, P> const & v)\r\n\t{\r\n\t\tthis->x -= static_cast<T>(v.x);\r\n\t\tthis->y -= static_cast<T>(v.y);\r\n\t\tthis->z -= static_cast<T>(v.z);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator*=(U scalar)\r\n\t{\r\n\t\tthis->x *= static_cast<T>(scalar);\r\n\t\tthis->y *= static_cast<T>(scalar);\r\n\t\tthis->z *= static_cast<T>(scalar);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator*=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x *= static_cast<T>(v.x);\r\n\t\tthis->y *= static_cast<T>(v.x);\r\n\t\tthis->z *= static_cast<T>(v.x);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator*=(tvec3<U, P> const & v)\r\n\t{\r\n\t\tthis->x *= static_cast<T>(v.x);\r\n\t\tthis->y *= static_cast<T>(v.y);\r\n\t\tthis->z *= static_cast<T>(v.z);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator/=(U v)\r\n\t{\r\n\t\tthis->x /= static_cast<T>(v);\r\n\t\tthis->y /= static_cast<T>(v);\r\n\t\tthis->z /= static_cast<T>(v);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator/=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x /= static_cast<T>(v.x);\r\n\t\tthis->y /= static_cast<T>(v.x);\r\n\t\tthis->z /= static_cast<T>(v.x);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator/=(tvec3<U, P> const & v)\r\n\t{\r\n\t\tthis->x /= static_cast<T>(v.x);\r\n\t\tthis->y /= static_cast<T>(v.y);\r\n\t\tthis->z /= static_cast<T>(v.z);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\t// -- Increment and decrement operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator++()\r\n\t{\r\n\t\t++this->x;\r\n\t\t++this->y;\r\n\t\t++this->z;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator--()\r\n\t{\r\n\t\t--this->x;\r\n\t\t--this->y;\r\n\t\t--this->z;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> tvec3<T, P>::operator++(int)\r\n\t{\r\n\t\ttvec3<T, P> Result(*this);\r\n\t\t++*this;\r\n\t\treturn Result;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> tvec3<T, P>::operator--(int)\r\n\t{\r\n\t\ttvec3<T, P> Result(*this);\r\n\t\t--*this;\r\n\t\treturn Result;\r\n\t}\r\n\r\n\t// -- Unary bit operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator%=(U scalar)\r\n\t{\r\n\t\tthis->x %= scalar;\r\n\t\tthis->y %= scalar;\r\n\t\tthis->z %= scalar;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator%=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x %= v.x;\r\n\t\tthis->y %= v.x;\r\n\t\tthis->z %= v.x;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator%=(tvec3<U, P> const & v)\r\n\t{\r\n\t\tthis->x %= v.x;\r\n\t\tthis->y %= v.y;\r\n\t\tthis->z %= v.z;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator&=(U scalar)\r\n\t{\r\n\t\tthis->x &= scalar;\r\n\t\tthis->y &= scalar;\r\n\t\tthis->z &= scalar;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator&=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x &= v.x;\r\n\t\tthis->y &= v.x;\r\n\t\tthis->z &= v.x;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator&=(tvec3<U, P> const & v)\r\n\t{\r\n\t\tthis->x &= v.x;\r\n\t\tthis->y &= v.y;\r\n\t\tthis->z &= v.z;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator|=(U scalar)\r\n\t{\r\n\t\tthis->x |= scalar;\r\n\t\tthis->y |= scalar;\r\n\t\tthis->z |= scalar;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator|=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x |= v.x;\r\n\t\tthis->y |= v.x;\r\n\t\tthis->z |= v.x;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator|=(tvec3<U, P> const & v)\r\n\t{\r\n\t\tthis->x |= v.x;\r\n\t\tthis->y |= v.y;\r\n\t\tthis->z |= v.z;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator^=(U scalar)\r\n\t{\r\n\t\tthis->x ^= scalar;\r\n\t\tthis->y ^= scalar;\r\n\t\tthis->z ^= scalar;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator^=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x ^= v.x;\r\n\t\tthis->y ^= v.x;\r\n\t\tthis->z ^= v.x;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator^=(tvec3<U, P> const & v)\r\n\t{\r\n\t\tthis->x ^= v.x;\r\n\t\tthis->y ^= v.y;\r\n\t\tthis->z ^= v.z;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator<<=(U scalar)\r\n\t{\r\n\t\tthis->x <<= scalar;\r\n\t\tthis->y <<= scalar;\r\n\t\tthis->z <<= scalar;\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator<<=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x <<= static_cast<T>(v.x);\r\n\t\tthis->y <<= static_cast<T>(v.x);\r\n\t\tthis->z <<= static_cast<T>(v.x);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator<<=(tvec3<U, P> const & v)\r\n\t{\r\n\t\tthis->x <<= static_cast<T>(v.x);\r\n\t\tthis->y <<= static_cast<T>(v.y);\r\n\t\tthis->z <<= static_cast<T>(v.z);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator>>=(U scalar)\r\n\t{\r\n\t\tthis->x >>= static_cast<T>(scalar);\r\n\t\tthis->y >>= static_cast<T>(scalar);\r\n\t\tthis->z >>= static_cast<T>(scalar);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator>>=(tvec1<U, P> const & v)\r\n\t{\r\n\t\tthis->x >>= static_cast<T>(v.x);\r\n\t\tthis->y >>= static_cast<T>(v.x);\r\n\t\tthis->z >>= static_cast<T>(v.x);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\ttemplate <typename U> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> & tvec3<T, P>::operator>>=(tvec3<U, P> const & v)\r\n\t{\r\n\t\tthis->x >>= static_cast<T>(v.x);\r\n\t\tthis->y >>= static_cast<T>(v.y);\r\n\t\tthis->z >>= static_cast<T>(v.z);\r\n\t\treturn *this;\r\n\t}\r\n\r\n\t// -- Unary arithmetic operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator+(tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn v;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator-(tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\t-v.x, \r\n\t\t\t-v.y, \r\n\t\t\t-v.z);\r\n\t}\r\n\r\n\t// -- Binary arithmetic operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator+(tvec3<T, P> const & v, T const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x + scalar,\r\n\t\t\tv.y + scalar,\r\n\t\t\tv.z + scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator+(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x + scalar.x,\r\n\t\t\tv.y + scalar.x,\r\n\t\t\tv.z + scalar.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator+(T const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar + v.x,\r\n\t\t\tscalar + v.y,\r\n\t\t\tscalar + v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator+(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar.x + v.x,\r\n\t\t\tscalar.x + v.y,\r\n\t\t\tscalar.x + v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator+(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv1.x + v2.x,\r\n\t\t\tv1.y + v2.y,\r\n\t\t\tv1.z + v2.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator-(tvec3<T, P> const & v, T const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x - scalar,\r\n\t\t\tv.y - scalar,\r\n\t\t\tv.z - scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator-(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x - scalar.x,\r\n\t\t\tv.y - scalar.x,\r\n\t\t\tv.z - scalar.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator-(T const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar - v.x,\r\n\t\t\tscalar - v.y,\r\n\t\t\tscalar - v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator-(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar.x - v.x,\r\n\t\t\tscalar.x - v.y,\r\n\t\t\tscalar.x - v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator-(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv1.x - v2.x,\r\n\t\t\tv1.y - v2.y,\r\n\t\t\tv1.z - v2.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator*(tvec3<T, P> const & v, T const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x * scalar,\r\n\t\t\tv.y * scalar,\r\n\t\t\tv.z * scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator*(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x * scalar.x,\r\n\t\t\tv.y * scalar.x,\r\n\t\t\tv.z * scalar.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator*(T const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar * v.x,\r\n\t\t\tscalar * v.y,\r\n\t\t\tscalar * v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator*(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar.x * v.x,\r\n\t\t\tscalar.x * v.y,\r\n\t\t\tscalar.x * v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator*(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv1.x * v2.x,\r\n\t\t\tv1.y * v2.y,\r\n\t\t\tv1.z * v2.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator/(tvec3<T, P> const & v, T const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x / scalar,\r\n\t\t\tv.y / scalar,\r\n\t\t\tv.z / scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator/(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x / scalar.x,\r\n\t\t\tv.y / scalar.x,\r\n\t\t\tv.z / scalar.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator/(T const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar / v.x,\r\n\t\t\tscalar / v.y,\r\n\t\t\tscalar / v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator/(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar.x / v.x,\r\n\t\t\tscalar.x / v.y,\r\n\t\t\tscalar.x / v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator/(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv1.x / v2.x,\r\n\t\t\tv1.y / v2.y,\r\n\t\t\tv1.z / v2.z);\r\n\t}\r\n\r\n\t// -- Binary bit operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator%(tvec3<T, P> const & v, T const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x % scalar,\r\n\t\t\tv.y % scalar,\r\n\t\t\tv.z % scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator%(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x % scalar.x,\r\n\t\t\tv.y % scalar.x,\r\n\t\t\tv.z % scalar.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator%(T const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar % v.x,\r\n\t\t\tscalar % v.y,\r\n\t\t\tscalar % v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator%(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar.x % v.x,\r\n\t\t\tscalar.x % v.y,\r\n\t\t\tscalar.x % v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator%(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv1.x % v2.x,\r\n\t\t\tv1.y % v2.y,\r\n\t\t\tv1.z % v2.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator&(tvec3<T, P> const & v, T const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x & scalar,\r\n\t\t\tv.y & scalar,\r\n\t\t\tv.z & scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator&(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x & scalar.x,\r\n\t\t\tv.y & scalar.x,\r\n\t\t\tv.z & scalar.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator&(T const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar & v.x,\r\n\t\t\tscalar & v.y,\r\n\t\t\tscalar & v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator&(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar.x & v.x,\r\n\t\t\tscalar.x & v.y,\r\n\t\t\tscalar.x & v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator&(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv1.x & v2.x,\r\n\t\t\tv1.y & v2.y,\r\n\t\t\tv1.z & v2.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator|(tvec3<T, P> const & v, T const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x | scalar,\r\n\t\t\tv.y | scalar,\r\n\t\t\tv.z | scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator|(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x | scalar.x,\r\n\t\t\tv.y | scalar.x,\r\n\t\t\tv.z | scalar.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator|(T const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar | v.x,\r\n\t\t\tscalar | v.y,\r\n\t\t\tscalar | v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator|(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar.x | v.x,\r\n\t\t\tscalar.x | v.y,\r\n\t\t\tscalar.x | v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator|(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv1.x | v2.x,\r\n\t\t\tv1.y | v2.y,\r\n\t\t\tv1.z | v2.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator^(tvec3<T, P> const & v, T const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x ^ scalar,\r\n\t\t\tv.y ^ scalar,\r\n\t\t\tv.z ^ scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator^(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x ^ scalar.x,\r\n\t\t\tv.y ^ scalar.x,\r\n\t\t\tv.z ^ scalar.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator^(T const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar ^ v.x,\r\n\t\t\tscalar ^ v.y,\r\n\t\t\tscalar ^ v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator^(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar.x ^ v.x,\r\n\t\t\tscalar.x ^ v.y,\r\n\t\t\tscalar.x ^ v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator^(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv1.x ^ v2.x,\r\n\t\t\tv1.y ^ v2.y,\r\n\t\t\tv1.z ^ v2.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator<<(tvec3<T, P> const & v, T const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x << scalar,\r\n\t\t\tv.y << scalar,\r\n\t\t\tv.z << scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator<<(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x << scalar.x,\r\n\t\t\tv.y << scalar.x,\r\n\t\t\tv.z << scalar.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator<<(T const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar << v.x,\r\n\t\t\tscalar << v.y,\r\n\t\t\tscalar << v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator<<(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar.x << v.x,\r\n\t\t\tscalar.x << v.y,\r\n\t\t\tscalar.x << v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator<<(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv1.x << v2.x,\r\n\t\t\tv1.y << v2.y,\r\n\t\t\tv1.z << v2.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator>>(tvec3<T, P> const & v, T const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x >> scalar,\r\n\t\t\tv.y >> scalar,\r\n\t\t\tv.z >> scalar);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator>>(tvec3<T, P> const & v, tvec1<T, P> const & scalar)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv.x >> scalar.x,\r\n\t\t\tv.y >> scalar.x,\r\n\t\t\tv.z >> scalar.x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator>>(T const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar >> v.x,\r\n\t\t\tscalar >> v.y,\r\n\t\t\tscalar >> v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator>>(tvec1<T, P> const & scalar, tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tscalar.x >> v.x,\r\n\t\t\tscalar.x >> v.y,\r\n\t\t\tscalar.x >> v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator>>(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tv1.x >> v2.x,\r\n\t\t\tv1.y >> v2.y,\r\n\t\t\tv1.z >> v2.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P> \r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> operator~(tvec3<T, P> const & v)\r\n\t{\r\n\t\treturn tvec3<T, P>(\r\n\t\t\t~v.x,\r\n\t\t\t~v.y,\r\n\t\t\t~v.z);\r\n\t}\r\n\r\n\t// -- Boolean operators --\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER bool operator==(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\r\n\t{\r\n\t\treturn (v1.x == v2.x) && (v1.y == v2.y) && (v1.z == v2.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER bool operator!=(tvec3<T, P> const & v1, tvec3<T, P> const & v2)\r\n\t{\r\n\t\treturn (v1.x != v2.x) || (v1.y != v2.y) || (v1.z != v2.z);\r\n\t}\r\n}//namespace glm\r\n","#pragma once\n\n// A value moving between JavaScript and C++ has three representations:\n// - The original JS value: a String\n// - The native on-the-wire value: a stack-allocated char*, say\n// - The C++ value: std::string\n//\n// We'll call the on-the-wire type WireType.\n\n#include <stdio.h>\n#include <cstdlib>\n#include <memory>\n#include <string>\n\n#define EMSCRIPTEN_ALWAYS_INLINE __attribute__((always_inline))\n\nnamespace emscripten {\n    #ifndef EMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES\n    #define EMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES 1\n    #endif\n\n\n    #if EMSCRIPTEN_HAS_UNBOUND_TYPE_NAMES\n    constexpr bool has_unbound_type_names = true;\n    #else\n    constexpr bool has_unbound_type_names = false;\n    #endif\n\n    namespace internal {\n        typedef const void* TYPEID;\n\n        // We don't need the full std::type_info implementation.  We\n        // just need a unique identifier per type and polymorphic type\n        // identification.\n        \n        template<typename T>\n        struct CanonicalizedID {\n            static char c;\n            static constexpr TYPEID get() {\n                return &c;\n            }\n        };\n\n        template<typename T>\n        char CanonicalizedID<T>::c;\n\n        template<typename T>\n        struct Canonicalized {\n            typedef typename std::remove_cv<typename std::remove_reference<T>::type>::type type;\n        };\n\n        template<typename T>\n        struct LightTypeID {\n            static constexpr TYPEID get() {\n                typedef typename Canonicalized<T>::type C;\n                return (has_unbound_type_names || std::is_polymorphic<C>::value)\n                    ? &typeid(C)\n                    : CanonicalizedID<C>::get();\n            }\n        };\n\n        template<typename T>\n        constexpr TYPEID getLightTypeID(const T& value) {\n            typedef typename Canonicalized<T>::type C;\n            return (has_unbound_type_names || std::is_polymorphic<C>::value)\n                ? &typeid(value)\n                : LightTypeID<T>::get();\n        }\n\n        template<typename T>\n        struct TypeID {\n            static constexpr TYPEID get() {\n                return LightTypeID<T>::get();\n            }\n        };\n\n        template<typename T>\n        struct TypeID<std::unique_ptr<T>> {\n            static constexpr TYPEID get() {\n                return TypeID<T>::get();\n            }\n        };\n\n        template<typename T>\n        struct TypeID<T*> {\n            static_assert(!std::is_pointer<T*>::value, \"Implicitly binding raw pointers is illegal.  Specify allow_raw_pointer<arg<?>>\");\n        };\n\n        template<typename T>\n        struct AllowedRawPointer {\n        };\n\n        template<typename T>\n        struct TypeID<AllowedRawPointer<T>> {\n            static constexpr TYPEID get() {\n                return LightTypeID<T*>::get();\n            }\n        };\n        \n        // ExecutePolicies<>\n\n        template<typename... Policies>\n        struct ExecutePolicies;\n\n        template<>\n        struct ExecutePolicies<> {\n            template<typename T, int Index>\n            struct With {\n                typedef T type;\n            };\n        };\n        \n        template<typename Policy, typename... Remaining>\n        struct ExecutePolicies<Policy, Remaining...> {\n            template<typename T, int Index>\n            struct With {\n                typedef typename Policy::template Transform<\n                    typename ExecutePolicies<Remaining...>::template With<T, Index>::type,\n                    Index\n                >::type type;\n            };\n        };\n\n        // TypeList<>\n\n        template<typename...>\n        struct TypeList {};\n\n        // Cons :: T, TypeList<types...> -> Cons<T, types...>\n\n        template<typename First, typename TypeList>\n        struct Cons;\n\n        template<typename First, typename... Rest>\n        struct Cons<First, TypeList<Rest...>> {\n            typedef TypeList<First, Rest...> type;\n        };\n\n        // Apply :: T, TypeList<types...> -> T<types...>\n\n        template<template<typename...> class Output, typename TypeList>\n        struct Apply;\n\n        template<template<typename...> class Output, typename... Types>\n        struct Apply<Output, TypeList<Types...>> {\n            typedef Output<Types...> type;\n        };\n\n        // MapWithIndex_\n\n        template<template<size_t, typename> class Mapper, size_t CurrentIndex, typename... Args>\n        struct MapWithIndex_;\n\n        template<template<size_t, typename> class Mapper, size_t CurrentIndex, typename First, typename... Rest>\n        struct MapWithIndex_<Mapper, CurrentIndex, First, Rest...> {\n            typedef typename Cons<\n                typename Mapper<CurrentIndex, First>::type,\n                typename MapWithIndex_<Mapper, CurrentIndex + 1, Rest...>::type\n                >::type type;\n        };\n\n        template<template<size_t, typename> class Mapper, size_t CurrentIndex>\n        struct MapWithIndex_<Mapper, CurrentIndex> {\n            typedef TypeList<> type;\n        };\n\n        template<template<typename...> class Output, template<size_t, typename> class Mapper, typename... Args>\n        struct MapWithIndex {\n            typedef typename internal::Apply<\n                Output,\n                typename MapWithIndex_<Mapper, 0, Args...>::type\n            >::type type;\n        };\n\n\n        template<typename ArgList>\n        struct ArgArrayGetter;\n\n        template<typename... Args>\n        struct ArgArrayGetter<TypeList<Args...>> {\n            static const TYPEID* get() {\n                static constexpr TYPEID types[] = { TypeID<Args>::get()... };\n                return types;\n            }\n        };\n\n        // WithPolicies<...>::ArgTypeList<...>\n\n        template<typename... Policies>\n        struct WithPolicies {\n            template<size_t Index, typename T>\n            struct MapWithPolicies {\n                typedef typename ExecutePolicies<Policies...>::template With<T, Index>::type type;\n            };\n\n            template<typename... Args>\n            struct ArgTypeList {\n                unsigned getCount() const {\n                    return sizeof...(Args);\n                }\n\n                const TYPEID* getTypes() const {\n                    return ArgArrayGetter<\n                        typename MapWithIndex<TypeList, MapWithPolicies, Args...>::type\n                    >::get();\n                }\n            };\n        };\n\n        // BindingType<T>\n\n        template<typename T>\n        struct BindingType;\n\n#define EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(type)                 \\\n        template<>                                                  \\\n        struct BindingType<type> {                                  \\\n            typedef type WireType;                                  \\\n            constexpr static WireType toWireType(const type& v) {   \\\n                return v;                                           \\\n            }                                                       \\\n            constexpr static type fromWireType(WireType v) {        \\\n                return v;                                           \\\n            }                                                       \\\n        }\n\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(char);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed char);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned char);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed short);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned short);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed int);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned int);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(signed long);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(unsigned long);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(float);\n        EMSCRIPTEN_DEFINE_NATIVE_BINDING_TYPE(double);\n\n        template<>\n        struct BindingType<void> {\n            typedef void WireType;\n        };\n\n        template<>\n        struct BindingType<bool> {\n            typedef bool WireType;\n            static WireType toWireType(bool b) {\n                return b;\n            }\n            static bool fromWireType(WireType wt) {\n                return wt;\n            }\n        };\n\n        template<>\n        struct BindingType<std::string> {\n            typedef struct {\n                size_t length;\n                char data[1]; // trailing data\n            }* WireType;\n            static WireType toWireType(const std::string& v) {\n                WireType wt = (WireType)malloc(sizeof(size_t) + v.length());\n                wt->length = v.length();\n                memcpy(wt->data, v.data(), v.length());\n                return wt;\n            }\n            static std::string fromWireType(WireType v) {\n                return std::string(v->data, v->length);\n            }\n        };\n\n        template<>\n        struct BindingType<std::wstring> {\n            typedef struct {\n                size_t length;\n                wchar_t data[1]; // trailing data\n            }* WireType;\n            static WireType toWireType(const std::wstring& v) {\n                WireType wt = (WireType)malloc(sizeof(size_t) + v.length() * sizeof(wchar_t));\n                wt->length = v.length();\n                wmemcpy(wt->data, v.data(), v.length());\n                return wt;\n            }\n            static std::wstring fromWireType(WireType v) {\n                return std::wstring(v->data, v->length);\n            }\n        };\n\n        template<typename T>\n        struct BindingType<const T> : public BindingType<T> {\n        };\n\n        template<typename T>\n        struct BindingType<T&> : public BindingType<T> {\n        };\n\n        template<typename T>\n        struct BindingType<const T&> : public BindingType<T> {\n        };\n\n        template<typename T>\n        struct BindingType<T&&> {\n            typedef typename BindingType<T>::WireType WireType;\n            static WireType toWireType(const T& v) {\n                return BindingType<T>::toWireType(v);\n            }\n            static T fromWireType(WireType wt) {\n                return BindingType<T>::fromWireType(wt);\n            }\n        };\n\n        template<typename T>\n        struct BindingType<T*> {\n            typedef T* WireType;\n            static WireType toWireType(T* p) {\n                return p;\n            }\n            static T* fromWireType(WireType wt) {\n                return wt;\n            }\n        };\n\n        template<typename T>\n        struct GenericBindingType {\n            typedef typename std::remove_reference<T>::type ActualT;\n            typedef ActualT* WireType;\n\n            static WireType toWireType(const T& v) {\n                return new T(v);\n            }\n\n            static WireType toWireType(T&& v) {\n                return new T(std::forward<T>(v));\n            }\n\n            static ActualT& fromWireType(WireType p) {\n                return *p;\n            }\n        };\n\n        template<typename T>\n        struct GenericBindingType<std::unique_ptr<T>> {\n            typedef typename BindingType<T*>::WireType WireType;\n\n            static WireType toWireType(std::unique_ptr<T> p) {\n                return BindingType<T*>::toWireType(p.release());\n            }\n\n            static std::unique_ptr<T> fromWireType(WireType wt) {\n                return std::unique_ptr<T>(BindingType<T*>::fromWireType(wt));\n            }\n        };\n\n        template<typename Enum>\n        struct EnumBindingType {\n            typedef Enum WireType;\n\n            static WireType toWireType(Enum v) {\n                return v;\n            }\n            static Enum fromWireType(WireType v) {\n                return v;\n            }\n        };\n\n        // catch-all generic binding\n        template<typename T>\n        struct BindingType : std::conditional<\n            std::is_enum<T>::value,\n            EnumBindingType<T>,\n            GenericBindingType<T> >::type\n        {};\n\n        template<typename T>\n        auto toWireType(T&& v) -> typename BindingType<T>::WireType {\n            return BindingType<T>::toWireType(std::forward<T>(v));\n        }\n    }\n\n    template<typename ElementType>\n    struct memory_view {\n        memory_view() = delete;\n        explicit memory_view(size_t size, const ElementType* data)\n            : size(size)\n            , data(data)\n        {}\n\n        const size_t size; // in elements, not bytes\n        const void* const data;\n    };\n\n    // Note that 'data' is marked const just so it can accept both\n    // const and nonconst pointers.  It is certainly possible for\n    // JavaScript to modify the C heap through the typed array given,\n    // as it merely aliases the C heap.\n    template<typename T>\n    inline memory_view<T> typed_memory_view(size_t size, const T* data) {\n        return memory_view<T>(size, data);\n    }\n\n    namespace internal {\n        template<typename ElementType>\n        struct BindingType<memory_view<ElementType>> {\n            // This non-word-sized WireType only works because I\n            // happen to know that clang will pass aggregates as\n            // pointers to stack elements and we never support\n            // converting JavaScript typed arrays back into\n            // memory_view.  (That is, fromWireType is not implemented\n            // on the C++ side, nor is toWireType implemented in\n            // JavaScript.)\n            typedef memory_view<ElementType> WireType;\n            static WireType toWireType(const memory_view<ElementType>& mv) {\n                return mv;\n            }\n        };\n    }\n}\n","// -*- C++ -*-\n//===-------------------------- locale ------------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_LOCALE\n#define _LIBCPP_LOCALE\n\n/*\n    locale synopsis\n\nnamespace std\n{\n\nclass locale\n{\npublic:\n    // types:\n    class facet;\n    class id;\n\n    typedef int category;\n    static const category // values assigned here are for exposition only\n        none     = 0x000,\n        collate  = 0x010,\n        ctype    = 0x020,\n        monetary = 0x040,\n        numeric  = 0x080,\n        time     = 0x100,\n        messages = 0x200,\n        all = collate | ctype | monetary | numeric | time | messages;\n\n    // construct/copy/destroy:\n    locale() noexcept;\n    locale(const locale& other) noexcept;\n    explicit locale(const char* std_name);\n    explicit locale(const string& std_name);\n    locale(const locale& other, const char* std_name, category);\n    locale(const locale& other, const string& std_name, category);\n    template <class Facet> locale(const locale& other, Facet* f);\n    locale(const locale& other, const locale& one, category);\n\n    ~locale(); // not virtual\n\n    const locale& operator=(const locale& other) noexcept;\n\n    template <class Facet> locale combine(const locale& other) const;\n\n    // locale operations:\n    basic_string<char> name() const;\n    bool operator==(const locale& other) const;\n    bool operator!=(const locale& other) const;\n    template <class charT, class Traits, class Allocator>\n      bool operator()(const basic_string<charT,Traits,Allocator>& s1,\n                      const basic_string<charT,Traits,Allocator>& s2) const;\n\n    // global locale objects:\n    static locale global(const locale&);\n    static const locale& classic();\n};\n\ntemplate <class Facet> const Facet& use_facet(const locale&);\ntemplate <class Facet> bool has_facet(const locale&) noexcept;\n\n// 22.3.3, convenience interfaces:\ntemplate <class charT> bool isspace (charT c, const locale& loc);\ntemplate <class charT> bool isprint (charT c, const locale& loc);\ntemplate <class charT> bool iscntrl (charT c, const locale& loc);\ntemplate <class charT> bool isupper (charT c, const locale& loc);\ntemplate <class charT> bool islower (charT c, const locale& loc);\ntemplate <class charT> bool isalpha (charT c, const locale& loc);\ntemplate <class charT> bool isdigit (charT c, const locale& loc);\ntemplate <class charT> bool ispunct (charT c, const locale& loc);\ntemplate <class charT> bool isxdigit(charT c, const locale& loc);\ntemplate <class charT> bool isalnum (charT c, const locale& loc);\ntemplate <class charT> bool isgraph (charT c, const locale& loc);\ntemplate <class charT> charT toupper(charT c, const locale& loc);\ntemplate <class charT> charT tolower(charT c, const locale& loc);\n\ntemplate<class Codecvt, class Elem = wchar_t,\n         class Wide_alloc = allocator<Elem>,\n         class Byte_alloc = allocator<char>>\nclass wstring_convert\n{\npublic:\n    typedef basic_string<char, char_traits<char>, Byte_alloc> byte_string;\n    typedef basic_string<Elem, char_traits<Elem>, Wide_alloc> wide_string;\n    typedef typename Codecvt::state_type                      state_type;\n    typedef typename wide_string::traits_type::int_type       int_type;\n\n    explicit wstring_convert(Codecvt* pcvt = new Codecvt);          // explicit in C++14\n    wstring_convert(Codecvt* pcvt, state_type state);\n    explicit wstring_convert(const byte_string& byte_err,           // explicit in C++14\n                    const wide_string& wide_err = wide_string());\n    wstring_convert(const wstring_convert&) = delete;               // C++14\n    wstring_convert & operator=(const wstring_convert &) = delete;  // C++14\n    ~wstring_convert();\n\n    wide_string from_bytes(char byte);\n    wide_string from_bytes(const char* ptr);\n    wide_string from_bytes(const byte_string& str);\n    wide_string from_bytes(const char* first, const char* last);\n\n    byte_string to_bytes(Elem wchar);\n    byte_string to_bytes(const Elem* wptr);\n    byte_string to_bytes(const wide_string& wstr);\n    byte_string to_bytes(const Elem* first, const Elem* last);\n\n    size_t converted() const; // noexcept in C++14\n    state_type state() const;\n};\n\ntemplate <class Codecvt, class Elem = wchar_t, class Tr = char_traits<Elem>>\nclass wbuffer_convert\n    : public basic_streambuf<Elem, Tr>\n{\npublic:\n    typedef typename Tr::state_type state_type;\n\n    explicit wbuffer_convert(streambuf* bytebuf = 0, Codecvt* pcvt = new Codecvt,\n                    state_type state = state_type());       // explicit in C++14\n    wbuffer_convert(const wbuffer_convert&) = delete;               // C++14\n    wbuffer_convert & operator=(const wbuffer_convert &) = delete;  // C++14\n    ~wbuffer_convert();                                             // C++14\n    \n    streambuf* rdbuf() const;\n    streambuf* rdbuf(streambuf* bytebuf);\n\n    state_type state() const;\n};\n\n// 22.4.1 and 22.4.1.3, ctype:\nclass ctype_base;\ntemplate <class charT> class ctype;\ntemplate <> class ctype<char>; // specialization\ntemplate <class charT> class ctype_byname;\ntemplate <> class ctype_byname<char>; // specialization\n\nclass codecvt_base;\ntemplate <class internT, class externT, class stateT> class codecvt;\ntemplate <class internT, class externT, class stateT> class codecvt_byname;\n\n// 22.4.2 and 22.4.3, numeric:\ntemplate <class charT, class InputIterator> class num_get;\ntemplate <class charT, class OutputIterator> class num_put;\ntemplate <class charT> class numpunct;\ntemplate <class charT> class numpunct_byname;\n\n// 22.4.4, col lation:\ntemplate <class charT> class collate;\ntemplate <class charT> class collate_byname;\n\n// 22.4.5, date and time:\nclass time_base;\ntemplate <class charT, class InputIterator> class time_get;\ntemplate <class charT, class InputIterator> class time_get_byname;\ntemplate <class charT, class OutputIterator> class time_put;\ntemplate <class charT, class OutputIterator> class time_put_byname;\n\n// 22.4.6, money:\nclass money_base;\ntemplate <class charT, class InputIterator> class money_get;\ntemplate <class charT, class OutputIterator> class money_put;\ntemplate <class charT, bool Intl> class moneypunct;\ntemplate <class charT, bool Intl> class moneypunct_byname;\n\n// 22.4.7, message retrieval:\nclass messages_base;\ntemplate <class charT> class messages;\ntemplate <class charT> class messages_byname;\n\n}  // std\n\n*/\n\n#include <__config>\n#include <__locale>\n#include <algorithm>\n#include <memory>\n#include <ios>\n#include <streambuf>\n#include <iterator>\n#include <limits>\n#ifndef __APPLE__\n#include <cstdarg>\n#endif\n#include <cstdlib>\n#include <ctime>\n#if defined(_LIBCPP_MSVCRT) || defined(__MINGW32__)\n#include <support/win32/locale_win32.h>\n#elif defined(_NEWLIB_VERSION)\n// FIXME: replace all the uses of _NEWLIB_VERSION with __NEWLIB__ preceded by an\n// include of <sys/cdefs.h> once https://sourceware.org/ml/newlib-cvs/2014-q3/msg00038.html\n// has had a chance to bake for a bit\n#include <support/newlib/xlocale.h>\n#elif !defined(__ANDROID__)\n#include <nl_types.h>\n#endif\n\n#ifdef __APPLE__\n#include <Availability.h>\n#endif\n\n#include <__undef_min_max>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n#if defined(__APPLE__) || defined(__FreeBSD__)\n#  define _LIBCPP_GET_C_LOCALE 0\n#elif defined(__NetBSD__)\n#  define _LIBCPP_GET_C_LOCALE LC_C_LOCALE\n#else\n#  define _LIBCPP_GET_C_LOCALE __cloc()\n   // Get the C locale object\n   _LIBCPP_FUNC_VIS locale_t __cloc();\n#define __cloc_defined\n#endif\n\ntypedef _VSTD::remove_pointer<locale_t>::type __locale_struct;\ntypedef _VSTD::unique_ptr<__locale_struct, decltype(&freelocale)> __locale_unique_ptr;\n#ifndef _LIBCPP_LOCALE__L_EXTENSIONS\ntypedef _VSTD::unique_ptr<__locale_struct, decltype(&uselocale)> __locale_raii;\n#endif\n\n// OSX has nice foo_l() functions that let you turn off use of the global\n// locale.  Linux, not so much.  The following functions avoid the locale when\n// that's possible and otherwise do the wrong thing.  FIXME.\n#if defined(__linux__) || defined(__EMSCRIPTEN__) || defined(_AIX) || \\\n    defined(_NEWLIB_VERSION)\n\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\ndecltype(MB_CUR_MAX_L(_VSTD::declval<locale_t>()))\ninline _LIBCPP_INLINE_VISIBILITY\n__mb_cur_max_l(locale_t __l)\n{\n  return MB_CUR_MAX_L(__l);\n}\n#else  // _LIBCPP_LOCALE__L_EXTENSIONS\ninline _LIBCPP_ALWAYS_INLINE\ndecltype(MB_CUR_MAX) __mb_cur_max_l(locale_t __l)\n{\n  __locale_raii __current(uselocale(__l), uselocale);\n  return MB_CUR_MAX;\n}\n#endif // _LIBCPP_LOCALE__L_EXTENSIONS\n\ninline _LIBCPP_ALWAYS_INLINE\nwint_t __btowc_l(int __c, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return btowc_l(__c, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return btowc(__c);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nint __wctob_l(wint_t __c, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return wctob_l(__c, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return wctob(__c);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __wcsnrtombs_l(char *__dest, const wchar_t **__src, size_t __nwc,\n                      size_t __len, mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return wcsnrtombs_l(__dest, __src, __nwc, __len, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return wcsnrtombs(__dest, __src, __nwc, __len, __ps);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __wcrtomb_l(char *__s, wchar_t __wc, mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return wcrtomb_l(__s, __wc, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return wcrtomb(__s, __wc, __ps);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __mbsnrtowcs_l(wchar_t * __dest, const char **__src, size_t __nms,\n                      size_t __len, mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbsnrtowcs_l(__dest, __src, __nms, __len, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbsnrtowcs(__dest, __src, __nms, __len, __ps);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __mbrtowc_l(wchar_t *__pwc, const char *__s, size_t __n,\n                   mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbrtowc_l(__pwc, __s, __n, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbrtowc(__pwc, __s, __n, __ps);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nint __mbtowc_l(wchar_t *__pwc, const char *__pmb, size_t __max, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbtowc_l(__pwc, __pmb, __max, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbtowc(__pwc, __pmb, __max);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __mbrlen_l(const char *__s, size_t __n, mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbrlen_l(__s, __n, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbrlen(__s, __n, __ps);\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nlconv *__localeconv_l(locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return localeconv_l(__l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return localeconv();\n#endif\n}\n\ninline _LIBCPP_ALWAYS_INLINE\nsize_t __mbsrtowcs_l(wchar_t *__dest, const char **__src, size_t __len,\n                     mbstate_t *__ps, locale_t __l)\n{\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  return mbsrtowcs_l(__dest, __src, __len, __ps, __l);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  return mbsrtowcs(__dest, __src, __len, __ps);\n#endif\n}\n\ninline\nint __snprintf_l(char *__s, size_t __n, locale_t __l, const char *__format, ...) {\n  va_list __va;\n  va_start(__va, __format);\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  int __res = vsnprintf_l(__s, __n, __l, __format, __va);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  int __res = vsnprintf(__s, __n, __format, __va);\n#endif\n  va_end(__va);\n  return __res;\n}\n\ninline\nint __asprintf_l(char **__s, locale_t __l, const char *__format, ...) {\n  va_list __va;\n  va_start(__va, __format);\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  int __res = vasprintf_l(__s, __l, __format, __va);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  int __res = vasprintf(__s, __format, __va);\n#endif\n  va_end(__va);\n  return __res;\n}\n\ninline\nint __sscanf_l(const char *__s, locale_t __l, const char *__format, ...) {\n  va_list __va;\n  va_start(__va, __format);\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n  int __res = vsscanf_l(__s, __l, __format, __va);\n#else\n  __locale_raii __current(uselocale(__l), uselocale);\n  int __res = vsscanf(__s, __format, __va);\n#endif\n  va_end(__va);\n  return __res;\n}\n\n#endif  // __linux__\n\n// __scan_keyword\n// Scans [__b, __e) until a match is found in the basic_strings range\n//  [__kb, __ke) or until it can be shown that there is no match in [__kb, __ke).\n//  __b will be incremented (visibly), consuming CharT until a match is found\n//  or proved to not exist.  A keyword may be \"\", in which will match anything.\n//  If one keyword is a prefix of another, and the next CharT in the input\n//  might match another keyword, the algorithm will attempt to find the longest\n//  matching keyword.  If the longer matching keyword ends up not matching, then\n//  no keyword match is found.  If no keyword match is found, __ke is returned\n//  and failbit is set in __err.\n//  Else an iterator pointing to the matching keyword is found.  If more than\n//  one keyword matches, an iterator to the first matching keyword is returned.\n//  If on exit __b == __e, eofbit is set in __err.  If __case_sensitive is false,\n//  __ct is used to force to lower case before comparing characters.\n//  Examples:\n//  Keywords:  \"a\", \"abb\"\n//  If the input is \"a\", the first keyword matches and eofbit is set.\n//  If the input is \"abc\", no match is found and \"ab\" are consumed.\ntemplate <class _InputIterator, class _ForwardIterator, class _Ctype>\n_LIBCPP_HIDDEN\n_ForwardIterator\n__scan_keyword(_InputIterator& __b, _InputIterator __e,\n               _ForwardIterator __kb, _ForwardIterator __ke,\n               const _Ctype& __ct, ios_base::iostate& __err,\n               bool __case_sensitive = true)\n{\n    typedef typename iterator_traits<_InputIterator>::value_type _CharT;\n    size_t __nkw = static_cast<size_t>(_VSTD::distance(__kb, __ke));\n    const unsigned char __doesnt_match = '\\0';\n    const unsigned char __might_match = '\\1';\n    const unsigned char __does_match = '\\2';\n    unsigned char __statbuf[100];\n    unsigned char* __status = __statbuf;\n    unique_ptr<unsigned char, void(*)(void*)> __stat_hold(0, free);\n    if (__nkw > sizeof(__statbuf))\n    {\n        __status = (unsigned char*)malloc(__nkw);\n        if (__status == 0)\n            __throw_bad_alloc();\n        __stat_hold.reset(__status);\n    }\n    size_t __n_might_match = __nkw;  // At this point, any keyword might match\n    size_t __n_does_match = 0;       // but none of them definitely do\n    // Initialize all statuses to __might_match, except for \"\" keywords are __does_match\n    unsigned char* __st = __status;\n    for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, ++__st)\n    {\n        if (!__ky->empty())\n            *__st = __might_match;\n        else\n        {\n            *__st = __does_match;\n            --__n_might_match;\n            ++__n_does_match;\n        }\n    }\n    // While there might be a match, test keywords against the next CharT\n    for (size_t __indx = 0; __b != __e && __n_might_match > 0; ++__indx)\n    {\n        // Peek at the next CharT but don't consume it\n        _CharT __c = *__b;\n        if (!__case_sensitive)\n            __c = __ct.toupper(__c);\n        bool __consume = false;\n        // For each keyword which might match, see if the __indx character is __c\n        // If a match if found, consume __c\n        // If a match is found, and that is the last character in the keyword,\n        //    then that keyword matches.\n        // If the keyword doesn't match this character, then change the keyword\n        //    to doesn't match\n        __st = __status;\n        for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, ++__st)\n        {\n            if (*__st == __might_match)\n            {\n                _CharT __kc = (*__ky)[__indx];\n                if (!__case_sensitive)\n                    __kc = __ct.toupper(__kc);\n                if (__c == __kc)\n                {\n                    __consume = true;\n                    if (__ky->size() == __indx+1)\n                    {\n                        *__st = __does_match;\n                        --__n_might_match;\n                        ++__n_does_match;\n                    }\n                }\n                else\n                {\n                    *__st = __doesnt_match;\n                    --__n_might_match;\n                }\n            }\n        }\n        // consume if we matched a character\n        if (__consume)\n        {\n            ++__b;\n            // If we consumed a character and there might be a matched keyword that\n            //   was marked matched on a previous iteration, then such keywords\n            //   which are now marked as not matching.\n            if (__n_might_match + __n_does_match > 1)\n            {\n                __st = __status;\n                for (_ForwardIterator __ky = __kb; __ky != __ke; ++__ky, ++__st)\n                {\n                    if (*__st == __does_match && __ky->size() != __indx+1)\n                    {\n                        *__st = __doesnt_match;\n                        --__n_does_match;\n                    }\n                }\n            }\n        }\n    }\n    // We've exited the loop because we hit eof and/or we have no more \"might matches\".\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    // Return the first matching result\n    for (__st = __status; __kb != __ke; ++__kb, ++__st)\n        if (*__st == __does_match)\n            break;\n    if (__kb == __ke)\n        __err |= ios_base::failbit;\n    return __kb;\n}\n\nstruct _LIBCPP_TYPE_VIS __num_get_base\n{\n    static const int __num_get_buf_sz = 40;\n\n    static int __get_base(ios_base&);\n    static const char __src[33];\n};\n\n_LIBCPP_FUNC_VIS\nvoid __check_grouping(const string& __grouping, unsigned* __g, unsigned* __g_end,\n                      ios_base::iostate& __err);\n\ntemplate <class _CharT>\nstruct __num_get\n    : protected __num_get_base\n{\n    static string __stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep);\n    static string __stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,\n                                      _CharT& __thousands_sep);\n    static int __stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,\n                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,\n                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms);\n    static int __stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp,\n                                   char* __a, char*& __a_end,\n                                   _CharT __decimal_point, _CharT __thousands_sep,\n                                   const string& __grouping, unsigned* __g,\n                                   unsigned*& __g_end, unsigned& __dc, _CharT* __atoms);\n};\n\ntemplate <class _CharT>\nstring\n__num_get<_CharT>::__stage2_int_prep(ios_base& __iob, _CharT* __atoms, _CharT& __thousands_sep)\n{\n    locale __loc = __iob.getloc();\n    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 26, __atoms);\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n    __thousands_sep = __np.thousands_sep();\n    return __np.grouping();\n}\n\ntemplate <class _CharT>\nstring\n__num_get<_CharT>::__stage2_float_prep(ios_base& __iob, _CharT* __atoms, _CharT& __decimal_point,\n                    _CharT& __thousands_sep)\n{\n    locale __loc = __iob.getloc();\n    use_facet<ctype<_CharT> >(__loc).widen(__src, __src + 32, __atoms);\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__loc);\n    __decimal_point = __np.decimal_point();\n    __thousands_sep = __np.thousands_sep();\n    return __np.grouping();\n}\n\ntemplate <class _CharT>\nint\n__num_get<_CharT>::__stage2_int_loop(_CharT __ct, int __base, char* __a, char*& __a_end,\n                  unsigned& __dc, _CharT __thousands_sep, const string& __grouping,\n                  unsigned* __g, unsigned*& __g_end, _CharT* __atoms)\n{\n    if (__a_end == __a && (__ct == __atoms[24] || __ct == __atoms[25]))\n    {\n        *__a_end++ = __ct == __atoms[24] ? '+' : '-';\n        __dc = 0;\n        return 0;\n    }\n    if (__grouping.size() != 0 && __ct == __thousands_sep)\n    {\n        if (__g_end-__g < __num_get_buf_sz)\n        {\n            *__g_end++ = __dc;\n            __dc = 0;\n        }\n        return 0;\n    }\n    ptrdiff_t __f = find(__atoms, __atoms + 26, __ct) - __atoms;\n    if (__f >= 24)\n        return -1;\n    switch (__base)\n    {\n    case 8:\n    case 10:\n        if (__f >= __base)\n            return -1;\n        break;\n    case 16:\n        if (__f < 22)\n            break;\n        if (__a_end != __a && __a_end - __a <= 2 && __a_end[-1] == '0')\n        {\n            __dc = 0;\n            *__a_end++ = __src[__f];\n            return 0;\n        }\n        return -1;\n    }\n    *__a_end++ = __src[__f];\n    ++__dc;\n    return 0;\n}\n\ntemplate <class _CharT>\nint\n__num_get<_CharT>::__stage2_float_loop(_CharT __ct, bool& __in_units, char& __exp, char* __a, char*& __a_end,\n                    _CharT __decimal_point, _CharT __thousands_sep, const string& __grouping,\n                    unsigned* __g, unsigned*& __g_end, unsigned& __dc, _CharT* __atoms)\n{\n    if (__ct == __decimal_point)\n    {\n        if (!__in_units)\n            return -1;\n        __in_units = false;\n        *__a_end++ = '.';\n        if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)\n            *__g_end++ = __dc;\n        return 0;\n    }\n    if (__ct == __thousands_sep && __grouping.size() != 0)\n    {\n        if (!__in_units)\n            return -1;\n        if (__g_end-__g < __num_get_buf_sz)\n        {\n            *__g_end++ = __dc;\n            __dc = 0;\n        }\n        return 0;\n    }\n    ptrdiff_t __f = find(__atoms, __atoms + 32, __ct) - __atoms;\n    if (__f >= 32)\n        return -1;\n    char __x = __src[__f];\n    if (__x == '-' || __x == '+')\n    {\n        if (__a_end == __a || (__a_end[-1] & 0x5F) == (__exp & 0x7F))\n        {\n            *__a_end++ = __x;\n            return 0;\n        }\n        return -1;\n    }\n    if (__x == 'x' || __x == 'X')\n        __exp = 'P';\n    else if ((__x & 0x5F) == __exp)\n    {\n        __exp |= 0x80;\n        if (__in_units)\n        {\n            __in_units = false;\n            if (__grouping.size() != 0 && __g_end-__g < __num_get_buf_sz)\n                *__g_end++ = __dc;\n        }\n    }\n    *__a_end++ = __x;\n    if (__f >= 22)\n        return 0;\n    ++__dc;\n    return 0;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_TYPE_VIS __num_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_TYPE_VIS __num_get<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY num_get\n    : public locale::facet,\n      private __num_get<_CharT>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _InputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit num_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, bool& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned short& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned int& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, unsigned long long& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, float& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, double& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, long double& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, void*& __v) const\n    {\n        return do_get(__b, __e, __iob, __err, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~num_get() {}\n\n    template <class _Fp>\n    iter_type __do_get_floating_point\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Fp& __v) const;\n\n    template <class _Signed>\n    iter_type __do_get_signed\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Signed& __v) const;\n\n    template <class _Unsigned>\n    iter_type __do_get_unsigned\n                            (iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, _Unsigned& __v) const;\n\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, bool& __v) const;\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long& __v) const\n    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long long& __v) const\n    { return this->__do_get_signed ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned short& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned int& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned long& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, unsigned long long& __v) const\n    { return this->__do_get_unsigned ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, float& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, double& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, long double& __v) const\n    { return this->__do_get_floating_point ( __b, __e, __iob, __err, __v ); }\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, void*& __v) const;\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\nnum_get<_CharT, _InputIterator>::id;\n\ntemplate <class _Tp>\n_Tp\n__num_get_signed_integral(const char* __a, const char* __a_end,\n                          ios_base::iostate& __err, int __base)\n{\n    if (__a != __a_end)\n    {\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        long long __ll = strtoll_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE         ||\n                 __ll < numeric_limits<_Tp>::min() ||\n                 numeric_limits<_Tp>::max() < __ll)\n        {\n            __err = ios_base::failbit;\n            if (__ll > 0)\n                return numeric_limits<_Tp>::max();\n            else\n                return numeric_limits<_Tp>::min();\n        }\n        return static_cast<_Tp>(__ll);\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _Tp>\n_Tp\n__num_get_unsigned_integral(const char* __a, const char* __a_end,\n                            ios_base::iostate& __err, int __base)\n{\n    if (__a != __a_end)\n    {\n        if (*__a == '-')\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        unsigned long long __ll = strtoull_l(__a, &__p2, __base, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE ||\n                 numeric_limits<_Tp>::max() < __ll)\n        {\n            __err = ios_base::failbit;\n            return numeric_limits<_Tp>::max();\n        }\n        return static_cast<_Tp>(__ll);\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _Tp>\n_Tp\n__num_get_float(const char* __a, const char* __a_end, ios_base::iostate& __err)\n{\n    if (__a != __a_end)\n    {\n        typename remove_reference<decltype(errno)>::type __save_errno = errno;\n        errno = 0;\n        char *__p2;\n        long double __ld = strtold_l(__a, &__p2, _LIBCPP_GET_C_LOCALE);\n        typename remove_reference<decltype(errno)>::type __current_errno = errno;\n        if (__current_errno == 0)\n            errno = __save_errno;\n        if (__p2 != __a_end)\n        {\n            __err = ios_base::failbit;\n            return 0;\n        }\n        else if (__current_errno == ERANGE)\n            __err = ios_base::failbit;\n        return static_cast<_Tp>(__ld);\n    }\n    __err = ios_base::failbit;\n    return 0;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        bool& __v) const\n{\n    if ((__iob.flags() & ios_base::boolalpha) == 0)\n    {\n        long __lv = -1;\n        __b = do_get(__b, __e, __iob, __err, __lv);\n        switch (__lv)\n        {\n        case 0:\n            __v = false;\n            break;\n        case 1:\n            __v = true;\n            break;\n        default:\n            __v = true;\n            __err = ios_base::failbit;\n            break;\n        }\n        return __b;\n    }\n    const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__iob.getloc());\n    const numpunct<_CharT>& __np = use_facet<numpunct<_CharT> >(__iob.getloc());\n    typedef typename numpunct<_CharT>::string_type string_type;\n    const string_type __names[2] = {__np.truename(), __np.falsename()};\n    const string_type* __i = __scan_keyword(__b, __e, __names, __names+2,\n                                            __ct, __err);\n    __v = __i == __names;\n    return __b;\n}\n\n// signed\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Signed>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_signed(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Signed& __v) const\n{\n    // Stage 1\n    int __base = this->__get_base(__iob);\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping, __g, __g_end,\n                                    __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_signed_integral<_Signed>(__a, __a_end, __err, __base);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n// unsigned\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Unsigned>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_unsigned(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Unsigned& __v) const\n{\n    // Stage 1\n    int __base = this->__get_base(__iob);\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_int_prep(__iob, __atoms, __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping, __g, __g_end,\n                                    __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_unsigned_integral<_Unsigned>(__a, __a_end, __err, __base);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n// floating point\n\ntemplate <class _CharT, class _InputIterator>\ntemplate <class _Fp>\n_InputIterator\nnum_get<_CharT, _InputIterator>::__do_get_floating_point(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        _Fp& __v) const\n{\n    // Stage 1, nothing to do\n    // Stage 2\n    char_type __atoms[32];\n    char_type __decimal_point;\n    char_type __thousands_sep;\n    string __grouping = this->__stage2_float_prep(__iob, __atoms,\n                                                  __decimal_point,\n                                                  __thousands_sep);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    bool __in_units = true;\n    char __exp = 'E';\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_float_loop(*__b, __in_units, __exp, __a, __a_end,\n                                      __decimal_point, __thousands_sep,\n                                      __grouping, __g, __g_end,\n                                      __dc, __atoms))\n            break;\n    }\n    if (__grouping.size() != 0 && __in_units && __g_end-__g < __num_get_base::__num_get_buf_sz)\n        *__g_end++ = __dc;\n    // Stage 3\n    __v = __num_get_float<_Fp>(__a, __a_end, __err);\n    // Digit grouping checked\n    __check_grouping(__grouping, __g, __g_end, __err);\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nnum_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                        ios_base& __iob,\n                                        ios_base::iostate& __err,\n                                        void*& __v) const\n{\n    // Stage 1\n    int __base = 16;\n    // Stage 2\n    char_type __atoms[26];\n    char_type __thousands_sep = 0;\n    string __grouping;\n    use_facet<ctype<_CharT> >(__iob.getloc()).widen(__num_get_base::__src,\n                                                    __num_get_base::__src + 26, __atoms);\n    string __buf;\n    __buf.resize(__buf.capacity());\n    char* __a = &__buf[0];\n    char* __a_end = __a;\n    unsigned __g[__num_get_base::__num_get_buf_sz];\n    unsigned* __g_end = __g;\n    unsigned __dc = 0;\n    for (; __b != __e; ++__b)\n    {\n        if (__a_end == __a + __buf.size())\n        {\n            size_t __tmp = __buf.size();\n            __buf.resize(2*__buf.size());\n            __buf.resize(__buf.capacity());\n            __a = &__buf[0];\n            __a_end = __a + __tmp;\n        }\n        if (this->__stage2_int_loop(*__b, __base, __a, __a_end, __dc,\n                                    __thousands_sep, __grouping,\n                                    __g, __g_end, __atoms))\n            break;\n    }\n    // Stage 3\n    __buf.resize(__a_end - __a);\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    if (sscanf_l(__buf.c_str(), _LIBCPP_GET_C_LOCALE, \"%p\", &__v) != 1)\n#else\n    if (__sscanf_l(__buf.c_str(), __cloc(), \"%p\", &__v) != 1)\n#endif\n        __err = ios_base::failbit;\n    // EOF checked\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS num_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS num_get<wchar_t>)\n\nstruct _LIBCPP_TYPE_VIS __num_put_base\n{\nprotected:\n    static void __format_int(char* __fmt, const char* __len, bool __signd,\n                             ios_base::fmtflags __flags);\n    static bool __format_float(char* __fmt, const char* __len,\n                               ios_base::fmtflags __flags);\n    static char* __identify_padding(char* __nb, char* __ne,\n                                    const ios_base& __iob);\n};\n\ntemplate <class _CharT>\nstruct __num_put\n    : protected __num_put_base\n{\n    static void __widen_and_group_int(char* __nb, char* __np, char* __ne,\n                                      _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                      const locale& __loc);\n    static void __widen_and_group_float(char* __nb, char* __np, char* __ne,\n                                        _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                        const locale& __loc);\n};\n\ntemplate <class _CharT>\nvoid\n__num_put<_CharT>::__widen_and_group_int(char* __nb, char* __np, char* __ne,\n                                         _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                         const locale& __loc)\n{\n    const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);\n    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);\n    string __grouping = __npt.grouping();\n    if (__grouping.empty())\n    {\n        __ct.widen(__nb, __ne, __ob);\n        __oe = __ob + (__ne - __nb);\n    }\n    else\n    {\n        __oe = __ob;\n        char* __nf = __nb;\n        if (*__nf == '-' || *__nf == '+')\n            *__oe++ = __ct.widen(*__nf++);\n        if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||\n                                                   __nf[1] == 'X'))\n        {\n            *__oe++ = __ct.widen(*__nf++);\n            *__oe++ = __ct.widen(*__nf++);\n        }\n        reverse(__nf, __ne);\n        _CharT __thousands_sep = __npt.thousands_sep();\n        unsigned __dc = 0;\n        unsigned __dg = 0;\n        for (char* __p = __nf; __p < __ne; ++__p)\n        {\n            if (static_cast<unsigned>(__grouping[__dg]) > 0 &&\n                __dc == static_cast<unsigned>(__grouping[__dg]))\n            {\n                *__oe++ = __thousands_sep;\n                __dc = 0;\n                if (__dg < __grouping.size()-1)\n                    ++__dg;\n            }\n            *__oe++ = __ct.widen(*__p);\n            ++__dc;\n        }\n        reverse(__ob + (__nf - __nb), __oe);\n    }\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __ob + (__np - __nb);\n}\n\ntemplate <class _CharT>\nvoid\n__num_put<_CharT>::__widen_and_group_float(char* __nb, char* __np, char* __ne,\n                                           _CharT* __ob, _CharT*& __op, _CharT*& __oe,\n                                           const locale& __loc)\n{\n    const ctype<_CharT>&    __ct = use_facet<ctype<_CharT> >   (__loc);\n    const numpunct<_CharT>& __npt = use_facet<numpunct<_CharT> >(__loc);\n    string __grouping = __npt.grouping();\n    __oe = __ob;\n    char* __nf = __nb;\n    if (*__nf == '-' || *__nf == '+')\n        *__oe++ = __ct.widen(*__nf++);\n    char* __ns;\n    if (__ne - __nf >= 2 && __nf[0] == '0' && (__nf[1] == 'x' ||\n                                               __nf[1] == 'X'))\n    {\n        *__oe++ = __ct.widen(*__nf++);\n        *__oe++ = __ct.widen(*__nf++);\n        for (__ns = __nf; __ns < __ne; ++__ns)\n            if (!isxdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))\n                break;\n    }\n    else\n    {\n        for (__ns = __nf; __ns < __ne; ++__ns)\n            if (!isdigit_l(*__ns, _LIBCPP_GET_C_LOCALE))\n                break;\n    }\n    if (__grouping.empty())\n    {\n        __ct.widen(__nf, __ns, __oe);\n        __oe += __ns - __nf;\n    }\n    else\n    {\n        reverse(__nf, __ns);\n        _CharT __thousands_sep = __npt.thousands_sep();\n        unsigned __dc = 0;\n        unsigned __dg = 0;\n        for (char* __p = __nf; __p < __ns; ++__p)\n        {\n            if (__grouping[__dg] > 0 && __dc == static_cast<unsigned>(__grouping[__dg]))\n            {\n                *__oe++ = __thousands_sep;\n                __dc = 0;\n                if (__dg < __grouping.size()-1)\n                    ++__dg;\n            }\n            *__oe++ = __ct.widen(*__p);\n            ++__dc;\n        }\n        reverse(__ob + (__nf - __nb), __oe);\n    }\n    for (__nf = __ns; __nf < __ne; ++__nf)\n    {\n        if (*__nf == '.')\n        {\n            *__oe++ = __npt.decimal_point();\n            ++__nf;\n            break;\n        }\n        else\n            *__oe++ = __ct.widen(*__nf);\n    }\n    __ct.widen(__nf, __ne, __oe);\n    __oe += __ne - __nf;\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __ob + (__np - __nb);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_TYPE_VIS __num_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(struct _LIBCPP_TYPE_VIS __num_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY num_put\n    : public locale::facet,\n      private __num_put<_CharT>\n{\npublic:\n    typedef _CharT char_type;\n    typedef _OutputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit num_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  bool __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  unsigned long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  unsigned long long __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  double __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  long double __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  const void* __v) const\n    {\n        return do_put(__s, __iob, __fl, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~num_put() {}\n\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             bool __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long long __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             unsigned long) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             unsigned long long) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             double __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             long double __v) const;\n    virtual iter_type do_put(iter_type __s, ios_base& __iob, char_type __fl,\n                             const void* __v) const;\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\nnum_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_LIBCPP_HIDDEN\n_OutputIterator\n__pad_and_output(_OutputIterator __s,\n                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,\n                 ios_base& __iob, _CharT __fl)\n{\n    streamsize __sz = __oe - __ob;\n    streamsize __ns = __iob.width();\n    if (__ns > __sz)\n        __ns -= __sz;\n    else\n        __ns = 0;\n    for (;__ob < __op; ++__ob, ++__s)\n        *__s = *__ob;\n    for (; __ns; --__ns, ++__s)\n        *__s = __fl;\n    for (; __ob < __oe; ++__ob, ++__s)\n        *__s = *__ob;\n    __iob.width(0);\n    return __s;\n}\n\n#if !defined(__APPLE__) || \\\n    (defined(__MAC_OS_X_VERSION_MIN_REQUIRED) && __MAC_OS_X_VERSION_MIN_REQUIRED > __MAC_10_8) || \\\n    (defined(__IPHONE_OS_VERSION_MIN_REQUIRED) && __IPHONE_OS_VERSION_MIN_REQUIRED > __IPHONE_6_0)\n\ntemplate <class _CharT, class _Traits>\n_LIBCPP_HIDDEN\nostreambuf_iterator<_CharT, _Traits>\n__pad_and_output(ostreambuf_iterator<_CharT, _Traits> __s,\n                 const _CharT* __ob, const _CharT* __op, const _CharT* __oe,\n                 ios_base& __iob, _CharT __fl)\n{\n    if (__s.__sbuf_ == nullptr)\n        return __s;\n    streamsize __sz = __oe - __ob;\n    streamsize __ns = __iob.width();\n    if (__ns > __sz)\n        __ns -= __sz;\n    else\n        __ns = 0;\n    streamsize __np = __op - __ob;\n    if (__np > 0)\n    {\n        if (__s.__sbuf_->sputn(__ob, __np) != __np)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    if (__ns > 0)\n    {\n        basic_string<_CharT, _Traits> __sp(__ns, __fl);\n        if (__s.__sbuf_->sputn(__sp.data(), __ns) != __ns)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    __np = __oe - __op;\n    if (__np > 0)\n    {\n        if (__s.__sbuf_->sputn(__op, __np) != __np)\n        {\n            __s.__sbuf_ = nullptr;\n            return __s;\n        }\n    }\n    __iob.width(0);\n    return __s;\n}\n\n#endif\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, bool __v) const\n{\n    if ((__iob.flags() & ios_base::boolalpha) == 0)\n        return do_put(__s, __iob, __fl, (unsigned long)__v);\n    const numpunct<char_type>& __np = use_facet<numpunct<char_type> >(__iob.getloc());\n    typedef typename numpunct<char_type>::string_type string_type;\n#if _LIBCPP_DEBUG_LEVEL >= 2\n    string_type __tmp(__v ? __np.truename() : __np.falsename());\n    string_type __nm = _VSTD::move(__tmp);\n#else\n    string_type __nm = __v ? __np.truename() : __np.falsename();\n#endif\n    for (typename string_type::iterator __i = __nm.begin(); __i != __nm.end(); ++__i, ++__s)\n        *__s = *__i;\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[6] = {'%', 0};\n    const char* __len = \"l\";\n    this->__format_int(__fmt+1, __len, true, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<long>::digits / 3)\n                          + ((numeric_limits<long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"ll\";\n    this->__format_int(__fmt+1, __len, true, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<long long>::digits / 3)\n                          + ((numeric_limits<long long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, unsigned long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[6] = {'%', 0};\n    const char* __len = \"l\";\n    this->__format_int(__fmt+1, __len, false, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<unsigned long>::digits / 3)\n                          + ((numeric_limits<unsigned long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, unsigned long long __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"ll\";\n    this->__format_int(__fmt+1, __len, false, __iob.flags());\n    const unsigned __nbuf = (numeric_limits<unsigned long long>::digits / 3)\n                          + ((numeric_limits<unsigned long long>::digits % 3) != 0)\n                          + 1;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_int(__nar, __np, __ne, __o, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, double __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"\";\n    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());\n    const unsigned __nbuf = 30;\n    char __nar[__nbuf];\n    char* __nb = __nar;\n    int __nc;\n    if (__specify_precision)\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,\n                                   (int)__iob.precision(), __v);\n#else\n        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt,\n                            (int)__iob.precision(), __v);\n#endif\n    else\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt, __v);\n#endif\n    unique_ptr<char, void(*)(void*)> __nbh(0, free);\n    if (__nc > static_cast<int>(__nbuf-1))\n    {\n        if (__specify_precision)\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);\n#else\n            __nc = __asprintf_l(&__nb, __cloc(), __fmt,\n                              (int)__iob.precision(), __v);\n#endif\n        else\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n            __nc = __asprintf_l(&__nb, __cloc(), __fmt, (int)__iob.precision(), __v);\n#endif\n        if (__nb == 0)\n            __throw_bad_alloc();\n        __nbh.reset(__nb);\n    }\n    char* __ne = __nb + __nc;\n    char* __np = this->__identify_padding(__nb, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __ob = __o;\n    unique_ptr<char_type, void(*)(void*)> __obh(0, free);\n    if (__nb != __nar)\n    {\n        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));\n        if (__ob == 0)\n            __throw_bad_alloc();\n        __obh.reset(__ob);\n    }\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, long double __v) const\n{\n    // Stage 1 - Get number in narrow char\n    char __fmt[8] = {'%', 0};\n    const char* __len = \"L\";\n    bool __specify_precision = this->__format_float(__fmt+1, __len, __iob.flags());\n    const unsigned __nbuf = 30;\n    char __nar[__nbuf];\n    char* __nb = __nar;\n    int __nc;\n    if (__specify_precision)\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt,\n                                   (int)__iob.precision(), __v);\n#else\n        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt,\n                            (int)__iob.precision(), __v);\n#endif\n    else\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __nc = snprintf_l(__nb, __nbuf, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n        __nc = __snprintf_l(__nb, __nbuf, __cloc(), __fmt, __v);\n#endif\n    unique_ptr<char, void(*)(void*)> __nbh(0, free);\n    if (__nc > static_cast<int>(__nbuf-1))\n    {\n        if (__specify_precision)\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, (int)__iob.precision(), __v);\n#else\n            __nc = __asprintf_l(&__nb, __cloc(), __fmt,\n                              (int)__iob.precision(), __v);\n#endif\n        else\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n            __nc = asprintf_l(&__nb, _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n            __nc = __asprintf_l(&__nb, __cloc(), __fmt, __v);\n#endif\n        if (__nb == 0)\n            __throw_bad_alloc();\n        __nbh.reset(__nb);\n    }\n    char* __ne = __nb + __nc;\n    char* __np = this->__identify_padding(__nb, __ne, __iob);\n    // Stage 2 - Widen __nar while adding thousands separators\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __ob = __o;\n    unique_ptr<char_type, void(*)(void*)> __obh(0, free);\n    if (__nb != __nar)\n    {\n        __ob = (char_type*)malloc(2*static_cast<size_t>(__nc)*sizeof(char_type));\n        if (__ob == 0)\n            __throw_bad_alloc();\n        __obh.reset(__ob);\n    }\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    this->__widen_and_group_float(__nb, __np, __ne, __ob, __op, __oe, __iob.getloc());\n    // [__o, __oe) contains thousands_sep'd wide number\n    // Stage 3 & 4\n    __s = __pad_and_output(__s, __ob, __op, __oe, __iob, __fl);\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nnum_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base& __iob,\n                                         char_type __fl, const void* __v) const\n{\n    // Stage 1 - Get pointer in narrow char\n    char __fmt[6] = \"%p\";\n    const unsigned __nbuf = 20;\n    char __nar[__nbuf];\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n    int __nc = snprintf_l(__nar, sizeof(__nar), _LIBCPP_GET_C_LOCALE, __fmt, __v);\n#else\n    int __nc = __snprintf_l(__nar, sizeof(__nar), __cloc(), __fmt, __v);\n#endif\n    char* __ne = __nar + __nc;\n    char* __np = this->__identify_padding(__nar, __ne, __iob);\n    // Stage 2 - Widen __nar\n    char_type __o[2*(__nbuf-1) - 1];\n    char_type* __op;  // pad here\n    char_type* __oe;  // end of output\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __ct.widen(__nar, __ne, __o);\n    __oe = __o + (__ne - __nar);\n    if (__np == __ne)\n        __op = __oe;\n    else\n        __op = __o + (__np - __nar);\n    // [__o, __oe) contains wide number\n    // Stage 3 & 4\n    return __pad_and_output(__s, __o, __op, __oe, __iob, __fl);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS num_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS num_put<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator>\n_LIBCPP_HIDDEN\nint\n__get_up_to_n_digits(_InputIterator& __b, _InputIterator __e,\n                     ios_base::iostate& __err, const ctype<_CharT>& __ct, int __n)\n{\n    // Precondition:  __n >= 1\n    if (__b == __e)\n    {\n        __err |= ios_base::eofbit | ios_base::failbit;\n        return 0;\n    }\n    // get first digit\n    _CharT __c = *__b;\n    if (!__ct.is(ctype_base::digit, __c))\n    {\n        __err |= ios_base::failbit;\n        return 0;\n    }\n    int __r = __ct.narrow(__c, 0) - '0';\n    for (++__b, --__n; __b != __e && __n > 0; ++__b, --__n)\n    {\n        // get next digit\n        __c = *__b;\n        if (!__ct.is(ctype_base::digit, __c))\n            return __r;\n        __r = __r * 10 + __ct.narrow(__c, 0) - '0';\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __r;\n}\n\nclass _LIBCPP_TYPE_VIS time_base\n{\npublic:\n    enum dateorder {no_order, dmy, mdy, ymd, ydm};\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS_ONLY __time_get_c_storage\n{\nprotected:\n    typedef basic_string<_CharT> string_type;\n\n    virtual const string_type* __weeks() const;\n    virtual const string_type* __months() const;\n    virtual const string_type* __am_pm() const;\n    virtual const string_type& __c() const;\n    virtual const string_type& __r() const;\n    virtual const string_type& __x() const;\n    virtual const string_type& __X() const;\n};\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY time_get\n    : public locale::facet,\n      public time_base,\n      private __time_get_c_storage<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _InputIterator          iter_type;\n    typedef time_base::dateorder    dateorder;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    dateorder date_order() const\n    {\n        return this->do_date_order();\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_time(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_time(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_date(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_date(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_weekday(iter_type __b, iter_type __e, ios_base& __iob,\n                          ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_weekday(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_monthname(iter_type __b, iter_type __e, ios_base& __iob,\n                            ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_monthname(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get_year(iter_type __b, iter_type __e, ios_base& __iob,\n                       ios_base::iostate& __err, tm* __tm) const\n    {\n        return do_get_year(__b, __e, __iob, __err, __tm);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, tm *__tm,\n                  char __fmt, char __mod = 0) const\n    {\n        return do_get(__b, __e, __iob, __err, __tm, __fmt, __mod);\n    }\n\n    iter_type get(iter_type __b, iter_type __e, ios_base& __iob,\n                  ios_base::iostate& __err, tm* __tm,\n                  const char_type* __fmtb, const char_type* __fmte) const;\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_get() {}\n\n    virtual dateorder do_date_order() const;\n    virtual iter_type do_get_time(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_date(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_weekday(iter_type __b, iter_type __e, ios_base& __iob,\n                                     ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_monthname(iter_type __b, iter_type __e, ios_base& __iob,\n                                       ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get_year(iter_type __b, iter_type __e, ios_base& __iob,\n                                  ios_base::iostate& __err, tm* __tm) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, ios_base& __iob,\n                             ios_base::iostate& __err, tm* __tm,\n                             char __fmt, char __mod) const;\nprivate:\n    void __get_white_space(iter_type& __b, iter_type __e,\n                           ios_base::iostate& __err, const ctype<char_type>& __ct) const;\n    void __get_percent(iter_type& __b, iter_type __e, ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n\n    void __get_weekdayname(int& __m,\n                           iter_type& __b, iter_type __e,\n                           ios_base::iostate& __err,\n                           const ctype<char_type>& __ct) const;\n    void __get_monthname(int& __m,\n                         iter_type& __b, iter_type __e,\n                         ios_base::iostate& __err,\n                         const ctype<char_type>& __ct) const;\n    void __get_day(int& __d,\n                   iter_type& __b, iter_type __e,\n                   ios_base::iostate& __err,\n                   const ctype<char_type>& __ct) const;\n    void __get_month(int& __m,\n                     iter_type& __b, iter_type __e,\n                     ios_base::iostate& __err,\n                     const ctype<char_type>& __ct) const;\n    void __get_year(int& __y,\n                   iter_type& __b, iter_type __e,\n                   ios_base::iostate& __err,\n                   const ctype<char_type>& __ct) const;\n    void __get_year4(int& __y,\n                    iter_type& __b, iter_type __e,\n                    ios_base::iostate& __err,\n                    const ctype<char_type>& __ct) const;\n    void __get_hour(int& __d,\n                    iter_type& __b, iter_type __e,\n                    ios_base::iostate& __err,\n                    const ctype<char_type>& __ct) const;\n    void __get_12_hour(int& __h,\n                       iter_type& __b, iter_type __e,\n                       ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n    void __get_am_pm(int& __h,\n                     iter_type& __b, iter_type __e,\n                     ios_base::iostate& __err,\n                     const ctype<char_type>& __ct) const;\n    void __get_minute(int& __m,\n                      iter_type& __b, iter_type __e,\n                      ios_base::iostate& __err,\n                      const ctype<char_type>& __ct) const;\n    void __get_second(int& __s,\n                      iter_type& __b, iter_type __e,\n                      ios_base::iostate& __err,\n                      const ctype<char_type>& __ct) const;\n    void __get_weekday(int& __w,\n                       iter_type& __b, iter_type __e,\n                       ios_base::iostate& __err,\n                       const ctype<char_type>& __ct) const;\n    void __get_day_year_num(int& __w,\n                            iter_type& __b, iter_type __e,\n                            ios_base::iostate& __err,\n                            const ctype<char_type>& __ct) const;\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\ntime_get<_CharT, _InputIterator>::id;\n\n// time_get primitives\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_weekdayname(int& __w,\n                                                    iter_type& __b, iter_type __e,\n                                                    ios_base::iostate& __err,\n                                                    const ctype<char_type>& __ct) const\n{\n    // Note:  ignoring case comes from the POSIX strptime spec\n    const string_type* __wk = this->__weeks();\n    ptrdiff_t __i = __scan_keyword(__b, __e, __wk, __wk+14, __ct, __err, false) - __wk;\n    if (__i < 14)\n        __w = __i % 7;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_monthname(int& __m,\n                                                  iter_type& __b, iter_type __e,\n                                                  ios_base::iostate& __err,\n                                                  const ctype<char_type>& __ct) const\n{\n    // Note:  ignoring case comes from the POSIX strptime spec\n    const string_type* __month = this->__months();\n    ptrdiff_t __i = __scan_keyword(__b, __e, __month, __month+24, __ct, __err, false) - __month;\n    if (__i < 24)\n        __m = __i % 12;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_day(int& __d,\n                                            iter_type& __b, iter_type __e,\n                                            ios_base::iostate& __err,\n                                            const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 31)\n        __d = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_month(int& __m,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2) - 1;\n    if (!(__err & ios_base::failbit) && __t <= 11)\n        __m = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_year(int& __y,\n                                             iter_type& __b, iter_type __e,\n                                             ios_base::iostate& __err,\n                                             const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);\n    if (!(__err & ios_base::failbit))\n    {\n        if (__t < 69)\n            __t += 2000;\n        else if (69 <= __t && __t <= 99)\n            __t += 1900;\n        __y = __t - 1900;\n    }\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_year4(int& __y,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 4);\n    if (!(__err & ios_base::failbit))\n        __y = __t - 1900;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_hour(int& __h,\n                                             iter_type& __b, iter_type __e,\n                                             ios_base::iostate& __err,\n                                             const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 23)\n        __h = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_12_hour(int& __h,\n                                                iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && 1 <= __t && __t <= 12)\n        __h = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_minute(int& __m,\n                                               iter_type& __b, iter_type __e,\n                                               ios_base::iostate& __err,\n                                               const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 59)\n        __m = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_second(int& __s,\n                                               iter_type& __b, iter_type __e,\n                                               ios_base::iostate& __err,\n                                               const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 2);\n    if (!(__err & ios_base::failbit) && __t <= 60)\n        __s = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_weekday(int& __w,\n                                                iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 1);\n    if (!(__err & ios_base::failbit) && __t <= 6)\n        __w = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_day_year_num(int& __d,\n                                                     iter_type& __b, iter_type __e,\n                                                     ios_base::iostate& __err,\n                                                     const ctype<char_type>& __ct) const\n{\n    int __t = __get_up_to_n_digits(__b, __e, __err, __ct, 3);\n    if (!(__err & ios_base::failbit) && __t <= 365)\n        __d = __t;\n    else\n        __err |= ios_base::failbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_white_space(iter_type& __b, iter_type __e,\n                                                    ios_base::iostate& __err,\n                                                    const ctype<char_type>& __ct) const\n{\n    for (; __b != __e && __ct.is(ctype_base::space, *__b); ++__b)\n        ;\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_am_pm(int& __h,\n                                              iter_type& __b, iter_type __e,\n                                              ios_base::iostate& __err,\n                                              const ctype<char_type>& __ct) const\n{\n    const string_type* __ap = this->__am_pm();\n    if (__ap[0].size() + __ap[1].size() == 0)\n    {\n        __err |= ios_base::failbit;\n        return;\n    }\n    ptrdiff_t __i = __scan_keyword(__b, __e, __ap, __ap+2, __ct, __err, false) - __ap;\n    if (__i == 0 && __h == 12)\n        __h = 0;\n    else if (__i == 1 && __h < 12)\n        __h += 12;\n}\n\ntemplate <class _CharT, class _InputIterator>\nvoid\ntime_get<_CharT, _InputIterator>::__get_percent(iter_type& __b, iter_type __e,\n                                                ios_base::iostate& __err,\n                                                const ctype<char_type>& __ct) const\n{\n    if (__b == __e)\n    {\n        __err |= ios_base::eofbit | ios_base::failbit;\n        return;\n    }\n    if (__ct.narrow(*__b, 0) != '%')\n        __err |= ios_base::failbit;\n    else if(++__b == __e)\n        __err |= ios_base::eofbit;\n}\n\n// time_get end primitives\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::get(iter_type __b, iter_type __e,\n                                      ios_base& __iob,\n                                      ios_base::iostate& __err, tm* __tm,\n                                      const char_type* __fmtb, const char_type* __fmte) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __err = ios_base::goodbit;\n    while (__fmtb != __fmte && __err == ios_base::goodbit)\n    {\n        if (__b == __e)\n        {\n            __err = ios_base::failbit;\n            break;\n        }\n        if (__ct.narrow(*__fmtb, 0) == '%')\n        {\n            if (++__fmtb == __fmte)\n            {\n                __err = ios_base::failbit;\n                break;\n            }\n            char __cmd = __ct.narrow(*__fmtb, 0);\n            char __opt = '\\0';\n            if (__cmd == 'E' || __cmd == '0')\n            {\n                if (++__fmtb == __fmte)\n                {\n                    __err = ios_base::failbit;\n                    break;\n                }\n                __opt = __cmd;\n                __cmd = __ct.narrow(*__fmtb, 0);\n            }\n            __b = do_get(__b, __e, __iob, __err, __tm, __cmd, __opt);\n            ++__fmtb;\n        }\n        else if (__ct.is(ctype_base::space, *__fmtb))\n        {\n            for (++__fmtb; __fmtb != __fmte && __ct.is(ctype_base::space, *__fmtb); ++__fmtb)\n                ;\n            for (        ;    __b != __e    && __ct.is(ctype_base::space, *__b);    ++__b)\n                ;\n        }\n        else if (__ct.toupper(*__b) == __ct.toupper(*__fmtb))\n        {\n            ++__b;\n            ++__fmtb;\n        }\n        else\n            __err = ios_base::failbit;\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\ntypename time_get<_CharT, _InputIterator>::dateorder\ntime_get<_CharT, _InputIterator>::do_date_order() const\n{\n    return mdy;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_time(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const char_type __fmt[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};\n    return get(__b, __e, __iob, __err, __tm, __fmt, __fmt + sizeof(__fmt)/sizeof(__fmt[0]));\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_date(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const string_type& __fmt = this->__x();\n    return get(__b, __e, __iob, __err, __tm, __fmt.data(), __fmt.data() + __fmt.size());\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_weekday(iter_type __b, iter_type __e,\n                                                 ios_base& __iob,\n                                                 ios_base::iostate& __err,\n                                                 tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_monthname(iter_type __b, iter_type __e,\n                                                   ios_base& __iob,\n                                                   ios_base::iostate& __err,\n                                                   tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get_year(iter_type __b, iter_type __e,\n                                              ios_base& __iob,\n                                              ios_base::iostate& __err,\n                                              tm* __tm) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    __get_year(__tm->tm_year, __b, __e, __err, __ct);\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\ntime_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                         ios_base& __iob,\n                                         ios_base::iostate& __err, tm* __tm,\n                                         char __fmt, char) const\n{\n    __err = ios_base::goodbit;\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    switch (__fmt)\n    {\n    case 'a':\n    case 'A':\n        __get_weekdayname(__tm->tm_wday, __b, __e, __err, __ct);\n        break;\n    case 'b':\n    case 'B':\n    case 'h':\n        __get_monthname(__tm->tm_mon, __b, __e, __err, __ct);\n        break;\n    case 'c':\n        {\n        const string_type& __fm = this->__c();\n        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());\n        }\n        break;\n    case 'd':\n    case 'e':\n        __get_day(__tm->tm_mday, __b, __e, __err, __ct);\n        break;\n    case 'D':\n        {\n        const char_type __fm[] = {'%', 'm', '/', '%', 'd', '/', '%', 'y'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'F':\n        {\n        const char_type __fm[] = {'%', 'Y', '-', '%', 'm', '-', '%', 'd'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'H':\n        __get_hour(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'I':\n        __get_12_hour(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'j':\n        __get_day_year_num(__tm->tm_yday, __b, __e, __err, __ct);\n        break;\n    case 'm':\n        __get_month(__tm->tm_mon, __b, __e, __err, __ct);\n        break;\n    case 'M':\n        __get_minute(__tm->tm_min, __b, __e, __err, __ct);\n        break;\n    case 'n':\n    case 't':\n        __get_white_space(__b, __e, __err, __ct);\n        break;\n    case 'p':\n        __get_am_pm(__tm->tm_hour, __b, __e, __err, __ct);\n        break;\n    case 'r':\n        {\n        const char_type __fm[] = {'%', 'I', ':', '%', 'M', ':', '%', 'S', ' ', '%', 'p'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'R':\n        {\n        const char_type __fm[] = {'%', 'H', ':', '%', 'M'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'S':\n        __get_second(__tm->tm_sec, __b, __e, __err, __ct);\n        break;\n    case 'T':\n        {\n        const char_type __fm[] = {'%', 'H', ':', '%', 'M', ':', '%', 'S'};\n        __b = get(__b, __e, __iob, __err, __tm, __fm, __fm + sizeof(__fm)/sizeof(__fm[0]));\n        }\n        break;\n    case 'w':\n        __get_weekday(__tm->tm_wday, __b, __e, __err, __ct);\n        break;\n    case 'x':\n        return do_get_date(__b, __e, __iob, __err, __tm);\n    case 'X':\n        {\n        const string_type& __fm = this->__X();\n        __b = get(__b, __e, __iob, __err, __tm, __fm.data(), __fm.data() + __fm.size());\n        }\n        break;\n    case 'y':\n        __get_year(__tm->tm_year, __b, __e, __err, __ct);\n        break;\n    case 'Y':\n        __get_year4(__tm->tm_year, __b, __e, __err, __ct);\n        break;\n    case '%':\n        __get_percent(__b, __e, __err, __ct);\n        break;\n    default:\n        __err |= ios_base::failbit;\n    }\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_get<wchar_t>)\n\nclass _LIBCPP_TYPE_VIS __time_get\n{\nprotected:\n    locale_t __loc_;\n\n    __time_get(const char* __nm);\n    __time_get(const string& __nm);\n    ~__time_get();\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS_ONLY __time_get_storage\n    : public __time_get\n{\nprotected:\n    typedef basic_string<_CharT> string_type;\n\n    string_type __weeks_[14];\n    string_type __months_[24];\n    string_type __am_pm_[2];\n    string_type __c_;\n    string_type __r_;\n    string_type __x_;\n    string_type __X_;\n\n    explicit __time_get_storage(const char* __nm);\n    explicit __time_get_storage(const string& __nm);\n\n    _LIBCPP_ALWAYS_INLINE ~__time_get_storage() {}\n\n    time_base::dateorder __do_date_order() const;\n\nprivate:\n    void init(const ctype<_CharT>&);\n    string_type __analyze(char __fmt, const ctype<_CharT>&);\n};\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY time_get_byname\n    : public time_get<_CharT, _InputIterator>,\n      private __time_get_storage<_CharT>\n{\npublic:\n    typedef time_base::dateorder    dateorder;\n    typedef _InputIterator          iter_type;\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_get_byname(const char* __nm, size_t __refs = 0)\n        : time_get<_CharT, _InputIterator>(__refs),\n          __time_get_storage<_CharT>(__nm) {}\n    _LIBCPP_INLINE_VISIBILITY\n    explicit time_get_byname(const string& __nm, size_t __refs = 0)\n        : time_get<_CharT, _InputIterator>(__refs),\n          __time_get_storage<_CharT>(__nm) {}\n\nprotected:\n    _LIBCPP_INLINE_VISIBILITY\n    ~time_get_byname() {}\n\n    _LIBCPP_INLINE_VISIBILITY\n    virtual dateorder do_date_order() const {return this->__do_date_order();}\nprivate:\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __weeks() const  {return this->__weeks_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __months() const {return this->__months_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type* __am_pm() const  {return this->__am_pm_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __c() const      {return this->__c_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __r() const      {return this->__r_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __x() const      {return this->__x_;}\n    _LIBCPP_INLINE_VISIBILITY\n    virtual const string_type& __X() const      {return this->__X_;}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_get_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_get_byname<wchar_t>)\n\nclass _LIBCPP_TYPE_VIS __time_put\n{\n    locale_t __loc_;\nprotected:\n    _LIBCPP_ALWAYS_INLINE __time_put() : __loc_(_LIBCPP_GET_C_LOCALE) {}\n    __time_put(const char* __nm);\n    __time_put(const string& __nm);\n    ~__time_put();\n    void __do_put(char* __nb, char*& __ne, const tm* __tm,\n                  char __fmt, char __mod) const;\n    void __do_put(wchar_t* __wb, wchar_t*& __we, const tm* __tm,\n                  char __fmt, char __mod) const;\n};\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY time_put\n    : public locale::facet,\n      private __time_put\n{\npublic:\n    typedef _CharT char_type;\n    typedef _OutputIterator iter_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl, const tm* __tm,\n                  const char_type* __pb, const char_type* __pe) const;\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, ios_base& __iob, char_type __fl,\n                  const tm* __tm, char __fmt, char __mod = 0) const\n    {\n        return do_put(__s, __iob, __fl, __tm, __fmt, __mod);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_put() {}\n    virtual iter_type do_put(iter_type __s, ios_base&, char_type, const tm* __tm,\n                             char __fmt, char __mod) const;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(const char* __nm, size_t __refs)\n        : locale::facet(__refs),\n          __time_put(__nm) {}\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put(const string& __nm, size_t __refs)\n        : locale::facet(__refs),\n          __time_put(__nm) {}\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\ntime_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\ntime_put<_CharT, _OutputIterator>::put(iter_type __s, ios_base& __iob,\n                                       char_type __fl, const tm* __tm,\n                                       const char_type* __pb,\n                                       const char_type* __pe) const\n{\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__iob.getloc());\n    for (; __pb != __pe; ++__pb)\n    {\n        if (__ct.narrow(*__pb, 0) == '%')\n        {\n            if (++__pb == __pe)\n            {\n                *__s++ = __pb[-1];\n                break;\n            }\n            char __mod = 0;\n            char __fmt = __ct.narrow(*__pb, 0);\n            if (__fmt == 'E' || __fmt == 'O')\n            {\n                if (++__pb == __pe)\n                {\n                    *__s++ = __pb[-2];\n                    *__s++ = __pb[-1];\n                    break;\n                }\n                __mod = __fmt;\n                __fmt = __ct.narrow(*__pb, 0);\n            }\n            __s = do_put(__s, __iob, __fl, __tm, __fmt, __mod);\n        }\n        else\n            *__s++ = *__pb;\n    }\n    return __s;\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\ntime_put<_CharT, _OutputIterator>::do_put(iter_type __s, ios_base&,\n                                          char_type, const tm* __tm,\n                                          char __fmt, char __mod) const\n{\n    char_type __nar[100];\n    char_type* __nb = __nar;\n    char_type* __ne = __nb + 100;\n    __do_put(__nb, __ne, __tm, __fmt, __mod);\n    return _VSTD::copy(__nb, __ne, __s);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY time_put_byname\n    : public time_put<_CharT, _OutputIterator>\n{\npublic:\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put_byname(const char* __nm, size_t __refs = 0)\n        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit time_put_byname(const string& __nm, size_t __refs = 0)\n        : time_put<_CharT, _OutputIterator>(__nm, __refs) {}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~time_put_byname() {}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_put_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS time_put_byname<wchar_t>)\n\n// money_base\n\nclass _LIBCPP_TYPE_VIS money_base\n{\npublic:\n    enum part {none, space, symbol, sign, value};\n    struct pattern {char field[4];};\n\n    _LIBCPP_ALWAYS_INLINE money_base() {}\n};\n\n// moneypunct\n\ntemplate <class _CharT, bool _International = false>\nclass _LIBCPP_TYPE_VIS_ONLY moneypunct\n    : public locale::facet,\n      public money_base\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE char_type   decimal_point() const {return do_decimal_point();}\n    _LIBCPP_ALWAYS_INLINE char_type   thousands_sep() const {return do_thousands_sep();}\n    _LIBCPP_ALWAYS_INLINE string      grouping()      const {return do_grouping();}\n    _LIBCPP_ALWAYS_INLINE string_type curr_symbol()   const {return do_curr_symbol();}\n    _LIBCPP_ALWAYS_INLINE string_type positive_sign() const {return do_positive_sign();}\n    _LIBCPP_ALWAYS_INLINE string_type negative_sign() const {return do_negative_sign();}\n    _LIBCPP_ALWAYS_INLINE int         frac_digits()   const {return do_frac_digits();}\n    _LIBCPP_ALWAYS_INLINE pattern     pos_format()    const {return do_pos_format();}\n    _LIBCPP_ALWAYS_INLINE pattern     neg_format()    const {return do_neg_format();}\n\n    static locale::id id;\n    static const bool intl = _International;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~moneypunct() {}\n\n    virtual char_type   do_decimal_point() const {return numeric_limits<char_type>::max();}\n    virtual char_type   do_thousands_sep() const {return numeric_limits<char_type>::max();}\n    virtual string      do_grouping()      const {return string();}\n    virtual string_type do_curr_symbol()   const {return string_type();}\n    virtual string_type do_positive_sign() const {return string_type();}\n    virtual string_type do_negative_sign() const {return string_type(1, '-');}\n    virtual int         do_frac_digits()   const {return 0;}\n    virtual pattern     do_pos_format()    const\n        {pattern __p = {{symbol, sign, none, value}}; return __p;}\n    virtual pattern     do_neg_format()    const\n        {pattern __p = {{symbol, sign, none, value}}; return __p;}\n};\n\ntemplate <class _CharT, bool _International>\nlocale::id\nmoneypunct<_CharT, _International>::id;\n\ntemplate <class _CharT, bool _International>\nconst bool\nmoneypunct<_CharT, _International>::intl;\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct<char, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct<char, true>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct<wchar_t, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct<wchar_t, true>)\n\n// moneypunct_byname\n\ntemplate <class _CharT, bool _International = false>\nclass _LIBCPP_TYPE_VIS_ONLY moneypunct_byname\n    : public moneypunct<_CharT, _International>\n{\npublic:\n    typedef money_base::pattern  pattern;\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct_byname(const char* __nm, size_t __refs = 0)\n        : moneypunct<_CharT, _International>(__refs) {init(__nm);}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit moneypunct_byname(const string& __nm, size_t __refs = 0)\n        : moneypunct<_CharT, _International>(__refs) {init(__nm.c_str());}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~moneypunct_byname() {}\n\n    virtual char_type   do_decimal_point() const {return __decimal_point_;}\n    virtual char_type   do_thousands_sep() const {return __thousands_sep_;}\n    virtual string      do_grouping()      const {return __grouping_;}\n    virtual string_type do_curr_symbol()   const {return __curr_symbol_;}\n    virtual string_type do_positive_sign() const {return __positive_sign_;}\n    virtual string_type do_negative_sign() const {return __negative_sign_;}\n    virtual int         do_frac_digits()   const {return __frac_digits_;}\n    virtual pattern     do_pos_format()    const {return __pos_format_;}\n    virtual pattern     do_neg_format()    const {return __neg_format_;}\n\nprivate:\n    char_type   __decimal_point_;\n    char_type   __thousands_sep_;\n    string      __grouping_;\n    string_type __curr_symbol_;\n    string_type __positive_sign_;\n    string_type __negative_sign_;\n    int         __frac_digits_;\n    pattern     __pos_format_;\n    pattern     __neg_format_;\n\n    void init(const char*);\n};\n\ntemplate<> void moneypunct_byname<char, false>::init(const char*);\ntemplate<> void moneypunct_byname<char, true>::init(const char*);\ntemplate<> void moneypunct_byname<wchar_t, false>::init(const char*);\ntemplate<> void moneypunct_byname<wchar_t, true>::init(const char*);\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct_byname<char, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct_byname<char, true>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct_byname<wchar_t, false>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS moneypunct_byname<wchar_t, true>)\n\n// money_get\n\ntemplate <class _CharT>\nclass __money_get\n{\nprotected:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE __money_get() {}\n\n    static void __gather_info(bool __intl, const locale& __loc,\n                              money_base::pattern& __pat, char_type& __dp,\n                              char_type& __ts, string& __grp,\n                              string_type& __sym, string_type& __psn,\n                              string_type& __nsn, int& __fd);\n};\n\ntemplate <class _CharT>\nvoid\n__money_get<_CharT>::__gather_info(bool __intl, const locale& __loc,\n                                   money_base::pattern& __pat, char_type& __dp,\n                                   char_type& __ts, string& __grp,\n                                   string_type& __sym, string_type& __psn,\n                                   string_type& __nsn, int& __fd)\n{\n    if (__intl)\n    {\n        const moneypunct<char_type, true>& __mp =\n            use_facet<moneypunct<char_type, true> >(__loc);\n        __pat = __mp.neg_format();\n        __nsn = __mp.negative_sign();\n        __psn = __mp.positive_sign();\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n    else\n    {\n        const moneypunct<char_type, false>& __mp =\n            use_facet<moneypunct<char_type, false> >(__loc);\n        __pat = __mp.neg_format();\n        __nsn = __mp.negative_sign();\n        __psn = __mp.positive_sign();\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS __money_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS __money_get<wchar_t>)\n\ntemplate <class _CharT, class _InputIterator = istreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY money_get\n    : public locale::facet,\n      private __money_get<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _InputIterator          iter_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit money_get(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,\n                  ios_base::iostate& __err, long double& __v) const\n    {\n        return do_get(__b, __e, __intl, __iob, __err, __v);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type get(iter_type __b, iter_type __e, bool __intl, ios_base& __iob,\n                  ios_base::iostate& __err, string_type& __v) const\n    {\n        return do_get(__b, __e, __intl, __iob, __err, __v);\n    }\n\n    static locale::id id;\n\nprotected:\n\n    _LIBCPP_ALWAYS_INLINE\n    ~money_get() {}\n\n    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,\n                             ios_base& __iob, ios_base::iostate& __err,\n                             long double& __v) const;\n    virtual iter_type do_get(iter_type __b, iter_type __e, bool __intl,\n                             ios_base& __iob, ios_base::iostate& __err,\n                             string_type& __v) const;\n\nprivate:\n    static bool __do_get(iter_type& __b, iter_type __e,\n                         bool __intl, const locale& __loc,\n                         ios_base::fmtflags __flags, ios_base::iostate& __err,\n                         bool& __neg, const ctype<char_type>& __ct,\n                         unique_ptr<char_type, void(*)(void*)>& __wb,\n                         char_type*& __wn, char_type* __we);\n};\n\ntemplate <class _CharT, class _InputIterator>\nlocale::id\nmoney_get<_CharT, _InputIterator>::id;\n\n_LIBCPP_FUNC_VIS void __do_nothing(void*);\n\ntemplate <class _Tp>\n_LIBCPP_HIDDEN\nvoid\n__double_or_nothing(unique_ptr<_Tp, void(*)(void*)>& __b, _Tp*& __n, _Tp*& __e)\n{\n    bool __owns = __b.get_deleter() != __do_nothing;\n    size_t __cur_cap = static_cast<size_t>(__e-__b.get()) * sizeof(_Tp);\n    size_t __new_cap = __cur_cap < numeric_limits<size_t>::max() / 2 ?\n                       2 * __cur_cap : numeric_limits<size_t>::max();\n    size_t __n_off = static_cast<size_t>(__n - __b.get());\n    _Tp* __t = (_Tp*)realloc(__owns ? __b.get() : 0, __new_cap);\n    if (__t == 0)\n        __throw_bad_alloc();\n    if (__owns)\n        __b.release();\n    __b = unique_ptr<_Tp, void(*)(void*)>(__t, free);\n    __new_cap /= sizeof(_Tp);\n    __n = __b.get() + __n_off;\n    __e = __b.get() + __new_cap;\n}\n\n// true == success\ntemplate <class _CharT, class _InputIterator>\nbool\nmoney_get<_CharT, _InputIterator>::__do_get(iter_type& __b, iter_type __e,\n                                            bool __intl, const locale& __loc,\n                                            ios_base::fmtflags __flags,\n                                            ios_base::iostate& __err,\n                                            bool& __neg,\n                                            const ctype<char_type>& __ct,\n                                            unique_ptr<char_type, void(*)(void*)>& __wb,\n                                            char_type*& __wn, char_type* __we)\n{\n    const unsigned __bz = 100;\n    unsigned __gbuf[__bz];\n    unique_ptr<unsigned, void(*)(void*)> __gb(__gbuf, __do_nothing);\n    unsigned* __gn = __gb.get();\n    unsigned* __ge = __gn + __bz;\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __psn;\n    string_type __nsn;\n    // Capture the spaces read into money_base::{space,none} so they\n    // can be compared to initial spaces in __sym.\n    string_type __spaces;\n    int __fd;\n    __money_get<_CharT>::__gather_info(__intl, __loc, __pat, __dp, __ts, __grp,\n                                       __sym, __psn, __nsn, __fd);\n    const string_type* __trailing_sign = 0;\n    __wn = __wb.get();\n    for (unsigned __p = 0; __p < 4 && __b != __e; ++__p)\n    {\n        switch (__pat.field[__p])\n        {\n        case money_base::space:\n            if (__p != 3)\n            {\n                if (__ct.is(ctype_base::space, *__b))\n                    __spaces.push_back(*__b++);\n                else\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n            }\n            // drop through\n        case money_base::none:\n            if (__p != 3)\n            {\n                while (__b != __e && __ct.is(ctype_base::space, *__b))\n                    __spaces.push_back(*__b++);\n            }\n            break;\n        case money_base::sign:\n            if (__psn.size() + __nsn.size() > 0)\n            {\n                if (__psn.size() == 0 || __nsn.size() == 0)\n                {   // sign is optional\n                    if (__psn.size() > 0)\n                    {   // __nsn.size() == 0\n                        if (*__b == __psn[0])\n                        {\n                            ++__b;\n                            if (__psn.size() > 1)\n                                __trailing_sign = &__psn;\n                        }\n                        else\n                            __neg = true;\n                    }\n                    else if (*__b == __nsn[0])  // __nsn.size() > 0 &&  __psn.size() == 0\n                    {\n                        ++__b;\n                        __neg = true;\n                        if (__nsn.size() > 1)\n                            __trailing_sign = &__nsn;\n                    }\n                }\n                else  // sign is required\n                {\n                    if (*__b == __psn[0])\n                    {\n                        ++__b;\n                        if (__psn.size() > 1)\n                            __trailing_sign = &__psn;\n                    }\n                    else if (*__b == __nsn[0])\n                    {\n                        ++__b;\n                        __neg = true;\n                        if (__nsn.size() > 1)\n                            __trailing_sign = &__nsn;\n                    }\n                    else\n                    {\n                        __err |= ios_base::failbit;\n                        return false;\n                    }\n                }\n            }\n            break;\n        case money_base::symbol:\n            {\n            bool __more_needed = __trailing_sign ||\n                                 (__p < 2)       ||\n                                 (__p == 2 && __pat.field[3] != static_cast<char>(money_base::none));\n            bool __sb = (__flags & ios_base::showbase) != 0;\n            if (__sb || __more_needed)\n            {\n                typename string_type::const_iterator __sym_space_end = __sym.begin();\n                if (__p > 0 && (__pat.field[__p - 1] == money_base::none ||\n                                __pat.field[__p - 1] == money_base::space)) {\n                    // Match spaces we've already read against spaces at\n                    // the beginning of __sym.\n                    while (__sym_space_end != __sym.end() &&\n                           __ct.is(ctype_base::space, *__sym_space_end))\n                        ++__sym_space_end;\n                    const size_t __num_spaces = __sym_space_end - __sym.begin();\n                    if (__num_spaces > __spaces.size() ||\n                        !equal(__spaces.end() - __num_spaces, __spaces.end(),\n                               __sym.begin())) {\n                        // No match. Put __sym_space_end back at the\n                        // beginning of __sym, which will prevent a\n                        // match in the next loop.\n                        __sym_space_end = __sym.begin();\n                    }\n                }\n                typename string_type::const_iterator __sym_curr_char = __sym_space_end;\n                while (__sym_curr_char != __sym.end() && __b != __e &&\n                       *__b == *__sym_curr_char) {\n                    ++__b;\n                    ++__sym_curr_char;\n                }\n                if (__sb && __sym_curr_char != __sym.end())\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n            }\n            }\n            break;\n        case money_base::value:\n            {\n            unsigned __ng = 0;\n            for (; __b != __e; ++__b)\n            {\n                char_type __c = *__b;\n                if (__ct.is(ctype_base::digit, __c))\n                {\n                    if (__wn == __we)\n                        __double_or_nothing(__wb, __wn, __we);\n                    *__wn++ = __c;\n                    ++__ng;\n                }\n                else if (__grp.size() > 0 && __ng > 0 && __c == __ts)\n                {\n                    if (__gn == __ge)\n                        __double_or_nothing(__gb, __gn, __ge);\n                    *__gn++ = __ng;\n                    __ng = 0;\n                }\n                else\n                    break;\n            }\n            if (__gb.get() != __gn && __ng > 0)\n            {\n                if (__gn == __ge)\n                    __double_or_nothing(__gb, __gn, __ge);\n                *__gn++ = __ng;\n            }\n            if (__fd > 0)\n            {\n                if (__b == __e || *__b != __dp)\n                {\n                    __err |= ios_base::failbit;\n                    return false;\n                }\n                for (++__b; __fd > 0; --__fd, ++__b)\n                {\n                    if (__b == __e || !__ct.is(ctype_base::digit, *__b))\n                    {\n                        __err |= ios_base::failbit;\n                        return false;\n                    }\n                    if (__wn == __we)\n                        __double_or_nothing(__wb, __wn, __we);\n                    *__wn++ = *__b;\n                }\n            }\n            if (__wn == __wb.get())\n            {\n                __err |= ios_base::failbit;\n                return false;\n            }\n            }\n            break;\n        }\n    }\n    if (__trailing_sign)\n    {\n        for (unsigned __i = 1; __i < __trailing_sign->size(); ++__i, ++__b)\n        {\n            if (__b == __e || *__b != (*__trailing_sign)[__i])\n            {\n                __err |= ios_base::failbit;\n                return false;\n            }\n        }\n    }\n    if (__gb.get() != __gn)\n    {\n        ios_base::iostate __et = ios_base::goodbit;\n        __check_grouping(__grp, __gb.get(), __gn, __et);\n        if (__et)\n        {\n            __err |= ios_base::failbit;\n            return false;\n        }\n    }\n    return true;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nmoney_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                          bool __intl, ios_base& __iob,\n                                          ios_base::iostate& __err,\n                                          long double& __v) const\n{\n    const int __bz = 100;\n    char_type __wbuf[__bz];\n    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);\n    char_type* __wn;\n    char_type* __we = __wbuf + __bz;\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = false;\n    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,\n                 __wb, __wn, __we))\n    {\n        const char __src[] = \"0123456789\";\n        char_type __atoms[sizeof(__src)-1];\n        __ct.widen(__src, __src + (sizeof(__src)-1), __atoms);\n        char __nbuf[__bz];\n        char* __nc = __nbuf;\n        unique_ptr<char, void(*)(void*)> __h(0, free);\n        if (__wn - __wb.get() > __bz-2)\n        {\n            __h.reset((char*)malloc(static_cast<size_t>(__wn - __wb.get() + 2)));\n            if (__h.get() == 0)\n                __throw_bad_alloc();\n            __nc = __h.get();\n        }\n        if (__neg)\n            *__nc++ = '-';\n        for (const char_type* __w = __wb.get(); __w < __wn; ++__w, ++__nc)\n            *__nc = __src[find(__atoms, _VSTD::end(__atoms), *__w) - __atoms];\n        *__nc = char();\n        if (sscanf(__nbuf, \"%Lf\", &__v) != 1)\n            __throw_runtime_error(\"money_get error\");\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\ntemplate <class _CharT, class _InputIterator>\n_InputIterator\nmoney_get<_CharT, _InputIterator>::do_get(iter_type __b, iter_type __e,\n                                          bool __intl, ios_base& __iob,\n                                          ios_base::iostate& __err,\n                                          string_type& __v) const\n{\n    const int __bz = 100;\n    char_type __wbuf[__bz];\n    unique_ptr<char_type, void(*)(void*)> __wb(__wbuf, __do_nothing);\n    char_type* __wn;\n    char_type* __we = __wbuf + __bz;\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = false;\n    if (__do_get(__b, __e, __intl, __loc, __iob.flags(), __err, __neg, __ct,\n                 __wb, __wn, __we))\n    {\n        __v.clear();\n        if (__neg)\n            __v.push_back(__ct.widen('-'));\n        char_type __z = __ct.widen('0');\n        char_type* __w;\n        for (__w = __wb.get(); __w < __wn-1; ++__w)\n            if (*__w != __z)\n                break;\n        __v.append(__w, __wn);\n    }\n    if (__b == __e)\n        __err |= ios_base::eofbit;\n    return __b;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS money_get<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS money_get<wchar_t>)\n\n// money_put\n\ntemplate <class _CharT>\nclass __money_put\n{\nprotected:\n    typedef _CharT                  char_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE __money_put() {}\n\n    static void __gather_info(bool __intl, bool __neg, const locale& __loc,\n                              money_base::pattern& __pat, char_type& __dp,\n                              char_type& __ts, string& __grp,\n                              string_type& __sym, string_type& __sn,\n                              int& __fd);\n    static void __format(char_type* __mb, char_type*& __mi, char_type*& __me,\n                         ios_base::fmtflags __flags,\n                         const char_type* __db, const char_type* __de,\n                         const ctype<char_type>& __ct, bool __neg,\n                         const money_base::pattern& __pat, char_type __dp,\n                         char_type __ts, const string& __grp,\n                         const string_type& __sym, const string_type& __sn,\n                         int __fd);\n};\n\ntemplate <class _CharT>\nvoid\n__money_put<_CharT>::__gather_info(bool __intl, bool __neg, const locale& __loc,\n                                   money_base::pattern& __pat, char_type& __dp,\n                                   char_type& __ts, string& __grp,\n                                   string_type& __sym, string_type& __sn,\n                                   int& __fd)\n{\n    if (__intl)\n    {\n        const moneypunct<char_type, true>& __mp =\n            use_facet<moneypunct<char_type, true> >(__loc);\n        if (__neg)\n        {\n            __pat = __mp.neg_format();\n            __sn = __mp.negative_sign();\n        }\n        else\n        {\n            __pat = __mp.pos_format();\n            __sn = __mp.positive_sign();\n        }\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n    else\n    {\n        const moneypunct<char_type, false>& __mp =\n            use_facet<moneypunct<char_type, false> >(__loc);\n        if (__neg)\n        {\n            __pat = __mp.neg_format();\n            __sn = __mp.negative_sign();\n        }\n        else\n        {\n            __pat = __mp.pos_format();\n            __sn = __mp.positive_sign();\n        }\n        __dp = __mp.decimal_point();\n        __ts = __mp.thousands_sep();\n        __grp = __mp.grouping();\n        __sym = __mp.curr_symbol();\n        __fd = __mp.frac_digits();\n    }\n}\n\ntemplate <class _CharT>\nvoid\n__money_put<_CharT>::__format(char_type* __mb, char_type*& __mi, char_type*& __me,\n                              ios_base::fmtflags __flags,\n                              const char_type* __db, const char_type* __de,\n                              const ctype<char_type>& __ct, bool __neg,\n                              const money_base::pattern& __pat, char_type __dp,\n                              char_type __ts, const string& __grp,\n                              const string_type& __sym, const string_type& __sn,\n                              int __fd)\n{\n    __me = __mb;\n    for (unsigned __p = 0; __p < 4; ++__p)\n    {\n        switch (__pat.field[__p])\n        {\n        case money_base::none:\n            __mi = __me;\n            break;\n        case money_base::space:\n            __mi = __me;\n            *__me++ = __ct.widen(' ');\n            break;\n        case money_base::sign:\n            if (!__sn.empty())\n                *__me++ = __sn[0];\n            break;\n        case money_base::symbol:\n            if (!__sym.empty() && (__flags & ios_base::showbase))\n                __me = _VSTD::copy(__sym.begin(), __sym.end(), __me);\n            break;\n        case money_base::value:\n            {\n            // remember start of value so we can reverse it\n            char_type* __t = __me;\n            // find beginning of digits\n            if (__neg)\n                ++__db;\n            // find end of digits\n            const char_type* __d;\n            for (__d = __db; __d < __de; ++__d)\n                if (!__ct.is(ctype_base::digit, *__d))\n                    break;\n            // print fractional part\n            if (__fd > 0)\n            {\n                int __f;\n                for (__f = __fd; __d > __db && __f > 0; --__f)\n                    *__me++ = *--__d;\n                char_type __z = __f > 0 ? __ct.widen('0') : char_type();\n                for (; __f > 0; --__f)\n                    *__me++ = __z;\n                *__me++ = __dp;\n            }\n            // print units part\n            if (__d == __db)\n            {\n                *__me++ = __ct.widen('0');\n            }\n            else\n            {\n                unsigned __ng = 0;\n                unsigned __ig = 0;\n                unsigned __gl = __grp.empty() ? numeric_limits<unsigned>::max()\n                                              : static_cast<unsigned>(__grp[__ig]);\n                while (__d != __db)\n                {\n                    if (__ng == __gl)\n                    {\n                        *__me++ = __ts;\n                        __ng = 0;\n                        if (++__ig < __grp.size())\n                            __gl = __grp[__ig] == numeric_limits<char>::max() ?\n                                        numeric_limits<unsigned>::max() :\n                                        static_cast<unsigned>(__grp[__ig]);\n                    }\n                    *__me++ = *--__d;\n                    ++__ng;\n                }\n            }\n            // reverse it\n            reverse(__t, __me);\n            }\n            break;\n        }\n    }\n    // print rest of sign, if any\n    if (__sn.size() > 1)\n        __me = _VSTD::copy(__sn.begin()+1, __sn.end(), __me);\n    // set alignment\n    if ((__flags & ios_base::adjustfield) == ios_base::left)\n        __mi = __me;\n    else if ((__flags & ios_base::adjustfield) != ios_base::internal)\n        __mi = __mb;\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS __money_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS __money_put<wchar_t>)\n\ntemplate <class _CharT, class _OutputIterator = ostreambuf_iterator<_CharT> >\nclass _LIBCPP_TYPE_VIS_ONLY money_put\n    : public locale::facet,\n      private __money_put<_CharT>\n{\npublic:\n    typedef _CharT                  char_type;\n    typedef _OutputIterator         iter_type;\n    typedef basic_string<char_type> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit money_put(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,\n                  long double __units) const\n    {\n        return do_put(__s, __intl, __iob, __fl, __units);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    iter_type put(iter_type __s, bool __intl, ios_base& __iob, char_type __fl,\n                  const string_type& __digits) const\n    {\n        return do_put(__s, __intl, __iob, __fl, __digits);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~money_put() {}\n\n    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,\n                             char_type __fl, long double __units) const;\n    virtual iter_type do_put(iter_type __s, bool __intl, ios_base& __iob,\n                             char_type __fl, const string_type& __digits) const;\n};\n\ntemplate <class _CharT, class _OutputIterator>\nlocale::id\nmoney_put<_CharT, _OutputIterator>::id;\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nmoney_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,\n                                           ios_base& __iob, char_type __fl,\n                                           long double __units) const\n{\n    // convert to char\n    const size_t __bs = 100;\n    char __buf[__bs];\n    char* __bb = __buf;\n    char_type __digits[__bs];\n    char_type* __db = __digits;\n    size_t __n = static_cast<size_t>(snprintf(__bb, __bs, \"%.0Lf\", __units));\n    unique_ptr<char, void(*)(void*)> __hn(0, free);\n    unique_ptr<char_type, void(*)(void*)> __hd(0, free);\n    // secure memory for digit storage\n    if (__n > __bs-1)\n    {\n#ifdef _LIBCPP_LOCALE__L_EXTENSIONS\n        __n = static_cast<size_t>(asprintf_l(&__bb, _LIBCPP_GET_C_LOCALE, \"%.0Lf\", __units));\n#else\n        __n = __asprintf_l(&__bb, __cloc(), \"%.0Lf\", __units);\n#endif\n        if (__bb == 0)\n            __throw_bad_alloc();\n        __hn.reset(__bb);\n        __hd.reset((char_type*)malloc(__n * sizeof(char_type)));\n        if (__hd == nullptr)\n            __throw_bad_alloc();\n        __db = __hd.get();\n    }\n    // gather info\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    __ct.widen(__bb, __bb + __n, __db);\n    bool __neg = __n > 0 && __bb[0] == '-';\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __sn;\n    int __fd;\n    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    // secure memory for formatting\n    char_type __mbuf[__bs];\n    char_type* __mb = __mbuf;\n    unique_ptr<char_type, void(*)(void*)> __hw(0, free);\n    size_t __exn = static_cast<int>(__n) > __fd ?\n                   (__n - static_cast<size_t>(__fd)) * 2 + __sn.size() +\n                    __sym.size() + static_cast<size_t>(__fd) + 1\n                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;\n    if (__exn > __bs)\n    {\n        __hw.reset((char_type*)malloc(__exn * sizeof(char_type)));\n        __mb = __hw.get();\n        if (__mb == 0)\n            __throw_bad_alloc();\n    }\n    // format\n    char_type* __mi;\n    char_type* __me;\n    this->__format(__mb, __mi, __me, __iob.flags(),\n                   __db, __db + __n, __ct,\n                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);\n}\n\ntemplate <class _CharT, class _OutputIterator>\n_OutputIterator\nmoney_put<_CharT, _OutputIterator>::do_put(iter_type __s, bool __intl,\n                                           ios_base& __iob, char_type __fl,\n                                           const string_type& __digits) const\n{\n    // gather info\n    locale __loc = __iob.getloc();\n    const ctype<char_type>& __ct = use_facet<ctype<char_type> >(__loc);\n    bool __neg = __digits.size() > 0 && __digits[0] == __ct.widen('-');\n    money_base::pattern __pat;\n    char_type __dp;\n    char_type __ts;\n    string __grp;\n    string_type __sym;\n    string_type __sn;\n    int __fd;\n    this->__gather_info(__intl, __neg, __loc, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    // secure memory for formatting\n    char_type __mbuf[100];\n    char_type* __mb = __mbuf;\n    unique_ptr<char_type, void(*)(void*)> __h(0, free);\n    size_t __exn = static_cast<int>(__digits.size()) > __fd ?\n                   (__digits.size() - static_cast<size_t>(__fd)) * 2 +\n                    __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 1\n                 : __sn.size() + __sym.size() + static_cast<size_t>(__fd) + 2;\n    if (__exn > 100)\n    {\n        __h.reset((char_type*)malloc(__exn * sizeof(char_type)));\n        __mb = __h.get();\n        if (__mb == 0)\n            __throw_bad_alloc();\n    }\n    // format\n    char_type* __mi;\n    char_type* __me;\n    this->__format(__mb, __mi, __me, __iob.flags(),\n                   __digits.data(), __digits.data() + __digits.size(), __ct,\n                   __neg, __pat, __dp, __ts, __grp, __sym, __sn, __fd);\n    return __pad_and_output(__s, __mb, __mi, __me, __iob, __fl);\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS money_put<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS money_put<wchar_t>)\n\n// messages\n\nclass _LIBCPP_TYPE_VIS messages_base\n{\npublic:\n    typedef ptrdiff_t catalog;\n\n    _LIBCPP_ALWAYS_INLINE messages_base() {}\n};\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS_ONLY messages\n    : public locale::facet,\n      public messages_base\n{\npublic:\n    typedef _CharT               char_type;\n    typedef basic_string<_CharT> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages(size_t __refs = 0)\n        : locale::facet(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    catalog open(const basic_string<char>& __nm, const locale& __loc) const\n    {\n        return do_open(__nm, __loc);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    string_type get(catalog __c, int __set, int __msgid,\n                    const string_type& __dflt) const\n    {\n        return do_get(__c, __set, __msgid, __dflt);\n    }\n\n    _LIBCPP_ALWAYS_INLINE\n    void close(catalog __c) const\n    {\n        do_close(__c);\n    }\n\n    static locale::id id;\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~messages() {}\n\n    virtual catalog do_open(const basic_string<char>&, const locale&) const;\n    virtual string_type do_get(catalog, int __set, int __msgid,\n                               const string_type& __dflt) const;\n    virtual void do_close(catalog) const;\n};\n\ntemplate <class _CharT>\nlocale::id\nmessages<_CharT>::id;\n\ntemplate <class _CharT>\ntypename messages<_CharT>::catalog\nmessages<_CharT>::do_open(const basic_string<char>& __nm, const locale&) const\n{\n#if defined(_WIN32) || defined(__ANDROID__) || defined(_NEWLIB_VERSION)\n    return -1;\n#else // _WIN32 || __ANDROID__\n    catalog __cat = (catalog)catopen(__nm.c_str(), NL_CAT_LOCALE);\n    if (__cat != -1)\n        __cat = static_cast<catalog>((static_cast<size_t>(__cat) >> 1));\n    return __cat;\n#endif // _WIN32 || __ANDROID__\n}\n\ntemplate <class _CharT>\ntypename messages<_CharT>::string_type\nmessages<_CharT>::do_get(catalog __c, int __set, int __msgid,\n                         const string_type& __dflt) const\n{\n#if defined(_WIN32) || defined(__ANDROID__) || defined(_NEWLIB_VERSION)\n    return __dflt;\n#else // _WIN32\n    string __ndflt;\n    __narrow_to_utf8<sizeof(char_type)*__CHAR_BIT__>()(back_inserter(__ndflt),\n                                                       __dflt.c_str(),\n                                                       __dflt.c_str() + __dflt.size());\n    if (__c != -1)\n        __c <<= 1;\n    nl_catd __cat = (nl_catd)__c;\n    char* __n = catgets(__cat, __set, __msgid, __ndflt.c_str());\n    string_type __w;\n    __widen_from_utf8<sizeof(char_type)*__CHAR_BIT__>()(back_inserter(__w),\n                                                        __n, __n + strlen(__n));\n    return __w;\n#endif // _WIN32\n}\n\ntemplate <class _CharT>\nvoid\nmessages<_CharT>::do_close(catalog __c) const\n{\n#if !defined(_WIN32) && !defined(__ANDROID__) && !defined(_NEWLIB_VERSION)\n    if (__c != -1)\n        __c <<= 1;\n    nl_catd __cat = (nl_catd)__c;\n    catclose(__cat);\n#endif // !_WIN32\n}\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS messages<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS messages<wchar_t>)\n\ntemplate <class _CharT>\nclass _LIBCPP_TYPE_VIS_ONLY messages_byname\n    : public messages<_CharT>\n{\npublic:\n    typedef messages_base::catalog catalog;\n    typedef basic_string<_CharT> string_type;\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages_byname(const char*, size_t __refs = 0)\n        : messages<_CharT>(__refs) {}\n\n    _LIBCPP_ALWAYS_INLINE\n    explicit messages_byname(const string&, size_t __refs = 0)\n        : messages<_CharT>(__refs) {}\n\nprotected:\n    _LIBCPP_ALWAYS_INLINE\n    ~messages_byname() {}\n};\n\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS messages_byname<char>)\n_LIBCPP_EXTERN_TEMPLATE2(class _LIBCPP_TYPE_VIS messages_byname<wchar_t>)\n\ntemplate<class _Codecvt, class _Elem = wchar_t,\n         class _Wide_alloc = allocator<_Elem>,\n         class _Byte_alloc = allocator<char> >\nclass _LIBCPP_TYPE_VIS_ONLY wstring_convert\n{\npublic:\n    typedef basic_string<char, char_traits<char>, _Byte_alloc>   byte_string;\n    typedef basic_string<_Elem, char_traits<_Elem>, _Wide_alloc> wide_string;\n    typedef typename _Codecvt::state_type                        state_type;\n    typedef typename wide_string::traits_type::int_type          int_type;\n\nprivate:\n    byte_string __byte_err_string_;\n    wide_string __wide_err_string_;\n    _Codecvt* __cvtptr_;\n    state_type __cvtstate_;\n    size_t __cvtcount_;\n\n    wstring_convert(const wstring_convert& __wc);\n    wstring_convert& operator=(const wstring_convert& __wc);\npublic:\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wstring_convert(_Codecvt* __pcvt = new _Codecvt);\n    wstring_convert(_Codecvt* __pcvt, state_type __state);\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wstring_convert(const byte_string& __byte_err,\n                    const wide_string& __wide_err = wide_string());\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n    wstring_convert(wstring_convert&& __wc);\n#endif\n    ~wstring_convert();\n\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(char __byte)\n        {return from_bytes(&__byte, &__byte+1);}\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(const char* __ptr)\n        {return from_bytes(__ptr, __ptr + char_traits<char>::length(__ptr));}\n    _LIBCPP_ALWAYS_INLINE\n    wide_string from_bytes(const byte_string& __str)\n        {return from_bytes(__str.data(), __str.data() + __str.size());}\n    wide_string from_bytes(const char* __first, const char* __last);\n\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(_Elem __wchar)\n        {return to_bytes(&__wchar, &__wchar+1);}\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(const _Elem* __wptr)\n        {return to_bytes(__wptr, __wptr + char_traits<_Elem>::length(__wptr));}\n    _LIBCPP_ALWAYS_INLINE\n    byte_string to_bytes(const wide_string& __wstr)\n        {return to_bytes(__wstr.data(), __wstr.data() + __wstr.size());}\n    byte_string to_bytes(const _Elem* __first, const _Elem* __last);\n\n    _LIBCPP_ALWAYS_INLINE\n    size_t converted() const _NOEXCEPT {return __cvtcount_;}\n    _LIBCPP_ALWAYS_INLINE\n    state_type state() const {return __cvtstate_;}\n};\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline _LIBCPP_ALWAYS_INLINE\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(_Codecvt* __pcvt)\n        : __cvtptr_(__pcvt), __cvtstate_(), __cvtcount_(0)\n{\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline _LIBCPP_ALWAYS_INLINE\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(_Codecvt* __pcvt, state_type __state)\n        : __cvtptr_(__pcvt), __cvtstate_(__state), __cvtcount_(0)\n{\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(const byte_string& __byte_err, const wide_string& __wide_err)\n        : __byte_err_string_(__byte_err), __wide_err_string_(__wide_err),\n          __cvtstate_(), __cvtcount_(0)\n{\n    __cvtptr_ = new _Codecvt;\n}\n\n#ifndef _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ninline _LIBCPP_ALWAYS_INLINE\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    wstring_convert(wstring_convert&& __wc)\n        : __byte_err_string_(_VSTD::move(__wc.__byte_err_string_)),\n          __wide_err_string_(_VSTD::move(__wc.__wide_err_string_)),\n          __cvtptr_(__wc.__cvtptr_),\n          __cvtstate_(__wc.__cvtstate_), __cvtcount_(__wc.__cvtstate_)\n{\n    __wc.__cvtptr_ = nullptr;\n}\n\n#endif  // _LIBCPP_HAS_NO_RVALUE_REFERENCES\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::~wstring_convert()\n{\n    delete __cvtptr_;\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ntypename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::wide_string\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    from_bytes(const char* __frm, const char* __frm_end)\n{\n    __cvtcount_ = 0;\n    if (__cvtptr_ != nullptr)\n    {\n        wide_string __ws(2*(__frm_end - __frm), _Elem());\n        if (__frm != __frm_end)\n            __ws.resize(__ws.capacity());\n        codecvt_base::result __r = codecvt_base::ok;\n        state_type __st = __cvtstate_;\n        if (__frm != __frm_end)\n        {\n            _Elem* __to = &__ws[0];\n            _Elem* __to_end = __to + __ws.size();\n            const char* __frm_nxt;\n            do\n            {\n                _Elem* __to_nxt;\n                __r = __cvtptr_->in(__st, __frm, __frm_end, __frm_nxt,\n                                          __to, __to_end, __to_nxt);\n                __cvtcount_ += __frm_nxt - __frm;\n                if (__frm_nxt == __frm)\n                {\n                    __r = codecvt_base::error;\n                }\n                else if (__r == codecvt_base::noconv)\n                {\n                    __ws.resize(__to - &__ws[0]);\n                    // This only gets executed if _Elem is char\n                    __ws.append((const _Elem*)__frm, (const _Elem*)__frm_end);\n                    __frm = __frm_nxt;\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __ws.resize(__to_nxt - &__ws[0]);\n                    __frm = __frm_nxt;\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __s = __to_nxt - &__ws[0];\n                    __ws.resize(2 * __s);\n                    __to = &__ws[0] + __s;\n                    __to_end = &__ws[0] + __ws.size();\n                    __frm = __frm_nxt;\n                }\n            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);\n        }\n        if (__r == codecvt_base::ok)\n            return __ws;\n    }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__wide_err_string_.empty())\n        throw range_error(\"wstring_convert: from_bytes error\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __wide_err_string_;\n}\n\ntemplate<class _Codecvt, class _Elem, class _Wide_alloc, class _Byte_alloc>\ntypename wstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::byte_string\nwstring_convert<_Codecvt, _Elem, _Wide_alloc, _Byte_alloc>::\n    to_bytes(const _Elem* __frm, const _Elem* __frm_end)\n{\n    __cvtcount_ = 0;\n    if (__cvtptr_ != nullptr)\n    {\n        byte_string __bs(2*(__frm_end - __frm), char());\n        if (__frm != __frm_end)\n            __bs.resize(__bs.capacity());\n        codecvt_base::result __r = codecvt_base::ok;\n        state_type __st = __cvtstate_;\n        if (__frm != __frm_end)\n        {\n            char* __to = &__bs[0];\n            char* __to_end = __to + __bs.size();\n            const _Elem* __frm_nxt;\n            do\n            {\n                char* __to_nxt;\n                __r = __cvtptr_->out(__st, __frm, __frm_end, __frm_nxt,\n                                           __to, __to_end, __to_nxt);\n                __cvtcount_ += __frm_nxt - __frm;\n                if (__frm_nxt == __frm)\n                {\n                    __r = codecvt_base::error;\n                }\n                else if (__r == codecvt_base::noconv)\n                {\n                    __bs.resize(__to - &__bs[0]);\n                    // This only gets executed if _Elem is char\n                    __bs.append((const char*)__frm, (const char*)__frm_end);\n                    __frm = __frm_nxt;\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __bs.resize(__to_nxt - &__bs[0]);\n                    __frm = __frm_nxt;\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __s = __to_nxt - &__bs[0];\n                    __bs.resize(2 * __s);\n                    __to = &__bs[0] + __s;\n                    __to_end = &__bs[0] + __bs.size();\n                    __frm = __frm_nxt;\n                }\n            } while (__r == codecvt_base::partial && __frm_nxt < __frm_end);\n        }\n        if (__r == codecvt_base::ok)\n        {\n            size_t __s = __bs.size();\n            __bs.resize(__bs.capacity());\n            char* __to = &__bs[0] + __s;\n            char* __to_end = __to + __bs.size();\n            do\n            {\n                char* __to_nxt;\n                __r = __cvtptr_->unshift(__st, __to, __to_end, __to_nxt);\n                if (__r == codecvt_base::noconv)\n                {\n                    __bs.resize(__to - &__bs[0]);\n                    __r = codecvt_base::ok;\n                }\n                else if (__r == codecvt_base::ok)\n                {\n                    __bs.resize(__to_nxt - &__bs[0]);\n                }\n                else if (__r == codecvt_base::partial)\n                {\n                    ptrdiff_t __sp = __to_nxt - &__bs[0];\n                    __bs.resize(2 * __sp);\n                    __to = &__bs[0] + __sp;\n                    __to_end = &__bs[0] + __bs.size();\n                }\n            } while (__r == codecvt_base::partial);\n            if (__r == codecvt_base::ok)\n                return __bs;\n        }\n    }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    if (__byte_err_string_.empty())\n        throw range_error(\"wstring_convert: to_bytes error\");\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __byte_err_string_;\n}\n\ntemplate <class _Codecvt, class _Elem = wchar_t, class _Tr = char_traits<_Elem> >\nclass _LIBCPP_TYPE_VIS_ONLY wbuffer_convert\n    : public basic_streambuf<_Elem, _Tr>\n{\npublic:\n    // types:\n    typedef _Elem                          char_type;\n    typedef _Tr                            traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n    typedef typename _Codecvt::state_type  state_type;\n\nprivate:\n    char*       __extbuf_;\n    const char* __extbufnext_;\n    const char* __extbufend_;\n    char __extbuf_min_[8];\n    size_t __ebs_;\n    char_type* __intbuf_;\n    size_t __ibs_;\n    streambuf* __bufptr_;\n    _Codecvt* __cv_;\n    state_type __st_;\n    ios_base::openmode __cm_;\n    bool __owns_eb_;\n    bool __owns_ib_;\n    bool __always_noconv_;\n\n    wbuffer_convert(const wbuffer_convert&);\n    wbuffer_convert& operator=(const wbuffer_convert&);\npublic:\n    _LIBCPP_EXPLICIT_AFTER_CXX11 wbuffer_convert(streambuf* __bytebuf = 0, \n            _Codecvt* __pcvt = new _Codecvt, state_type __state = state_type());\n    ~wbuffer_convert();\n\n    _LIBCPP_INLINE_VISIBILITY\n    streambuf* rdbuf() const {return __bufptr_;}\n    _LIBCPP_INLINE_VISIBILITY\n    streambuf* rdbuf(streambuf* __bytebuf)\n    {\n        streambuf* __r = __bufptr_;\n        __bufptr_ = __bytebuf;\n        return __r;\n    }\n\n    _LIBCPP_INLINE_VISIBILITY\n    state_type state() const {return __st_;}\n\nprotected:\n    virtual int_type underflow();\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n    virtual int_type overflow (int_type __c = traits_type::eof());\n    virtual basic_streambuf<char_type, traits_type>* setbuf(char_type* __s,\n                                                            streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __wch = ios_base::in | ios_base::out);\n    virtual int sync();\n\nprivate:\n    bool __read_mode();\n    void __write_mode();\n    wbuffer_convert* __close();\n};\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>::\n    wbuffer_convert(streambuf* __bytebuf, _Codecvt* __pcvt, state_type __state)\n    : __extbuf_(0),\n      __extbufnext_(0),\n      __extbufend_(0),\n      __ebs_(0),\n      __intbuf_(0),\n      __ibs_(0),\n      __bufptr_(__bytebuf),\n      __cv_(__pcvt),\n      __st_(__state),\n      __cm_(0),\n      __owns_eb_(false),\n      __owns_ib_(false),\n      __always_noconv_(__cv_ ? __cv_->always_noconv() : false)\n{\n    setbuf(0, 4096);\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>::~wbuffer_convert()\n{\n    __close();\n    delete __cv_;\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::underflow()\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return traits_type::eof();\n    bool __initial = __read_mode();\n    char_type __1buf;\n    if (this->gptr() == 0)\n        this->setg(&__1buf, &__1buf+1, &__1buf+1);\n    const size_t __unget_sz = __initial ? 0 : min<size_t>((this->egptr() - this->eback()) / 2, 4);\n    int_type __c = traits_type::eof();\n    if (this->gptr() == this->egptr())\n    {\n        memmove(this->eback(), this->egptr() - __unget_sz, __unget_sz * sizeof(char_type));\n        if (__always_noconv_)\n        {\n            streamsize __nmemb = static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz);\n            __nmemb = __bufptr_->sgetn((char*)this->eback() + __unget_sz, __nmemb);\n            if (__nmemb != 0)\n            {\n                this->setg(this->eback(),\n                           this->eback() + __unget_sz,\n                           this->eback() + __unget_sz + __nmemb);\n                __c = *this->gptr();\n            }\n        }\n        else\n        {\n            memmove(__extbuf_, __extbufnext_, __extbufend_ - __extbufnext_);\n            __extbufnext_ = __extbuf_ + (__extbufend_ - __extbufnext_);\n            __extbufend_ = __extbuf_ + (__extbuf_ == __extbuf_min_ ? sizeof(__extbuf_min_) : __ebs_);\n            streamsize __nmemb = _VSTD::min(static_cast<streamsize>(this->egptr() - this->eback() - __unget_sz),\n                                 static_cast<streamsize>(__extbufend_ - __extbufnext_));\n            codecvt_base::result __r;\n            state_type __svs = __st_;\n            streamsize __nr = __bufptr_->sgetn(const_cast<char*>(__extbufnext_), __nmemb);\n            if (__nr != 0)\n            {\n                __extbufend_ = __extbufnext_ + __nr;\n                char_type*  __inext;\n                __r = __cv_->in(__st_, __extbuf_, __extbufend_, __extbufnext_,\n                                       this->eback() + __unget_sz,\n                                       this->egptr(), __inext);\n                if (__r == codecvt_base::noconv)\n                {\n                    this->setg((char_type*)__extbuf_, (char_type*)__extbuf_, (char_type*)__extbufend_);\n                    __c = *this->gptr();\n                }\n                else if (__inext != this->eback() + __unget_sz)\n                {\n                    this->setg(this->eback(), this->eback() + __unget_sz, __inext);\n                    __c = *this->gptr();\n                }\n            }\n        }\n    }\n    else\n        __c = *this->gptr();\n    if (this->eback() == &__1buf)\n        this->setg(0, 0, 0);\n    return __c;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::pbackfail(int_type __c)\n{\n    if (__cv_ != 0 && __bufptr_ != 0 && this->eback() < this->gptr())\n    {\n        if (traits_type::eq_int_type(__c, traits_type::eof()))\n        {\n            this->gbump(-1);\n            return traits_type::not_eof(__c);\n        }\n        if (traits_type::eq(traits_type::to_char_type(__c), this->gptr()[-1]))\n        {\n            this->gbump(-1);\n            *this->gptr() = traits_type::to_char_type(__c);\n            return __c;\n        }\n    }\n    return traits_type::eof();\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::int_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::overflow(int_type __c)\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return traits_type::eof();\n    __write_mode();\n    char_type __1buf;\n    char_type* __pb_save = this->pbase();\n    char_type* __epb_save = this->epptr();\n    if (!traits_type::eq_int_type(__c, traits_type::eof()))\n    {\n        if (this->pptr() == 0)\n            this->setp(&__1buf, &__1buf+1);\n        *this->pptr() = traits_type::to_char_type(__c);\n        this->pbump(1);\n    }\n    if (this->pptr() != this->pbase())\n    {\n        if (__always_noconv_)\n        {\n            streamsize __nmemb = static_cast<streamsize>(this->pptr() - this->pbase());\n            if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)\n                return traits_type::eof();\n        }\n        else\n        {\n            char* __extbe = __extbuf_;\n            codecvt_base::result __r;\n            do\n            {\n                const char_type* __e;\n                __r = __cv_->out(__st_, this->pbase(), this->pptr(), __e,\n                                        __extbuf_, __extbuf_ + __ebs_, __extbe);\n                if (__e == this->pbase())\n                    return traits_type::eof();\n                if (__r == codecvt_base::noconv)\n                {\n                    streamsize __nmemb = static_cast<size_t>(this->pptr() - this->pbase());\n                    if (__bufptr_->sputn((const char*)this->pbase(), __nmemb) != __nmemb)\n                        return traits_type::eof();\n                }\n                else if (__r == codecvt_base::ok || __r == codecvt_base::partial)\n                {\n                    streamsize __nmemb = static_cast<size_t>(__extbe - __extbuf_);\n                    if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)\n                        return traits_type::eof();\n                    if (__r == codecvt_base::partial)\n                    {\n                        this->setp((char_type*)__e, this->pptr());\n                        this->pbump(this->epptr() - this->pbase());\n                    }\n                }\n                else\n                    return traits_type::eof();\n            } while (__r == codecvt_base::partial);\n        }\n        this->setp(__pb_save, __epb_save);\n    }\n    return traits_type::not_eof(__c);\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nbasic_streambuf<_Elem, _Tr>*\nwbuffer_convert<_Codecvt, _Elem, _Tr>::setbuf(char_type* __s, streamsize __n)\n{\n    this->setg(0, 0, 0);\n    this->setp(0, 0);\n    if (__owns_eb_)\n        delete [] __extbuf_;\n    if (__owns_ib_)\n        delete [] __intbuf_;\n    __ebs_ = __n;\n    if (__ebs_ > sizeof(__extbuf_min_))\n    {\n        if (__always_noconv_ && __s)\n        {\n            __extbuf_ = (char*)__s;\n            __owns_eb_ = false;\n        }\n        else\n        {\n            __extbuf_ = new char[__ebs_];\n            __owns_eb_ = true;\n        }\n    }\n    else\n    {\n        __extbuf_ = __extbuf_min_;\n        __ebs_ = sizeof(__extbuf_min_);\n        __owns_eb_ = false;\n    }\n    if (!__always_noconv_)\n    {\n        __ibs_ = max<streamsize>(__n, sizeof(__extbuf_min_));\n        if (__s && __ibs_ >= sizeof(__extbuf_min_))\n        {\n            __intbuf_ = __s;\n            __owns_ib_ = false;\n        }\n        else\n        {\n            __intbuf_ = new char_type[__ibs_];\n            __owns_ib_ = true;\n        }\n    }\n    else\n    {\n        __ibs_ = 0;\n        __intbuf_ = 0;\n        __owns_ib_ = false;\n    }\n    return this;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::seekoff(off_type __off, ios_base::seekdir __way,\n                                        ios_base::openmode __om)\n{\n    int __width = __cv_->encoding();\n    if (__cv_ == 0 || __bufptr_ == 0 || (__width <= 0 && __off != 0) || sync())\n        return pos_type(off_type(-1));\n    // __width > 0 || __off == 0\n    switch (__way)\n    {\n    case ios_base::beg:\n        break;\n    case ios_base::cur:\n        break;\n    case ios_base::end:\n        break;\n    default:\n        return pos_type(off_type(-1));\n    }\n    pos_type __r = __bufptr_->pubseekoff(__width * __off, __way, __om);\n    __r.state(__st_);\n    return __r;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\ntypename wbuffer_convert<_Codecvt, _Elem, _Tr>::pos_type\nwbuffer_convert<_Codecvt, _Elem, _Tr>::seekpos(pos_type __sp, ios_base::openmode __wch)\n{\n    if (__cv_ == 0 || __bufptr_ == 0 || sync())\n        return pos_type(off_type(-1));\n    if (__bufptr_->pubseekpos(__sp, __wch) == pos_type(off_type(-1)))\n        return pos_type(off_type(-1));\n    return __sp;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nint\nwbuffer_convert<_Codecvt, _Elem, _Tr>::sync()\n{\n    if (__cv_ == 0 || __bufptr_ == 0)\n        return 0;\n    if (__cm_ & ios_base::out)\n    {\n        if (this->pptr() != this->pbase())\n            if (overflow() == traits_type::eof())\n                return -1;\n        codecvt_base::result __r;\n        do\n        {\n            char* __extbe;\n            __r = __cv_->unshift(__st_, __extbuf_, __extbuf_ + __ebs_, __extbe);\n            streamsize __nmemb = static_cast<streamsize>(__extbe - __extbuf_);\n            if (__bufptr_->sputn(__extbuf_, __nmemb) != __nmemb)\n                return -1;\n        } while (__r == codecvt_base::partial);\n        if (__r == codecvt_base::error)\n            return -1;\n        if (__bufptr_->pubsync())\n            return -1;\n    }\n    else if (__cm_ & ios_base::in)\n    {\n        off_type __c;\n        if (__always_noconv_)\n            __c = this->egptr() - this->gptr();\n        else\n        {\n            int __width = __cv_->encoding();\n            __c = __extbufend_ - __extbufnext_;\n            if (__width > 0)\n                __c += __width * (this->egptr() - this->gptr());\n            else\n            {\n                if (this->gptr() != this->egptr())\n                {\n                    reverse(this->gptr(), this->egptr());\n                    codecvt_base::result __r;\n                    const char_type* __e = this->gptr();\n                    char* __extbe;\n                    do\n                    {\n                        __r = __cv_->out(__st_, __e, this->egptr(), __e,\n                                         __extbuf_, __extbuf_ + __ebs_, __extbe);\n                        switch (__r)\n                        {\n                        case codecvt_base::noconv:\n                            __c += this->egptr() - this->gptr();\n                            break;\n                        case codecvt_base::ok:\n                        case codecvt_base::partial:\n                            __c += __extbe - __extbuf_;\n                            break;\n                        default:\n                            return -1;\n                        }\n                    } while (__r == codecvt_base::partial);\n                }\n            }\n        }\n        if (__bufptr_->pubseekoff(-__c, ios_base::cur, __cm_) == pos_type(off_type(-1)))\n            return -1;\n        this->setg(0, 0, 0);\n        __cm_ = 0;\n    }\n    return 0;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nbool\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__read_mode()\n{\n    if (!(__cm_ & ios_base::in))\n    {\n        this->setp(0, 0);\n        if (__always_noconv_)\n            this->setg((char_type*)__extbuf_,\n                       (char_type*)__extbuf_ + __ebs_,\n                       (char_type*)__extbuf_ + __ebs_);\n        else\n            this->setg(__intbuf_, __intbuf_ + __ibs_, __intbuf_ + __ibs_);\n        __cm_ = ios_base::in;\n        return true;\n    }\n    return false;\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nvoid\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__write_mode()\n{\n    if (!(__cm_ & ios_base::out))\n    {\n        this->setg(0, 0, 0);\n        if (__ebs_ > sizeof(__extbuf_min_))\n        {\n            if (__always_noconv_)\n                this->setp((char_type*)__extbuf_,\n                           (char_type*)__extbuf_ + (__ebs_ - 1));\n            else\n                this->setp(__intbuf_, __intbuf_ + (__ibs_ - 1));\n        }\n        else\n            this->setp(0, 0);\n        __cm_ = ios_base::out;\n    }\n}\n\ntemplate <class _Codecvt, class _Elem, class _Tr>\nwbuffer_convert<_Codecvt, _Elem, _Tr>*\nwbuffer_convert<_Codecvt, _Elem, _Tr>::__close()\n{\n    wbuffer_convert* __rt = 0;\n    if (__cv_ != 0 && __bufptr_ != 0)\n    {\n        __rt = this;\n        if ((__cm_ & ios_base::out) && sync())\n            __rt = 0;\n    }\n    return __rt;\n}\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_LOCALE\n","// -*- C++ -*-\n//===------------------------- streambuf ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_STEAMBUF\n#define _LIBCPP_STEAMBUF\n\n/*\n    streambuf synopsis\n\nnamespace std\n{\n\ntemplate <class charT, class traits = char_traits<charT> >\nclass basic_streambuf\n{\npublic:\n    // types:\n    typedef charT char_type;\n    typedef traits traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    virtual ~basic_streambuf();\n\n    // 27.6.2.2.1 locales:\n    locale pubimbue(const locale& loc);\n    locale getloc() const;\n\n    // 27.6.2.2.2 buffer and positioning:\n    basic_streambuf* pubsetbuf(char_type* s, streamsize n);\n    pos_type pubseekoff(off_type off, ios_base::seekdir way,\n                        ios_base::openmode which = ios_base::in | ios_base::out);\n    pos_type pubseekpos(pos_type sp,\n                        ios_base::openmode which = ios_base::in | ios_base::out);\n    int pubsync();\n\n    // Get and put areas:\n    // 27.6.2.2.3 Get area:\n    streamsize in_avail();\n    int_type snextc();\n    int_type sbumpc();\n    int_type sgetc();\n    streamsize sgetn(char_type* s, streamsize n);\n\n    // 27.6.2.2.4 Putback:\n    int_type sputbackc(char_type c);\n    int_type sungetc();\n\n    // 27.6.2.2.5 Put area:\n    int_type sputc(char_type c);\n    streamsize sputn(const char_type* s, streamsize n);\n\nprotected:\n    basic_streambuf();\n    basic_streambuf(const basic_streambuf& rhs);\n    basic_streambuf& operator=(const basic_streambuf& rhs);\n    void swap(basic_streambuf& rhs);\n\n    // 27.6.2.3.2 Get area:\n    char_type* eback() const;\n    char_type* gptr() const;\n    char_type* egptr() const;\n    void gbump(int n);\n    void setg(char_type* gbeg, char_type* gnext, char_type* gend);\n\n    // 27.6.2.3.3 Put area:\n    char_type* pbase() const;\n    char_type* pptr() const;\n    char_type* epptr() const;\n    void pbump(int n);\n    void setp(char_type* pbeg, char_type* pend);\n\n    // 27.6.2.4 virtual functions:\n    // 27.6.2.4.1 Locales:\n    virtual void imbue(const locale& loc);\n\n    // 27.6.2.4.2 Buffer management and positioning:\n    virtual basic_streambuf* setbuf(char_type* s, streamsize n);\n    virtual pos_type seekoff(off_type off, ios_base::seekdir way,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type sp,\n                             ios_base::openmode which = ios_base::in | ios_base::out);\n    virtual int sync();\n\n    // 27.6.2.4.3 Get area:\n    virtual streamsize showmanyc();\n    virtual streamsize xsgetn(char_type* s, streamsize n);\n    virtual int_type underflow();\n    virtual int_type uflow();\n\n    // 27.6.2.4.4 Putback:\n    virtual int_type pbackfail(int_type c = traits_type::eof());\n\n    // 27.6.2.4.5 Put area:\n    virtual streamsize xsputn(const char_type* s, streamsize n);\n    virtual int_type overflow (int_type c = traits_type::eof());\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <iosfwd>\n#include <ios>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\ntemplate <class _CharT, class _Traits>\nclass _LIBCPP_TYPE_VIS_ONLY basic_streambuf\n{\npublic:\n    // types:\n    typedef _CharT                         char_type;\n    typedef _Traits                        traits_type;\n    typedef typename traits_type::int_type int_type;\n    typedef typename traits_type::pos_type pos_type;\n    typedef typename traits_type::off_type off_type;\n\n    virtual ~basic_streambuf();\n\n    // 27.6.2.2.1 locales:\n    locale pubimbue(const locale& __loc);\n    locale getloc() const;\n\n    // 27.6.2.2.2 buffer and positioning:\n    basic_streambuf* pubsetbuf(char_type* __s, streamsize __n);\n    pos_type pubseekoff(off_type __off, ios_base::seekdir __way,\n                        ios_base::openmode __which = ios_base::in | ios_base::out);\n    pos_type pubseekpos(pos_type __sp,\n                        ios_base::openmode __which = ios_base::in | ios_base::out);\n    int pubsync();\n\n    // Get and put areas:\n    // 27.6.2.2.3 Get area:\n    streamsize in_avail();\n    int_type snextc();\n    int_type sbumpc();\n    int_type sgetc();\n    streamsize sgetn(char_type* __s, streamsize __n);\n\n    // 27.6.2.2.4 Putback:\n    int_type sputbackc(char_type __c);\n    int_type sungetc();\n\n    // 27.6.2.2.5 Put area:\n    int_type sputc(char_type __c);\n    streamsize sputn(const char_type* __s, streamsize __n);\n\nprotected:\n    basic_streambuf();\n    basic_streambuf(const basic_streambuf& __rhs);\n    basic_streambuf& operator=(const basic_streambuf& __rhs);\n    void swap(basic_streambuf& __rhs);\n\n    // 27.6.2.3.2 Get area:\n    _LIBCPP_ALWAYS_INLINE char_type* eback() const {return __binp_;}\n    _LIBCPP_ALWAYS_INLINE char_type* gptr()  const {return __ninp_;}\n    _LIBCPP_ALWAYS_INLINE char_type* egptr() const {return __einp_;}\n    void gbump(int __n);\n    void setg(char_type* __gbeg, char_type* __gnext, char_type* __gend);\n\n    // 27.6.2.3.3 Put area:\n    _LIBCPP_ALWAYS_INLINE char_type* pbase() const {return __bout_;}\n    _LIBCPP_ALWAYS_INLINE char_type* pptr()  const {return __nout_;}\n    _LIBCPP_ALWAYS_INLINE char_type* epptr() const {return __eout_;}\n    void pbump(int __n);\n    void setp(char_type* __pbeg, char_type* __pend);\n\n    // 27.6.2.4 virtual functions:\n    // 27.6.2.4.1 Locales:\n    virtual void imbue(const locale& __loc);\n\n    // 27.6.2.4.2 Buffer management and positioning:\n    virtual basic_streambuf* setbuf(char_type* __s, streamsize __n);\n    virtual pos_type seekoff(off_type __off, ios_base::seekdir __way,\n                             ios_base::openmode __which = ios_base::in | ios_base::out);\n    virtual pos_type seekpos(pos_type __sp,\n                             ios_base::openmode __which = ios_base::in | ios_base::out);\n    virtual int sync();\n\n    // 27.6.2.4.3 Get area:\n    virtual streamsize showmanyc();\n    virtual streamsize xsgetn(char_type* __s, streamsize __n);\n    virtual int_type underflow();\n    virtual int_type uflow();\n\n    // 27.6.2.4.4 Putback:\n    virtual int_type pbackfail(int_type __c = traits_type::eof());\n\n    // 27.6.2.4.5 Put area:\n    virtual streamsize xsputn(const char_type* __s, streamsize __n);\n    virtual int_type overflow(int_type __c = traits_type::eof());\n\nprivate:\n    locale __loc_;\n    char_type* __binp_;\n    char_type* __ninp_;\n    char_type* __einp_;\n    char_type* __bout_;\n    char_type* __nout_;\n    char_type* __eout_;\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::~basic_streambuf()\n{\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale\nbasic_streambuf<_CharT, _Traits>::pubimbue(const locale& __loc)\n{\n    imbue(__loc);\n    locale __r = __loc_;\n    __loc_ = __loc;\n    return __r;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nlocale\nbasic_streambuf<_CharT, _Traits>::getloc() const\n{\n    return __loc_;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nbasic_streambuf<_CharT, _Traits>*\nbasic_streambuf<_CharT, _Traits>::pubsetbuf(char_type* __s, streamsize __n)\n{\n    return setbuf(__s, __n);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::pubseekoff(off_type __off,\n                                             ios_base::seekdir __way,\n                                             ios_base::openmode __which)\n{\n    return seekoff(__off, __way, __which);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::pubseekpos(pos_type __sp,\n                                             ios_base::openmode __which)\n{\n    return seekpos(__sp, __which);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nint\nbasic_streambuf<_CharT, _Traits>::pubsync()\n{\n    return sync();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nbasic_streambuf<_CharT, _Traits>::in_avail()\n{\n    if (__ninp_ < __einp_)\n        return static_cast<streamsize>(__einp_ - __ninp_);\n    return showmanyc();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::snextc()\n{\n    if (sbumpc() == traits_type::eof())\n        return traits_type::eof();\n    return sgetc();\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sbumpc()\n{\n    if (__ninp_ == __einp_)\n        return uflow();\n    return traits_type::to_int_type(*__ninp_++);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sgetc()\n{\n    if (__ninp_ == __einp_)\n        return underflow();\n    return traits_type::to_int_type(*__ninp_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nbasic_streambuf<_CharT, _Traits>::sgetn(char_type* __s, streamsize __n)\n{\n    return xsgetn(__s, __n);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sputbackc(char_type __c)\n{\n    if (__binp_ == __ninp_ || !traits_type::eq(__c, __ninp_[-1]))\n        return pbackfail(traits_type::to_int_type(__c));\n    return traits_type::to_int_type(*--__ninp_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sungetc()\n{\n    if (__binp_ == __ninp_)\n        return pbackfail();\n    return traits_type::to_int_type(*--__ninp_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::sputc(char_type __c)\n{\n    if (__nout_ == __eout_)\n        return overflow(traits_type::to_int_type(__c));\n    *__nout_++ = __c;\n    return traits_type::to_int_type(__c);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nstreamsize\nbasic_streambuf<_CharT, _Traits>::sputn(const char_type* __s, streamsize __n)\n{\n    return xsputn(__s, __n);\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::basic_streambuf()\n    : __binp_(0),\n      __ninp_(0),\n      __einp_(0),\n      __bout_(0),\n      __nout_(0),\n      __eout_(0)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>::basic_streambuf(const basic_streambuf& __sb)\n    : __loc_(__sb.__loc_),\n      __binp_(__sb.__binp_),\n      __ninp_(__sb.__ninp_),\n      __einp_(__sb.__einp_),\n      __bout_(__sb.__bout_),\n      __nout_(__sb.__nout_),\n      __eout_(__sb.__eout_)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>&\nbasic_streambuf<_CharT, _Traits>::operator=(const basic_streambuf& __sb)\n{\n    __loc_ = __sb.__loc_;\n    __binp_ = __sb.__binp_;\n    __ninp_ = __sb.__ninp_;\n    __einp_ = __sb.__einp_;\n    __bout_ = __sb.__bout_;\n    __nout_ = __sb.__nout_;\n    __eout_ = __sb.__eout_;\n    return *this;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_streambuf<_CharT, _Traits>::swap(basic_streambuf& __sb)\n{\n    _VSTD::swap(__loc_, __sb.__loc_);\n    _VSTD::swap(__binp_, __sb.__binp_);\n    _VSTD::swap(__ninp_, __sb.__ninp_);\n    _VSTD::swap(__einp_, __sb.__einp_);\n    _VSTD::swap(__bout_, __sb.__bout_);\n    _VSTD::swap(__nout_, __sb.__nout_);\n    _VSTD::swap(__eout_, __sb.__eout_);\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::gbump(int __n)\n{\n    __ninp_ += __n;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::setg(char_type* __gbeg, char_type* __gnext,\n                                                          char_type* __gend)\n{\n    __binp_ = __gbeg;\n    __ninp_ = __gnext;\n    __einp_ = __gend;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::pbump(int __n)\n{\n    __nout_ += __n;\n}\n\ntemplate <class _CharT, class _Traits>\ninline _LIBCPP_INLINE_VISIBILITY\nvoid\nbasic_streambuf<_CharT, _Traits>::setp(char_type* __pbeg, char_type* __pend)\n{\n    __bout_ = __nout_ = __pbeg;\n    __eout_ = __pend;\n}\n\ntemplate <class _CharT, class _Traits>\nvoid\nbasic_streambuf<_CharT, _Traits>::imbue(const locale&)\n{\n}\n\ntemplate <class _CharT, class _Traits>\nbasic_streambuf<_CharT, _Traits>*\nbasic_streambuf<_CharT, _Traits>::setbuf(char_type*, streamsize)\n{\n    return this;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::seekoff(off_type, ios_base::seekdir,\n                                          ios_base::openmode)\n{\n    return pos_type(off_type(-1));\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::pos_type\nbasic_streambuf<_CharT, _Traits>::seekpos(pos_type, ios_base::openmode)\n{\n    return pos_type(off_type(-1));\n}\n\ntemplate <class _CharT, class _Traits>\nint\nbasic_streambuf<_CharT, _Traits>::sync()\n{\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::showmanyc()\n{\n    return 0;\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::xsgetn(char_type* __s, streamsize __n)\n{\n    const int_type __eof = traits_type::eof();\n    int_type __c;\n    streamsize __i = 0;\n    for (;__i < __n; ++__i, ++__s)\n    {\n        if (__ninp_ < __einp_)\n            *__s = *__ninp_++;\n        else if ((__c = uflow()) != __eof)\n            *__s = traits_type::to_char_type(__c);\n        else\n            break;\n    }\n    return __i;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::underflow()\n{\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::uflow()\n{\n    if (underflow() == traits_type::eof())\n        return traits_type::eof();\n    return traits_type::to_int_type(*__ninp_++);\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::pbackfail(int_type)\n{\n    return traits_type::eof();\n}\n\ntemplate <class _CharT, class _Traits>\nstreamsize\nbasic_streambuf<_CharT, _Traits>::xsputn(const char_type* __s, streamsize __n)\n{\n    streamsize __i = 0;\n    int_type __eof = traits_type::eof();\n    for (; __i < __n; ++__s, ++__i)\n    {\n        if (__nout_ < __eout_)\n            *__nout_++ = *__s;\n        else if (overflow(traits_type::to_int_type(*__s)) == __eof)\n            break;\n    }\n    return __i;\n}\n\ntemplate <class _CharT, class _Traits>\ntypename basic_streambuf<_CharT, _Traits>::int_type\nbasic_streambuf<_CharT, _Traits>::overflow(int_type)\n{\n    return traits_type::eof();\n}\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_streambuf<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_streambuf<wchar_t>)\n\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_ios<char>)\n_LIBCPP_EXTERN_TEMPLATE(class _LIBCPP_TYPE_VIS basic_ios<wchar_t>)\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_STEAMBUF\n","///////////////////////////////////////////////////////////////////////////////////\r\n/// OpenGL Mathematics (glm.g-truc.net)\r\n///\r\n/// Copyright (c) 2005 - 2015 G-Truc Creation (www.g-truc.net)\r\n/// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n/// of this software and associated documentation files (the \"Software\"), to deal\r\n/// in the Software without restriction, including without limitation the rights\r\n/// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n/// copies of the Software, and to permit persons to whom the Software is\r\n/// furnished to do so, subject to the following conditions:\r\n/// \r\n/// The above copyright notice and this permission notice shall be included in\r\n/// all copies or substantial portions of the Software.\r\n/// \r\n/// Restrictions:\r\n///\t\tBy making use of the Software for military purposes, you choose to make\r\n///\t\ta Bunny unhappy.\r\n/// \r\n/// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n/// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n/// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n/// THE SOFTWARE.\r\n///\r\n/// @ref gtx_norm\r\n/// @file glm/gtx/norm.inl\r\n/// @date 2005-12-21 / 2008-07-24\r\n/// @author Christophe Riccio\r\n///////////////////////////////////////////////////////////////////////////////////\r\n\r\nnamespace glm\r\n{\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER T length2\r\n\t(\r\n\t\tT const & x\r\n\t)\r\n\t{\r\n\t\treturn x * x;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T length2\r\n\t(\r\n\t\ttvec2<T, P> const & x\r\n\t)\r\n\t{\r\n\t\treturn dot(x, x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T length2\r\n\t(\r\n\t\ttvec3<T, P> const & x\r\n\t)\r\n\t{\r\n\t\treturn dot(x, x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T length2\r\n\t(\r\n\t\ttvec4<T, P> const & x\r\n\t)\r\n\t{\r\n\t\treturn dot(x, x);\r\n\t}\r\n\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER T distance2\r\n\t(\r\n\t\tT const & p0,\r\n\t\tT const & p1\r\n\t)\r\n\t{\r\n\t\treturn length2(p1 - p0);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T distance2\r\n\t(\r\n\t\ttvec2<T, P> const & p0,\r\n\t\ttvec2<T, P> const & p1\r\n\t)\r\n\t{\r\n\t\treturn length2(p1 - p0);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T distance2\r\n\t(\r\n\t\ttvec3<T, P> const & p0,\r\n\t\ttvec3<T, P> const & p1\r\n\t)\r\n\t{\r\n\t\treturn length2(p1 - p0);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T distance2\r\n\t(\r\n\t\ttvec4<T, P> const & p0,\r\n\t\ttvec4<T, P> const & p1\r\n\t)\r\n\t{\r\n\t\treturn length2(p1 - p0);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T l1Norm\r\n\t(\r\n\t\ttvec3<T, P> const & a,\r\n\t\ttvec3<T, P> const & b\r\n\t)\r\n\t{\r\n\t\treturn abs(b.x - a.x) + abs(b.y - a.y) + abs(b.z - a.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T l1Norm\r\n\t(\r\n\t\ttvec3<T, P> const & v\r\n\t)\r\n\t{\r\n\t\treturn abs(v.x) + abs(v.y) + abs(v.z);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T l2Norm\r\n\t(\r\n\t\ttvec3<T, P> const & a,\r\n\t\ttvec3<T, P> const & b\r\n\t)\r\n\t{\r\n\t\treturn length(b - a);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T l2Norm\r\n\t(\r\n\t\ttvec3<T, P> const & v\r\n\t)\r\n\t{\r\n\t\treturn length(v);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T lxNorm\r\n\t(\r\n\t\ttvec3<T, P> const & x,\r\n\t\ttvec3<T, P> const & y,\r\n\t\tunsigned int Depth\r\n\t)\r\n\t{\r\n\t\treturn pow(pow(y.x - x.x, T(Depth)) + pow(y.y - x.y, T(Depth)) + pow(y.z - x.z, T(Depth)), T(1) / T(Depth));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER T lxNorm\r\n\t(\r\n\t\ttvec3<T, P> const & v,\r\n\t\tunsigned int Depth\r\n\t)\r\n\t{\r\n\t\treturn pow(pow(v.x, T(Depth)) + pow(v.y, T(Depth)) + pow(v.z, T(Depth)), T(1) / T(Depth));\r\n\t}\r\n\r\n}//namespace glm\r\n","///////////////////////////////////////////////////////////////////////////////////\r\n/// OpenGL Mathematics (glm.g-truc.net)\r\n///\r\n/// Copyright (c) 2005 - 2015 G-Truc Creation (www.g-truc.net)\r\n/// Permission is hereby granted, free of charge, to any person obtaining a copy\r\n/// of this software and associated documentation files (the \"Software\"), to deal\r\n/// in the Software without restriction, including without limitation the rights\r\n/// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\r\n/// copies of the Software, and to permit persons to whom the Software is\r\n/// furnished to do so, subject to the following conditions:\r\n/// \r\n/// The above copyright notice and this permission notice shall be included in\r\n/// all copies or substantial portions of the Software.\r\n/// \r\n/// Restrictions:\r\n///\t\tBy making use of the Software for military purposes, you choose to make\r\n///\t\ta Bunny unhappy.\r\n/// \r\n/// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\r\n/// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\r\n/// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\r\n/// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\r\n/// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\r\n/// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\r\n/// THE SOFTWARE.\r\n///\r\n/// @ref core\r\n/// @file glm/detail/func_geometric.inl\r\n/// @date 2008-08-03 / 2011-06-15\r\n/// @author Christophe Riccio\r\n///////////////////////////////////////////////////////////////////////////////////\r\n\r\n#include \"func_exponential.hpp\"\r\n#include \"func_common.hpp\"\r\n#include \"type_vec2.hpp\"\r\n#include \"type_vec4.hpp\"\r\n#include \"type_float.hpp\"\r\n\r\nnamespace glm{\r\nnamespace detail\r\n{\r\n\ttemplate <template <class, precision> class vecType, typename T, precision P>\r\n\tstruct compute_dot{};\r\n\r\n\ttemplate <typename T, precision P>\r\n\tstruct compute_dot<tvec1, T, P>\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static T call(tvec1<T, P> const & a, tvec1<T, P> const & b)\r\n\t\t{\r\n\t\t\treturn a.x * b.x;\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate <typename T, precision P>\r\n\tstruct compute_dot<tvec2, T, P>\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static T call(tvec2<T, P> const & x, tvec2<T, P> const & y)\r\n\t\t{\r\n\t\t\ttvec2<T, P> tmp(x * y);\r\n\t\t\treturn tmp.x + tmp.y;\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate <typename T, precision P>\r\n\tstruct compute_dot<tvec3, T, P>\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static T call(tvec3<T, P> const & x, tvec3<T, P> const & y)\r\n\t\t{\r\n\t\t\ttvec3<T, P> tmp(x * y);\r\n\t\t\treturn tmp.x + tmp.y + tmp.z;\r\n\t\t}\r\n\t};\r\n\r\n\ttemplate <typename T, precision P>\r\n\tstruct compute_dot<tvec4, T, P>\r\n\t{\r\n\t\tGLM_FUNC_QUALIFIER static T call(tvec4<T, P> const & x, tvec4<T, P> const & y)\r\n\t\t{\r\n\t\t\ttvec4<T, P> tmp(x * y);\r\n\t\t\treturn (tmp.x + tmp.y) + (tmp.z + tmp.w);\r\n\t\t}\r\n\t};\r\n}//namespace detail\r\n\r\n\t// length\r\n\ttemplate <typename genType>\r\n\tGLM_FUNC_QUALIFIER genType length(genType x)\r\n\t{\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559, \"'length' only accept floating-point inputs\");\r\n\r\n\t\treturn abs(x);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\r\n\tGLM_FUNC_QUALIFIER T length(vecType<T, P> const & v)\r\n\t{\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'length' only accept floating-point inputs\");\r\n\r\n\t\treturn sqrt(dot(v, v));\r\n\t}\r\n\r\n\t// distance\r\n\ttemplate <typename genType>\r\n\tGLM_FUNC_QUALIFIER genType distance(genType const & p0, genType const & p1)\r\n\t{\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559, \"'distance' only accept floating-point inputs\");\r\n\r\n\t\treturn length(p1 - p0);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\r\n\tGLM_FUNC_QUALIFIER T distance(vecType<T, P> const & p0, vecType<T, P> const & p1)\r\n\t{\r\n\t\treturn length(p1 - p0);\r\n\t}\r\n\r\n\t// dot\r\n\ttemplate <typename T>\r\n\tGLM_FUNC_QUALIFIER T dot(T x, T y)\r\n\t{\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'dot' only accept floating-point inputs\");\r\n\t\treturn x * y;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\r\n\tGLM_FUNC_QUALIFIER T dot(vecType<T, P> const & x, vecType<T, P> const & y)\r\n\t{\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'dot' only accept floating-point inputs\");\r\n\t\treturn detail::compute_dot<vecType, T, P>::call(x, y);\r\n\t}\r\n\r\n\t// cross\r\n\ttemplate <typename T, precision P>\r\n\tGLM_FUNC_QUALIFIER tvec3<T, P> cross(tvec3<T, P> const & x, tvec3<T, P> const & y)\r\n\t{\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'cross' only accept floating-point inputs\");\r\n\r\n\t\treturn tvec3<T, P>(\r\n\t\t\tx.y * y.z - y.y * x.z,\r\n\t\t\tx.z * y.x - y.z * x.x,\r\n\t\t\tx.x * y.y - y.x * x.y);\r\n\t}\r\n\r\n\t// normalize\r\n\ttemplate <typename genType>\r\n\tGLM_FUNC_QUALIFIER genType normalize(genType const & x)\r\n\t{\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559, \"'normalize' only accept floating-point inputs\");\r\n\r\n\t\treturn x < genType(0) ? genType(-1) : genType(1);\r\n\t}\r\n\r\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\r\n\tGLM_FUNC_QUALIFIER vecType<T, P> normalize(vecType<T, P> const & x)\r\n\t{\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'normalize' only accept floating-point inputs\");\r\n\r\n\t\treturn x * inversesqrt(dot(x, x));\r\n\t}\r\n\r\n\t// faceforward\r\n\ttemplate <typename genType>\r\n\tGLM_FUNC_QUALIFIER genType faceforward(genType const & N, genType const & I, genType const & Nref)\r\n\t{\r\n\t\treturn dot(Nref, I) < static_cast<genType>(0) ? N : -N;\r\n\t}\r\n\r\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\r\n\tGLM_FUNC_QUALIFIER vecType<T, P> faceforward(vecType<T, P> const & N, vecType<T, P> const & I, vecType<T, P> const & Nref)\r\n\t{\r\n\t\treturn dot(Nref, I) < static_cast<T>(0) ? N : -N;\r\n\t}\r\n\r\n\t// reflect\r\n\ttemplate <typename genType>\r\n\tGLM_FUNC_QUALIFIER genType reflect(genType const & I, genType const & N)\r\n\t{\r\n\t\treturn I - N * dot(N, I) * static_cast<genType>(2);\r\n\t}\r\n\r\n\t// refract\r\n\ttemplate <typename genType>\r\n\tGLM_FUNC_QUALIFIER genType refract(genType const & I, genType const & N, genType const & eta)\r\n\t{\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<genType>::is_iec559, \"'refract' only accept floating-point inputs\");\r\n\r\n\t\tgenType const dotValue(dot(N, I));\r\n\t\tgenType const k(static_cast<genType>(1) - eta * eta * (static_cast<genType>(1) - dotValue * dotValue));\r\n\t\treturn (eta * I - (eta * dotValue + sqrt(k)) * N) * static_cast<genType>(k >= static_cast<genType>(0));\r\n\t}\r\n\r\n\ttemplate <typename T, precision P, template <typename, precision> class vecType>\r\n\tGLM_FUNC_QUALIFIER vecType<T, P> refract(vecType<T, P> const & I, vecType<T, P> const & N, T eta)\r\n\t{\r\n\t\tGLM_STATIC_ASSERT(std::numeric_limits<T>::is_iec559, \"'refract' only accept floating-point inputs\");\r\n\r\n\t\tT const dotValue(dot(N, I));\r\n\t\tT const k(static_cast<T>(1) - eta * eta * (static_cast<T>(1) - dotValue * dotValue));\r\n\t\treturn (eta * I - (eta * dotValue + std::sqrt(k)) * N) * static_cast<T>(k >= static_cast<T>(0));\r\n\t}\r\n}//namespace glm\r\n","// -*- C++ -*-\n//===--------------------------- iomanip ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef _LIBCPP_IOMANIP\n#define _LIBCPP_IOMANIP\n\n/*\n    iomanip synopsis\n\nnamespace std {\n\n// types T1, T2, ... are unspecified implementation types\nT1 resetiosflags(ios_base::fmtflags mask);\nT2 setiosflags (ios_base::fmtflags mask);\nT3 setbase(int base);\ntemplate<charT> T4 setfill(charT c);\nT5 setprecision(int n);\nT6 setw(int n);\ntemplate <class moneyT> T7 get_money(moneyT& mon, bool intl = false);\ntemplate <class charT, class moneyT> T8 put_money(const moneyT& mon, bool intl = false);\ntemplate <class charT> T9 get_time(struct tm* tmb, const charT* fmt);\ntemplate <class charT> T10 put_time(const struct tm* tmb, const charT* fmt);\n\ntemplate <class charT>\n  T11 quoted(const charT* s, charT delim=charT('\"'), charT escape=charT('\\\\')); // C++14\n\ntemplate <class charT, class traits, class Allocator>\n  T12 quoted(const basic_string<charT, traits, Allocator>& s,\n             charT delim=charT('\"'), charT escape=charT('\\\\')); // C++14\n\ntemplate <class charT, class traits, class Allocator>\n  T13 quoted(basic_string<charT, traits, Allocator>& s,\n             charT delim=charT('\"'), charT escape=charT('\\\\')); // C++14\n\n}  // std\n\n*/\n\n#include <__config>\n#include <istream>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\n_LIBCPP_BEGIN_NAMESPACE_STD\n\n// resetiosflags\n\nclass __iom_t1\n{\n    ios_base::fmtflags __mask_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __iom_t1(ios_base::fmtflags __m) : __mask_(__m) {}\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t1& __x)\n    {\n        __is.unsetf(__x.__mask_);\n        return __is;\n    }\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t1& __x)\n    {\n        __os.unsetf(__x.__mask_);\n        return __os;\n    }\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t1\nresetiosflags(ios_base::fmtflags __mask)\n{\n    return __iom_t1(__mask);\n}\n\n// setiosflags\n\nclass __iom_t2\n{\n    ios_base::fmtflags __mask_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __iom_t2(ios_base::fmtflags __m) : __mask_(__m) {}\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t2& __x)\n    {\n        __is.setf(__x.__mask_);\n        return __is;\n    }\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t2& __x)\n    {\n        __os.setf(__x.__mask_);\n        return __os;\n    }\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t2\nsetiosflags(ios_base::fmtflags __mask)\n{\n    return __iom_t2(__mask);\n}\n\n// setbase\n\nclass __iom_t3\n{\n    int __base_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __iom_t3(int __b) : __base_(__b) {}\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t3& __x)\n    {\n        __is.setf(__x.__base_ == 8  ? ios_base::oct :\n                  __x.__base_ == 10 ? ios_base::dec :\n                  __x.__base_ == 16 ? ios_base::hex :\n                  ios_base::fmtflags(0), ios_base::basefield);\n        return __is;\n    }\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t3& __x)\n    {\n        __os.setf(__x.__base_ == 8  ? ios_base::oct :\n                  __x.__base_ == 10 ? ios_base::dec :\n                  __x.__base_ == 16 ? ios_base::hex :\n                  ios_base::fmtflags(0), ios_base::basefield);\n        return __os;\n    }\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t3\nsetbase(int __base)\n{\n    return __iom_t3(__base);\n}\n\n// setfill\n\ntemplate<class _CharT>\nclass __iom_t4\n{\n    _CharT __fill_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __iom_t4(_CharT __c) : __fill_(__c) {}\n\n    template <class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t4& __x)\n    {\n        __os.fill(__x.__fill_);\n        return __os;\n    }\n};\n\ntemplate<class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t4<_CharT>\nsetfill(_CharT __c)\n{\n    return __iom_t4<_CharT>(__c);\n}\n\n// setprecision\n\nclass __iom_t5\n{\n    int __n_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __iom_t5(int __n) : __n_(__n) {}\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t5& __x)\n    {\n        __is.precision(__x.__n_);\n        return __is;\n    }\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t5& __x)\n    {\n        __os.precision(__x.__n_);\n        return __os;\n    }\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t5\nsetprecision(int __n)\n{\n    return __iom_t5(__n);\n}\n\n// setw\n\nclass __iom_t6\n{\n    int __n_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    explicit __iom_t6(int __n) : __n_(__n) {}\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t6& __x)\n    {\n        __is.width(__x.__n_);\n        return __is;\n    }\n\n    template <class _CharT, class _Traits>\n    friend\n    _LIBCPP_INLINE_VISIBILITY\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t6& __x)\n    {\n        __os.width(__x.__n_);\n        return __os;\n    }\n};\n\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t6\nsetw(int __n)\n{\n    return __iom_t6(__n);\n}\n\n// get_money\n\ntemplate <class _MoneyT> class __iom_t7;\n\ntemplate <class _CharT, class _Traits, class _MoneyT>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t7<_MoneyT>& __x);\n\ntemplate <class _MoneyT>\nclass __iom_t7\n{\n    _MoneyT& __mon_;\n    bool __intl_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __iom_t7(_MoneyT& __mon, bool __intl)\n        : __mon_(__mon), __intl_(__intl) {}\n\n    template <class _CharT, class _Traits, class _Mp>\n    friend\n    basic_istream<_CharT, _Traits>&\n    operator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t7<_Mp>& __x);\n};\n\ntemplate <class _CharT, class _Traits, class _MoneyT>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t7<_MoneyT>& __x)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __s(__is);\n        if (__s)\n        {\n            typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n            typedef money_get<_CharT, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            const _Fp& __mf = use_facet<_Fp>(__is.getloc());\n            __mf.get(_Ip(__is), _Ip(), __x.__intl_, __is, __err, __x.__mon_);\n            __is.setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate <class _MoneyT>\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t7<_MoneyT>\nget_money(_MoneyT& __mon, bool __intl = false)\n{\n    return __iom_t7<_MoneyT>(__mon, __intl);\n}\n\n// put_money\n\ntemplate <class _MoneyT> class __iom_t8;\n\ntemplate <class _CharT, class _Traits, class _MoneyT>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t8<_MoneyT>& __x);\n\ntemplate <class _MoneyT>\nclass __iom_t8\n{\n    const _MoneyT& __mon_;\n    bool __intl_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __iom_t8(const _MoneyT& __mon, bool __intl)\n        : __mon_(__mon), __intl_(__intl) {}\n\n    template <class _CharT, class _Traits, class _Mp>\n    friend\n    basic_ostream<_CharT, _Traits>&\n    operator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t8<_Mp>& __x);\n};\n\ntemplate <class _CharT, class _Traits, class _MoneyT>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t8<_MoneyT>& __x)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n            typedef money_put<_CharT, _Op> _Fp;\n            const _Fp& __mf = use_facet<_Fp>(__os.getloc());\n            if (__mf.put(_Op(__os), __x.__intl_, __os, __os.fill(), __x.__mon_).failed())\n                __os.setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate <class _MoneyT>\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t8<_MoneyT>\nput_money(const _MoneyT& __mon, bool __intl = false)\n{\n    return __iom_t8<_MoneyT>(__mon, __intl);\n}\n\n// get_time\n\ntemplate <class _CharT> class __iom_t9;\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t9<_CharT>& __x);\n\ntemplate <class _CharT>\nclass __iom_t9\n{\n    tm* __tm_;\n    const _CharT* __fmt_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __iom_t9(tm* __tm, const _CharT* __fmt)\n        : __tm_(__tm), __fmt_(__fmt) {}\n\n    template <class _Cp, class _Traits>\n    friend\n    basic_istream<_Cp, _Traits>&\n    operator>>(basic_istream<_Cp, _Traits>& __is, const __iom_t9<_Cp>& __x);\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_istream<_CharT, _Traits>&\noperator>>(basic_istream<_CharT, _Traits>& __is, const __iom_t9<_CharT>& __x)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_istream<_CharT, _Traits>::sentry __s(__is);\n        if (__s)\n        {\n            typedef istreambuf_iterator<_CharT, _Traits> _Ip;\n            typedef time_get<_CharT, _Ip> _Fp;\n            ios_base::iostate __err = ios_base::goodbit;\n            const _Fp& __tf = use_facet<_Fp>(__is.getloc());\n            __tf.get(_Ip(__is), _Ip(), __is, __err, __x.__tm_,\n                     __x.__fmt_, __x.__fmt_ + _Traits::length(__x.__fmt_));\n            __is.setstate(__err);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __is.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __is;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t9<_CharT>\nget_time(tm* __tm, const _CharT* __fmt)\n{\n    return __iom_t9<_CharT>(__tm, __fmt);\n}\n\n// put_time\n\ntemplate <class _CharT> class __iom_t10;\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t10<_CharT>& __x);\n\ntemplate <class _CharT>\nclass __iom_t10\n{\n    const tm* __tm_;\n    const _CharT* __fmt_;\npublic:\n    _LIBCPP_INLINE_VISIBILITY\n    __iom_t10(const tm* __tm, const _CharT* __fmt)\n        : __tm_(__tm), __fmt_(__fmt) {}\n\n    template <class _Cp, class _Traits>\n    friend\n    basic_ostream<_Cp, _Traits>&\n    operator<<(basic_ostream<_Cp, _Traits>& __os, const __iom_t10<_Cp>& __x);\n};\n\ntemplate <class _CharT, class _Traits>\nbasic_ostream<_CharT, _Traits>&\noperator<<(basic_ostream<_CharT, _Traits>& __os, const __iom_t10<_CharT>& __x)\n{\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    try\n    {\n#endif  // _LIBCPP_NO_EXCEPTIONS\n        typename basic_ostream<_CharT, _Traits>::sentry __s(__os);\n        if (__s)\n        {\n            typedef ostreambuf_iterator<_CharT, _Traits> _Op;\n            typedef time_put<_CharT, _Op> _Fp;\n            const _Fp& __tf = use_facet<_Fp>(__os.getloc());\n            if (__tf.put(_Op(__os), __os, __os.fill(), __x.__tm_,\n                         __x.__fmt_, __x.__fmt_ + _Traits::length(__x.__fmt_)).failed())\n                __os.setstate(ios_base::badbit);\n        }\n#ifndef _LIBCPP_NO_EXCEPTIONS\n    }\n    catch (...)\n    {\n        __os.__set_badbit_and_consider_rethrow();\n    }\n#endif  // _LIBCPP_NO_EXCEPTIONS\n    return __os;\n}\n\ntemplate <class _CharT>\ninline _LIBCPP_INLINE_VISIBILITY\n__iom_t10<_CharT>\nput_time(const tm* __tm, const _CharT* __fmt)\n{\n    return __iom_t10<_CharT>(__tm, __fmt);\n}\n\n#if _LIBCPP_STD_VER > 11\n\ntemplate <class _CharT, class _Traits, class _ForwardIterator>\nstd::basic_ostream<_CharT, _Traits> &\n__quoted_output ( basic_ostream<_CharT, _Traits> &__os, \n        _ForwardIterator __first, _ForwardIterator __last, _CharT __delim, _CharT __escape )\n{\n    _VSTD::basic_string<_CharT, _Traits> __str;\n    __str.push_back(__delim);\n    for ( ; __first != __last; ++ __first )\n    {\n        if (_Traits::eq (*__first, __escape) || _Traits::eq (*__first, __delim))\n            __str.push_back(__escape);\n        __str.push_back(*__first);\n    }\n    __str.push_back(__delim);\n    return __put_character_sequence(__os, __str.data(), __str.size());\n}\n\ntemplate <class _CharT, class _Traits, class _String>\nbasic_istream<_CharT, _Traits> &\n__quoted_input ( basic_istream<_CharT, _Traits> &__is, _String & __string, _CharT __delim, _CharT __escape )\n{\n    __string.clear ();\n    _CharT __c;\n    __is >> __c;\n    if ( __is.fail ())\n        return __is;\n\n    if (!_Traits::eq (__c, __delim))    // no delimiter, read the whole string\n    {\n        __is.unget ();\n        __is >> __string;\n        return __is;\n    }\n\n    __save_flags<_CharT, _Traits> sf(__is);\n    noskipws (__is);\n    while (true)\n        {\n        __is >> __c;\n        if ( __is.fail ())\n            break;\n        if (_Traits::eq (__c, __escape))\n        {\n            __is >> __c;\n            if ( __is.fail ())\n                break;\n        }\n        else if (_Traits::eq (__c, __delim))\n            break;\n        __string.push_back ( __c );\n        }\n    return __is;\n}\n\n\ntemplate <class _CharT, class _Iter, class _Traits=char_traits<_CharT>>\nstruct __quoted_output_proxy\n{\n    _Iter  __first;\n    _Iter  __last;\n    _CharT  __delim;\n    _CharT  __escape;\n\n    __quoted_output_proxy(_Iter __f, _Iter __l, _CharT __d, _CharT __e)\n    : __first(__f), __last(__l), __delim(__d), __escape(__e) {}\n    //  This would be a nice place for a string_ref \n};\n\ntemplate <class _CharT, class _Traits, class _Iter>\nbasic_ostream<_CharT, _Traits>& operator<<(\n         basic_ostream<_CharT, _Traits>& __os, \n         const __quoted_output_proxy<_CharT, _Iter, _Traits> & __proxy)\n{\n    return __quoted_output (__os, __proxy.__first, __proxy.__last, __proxy.__delim, __proxy.__escape);\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\nstruct __quoted_proxy\n{\n    basic_string<_CharT, _Traits, _Allocator> &__string;\n    _CharT  __delim;\n    _CharT  __escape;\n\n    __quoted_proxy(basic_string<_CharT, _Traits, _Allocator> &__s, _CharT __d, _CharT __e)\n    : __string(__s), __delim(__d), __escape(__e) {}\n};\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY\nbasic_ostream<_CharT, _Traits>& operator<<(\n        basic_ostream<_CharT, _Traits>& __os, \n        const __quoted_proxy<_CharT, _Traits, _Allocator> & __proxy)\n{\n    return __quoted_output (__os, __proxy.__string.cbegin (), __proxy.__string.cend (), __proxy.__delim, __proxy.__escape);\n}\n\n//  extractor for non-const basic_string& proxies\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY\nbasic_istream<_CharT, _Traits>& operator>>(\n        basic_istream<_CharT, _Traits>& __is, \n        const __quoted_proxy<_CharT, _Traits, _Allocator> & __proxy)\n{\n    return __quoted_input ( __is, __proxy.__string, __proxy.__delim, __proxy.__escape );\n}\n\n\ntemplate <class _CharT>\n_LIBCPP_INLINE_VISIBILITY\n__quoted_output_proxy<_CharT, const _CharT *>\nquoted ( const _CharT *__s, _CharT __delim = _CharT('\"'), _CharT __escape =_CharT('\\\\'))\n{\n    const _CharT *__end = __s;\n    while ( *__end ) ++__end;\n    return __quoted_output_proxy<_CharT, const _CharT *> ( __s, __end, __delim, __escape );\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n_LIBCPP_INLINE_VISIBILITY\n__quoted_output_proxy<_CharT, typename basic_string <_CharT, _Traits, _Allocator>::const_iterator>\nquoted ( const basic_string <_CharT, _Traits, _Allocator> &__s, _CharT __delim = _CharT('\"'), _CharT __escape=_CharT('\\\\'))\n{\n    return __quoted_output_proxy<_CharT, \n            typename basic_string <_CharT, _Traits, _Allocator>::const_iterator> \n                    ( __s.cbegin(), __s.cend (), __delim, __escape );\n}\n\ntemplate <class _CharT, class _Traits, class _Allocator>\n__quoted_proxy<_CharT, _Traits, _Allocator>\nquoted ( basic_string <_CharT, _Traits, _Allocator> &__s, _CharT __delim = _CharT('\"'), _CharT __escape=_CharT('\\\\'))\n{\n    return __quoted_proxy<_CharT, _Traits, _Allocator>( __s, __delim, __escape );\n}\n#endif\n\n_LIBCPP_END_NAMESPACE_STD\n\n#endif  // _LIBCPP_IOMANIP\n","// Voro++, a 3D cell-based Voronoi library\n//\n// Author   : Chris H. Rycroft (LBL / UC Berkeley)\n// Email    : chr@alum.mit.edu\n// Date     : August 30th 2011\n\n/** \\file cell.cc\n * \\brief Function implementations for the voronoicell and related classes. */\n\n#include <cmath>\n#include <cstring>\n\n#include \"config.hh\"\n#include \"common.hh\"\n#include \"cell.hh\"\n\nnamespace voro {\n\n/** Constructs a Voronoi cell and sets up the initial memory. */\nvoronoicell_base::voronoicell_base() :\n\tcurrent_vertices(init_vertices), current_vertex_order(init_vertex_order),\n\tcurrent_delete_size(init_delete_size), current_delete2_size(init_delete2_size),\n\ted(new int*[current_vertices]), nu(new int[current_vertices]),\n\tpts(new double[3*current_vertices]), mem(new int[current_vertex_order]),\n\tmec(new int[current_vertex_order]), mep(new int*[current_vertex_order]),\n\tds(new int[current_delete_size]), stacke(ds+current_delete_size),\n\tds2(new int[current_delete2_size]), stacke2(ds2+current_delete_size),\n\tcurrent_marginal(init_marginal), marg(new int[current_marginal]) {\n\tint i;\n\tfor(i=0;i<3;i++) {\n\t\tmem[i]=init_n_vertices;mec[i]=0;\n\t\tmep[i]=new int[init_n_vertices*((i<<1)+1)];\n\t}\n\tmem[3]=init_3_vertices;mec[3]=0;\n\tmep[3]=new int[init_3_vertices*7];\n\tfor(i=4;i<current_vertex_order;i++) {\n\t\tmem[i]=init_n_vertices;mec[i]=0;\n\t\tmep[i]=new int[init_n_vertices*((i<<1)+1)];\n\t}\n}\n\n/** The voronoicell destructor deallocates all the dynamic memory. */\nvoronoicell_base::~voronoicell_base() {\n\tfor(int i=current_vertex_order-1;i>=0;i--) if(mem[i]>0) delete [] mep[i];\n\tdelete [] marg;\n\tdelete [] ds2;delete [] ds;\n\tdelete [] mep;delete [] mec;\n\tdelete [] mem;delete [] pts;\n\tdelete [] nu;delete [] ed;\n}\n\n/** Ensures that enough memory is allocated prior to carrying out a copy.\n * \\param[in] vc a reference to the specialized version of the calling class.\n * \\param[in] vb a pointered to the class to be copied. */\ntemplate<class vc_class>\nvoid voronoicell_base::check_memory_for_copy(vc_class &vc,voronoicell_base* vb) {\n\twhile(current_vertex_order<vb->current_vertex_order) add_memory_vorder(vc);\n\tfor(int i=0;i<current_vertex_order;i++) while(mem[i]<vb->mec[i]) add_memory(vc,i,ds2);\n\twhile(current_vertices<vb->p) add_memory_vertices(vc);\n}\n\n/** Copies the vertex and edge information from another class. The routine\n * assumes that enough memory is available for the copy.\n * \\param[in] vb a pointer to the class to copy. */\nvoid voronoicell_base::copy(voronoicell_base* vb) {\n\tint i,j;\n\tp=vb->p;up=0;\n\tfor(i=0;i<current_vertex_order;i++) {\n\t\tmec[i]=vb->mec[i];\n\t\tfor(j=0;j<mec[i]*(2*i+1);j++) mep[i][j]=vb->mep[i][j];\n\t\tfor(j=0;j<mec[i]*(2*i+1);j+=2*i+1) ed[mep[i][j+2*i]]=mep[i]+j;\n\t}\n\tfor(i=0;i<p;i++) nu[i]=vb->nu[i];\n\tfor(i=0;i<3*p;i++) pts[i]=vb->pts[i];\n}\n\n/** Copies the information from another voronoicell class into this\n * class, extending memory allocation if necessary.\n * \\param[in] c the class to copy. */\nvoid voronoicell_neighbor::operator=(voronoicell &c) {\n\tvoronoicell_base *vb=((voronoicell_base*) &c);\n\tcheck_memory_for_copy(*this,vb);copy(vb);\n\tint i,j;\n\tfor(i=0;i<c.current_vertex_order;i++) {\n\t\tfor(j=0;j<c.mec[i]*i;j++) mne[i][j]=0;\n\t\tfor(j=0;j<c.mec[i];j++) ne[c.mep[i][(2*i+1)*j+2*i]]=mne[i]+(j*i);\n\t}\n}\n\n/** Copies the information from another voronoicell_neighbor class into this\n * class, extending memory allocation if necessary.\n * \\param[in] c the class to copy. */\nvoid voronoicell_neighbor::operator=(voronoicell_neighbor &c) {\n\tvoronoicell_base *vb=((voronoicell_base*) &c);\n\tcheck_memory_for_copy(*this,vb);copy(vb);\n\tint i,j;\n\tfor(i=0;i<c.current_vertex_order;i++) {\n\t\tfor(j=0;j<c.mec[i]*i;j++) mne[i][j]=c.mne[i][j];\n\t\tfor(j=0;j<c.mec[i];j++) ne[c.mep[i][(2*i+1)*j+2*i]]=mne[i]+(j*i);\n\t}\n}\n\n/** Translates the vertices of the Voronoi cell by a given vector.\n * \\param[in] (x,y,z) the coordinates of the vector. */\nvoid voronoicell_base::translate(double x,double y,double z) {\n\tx*=2;y*=2;z*=2;\n\tdouble *ptsp=pts;\n\twhile(ptsp<pts+3*p) {\n\t\t*(ptsp++)=x;*(ptsp++)=y;*(ptsp++)=z;\n\t}\n}\n\n/** Increases the memory storage for a particular vertex order, by increasing\n * the size of the of the corresponding mep array. If the arrays already exist,\n * their size is doubled; if they don't exist, then new ones of size\n * init_n_vertices are allocated. The routine also ensures that the pointers in\n * the ed array are updated, by making use of the back pointers. For the cases\n * where the back pointer has been temporarily overwritten in the marginal\n * vertex code, the auxiliary delete stack is scanned to find out how to update\n * the ed value. If the template has been instantiated with the neighbor\n * tracking turned on, then the routine also reallocates the corresponding mne\n * array.\n * \\param[in] i the order of the vertex memory to be increased. */\ntemplate<class vc_class>\nvoid voronoicell_base::add_memory(vc_class &vc,int i,int *stackp2) {\n\tint s=(i<<1)+1;\n\tif(mem[i]==0) {\n\t\tvc.n_allocate(i,init_n_vertices);\n\t\tmep[i]=new int[init_n_vertices*s];\n\t\tmem[i]=init_n_vertices;\n#if VOROPP_VERBOSE >=2\n\t\tfprintf(stderr,\"Order %d vertex memory created\\n\",i);\n#endif\n\t} else {\n\t\tint j=0,k,*l;\n\t\tmem[i]<<=1;\n\t\tif(mem[i]>max_n_vertices) voro_fatal_error(\"Point memory allocation exceeded absolute maximum\",VOROPP_MEMORY_ERROR);\n#if VOROPP_VERBOSE >=2\n\t\tfprintf(stderr,\"Order %d vertex memory scaled up to %d\\n\",i,mem[i]);\n#endif\n\t\tl=new int[s*mem[i]];\n\t\tint m=0;\n\t\tvc.n_allocate_aux1(i);\n\t\twhile(j<s*mec[i]) {\n\t\t\tk=mep[i][j+(i<<1)];\n\t\t\tif(k>=0) {\n\t\t\t\ted[k]=l+j;\n\t\t\t\tvc.n_set_to_aux1_offset(k,m);\n\t\t\t} else {\n\t\t\t\tint *dsp;\n\t\t\t\tfor(dsp=ds2;dsp<stackp2;dsp++) {\n\t\t\t\t\tif(ed[*dsp]==mep[i]+j) {\n\t\t\t\t\t\ted[*dsp]=l+j;\n\t\t\t\t\t\tvc.n_set_to_aux1_offset(*dsp,m);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(dsp==stackp2) voro_fatal_error(\"Couldn't relocate dangling pointer\",VOROPP_INTERNAL_ERROR);\n#if VOROPP_VERBOSE >=3\n\t\t\t\tfputs(\"Relocated dangling pointer\",stderr);\n#endif\n\t\t\t}\n\t\t\tfor(k=0;k<s;k++,j++) l[j]=mep[i][j];\n\t\t\tfor(k=0;k<i;k++,m++) vc.n_copy_to_aux1(i,m);\n\t\t}\n\t\tdelete [] mep[i];\n\t\tmep[i]=l;\n\t\tvc.n_switch_to_aux1(i);\n\t}\n}\n\n/** Doubles the maximum number of vertices allowed, by reallocating the ed, nu,\n * and pts arrays. If the allocation exceeds the absolute maximum set in\n * max_vertices, then the routine exits with a fatal error. If the template has\n * been instantiated with the neighbor tracking turned on, then the routine\n * also reallocates the ne array. */\ntemplate<class vc_class>\nvoid voronoicell_base::add_memory_vertices(vc_class &vc) {\n\tint i=(current_vertices<<1),j,**pp,*pnu;\n\tif(i>max_vertices) voro_fatal_error(\"Vertex memory allocation exceeded absolute maximum\",VOROPP_MEMORY_ERROR);\n#if VOROPP_VERBOSE >=2\n\tfprintf(stderr,\"Vertex memory scaled up to %d\\n\",i);\n#endif\n\tdouble *ppts;\n\tpp=new int*[i];\n\tfor(j=0;j<current_vertices;j++) pp[j]=ed[j];\n\tdelete [] ed;ed=pp;\n\tvc.n_add_memory_vertices(i);\n\tpnu=new int[i];\n\tfor(j=0;j<current_vertices;j++) pnu[j]=nu[j];\n\tdelete [] nu;nu=pnu;\n\tppts=new double[3*i];\n\tfor(j=0;j<3*current_vertices;j++) ppts[j]=pts[j];\n\tdelete [] pts;pts=ppts;\n\tcurrent_vertices=i;\n}\n\n/** Doubles the maximum allowed vertex order, by reallocating mem, mep, and mec\n * arrays. If the allocation exceeds the absolute maximum set in\n * max_vertex_order, then the routine causes a fatal error. If the template has\n * been instantiated with the neighbor tracking turned on, then the routine\n * also reallocates the mne array. */\ntemplate<class vc_class>\nvoid voronoicell_base::add_memory_vorder(vc_class &vc) {\n\tint i=(current_vertex_order<<1),j,*p1,**p2;\n\tif(i>max_vertex_order) voro_fatal_error(\"Vertex order memory allocation exceeded absolute maximum\",VOROPP_MEMORY_ERROR);\n#if VOROPP_VERBOSE >=2\n\tfprintf(stderr,\"Vertex order memory scaled up to %d\\n\",i);\n#endif\n\tp1=new int[i];\n\tfor(j=0;j<current_vertex_order;j++) p1[j]=mem[j];while(j<i) p1[j++]=0;\n\tdelete [] mem;mem=p1;\n\tp2=new int*[i];\n\tfor(j=0;j<current_vertex_order;j++) p2[j]=mep[j];\n\tdelete [] mep;mep=p2;\n\tp1=new int[i];\n\tfor(j=0;j<current_vertex_order;j++) p1[j]=mec[j];while(j<i) p1[j++]=0;\n\tdelete [] mec;mec=p1;\n\tvc.n_add_memory_vorder(i);\n\tcurrent_vertex_order=i;\n}\n\n/** Doubles the size allocation of the main delete stack. If the allocation\n * exceeds the absolute maximum set in max_delete_size, then routine causes a\n * fatal error. */\nvoid voronoicell_base::add_memory_ds(int *&stackp) {\n\tcurrent_delete_size<<=1;\n\tif(current_delete_size>max_delete_size) voro_fatal_error(\"Delete stack 1 memory allocation exceeded absolute maximum\",VOROPP_MEMORY_ERROR);\n#if VOROPP_VERBOSE >=2\n\tfprintf(stderr,\"Delete stack 1 memory scaled up to %d\\n\",current_delete_size);\n#endif\n\tint *dsn=new int[current_delete_size],*dsnp=dsn,*dsp=ds;\n\twhile(dsp<stackp) *(dsnp++)=*(dsp++);\n\tdelete [] ds;ds=dsn;stackp=dsnp;\n\tstacke=ds+current_delete_size;\n}\n\n/** Doubles the size allocation of the auxiliary delete stack. If the\n * allocation exceeds the absolute maximum set in max_delete2_size, then the\n * routine causes a fatal error. */\nvoid voronoicell_base::add_memory_ds2(int *&stackp2) {\n\tcurrent_delete2_size<<=1;\n\tif(current_delete2_size>max_delete2_size) voro_fatal_error(\"Delete stack 2 memory allocation exceeded absolute maximum\",VOROPP_MEMORY_ERROR);\n#if VOROPP_VERBOSE >=2\n\tfprintf(stderr,\"Delete stack 2 memory scaled up to %d\\n\",current_delete2_size);\n#endif\n\tint *dsn=new int[current_delete2_size],*dsnp=dsn,*dsp=ds2;\n\twhile(dsp<stackp2) *(dsnp++)=*(dsp++);\n\tdelete [] ds2;ds2=dsn;stackp2=dsnp;\n\tstacke2=ds2+current_delete2_size;\n}\n\n/** Initializes a Voronoi cell as a rectangular box with the given dimensions.\n * \\param[in] (xmin,xmax) the minimum and maximum x coordinates.\n * \\param[in] (ymin,ymax) the minimum and maximum y coordinates.\n * \\param[in] (zmin,zmax) the minimum and maximum z coordinates. */\nvoid voronoicell_base::init_base(double xmin,double xmax,double ymin,double ymax,double zmin,double zmax) {\n\tfor(int i=0;i<current_vertex_order;i++) mec[i]=0;up=0;\n\tmec[3]=p=8;xmin*=2;xmax*=2;ymin*=2;ymax*=2;zmin*=2;zmax*=2;\n\t*pts=xmin;pts[1]=ymin;pts[2]=zmin;\n\tpts[3]=xmax;pts[4]=ymin;pts[5]=zmin;\n\tpts[6]=xmin;pts[7]=ymax;pts[8]=zmin;\n\tpts[9]=xmax;pts[10]=ymax;pts[11]=zmin;\n\tpts[12]=xmin;pts[13]=ymin;pts[14]=zmax;\n\tpts[15]=xmax;pts[16]=ymin;pts[17]=zmax;\n\tpts[18]=xmin;pts[19]=ymax;pts[20]=zmax;\n\tpts[21]=xmax;pts[22]=ymax;pts[23]=zmax;\n\tint *q=mep[3];\n\t*q=1;q[1]=4;q[2]=2;q[3]=2;q[4]=1;q[5]=0;q[6]=0;\n\tq[7]=3;q[8]=5;q[9]=0;q[10]=2;q[11]=1;q[12]=0;q[13]=1;\n\tq[14]=0;q[15]=6;q[16]=3;q[17]=2;q[18]=1;q[19]=0;q[20]=2;\n\tq[21]=2;q[22]=7;q[23]=1;q[24]=2;q[25]=1;q[26]=0;q[27]=3;\n\tq[28]=6;q[29]=0;q[30]=5;q[31]=2;q[32]=1;q[33]=0;q[34]=4;\n\tq[35]=4;q[36]=1;q[37]=7;q[38]=2;q[39]=1;q[40]=0;q[41]=5;\n\tq[42]=7;q[43]=2;q[44]=4;q[45]=2;q[46]=1;q[47]=0;q[48]=6;\n\tq[49]=5;q[50]=3;q[51]=6;q[52]=2;q[53]=1;q[54]=0;q[55]=7;\n\t*ed=q;ed[1]=q+7;ed[2]=q+14;ed[3]=q+21;\n\ted[4]=q+28;ed[5]=q+35;ed[6]=q+42;ed[7]=q+49;\n\t*nu=nu[1]=nu[2]=nu[3]=nu[4]=nu[5]=nu[6]=nu[7]=3;\n}\n\n/** Initializes a Voronoi cell as a regular octahedron.\n * \\param[in] l The distance from the octahedron center to a vertex. Six\n *              vertices are initialized at (-l,0,0), (l,0,0), (0,-l,0),\n *              (0,l,0), (0,0,-l), and (0,0,l). */\nvoid voronoicell_base::init_octahedron_base(double l) {\n\tfor(int i=0;i<current_vertex_order;i++) mec[i]=0;up=0;\n\tmec[4]=p=6;l*=2;\n\t*pts=-l;pts[1]=0;pts[2]=0;\n\tpts[3]=l;pts[4]=0;pts[5]=0;\n\tpts[6]=0;pts[7]=-l;pts[8]=0;\n\tpts[9]=0;pts[10]=l;pts[11]=0;\n\tpts[12]=0;pts[13]=0;pts[14]=-l;\n\tpts[15]=0;pts[16]=0;pts[17]=l;\n\tint *q=mep[4];\n\t*q=2;q[1]=5;q[2]=3;q[3]=4;q[4]=0;q[5]=0;q[6]=0;q[7]=0;q[8]=0;\n\tq[9]=2;q[10]=4;q[11]=3;q[12]=5;q[13]=2;q[14]=2;q[15]=2;q[16]=2;q[17]=1;\n\tq[18]=0;q[19]=4;q[20]=1;q[21]=5;q[22]=0;q[23]=3;q[24]=0;q[25]=1;q[26]=2;\n\tq[27]=0;q[28]=5;q[29]=1;q[30]=4;q[31]=2;q[32]=3;q[33]=2;q[34]=1;q[35]=3;\n\tq[36]=0;q[37]=3;q[38]=1;q[39]=2;q[40]=3;q[41]=3;q[42]=1;q[43]=1;q[44]=4;\n\tq[45]=0;q[46]=2;q[47]=1;q[48]=3;q[49]=1;q[50]=3;q[51]=3;q[52]=1;q[53]=5;\n\t*ed=q;ed[1]=q+9;ed[2]=q+18;ed[3]=q+27;ed[4]=q+36;ed[5]=q+45;\n\t*nu=nu[1]=nu[2]=nu[3]=nu[4]=nu[5]=4;\n}\n\n/** Initializes a Voronoi cell as a tetrahedron. It assumes that the normal to\n * the face for the first three vertices points inside.\n * \\param (x0,y0,z0) a position vector for the first vertex.\n * \\param (x1,y1,z1) a position vector for the second vertex.\n * \\param (x2,y2,z2) a position vector for the third vertex.\n * \\param (x3,y3,z3) a position vector for the fourth vertex. */\nvoid voronoicell_base::init_tetrahedron_base(double x0,double y0,double z0,double x1,double y1,double z1,double x2,double y2,double z2,double x3,double y3,double z3) {\n\tfor(int i=0;i<current_vertex_order;i++) mec[i]=0;up=0;\n\tmec[3]=p=4;\n\t*pts=x0*2;pts[1]=y0*2;pts[2]=z0*2;\n\tpts[3]=x1*2;pts[4]=y1*2;pts[5]=z1*2;\n\tpts[6]=x2*2;pts[7]=y2*2;pts[8]=z2*2;\n\tpts[9]=x3*2;pts[10]=y3*2;pts[11]=z3*2;\n\tint *q=mep[3];\n\t*q=1;q[1]=3;q[2]=2;q[3]=0;q[4]=0;q[5]=0;q[6]=0;\n\tq[7]=0;q[8]=2;q[9]=3;q[10]=0;q[11]=2;q[12]=1;q[13]=1;\n\tq[14]=0;q[15]=3;q[16]=1;q[17]=2;q[18]=2;q[19]=1;q[20]=2;\n\tq[21]=0;q[22]=1;q[23]=2;q[24]=1;q[25]=2;q[26]=1;q[27]=3;\n\t*ed=q;ed[1]=q+7;ed[2]=q+14;ed[3]=q+21;\n\t*nu=nu[1]=nu[2]=nu[3]=3;\n}\n\n/** Checks that the relational table of the Voronoi cell is accurate, and\n * prints out any errors. This algorithm is O(p), so running it every time the\n * plane routine is called will result in a significant slowdown. */\nvoid voronoicell_base::check_relations() {\n\tint i,j;\n\tfor(i=0;i<p;i++) for(j=0;j<nu[i];j++) if(ed[ed[i][j]][ed[i][nu[i]+j]]!=i)\n\t\tprintf(\"Relational error at point %d, edge %d.\\n\",i,j);\n}\n\n/** This routine checks for any two vertices that are connected by more than\n * one edge. The plane algorithm is designed so that this should not happen, so\n * any occurrences are most likely errors. Note that the routine is O(p), so\n * running it every time the plane routine is called will result in a\n * significant slowdown. */\nvoid voronoicell_base::check_duplicates() {\n\tint i,j,k;\n\tfor(i=0;i<p;i++) for(j=1;j<nu[i];j++) for(k=0;k<j;k++) if(ed[i][j]==ed[i][k])\n\t\tprintf(\"Duplicate edges: (%d,%d) and (%d,%d) [%d]\\n\",i,j,i,k,ed[i][j]);\n}\n\n/** Constructs the relational table if the edges have been specified. */\nvoid voronoicell_base::construct_relations() {\n\tint i,j,k,l;\n\tfor(i=0;i<p;i++) for(j=0;j<nu[i];j++) {\n\t\tk=ed[i][j];\n\t\tl=0;\n\t\twhile(ed[k][l]!=i) {\n\t\t\tl++;\n\t\t\tif(l==nu[k]) voro_fatal_error(\"Relation table construction failed\",VOROPP_INTERNAL_ERROR);\n\t\t}\n\t\ted[i][nu[i]+j]=l;\n\t}\n}\n\n/** Starting from a point within the current cutting plane, this routine attempts\n * to find an edge to a point outside the cutting plane. This prevents the plane\n * routine from .\n * \\param[in] vc a reference to the specialized version of the calling class.\n * \\param[in,out] up */\ntemplate<class vc_class>\ninline bool voronoicell_base::search_for_outside_edge(vc_class &vc,int &up) {\n\tint i,lp,lw,*j(ds2),*stackp2(ds2);\n\tdouble l;\n\t*(stackp2++)=up;\n\twhile(j<stackp2) {\n\t\tup=*(j++);\n\t\tfor(i=0;i<nu[up];i++) {\n\t\t\tlp=ed[up][i];\n\t\t\tlw=m_test(lp,l);\n\t\t\tif(lw==-1) return true;\n\t\t\telse if(lw==0) add_to_stack(vc,lp,stackp2);\n\t\t}\n\t}\n\treturn false;\n}\n\n/** Adds a point to the auxiliary delete stack if it is not already there.\n * \\param[in] vc a reference to the specialized version of the calling class.\n * \\param[in] lp the index of the point to add.\n * \\param[in,out] stackp2 a pointer to the end of the stack entries. */\ntemplate<class vc_class>\ninline void voronoicell_base::add_to_stack(vc_class &vc,int lp,int *&stackp2) {\n\tfor(int *k(ds2);k<stackp2;k++) if(*k==lp) return;\n\tif(stackp2==stacke2) add_memory_ds2(stackp2);\n\t*(stackp2++)=lp;\n}\n\n/** Cuts the Voronoi cell by a particle whose center is at a separation of\n * (x,y,z) from the cell center. The value of rsq should be initially set to\n * \\f$x^2+y^2+z^2\\f$.\n * \\param[in] vc a reference to the specialized version of the calling class.\n * \\param[in] (x,y,z) the normal vector to the plane.\n * \\param[in] rsq the distance along this vector of the plane.\n * \\param[in] p_id the plane ID (for neighbor tracking only).\n * \\return False if the plane cut deleted the cell entirely, true otherwise. */\ntemplate<class vc_class>\nbool voronoicell_base::nplane(vc_class &vc,double x,double y,double z,double rsq,int p_id) {\n\tint count=0,i,j,k,lp=up,cp,qp,rp,*stackp(ds),*stackp2(ds2),*dsp;\n\tint us=0,ls=0,qs,iqs,cs,uw,qw,lw;\n\tint *edp,*edd;\n\tdouble u,l,r,q;bool complicated_setup=false,new_double_edge=false,double_edge=false;\n\n\t// Initialize the safe testing routine\n\tn_marg=0;px=x;py=y;pz=z;prsq=rsq;\n\n\t// Test approximately sqrt(n)/4 points for their proximity to the plane\n\t// and keep the one which is closest\n\tuw=m_test(up,u);\n\n\t// Starting from an initial guess, we now move from vertex to vertex,\n\t// to try and find an edge which intersects the cutting plane,\n\t// or a vertex which is on the plane\n\ttry {\n\t\tif(uw==1) {\n\n\t\t\t// The test point is inside the cutting plane.\n\t\t\tus=0;\n\t\t\tdo {\n\t\t\t\tlp=ed[up][us];\n\t\t\t\tlw=m_test(lp,l);\n\t\t\t\tif(l<u) break;\n\t\t\t\tus++;\n\t\t\t} while (us<nu[up]);\n\n\t\t\tif(us==nu[up]) {\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tls=ed[up][nu[up]+us];\n\t\t\twhile(lw==1) {\n\t\t\t\tif(++count>=p) throw true;\n\t\t\t\tu=l;up=lp;\n\t\t\t\tfor(us=0;us<ls;us++) {\n\t\t\t\t\tlp=ed[up][us];\n\t\t\t\t\tlw=m_test(lp,l);\n\t\t\t\t\tif(l<u) break;\n\t\t\t\t}\n\t\t\t\tif(us==ls) {\n\t\t\t\t\tus++;\n\t\t\t\t\twhile(us<nu[up]) {\n\t\t\t\t\t\tlp=ed[up][us];\n\t\t\t\t\t\tlw=m_test(lp,l);\n\t\t\t\t\t\tif(l<u) break;\n\t\t\t\t\t\tus++;\n\t\t\t\t\t}\n\t\t\t\t\tif(us==nu[up]) {\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tls=ed[up][nu[up]+us];\n\t\t\t}\n\n\t\t\t// If the last point in the iteration is within the\n\t\t\t// plane, we need to do the complicated setup\n\t\t\t// routine. Otherwise, we use the regular iteration.\n\t\t\tif(lw==0) {\n\t\t\t\tup=lp;\n\t\t\t\tcomplicated_setup=true;\n\t\t\t} else complicated_setup=false;\n\t\t} else if(uw==-1) {\n\t\t\tus=0;\n\t\t\tdo {\n\t\t\t\tqp=ed[up][us];\n\t\t\t\tqw=m_test(qp,q);\n\t\t\t\tif(u<q) break;\n\t\t\t\tus++;\n\t\t\t} while (us<nu[up]);\n\t\t\tif(us==nu[up]) return true;\n\n\t\t\twhile(qw==-1) {\n\t\t\t\tqs=ed[up][nu[up]+us];\n\t\t\t\tif(++count>=p) throw true;\n\t\t\t\tu=q;up=qp;\n\t\t\t\tfor(us=0;us<qs;us++) {\n\t\t\t\t\tqp=ed[up][us];\n\t\t\t\t\tqw=m_test(qp,q);\n\t\t\t\t\tif(u<q) break;\n\t\t\t\t}\n\t\t\t\tif(us==qs) {\n\t\t\t\t\tus++;\n\t\t\t\t\twhile(us<nu[up]) {\n\t\t\t\t\t\tqp=ed[up][us];\n\t\t\t\t\t\tqw=m_test(qp,q);\n\t\t\t\t\t\tif(u<q) break;\n\t\t\t\t\t\tus++;\n\t\t\t\t\t}\n\t\t\t\t\tif(us==nu[up]) return true;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(qw==1) {\n\t\t\t\tlp=up;ls=us;l=u;\n\t\t\t\tup=qp;us=ed[lp][nu[lp]+ls];u=q;\n\t\t\t\tcomplicated_setup=false;\n\t\t\t} else {\n\t\t\t\tup=qp;\n\t\t\t\tcomplicated_setup=true;\n\t\t\t}\n\t\t} else {\n\n\t\t\t// Our original test point was on the plane, so we\n\t\t\t// automatically head for the complicated setup\n\t\t\t// routine\n\t\t\tcomplicated_setup=true;\n\t\t}\n\t}\n\tcatch(bool except) {\n\t\t// This routine is a fall-back, in case floating point errors\n\t\t// cause the usual search routine to fail. In the fall-back\n\t\t// routine, we just test every edge to find one straddling\n\t\t// the plane.\n#if VOROPP_VERBOSE >=1\n\t\tfputs(\"Bailed out of convex calculation\\n\",stderr);\n#endif\n\t\tqw=1;lw=0;\n\t\tfor(qp=0;qp<p;qp++) {\n\t\t\tqw=m_test(qp,q);\n\t\t\tif(qw==1) {\n\n\t\t\t\t// The point is inside the cutting space. Now\n\t\t\t\t// see if we can find a neighbor which isn't.\n\t\t\t\tfor(us=0;us<nu[qp];us++) {\n\t\t\t\t\tlp=ed[qp][us];\n\t\t\t\t\tif(lp<qp) {\n\t\t\t\t\t\tlw=m_test(lp,l);\n\t\t\t\t\t\tif(lw!=1) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(us<nu[qp]) {\n\t\t\t\t\tup=qp;\n\t\t\t\t\tif(lw==0) {\n\t\t\t\t\t\tcomplicated_setup=true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcomplicated_setup=false;\n\t\t\t\t\t\tu=q;\n\t\t\t\t\t\tls=ed[up][nu[up]+us];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else if(qw==-1) {\n\n\t\t\t\t// The point is outside the cutting space. See\n\t\t\t\t// if we can find a neighbor which isn't.\n\t\t\t\tfor(ls=0;ls<nu[qp];ls++) {\n\t\t\t\t\tup=ed[qp][ls];\n\t\t\t\t\tif(up<qp) {\n\t\t\t\t\t\tuw=m_test(up,u);\n\t\t\t\t\t\tif(uw!=-1) break;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(ls<nu[qp]) {\n\t\t\t\t\tif(uw==0) {\n\t\t\t\t\t\tup=qp;\n\t\t\t\t\t\tcomplicated_setup=true;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcomplicated_setup=false;\n\t\t\t\t\t\tlp=qp;l=q;\n\t\t\t\t\t\tus=ed[lp][nu[lp]+ls];\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} else {\n\n\t\t\t\t// The point is in the plane, so we just\n\t\t\t\t// proceed with the complicated setup routine\n\t\t\t\tup=qp;\n\t\t\t\tcomplicated_setup=true;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif(qp==p) return qw==-1?true:false;\n\t}\n\n\t// We're about to add the first point of the new facet. In either\n\t// routine, we have to add a point, so first check there's space for\n\t// it.\n\tif(p==current_vertices) add_memory_vertices(vc);\n\n\tif(complicated_setup) {\n\n\t\t// We want to be strict about reaching the conclusion that the\n\t\t// cell is entirely within the cutting plane. It's not enough\n\t\t// to find a vertex that has edges which are all inside or on\n\t\t// the plane. If the vertex has neighbors that are also on the\n\t\t// plane, we should check those too.\n\t\tif(!search_for_outside_edge(vc,up)) return false;\n\n\t\t// The search algorithm found a point which is on the cutting\n\t\t// plane. We leave that point in place, and create a new one at\n\t\t// the same location.\n\t\tpts[3*p]=pts[3*up];\n\t\tpts[3*p+1]=pts[3*up+1];\n\t\tpts[3*p+2]=pts[3*up+2];\n\n\t\t// Search for a collection of edges of the test vertex which\n\t\t// are outside of the cutting space. Begin by testing the\n\t\t// zeroth edge.\n\t\ti=0;\n\t\tlp=*ed[up];\n\t\tlw=m_test(lp,l);\n\t\tif(lw!=-1) {\n\n\t\t\t// The first edge is either inside the cutting space,\n\t\t\t// or lies within the cutting plane. Test the edges\n\t\t\t// sequentially until we find one that is outside.\n\t\t\trp=lw;\n\t\t\tdo {\n\t\t\t\ti++;\n\n\t\t\t\t// If we reached the last edge with no luck\n\t\t\t\t// then all of the vertices are inside\n\t\t\t\t// or on the plane, so the cell is completely\n\t\t\t\t// deleted\n\t\t\t\tif(i==nu[up]) return false;\n\t\t\t\tlp=ed[up][i];\n\t\t\t\tlw=m_test(lp,l);\n\t\t\t} while (lw!=-1);\n\t\t\tj=i+1;\n\n\t\t\t// We found an edge outside the cutting space. Keep\n\t\t\t// moving through these edges until we find one that's\n\t\t\t// inside or on the plane.\n\t\t\twhile(j<nu[up]) {\n\t\t\t\tlp=ed[up][j];\n\t\t\t\tlw=m_test(lp,l);\n\t\t\t\tif(lw!=-1) break;\n\t\t\t\tj++;\n\t\t\t}\n\n\t\t\t// Compute the number of edges for the new vertex. In\n\t\t\t// general it will be the number of outside edges\n\t\t\t// found, plus two. But we need to recognize the\n\t\t\t// special case when all but one edge is outside, and\n\t\t\t// the remaining one is on the plane. For that case we\n\t\t\t// have to reduce the edge count by one to prevent\n\t\t\t// doubling up.\n\t\t\tif(j==nu[up]&&i==1&&rp==0) {\n\t\t\t\tnu[p]=nu[up];\n\t\t\t\tdouble_edge=true;\n\t\t\t} else nu[p]=j-i+2;\n\t\t\tk=1;\n\n\t\t\t// Add memory for the new vertex if needed, and\n\t\t\t// initialize\n\t\t\twhile (nu[p]>=current_vertex_order) add_memory_vorder(vc);\n\t\t\tif(mec[nu[p]]==mem[nu[p]]) add_memory(vc,nu[p],stackp2);\n\t\t\tvc.n_set_pointer(p,nu[p]);\n\t\t\ted[p]=mep[nu[p]]+((nu[p]<<1)+1)*mec[nu[p]]++;\n\t\t\ted[p][nu[p]<<1]=p;\n\n\t\t\t// Copy the edges of the original vertex into the new\n\t\t\t// one. Delete the edges of the original vertex, and\n\t\t\t// update the relational table.\n\t\t\tus=cycle_down(i,up);\n\t\t\twhile(i<j) {\n\t\t\t\tqp=ed[up][i];\n\t\t\t\tqs=ed[up][nu[up]+i];\n\t\t\t\tvc.n_copy(p,k,up,i);\n\t\t\t\ted[p][k]=qp;\n\t\t\t\ted[p][nu[p]+k]=qs;\n\t\t\t\ted[qp][qs]=p;\n\t\t\t\ted[qp][nu[qp]+qs]=k;\n\t\t\t\ted[up][i]=-1;\n\t\t\t\ti++;k++;\n\t\t\t}\n\t\t\tqs=i==nu[up]?0:i;\n\t\t} else {\n\n\t\t\t// In this case, the zeroth edge is outside the cutting\n\t\t\t// plane. Begin by searching backwards from the last\n\t\t\t// edge until we find an edge which isn't outside.\n\t\t\ti=nu[up]-1;\n\t\t\tlp=ed[up][i];\n\t\t\tlw=m_test(lp,l);\n\t\t\twhile(lw==-1) {\n\t\t\t\ti--;\n\n\t\t\t\t// If i reaches zero, then we have a point in\n\t\t\t\t// the plane all of whose edges are outside\n\t\t\t\t// the cutting space, so we just exit\n\t\t\t\tif(i==0) return true;\n\t\t\t\tlp=ed[up][i];\n\t\t\t\tlw=m_test(lp,l);\n\t\t\t}\n\n\t\t\t// Now search forwards from zero\n\t\t\tj=1;\n\t\t\tqp=ed[up][j];\n\t\t\tqw=m_test(qp,q);\n\t\t\twhile(qw==-1) {\n\t\t\t\tj++;\n\t\t\t\tqp=ed[up][j];\n\t\t\t\tqw=m_test(qp,l);\n\t\t\t}\n\n\t\t\t// Compute the number of edges for the new vertex. In\n\t\t\t// general it will be the number of outside edges\n\t\t\t// found, plus two. But we need to recognize the\n\t\t\t// special case when all but one edge is outside, and\n\t\t\t// the remaining one is on the plane. For that case we\n\t\t\t// have to reduce the edge count by one to prevent\n\t\t\t// doubling up.\n\t\t\tif(i==j&&qw==0) {\n\t\t\t\tdouble_edge=true;\n\t\t\t\tnu[p]=nu[up];\n\t\t\t} else {\n\t\t\t\tnu[p]=nu[up]-i+j+1;\n\t\t\t}\n\n\t\t\t// Add memory to store the vertex if it doesn't exist\n\t\t\t// already\n\t\t\tk=1;\n\t\t\twhile(nu[p]>=current_vertex_order) add_memory_vorder(vc);\n\t\t\tif(mec[nu[p]]==mem[nu[p]]) add_memory(vc,nu[p],stackp2);\n\n\t\t\t// Copy the edges of the original vertex into the new\n\t\t\t// one. Delete the edges of the original vertex, and\n\t\t\t// update the relational table.\n\t\t\tvc.n_set_pointer(p,nu[p]);\n\t\t\ted[p]=mep[nu[p]]+((nu[p]<<1)+1)*mec[nu[p]]++;\n\t\t\ted[p][nu[p]<<1]=p;\n\t\t\tus=i++;\n\t\t\twhile(i<nu[up]) {\n\t\t\t\tqp=ed[up][i];\n\t\t\t\tqs=ed[up][nu[up]+i];\n\t\t\t\tvc.n_copy(p,k,up,i);\n\t\t\t\ted[p][k]=qp;\n\t\t\t\ted[p][nu[p]+k]=qs;\n\t\t\t\ted[qp][qs]=p;\n\t\t\t\ted[qp][nu[qp]+qs]=k;\n\t\t\t\ted[up][i]=-1;\n\t\t\t\ti++;k++;\n\t\t\t}\n\t\t\ti=0;\n\t\t\twhile(i<j) {\n\t\t\t\tqp=ed[up][i];\n\t\t\t\tqs=ed[up][nu[up]+i];\n\t\t\t\tvc.n_copy(p,k,up,i);\n\t\t\t\ted[p][k]=qp;\n\t\t\t\ted[p][nu[p]+k]=qs;\n\t\t\t\ted[qp][qs]=p;\n\t\t\t\ted[qp][nu[qp]+qs]=k;\n\t\t\t\ted[up][i]=-1;\n\t\t\t\ti++;k++;\n\t\t\t}\n\t\t\tqs=j;\n\t\t}\n\t\tif(!double_edge) {\n\t\t\tvc.n_copy(p,k,up,qs);\n\t\t\tvc.n_set(p,0,p_id);\n\t\t} else vc.n_copy(p,0,up,qs);\n\n\t\t// Add this point to the auxiliary delete stack\n\t\tif(stackp2==stacke2) add_memory_ds2(stackp2);\n\t\t*(stackp2++)=up;\n\n\t\t// Look at the edges on either side of the group that was\n\t\t// detected. We're going to commence facet computation by\n\t\t// moving along one of them. We are going to end up coming back\n\t\t// along the other one.\n\t\tcs=k;\n\t\tqp=up;q=u;\n\t\ti=ed[up][us];\n\t\tus=ed[up][nu[up]+us];\n\t\tup=i;\n\t\ted[qp][nu[qp]<<1]=-p;\n\n\t} else {\n\n\t\t// The search algorithm found an intersected edge between the\n\t\t// points lp and up. Create a new vertex between them which\n\t\t// lies on the cutting plane. Since u and l differ by at least\n\t\t// the tolerance, this division should never screw up.\n\t\tif(stackp==stacke) add_memory_ds(stackp);\n\t\t*(stackp++)=up;\n\t\tr=u/(u-l);l=1-r;\n\t\tpts[3*p]=pts[3*lp]*r+pts[3*up]*l;\n\t\tpts[3*p+1]=pts[3*lp+1]*r+pts[3*up+1]*l;\n\t\tpts[3*p+2]=pts[3*lp+2]*r+pts[3*up+2]*l;\n\n\t\t// This point will always have three edges. Connect one of them\n\t\t// to lp.\n\t\tnu[p]=3;\n\t\tif(mec[3]==mem[3]) add_memory(vc,3,stackp2);\n\t\tvc.n_set_pointer(p,3);\n\t\tvc.n_set(p,0,p_id);\n\t\tvc.n_copy(p,1,up,us);\n\t\tvc.n_copy(p,2,lp,ls);\n\t\ted[p]=mep[3]+7*mec[3]++;\n\t\ted[p][6]=p;\n\t\ted[up][us]=-1;\n\t\ted[lp][ls]=p;\n\t\ted[lp][nu[lp]+ls]=1;\n\t\ted[p][1]=lp;\n\t\ted[p][nu[p]+1]=ls;\n\t\tcs=2;\n\n\t\t// Set the direction to move in\n\t\tqs=cycle_up(us,up);\n\t\tqp=up;q=u;\n\t}\n\n\t// When the code reaches here, we have initialized the first point, and\n\t// we have a direction for moving it to construct the rest of the facet\n\tcp=p;rp=p;p++;\n\twhile(qp!=up||qs!=us) {\n\n\t\t// We're currently tracing round an intersected facet. Keep\n\t\t// moving around it until we find a point or edge which\n\t\t// intersects the plane.\n\t\tlp=ed[qp][qs];\n\t\tlw=m_test(lp,l);\n\n\t\tif(lw==1) {\n\n\t\t\t// The point is still in the cutting space. Just add it\n\t\t\t// to the delete stack and keep moving.\n\t\t\tqs=cycle_up(ed[qp][nu[qp]+qs],lp);\n\t\t\tqp=lp;\n\t\t\tq=l;\n\t\t\tif(stackp==stacke) add_memory_ds(stackp);\n\t\t\t*(stackp++)=qp;\n\n\t\t} else if(lw==-1) {\n\n\t\t\t// The point is outside of the cutting space, so we've\n\t\t\t// found an intersected edge. Introduce a regular point\n\t\t\t// at the point of intersection. Connect it to the\n\t\t\t// point we just tested. Also connect it to the previous\n\t\t\t// new point in the facet we're constructing.\n\t\t\tif(p==current_vertices) add_memory_vertices(vc);\n\t\t\tr=q/(q-l);l=1-r;\n\t\t\tpts[3*p]=pts[3*lp]*r+pts[3*qp]*l;\n\t\t\tpts[3*p+1]=pts[3*lp+1]*r+pts[3*qp+1]*l;\n\t\t\tpts[3*p+2]=pts[3*lp+2]*r+pts[3*qp+2]*l;\n\t\t\tnu[p]=3;\n\t\t\tif(mec[3]==mem[3]) add_memory(vc,3,stackp2);\n\t\t\tls=ed[qp][qs+nu[qp]];\n\t\t\tvc.n_set_pointer(p,3);\n\t\t\tvc.n_set(p,0,p_id);\n\t\t\tvc.n_copy(p,1,qp,qs);\n\t\t\tvc.n_copy(p,2,lp,ls);\n\t\t\ted[p]=mep[3]+7*mec[3]++;\n\t\t\t*ed[p]=cp;\n\t\t\ted[p][1]=lp;\n\t\t\ted[p][3]=cs;\n\t\t\ted[p][4]=ls;\n\t\t\ted[p][6]=p;\n\t\t\ted[lp][ls]=p;\n\t\t\ted[lp][nu[lp]+ls]=1;\n\t\t\ted[cp][cs]=p;\n\t\t\ted[cp][nu[cp]+cs]=0;\n\t\t\ted[qp][qs]=-1;\n\t\t\tqs=cycle_up(qs,qp);\n\t\t\tcp=p++;\n\t\t\tcs=2;\n\t\t} else {\n\n\t\t\t// We've found a point which is on the cutting plane.\n\t\t\t// We're going to introduce a new point right here, but\n\t\t\t// first we need to figure out the number of edges it\n\t\t\t// has.\n\t\t\tif(p==current_vertices) add_memory_vertices(vc);\n\n\t\t\t// If the previous vertex detected a double edge, our\n\t\t\t// new vertex will have one less edge.\n\t\t\tk=double_edge?0:1;\n\t\t\tqs=ed[qp][nu[qp]+qs];\n\t\t\tqp=lp;\n\t\t\tiqs=qs;\n\n\t\t\t// Start testing the edges of the current point until\n\t\t\t// we find one which isn't outside the cutting space\n\t\t\tdo {\n\t\t\t\tk++;\n\t\t\t\tqs=cycle_up(qs,qp);\n\t\t\t\tlp=ed[qp][qs];\n\t\t\t\tlw=m_test(lp,l);\n\t\t\t} while (lw==-1);\n\n\t\t\t// Now we need to find out whether this marginal vertex\n\t\t\t// we are on has been visited before, because if that's\n\t\t\t// the case, we need to add vertices to the existing\n\t\t\t// new vertex, rather than creating a fresh one. We also\n\t\t\t// need to figure out whether we're in a case where we\n\t\t\t// might be creating a duplicate edge.\n\t\t\tj=-ed[qp][nu[qp]<<1];\n\t \t\tif(qp==up&&qs==us) {\n\n\t\t\t\t// If we're heading into the final part of the\n\t\t\t\t// new facet, then we never worry about the\n\t\t\t\t// duplicate edge calculation.\n\t\t\t\tnew_double_edge=false;\n\t\t\t\tif(j>0) k+=nu[j];\n\t\t\t} else {\n\t\t\t\tif(j>0) {\n\n\t\t\t\t\t// This vertex was visited before, so\n\t\t\t\t\t// count those vertices to the ones we\n\t\t\t\t\t// already have.\n\t\t\t\t\tk+=nu[j];\n\n\t\t\t\t\t// The only time when we might make a\n\t\t\t\t\t// duplicate edge is if the point we're\n\t\t\t\t\t// going to move to next is also a\n\t\t\t\t\t// marginal point, so test for that\n\t\t\t\t\t// first.\n\t\t\t\t\tif(lw==0) {\n\n\t\t\t\t\t\t// Now see whether this marginal point\n\t\t\t\t\t\t// has been visited before.\n\t\t\t\t\t\ti=-ed[lp][nu[lp]<<1];\n\t\t\t\t\t\tif(i>0) {\n\n\t\t\t\t\t\t\t// Now see if the last edge of that other\n\t\t\t\t\t\t\t// marginal point actually ends up here.\n\t\t\t\t\t\t\tif(ed[i][nu[i]-1]==j) {\n\t\t\t\t\t\t\t\tnew_double_edge=true;\n\t\t\t\t\t\t\t\tk-=1;\n\t\t\t\t\t\t\t} else new_double_edge=false;\n\t\t\t\t\t\t} else {\n\n\t\t\t\t\t\t\t// That marginal point hasn't been visited\n\t\t\t\t\t\t\t// before, so we probably don't have to worry\n\t\t\t\t\t\t\t// about duplicate edges, except in the\n\t\t\t\t\t\t\t// case when that's the way into the end\n\t\t\t\t\t\t\t// of the facet, because that way always creates\n\t\t\t\t\t\t\t// an edge.\n\t\t\t\t\t\t\tif(j==rp&&lp==up&&ed[qp][nu[qp]+qs]==us) {\n\t\t\t\t\t\t\t\tnew_double_edge=true;\n\t\t\t\t\t\t\t\tk-=1;\n\t\t\t\t\t\t\t} else new_double_edge=false;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else new_double_edge=false;\n\t\t\t\t} else {\n\n\t\t\t\t\t// The vertex hasn't been visited\n\t\t\t\t\t// before, but let's see if it's\n\t\t\t\t\t// marginal\n\t\t\t\t\tif(lw==0) {\n\n\t\t\t\t\t\t// If it is, we need to check\n\t\t\t\t\t\t// for the case that it's a\n\t\t\t\t\t\t// small branch, and that we're\n\t\t\t\t\t\t// heading right back to where\n\t\t\t\t\t\t// we came from\n\t\t\t\t\t\ti=-ed[lp][nu[lp]<<1];\n\t\t\t\t\t\tif(i==cp) {\n\t\t\t\t\t\t\tnew_double_edge=true;\n\t\t\t\t\t\t\tk-=1;\n\t\t\t\t\t\t} else new_double_edge=false;\n\t\t\t\t\t} else new_double_edge=false;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// k now holds the number of edges of the new vertex\n\t\t\t// we are forming. Add memory for it if it doesn't exist\n\t\t\t// already.\n\t\t\twhile(k>=current_vertex_order) add_memory_vorder(vc);\n\t\t\tif(mec[k]==mem[k]) add_memory(vc,k,stackp2);\n\n\t\t\t// Now create a new vertex with order k, or augment\n\t\t\t// the existing one\n\t\t\tif(j>0) {\n\n\t\t\t\t// If we're augmenting a vertex but we don't\n\t\t\t\t// actually need any more edges, just skip this\n\t\t\t\t// routine to avoid memory confusion\n\t\t\t\tif(nu[j]!=k) {\n\t\t\t\t\t// Allocate memory and copy the edges\n\t\t\t\t\t// of the previous instance into it\n\t\t\t\t\tvc.n_set_aux1(k);\n\t\t\t\t\tedp=mep[k]+((k<<1)+1)*mec[k]++;\n\t\t\t\t\ti=0;\n\t\t\t\t\twhile(i<nu[j]) {\n\t\t\t\t\t\tvc.n_copy_aux1(j,i);\n\t\t\t\t\t\tedp[i]=ed[j][i];\n\t\t\t\t\t\tedp[k+i]=ed[j][nu[j]+i];\n\t\t\t\t\t\ti++;\n\t\t\t\t\t}\n\t\t\t\t\tedp[k<<1]=j;\n\n\t\t\t\t\t// Remove the previous instance with\n\t\t\t\t\t// fewer vertices from the memory\n\t\t\t\t\t// structure\n\t\t\t\t\tedd=mep[nu[j]]+((nu[j]<<1)+1)*--mec[nu[j]];\n\t\t\t\t\tif(edd!=ed[j]) {\n\t\t\t\t\t\tfor(lw=0;lw<=(nu[j]<<1);lw++) ed[j][lw]=edd[lw];\n\t\t\t\t\t\tvc.n_set_aux2_copy(j,nu[j]);\n\t\t\t\t\t\tvc.n_copy_pointer(edd[nu[j]<<1],j);\n\t\t\t\t\t\ted[edd[nu[j]<<1]]=ed[j];\n\t\t\t\t\t}\n\t\t\t\t\tvc.n_set_to_aux1(j);\n\t\t\t\t\ted[j]=edp;\n\t\t\t\t} else i=nu[j];\n\t\t\t} else {\n\n\t\t\t\t// Allocate a new vertex of order k\n\t\t\t\tvc.n_set_pointer(p,k);\n\t\t\t\ted[p]=mep[k]+((k<<1)+1)*mec[k]++;\n\t\t\t\ted[p][k<<1]=p;\n\t\t\t\tif(stackp2==stacke2) add_memory_ds2(stackp2);\n\t\t\t\t*(stackp2++)=qp;\n\t\t\t\tpts[3*p]=pts[3*qp];\n\t\t\t\tpts[3*p+1]=pts[3*qp+1];\n\t\t\t\tpts[3*p+2]=pts[3*qp+2];\n\t\t\t\ted[qp][nu[qp]<<1]=-p;\n\t\t\t\tj=p++;\n\t\t\t\ti=0;\n\t\t\t}\n\t\t\tnu[j]=k;\n\n\t\t\t// Unless the previous case was a double edge, connect\n\t\t\t// the first available edge of the new vertex to the\n\t\t\t// last one in the facet\n\t\t\tif(!double_edge) {\n\t\t\t\ted[j][i]=cp;\n\t\t\t\ted[j][nu[j]+i]=cs;\n\t\t\t\tvc.n_set(j,i,p_id);\n\t\t\t\ted[cp][cs]=j;\n\t\t\t\ted[cp][nu[cp]+cs]=i;\n\t\t\t\ti++;\n\t\t\t}\n\n\t\t\t// Copy in the edges of the underlying vertex,\n\t\t\t// and do one less if this was a double edge\n\t\t\tqs=iqs;\n\t\t\twhile(i<(new_double_edge?k:k-1)) {\n\t\t\t\tqs=cycle_up(qs,qp);\n\t\t\t\tlp=ed[qp][qs];ls=ed[qp][nu[qp]+qs];\n\t\t\t\tvc.n_copy(j,i,qp,qs);\n\t\t\t\ted[j][i]=lp;\n\t\t\t\ted[j][nu[j]+i]=ls;\n\t\t\t\ted[lp][ls]=j;\n\t\t\t\ted[lp][nu[lp]+ls]=i;\n\t\t\t\ted[qp][qs]=-1;\n\t\t\t\ti++;\n\t\t\t}\n\t\t\tqs=cycle_up(qs,qp);\n\t\t\tcs=i;\n\t\t\tcp=j;\n\t\t\tvc.n_copy(j,new_double_edge?0:cs,qp,qs);\n\n\t\t\t// Update the double_edge flag, to pass it\n\t\t\t// to the next instance of this routine\n\t\t\tdouble_edge=new_double_edge;\n\t\t}\n\t}\n\n\t// Connect the final created vertex to the initial one\n\ted[cp][cs]=rp;\n\t*ed[rp]=cp;\n\ted[cp][nu[cp]+cs]=0;\n\ted[rp][nu[rp]]=cs;\n\n\t// Delete points: first, remove any duplicates\n\tdsp=ds;\n\twhile(dsp<stackp) {\n\t\tj=*dsp;\n\t\tif(ed[j][nu[j]]!=-1) {\n\t\t\ted[j][nu[j]]=-1;\n\t\t\tdsp++;\n\t\t} else *dsp=*(--stackp);\n\t}\n\n\t// Add the points in the auxiliary delete stack,\n\t// and reset their back pointers\n\tfor(dsp=ds2;dsp<stackp2;dsp++) {\n\t\tj=*dsp;\n\t\ted[j][nu[j]<<1]=j;\n\t\tif(ed[j][nu[j]]!=-1) {\n\t\t\ted[j][nu[j]]=-1;\n\t\t\tif(stackp==stacke) add_memory_ds(stackp);\n\t\t\t*(stackp++)=j;\n\t\t}\n\t}\n\n\t// Scan connections and add in extras\n\tfor(dsp=ds;dsp<stackp;dsp++) {\n\t\tcp=*dsp;\n\t\tfor(edp=ed[cp];edp<ed[cp]+nu[cp];edp++) {\n\t\t\tqp=*edp;\n\t\t\tif(qp!=-1&&ed[qp][nu[qp]]!=-1) {\n\t\t\t\tif(stackp==stacke) {\n\t\t\t\t\tint dis=stackp-dsp;\n\t\t\t\t\tadd_memory_ds(stackp);\n\t\t\t\t\tdsp=ds+dis;\n\t\t\t\t}\n\t\t\t\t*(stackp++)=qp;\n\t\t\t\ted[qp][nu[qp]]=-1;\n\t\t\t}\n\t\t}\n\t}\n\tup=0;\n\n\t// Delete them from the array structure\n\twhile(stackp>ds) {\n\t\t--p;\n\t\twhile(ed[p][nu[p]]==-1) {\n\t\t\tj=nu[p];\n\t\t\tedp=ed[p];edd=(mep[j]+((j<<1)+1)*--mec[j]);\n\t\t\twhile(edp<ed[p]+(j<<1)+1) *(edp++)=*(edd++);\n\t\t\tvc.n_set_aux2_copy(p,j);\n\t\t\tvc.n_copy_pointer(ed[p][(j<<1)],p);\n\t\t\ted[ed[p][(j<<1)]]=ed[p];\n\t\t\t--p;\n\t\t}\n\t\tup=*(--stackp);\n\t\tif(up<p) {\n\n\t\t\t// Vertex management\n\t\t\tpts[3*up]=pts[3*p];\n\t\t\tpts[3*up+1]=pts[3*p+1];\n\t\t\tpts[3*up+2]=pts[3*p+2];\n\n\t\t\t// Memory management\n\t\t\tj=nu[up];\n\t\t\tedp=ed[up];edd=(mep[j]+((j<<1)+1)*--mec[j]);\n\t\t\twhile(edp<ed[up]+(j<<1)+1) *(edp++)=*(edd++);\n\t\t\tvc.n_set_aux2_copy(up,j);\n\t\t\tvc.n_copy_pointer(ed[up][j<<1],up);\n\t\t\tvc.n_copy_pointer(up,p);\n\t\t\ted[ed[up][j<<1]]=ed[up];\n\n\t\t\t// Edge management\n\t\t\ted[up]=ed[p];\n\t\t\tnu[up]=nu[p];\n\t\t\tfor(i=0;i<nu[up];i++) ed[ed[up][i]][ed[up][nu[up]+i]]=up;\n\t\t\ted[up][nu[up]<<1]=up;\n\t\t} else up=p++;\n\t}\n\n\t// Check for any vertices of zero order\n\tif(*mec>0) voro_fatal_error(\"Zero order vertex formed\",VOROPP_INTERNAL_ERROR);\n\n\t// Collapse any order 2 vertices and exit\n\treturn collapse_order2(vc);\n}\n\n/** During the creation of a new facet in the plane routine, it is possible\n * that some order two vertices may arise. This routine removes them.\n * Suppose an order two vertex joins c and d. If there's a edge between\n * c and d already, then the order two vertex is just removed; otherwise,\n * the order two vertex is removed and c and d are joined together directly.\n * It is possible this process will create order two or order one vertices,\n * and the routine is continually run until all of them are removed.\n * \\return False if the vertex removal was unsuccessful, indicative of the cell\n *         reducing to zero volume and disappearing; true if the vertex removal\n *         was successful. */\ntemplate<class vc_class>\ninline bool voronoicell_base::collapse_order2(vc_class &vc) {\n\tif(!collapse_order1(vc)) return false;\n\tint a,b,i,j,k,l;\n\twhile(mec[2]>0) {\n\n\t\t// Pick a order 2 vertex and read in its edges\n\t\ti=--mec[2];\n\t\tj=mep[2][5*i];k=mep[2][5*i+1];\n\t\tif(j==k) {\n#if VOROPP_VERBOSE >=1\n\t\t\tfputs(\"Order two vertex joins itself\",stderr);\n#endif\n\t\t\treturn false;\n\t\t}\n\n\t\t// Scan the edges of j to see if joins k\n\t\tfor(l=0;l<nu[j];l++) {\n\t\t\tif(ed[j][l]==k) break;\n\t\t}\n\n\t\t// If j doesn't already join k, join them together.\n\t\t// Otherwise delete the connection to the current\n\t\t// vertex from j and k.\n\t\ta=mep[2][5*i+2];b=mep[2][5*i+3];i=mep[2][5*i+4];\n\t\tif(l==nu[j]) {\n\t\t\ted[j][a]=k;\n\t\t\ted[k][b]=j;\n\t\t\ted[j][nu[j]+a]=b;\n\t\t\ted[k][nu[k]+b]=a;\n\t\t} else {\n\t\t\tif(!delete_connection(vc,j,a,false)) return false;\n\t\t\tif(!delete_connection(vc,k,b,true)) return false;\n\t\t}\n\n\t\t// Compact the memory\n\t\t--p;\n\t\tif(up==i) up=0;\n\t\tif(p!=i) {\n\t\t\tif(up==p) up=i;\n\t\t\tpts[3*i]=pts[3*p];\n\t\t\tpts[3*i+1]=pts[3*p+1];\n\t\t\tpts[3*i+2]=pts[3*p+2];\n\t\t\tfor(k=0;k<nu[p];k++) ed[ed[p][k]][ed[p][nu[p]+k]]=i;\n\t\t\tvc.n_copy_pointer(i,p);\n\t\t\ted[i]=ed[p];\n\t\t\tnu[i]=nu[p];\n\t\t\ted[i][nu[i]<<1]=i;\n\t\t}\n\n\t\t// Collapse any order 1 vertices if they were created\n\t\tif(!collapse_order1(vc)) return false;\n\t}\n\treturn true;\n}\n\n/** Order one vertices can potentially be created during the order two collapse\n * routine. This routine keeps removing them until there are none left.\n * \\return False if the vertex removal was unsuccessful, indicative of the cell\n *         having zero volume and disappearing; true if the vertex removal was\n *         successful. */\ntemplate<class vc_class>\ninline bool voronoicell_base::collapse_order1(vc_class &vc) {\n\tint i,j,k;\n\twhile(mec[1]>0) {\n\t\tup=0;\n#if VOROPP_VERBOSE >=1\n\t\tfputs(\"Order one collapse\\n\",stderr);\n#endif\n\t\ti=--mec[1];\n\t\tj=mep[1][3*i];k=mep[1][3*i+1];\n\t\ti=mep[1][3*i+2];\n\t\tif(!delete_connection(vc,j,k,false)) return false;\n\t\t--p;\n\t\tif(up==i) up=0;\n\t\tif(p!=i) {\n\t\t\tif(up==p) up=i;\n\t\t\tpts[3*i]=pts[3*p];\n\t\t\tpts[3*i+1]=pts[3*p+1];\n\t\t\tpts[3*i+2]=pts[3*p+2];\n\t\t\tfor(k=0;k<nu[p];k++) ed[ed[p][k]][ed[p][nu[p]+k]]=i;\n\t\t\tvc.n_copy_pointer(i,p);\n\t\t\ted[i]=ed[p];\n\t\t\tnu[i]=nu[p];\n\t\t\ted[i][nu[i]<<1]=i;\n\t\t}\n\t}\n\treturn true;\n}\n\n/** This routine deletes the kth edge of vertex j and reorganizes the memory.\n * If the neighbor computation is enabled, we also have to supply an handedness\n * flag to decide whether to preserve the plane on the left or right of the\n * connection.\n * \\return False if a zero order vertex was formed, indicative of the cell\n *         disappearing; true if the vertex removal was successful. */\ntemplate<class vc_class>\ninline bool voronoicell_base::delete_connection(vc_class &vc,int j,int k,bool hand) {\n\tint q=hand?k:cycle_up(k,j);\n\tint i=nu[j]-1,l,*edp,*edd,m;\n#if VOROPP_VERBOSE >=1\n\tif(i<1) {\n\t\tfputs(\"Zero order vertex formed\\n\",stderr);\n\t\treturn false;\n\t}\n#endif\n\tif(mec[i]==mem[i]) add_memory(vc,i,ds2);\n\tvc.n_set_aux1(i);\n\tfor(l=0;l<q;l++) vc.n_copy_aux1(j,l);\n\twhile(l<i) {\n\t\tvc.n_copy_aux1_shift(j,l);\n\t\tl++;\n\t}\n\tedp=mep[i]+((i<<1)+1)*mec[i]++;\n\tedp[i<<1]=j;\n\tfor(l=0;l<k;l++) {\n\t\tedp[l]=ed[j][l];\n\t\tedp[l+i]=ed[j][l+nu[j]];\n\t}\n\twhile(l<i) {\n\t\tm=ed[j][l+1];\n\t\tedp[l]=m;\n\t\tk=ed[j][l+nu[j]+1];\n\t\tedp[l+i]=k;\n\t\ted[m][nu[m]+k]--;\n\t\tl++;\n\t}\n\n\tedd=mep[nu[j]]+((nu[j]<<1)+1)*--mec[nu[j]];\n\tfor(l=0;l<=(nu[j]<<1);l++) ed[j][l]=edd[l];\n\tvc.n_set_aux2_copy(j,nu[j]);\n\tvc.n_set_to_aux2(edd[nu[j]<<1]);\n\tvc.n_set_to_aux1(j);\n\ted[edd[nu[j]<<1]]=edd;\n\ted[j]=edp;\n\tnu[j]=i;\n\treturn true;\n}\n\n/** Calculates the volume of the Voronoi cell, by decomposing the cell into\n * tetrahedra extending outward from the zeroth vertex, whose volumes are\n * evaluated using a scalar triple product.\n * \\return A floating point number holding the calculated volume. */\ndouble voronoicell_base::volume() {\n\tconst double fe=1/48.0;\n\tdouble vol=0;\n\tint i,j,k,l,m,n;\n\tdouble ux,uy,uz,vx,vy,vz,wx,wy,wz;\n\tfor(i=1;i<p;i++) {\n\t\tux=*pts-pts[3*i];\n\t\tuy=pts[1]-pts[3*i+1];\n\t\tuz=pts[2]-pts[3*i+2];\n\t\tfor(j=0;j<nu[i];j++) {\n\t\t\tk=ed[i][j];\n\t\t\tif(k>=0) {\n\t\t\t\ted[i][j]=-1-k;\n\t\t\t\tl=cycle_up(ed[i][nu[i]+j],k);\n\t\t\t\tvx=pts[3*k]-*pts;\n\t\t\t\tvy=pts[3*k+1]-pts[1];\n\t\t\t\tvz=pts[3*k+2]-pts[2];\n\t\t\t\tm=ed[k][l];ed[k][l]=-1-m;\n\t\t\t\twhile(m!=i) {\n\t\t\t\t\tn=cycle_up(ed[k][nu[k]+l],m);\n\t\t\t\t\twx=pts[3*m]-*pts;\n\t\t\t\t\twy=pts[3*m+1]-pts[1];\n\t\t\t\t\twz=pts[3*m+2]-pts[2];\n\t\t\t\t\tvol+=ux*vy*wz+uy*vz*wx+uz*vx*wy-uz*vy*wx-uy*vx*wz-ux*vz*wy;\n\t\t\t\t\tk=m;l=n;vx=wx;vy=wy;vz=wz;\n\t\t\t\t\tm=ed[k][l];ed[k][l]=-1-m;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treset_edges();\n\treturn vol*fe;\n}\n\n/** Calculates the areas of each face of the Voronoi cell and prints the\n * results to an output stream.\n * \\param[out] v the vector to store the results in. */\nvoid voronoicell_base::face_areas(std::vector<double> &v) {\n\tdouble area;\n\tv.clear();\n\tint i,j,k,l,m,n;\n\tdouble ux,uy,uz,vx,vy,vz,wx,wy,wz;\n\tfor(i=1;i<p;i++) for(j=0;j<nu[i];j++) {\n\t\tk=ed[i][j];\n\t\tif(k>=0) {\n\t\t\tarea=0;\n\t\t\ted[i][j]=-1-k;\n\t\t\tl=cycle_up(ed[i][nu[i]+j],k);\n\t\t\tm=ed[k][l];ed[k][l]=-1-m;\n\t\t\twhile(m!=i) {\n\t\t\t\tn=cycle_up(ed[k][nu[k]+l],m);\n\t\t\t\tux=pts[3*k]-pts[3*i];\n\t\t\t\tuy=pts[3*k+1]-pts[3*i+1];\n\t\t\t\tuz=pts[3*k+2]-pts[3*i+2];\n\t\t\t\tvx=pts[3*m]-pts[3*i];\n\t\t\t\tvy=pts[3*m+1]-pts[3*i+1];\n\t\t\t\tvz=pts[3*m+2]-pts[3*i+2];\n\t\t\t\twx=uy*vz-uz*vy;\n\t\t\t\twy=uz*vx-ux*vz;\n\t\t\t\twz=ux*vy-uy*vx;\n\t\t\t\tarea+=sqrt(wx*wx+wy*wy+wz*wz);\n\t\t\t\tk=m;l=n;\n\t\t\t\tm=ed[k][l];ed[k][l]=-1-m;\n\t\t\t}\n\t\t\tv.push_back(0.125*area);\n\t\t}\n\t}\n\treset_edges();\n}\n\n\n/** Calculates the total surface area of the Voronoi cell.\n * \\return The computed area. */\ndouble voronoicell_base::surface_area() {\n\tdouble area=0;\n\tint i,j,k,l,m,n;\n\tdouble ux,uy,uz,vx,vy,vz,wx,wy,wz;\n\tfor(i=1;i<p;i++) for(j=0;j<nu[i];j++) {\n\t\tk=ed[i][j];\n\t\tif(k>=0) {\n\t\t\ted[i][j]=-1-k;\n\t\t\tl=cycle_up(ed[i][nu[i]+j],k);\n\t\t\tm=ed[k][l];ed[k][l]=-1-m;\n\t\t\twhile(m!=i) {\n\t\t\t\tn=cycle_up(ed[k][nu[k]+l],m);\n\t\t\t\tux=pts[3*k]-pts[3*i];\n\t\t\t\tuy=pts[3*k+1]-pts[3*i+1];\n\t\t\t\tuz=pts[3*k+2]-pts[3*i+2];\n\t\t\t\tvx=pts[3*m]-pts[3*i];\n\t\t\t\tvy=pts[3*m+1]-pts[3*i+1];\n\t\t\t\tvz=pts[3*m+2]-pts[3*i+2];\n\t\t\t\twx=uy*vz-uz*vy;\n\t\t\t\twy=uz*vx-ux*vz;\n\t\t\t\twz=ux*vy-uy*vx;\n\t\t\t\tarea+=sqrt(wx*wx+wy*wy+wz*wz);\n\t\t\t\tk=m;l=n;\n\t\t\t\tm=ed[k][l];ed[k][l]=-1-m;\n\t\t\t}\n\t\t}\n\t}\n\treset_edges();\n\treturn 0.125*area;\n}\n\n\n/** Calculates the centroid of the Voronoi cell, by decomposing the cell into\n * tetrahedra extending outward from the zeroth vertex.\n * \\param[out] (cx,cy,cz) references to floating point numbers in which to\n *                        pass back the centroid vector. */\nvoid voronoicell_base::centroid(double &cx,double &cy,double &cz) {\n\tdouble tvol,vol=0;cx=cy=cz=0;\n\tint i,j,k,l,m,n;\n\tdouble ux,uy,uz,vx,vy,vz,wx,wy,wz;\n\tfor(i=1;i<p;i++) {\n\t\tux=*pts-pts[3*i];\n\t\tuy=pts[1]-pts[3*i+1];\n\t\tuz=pts[2]-pts[3*i+2];\n\t\tfor(j=0;j<nu[i];j++) {\n\t\t\tk=ed[i][j];\n\t\t\tif(k>=0) {\n\t\t\t\ted[i][j]=-1-k;\n\t\t\t\tl=cycle_up(ed[i][nu[i]+j],k);\n\t\t\t\tvx=pts[3*k]-*pts;\n\t\t\t\tvy=pts[3*k+1]-pts[1];\n\t\t\t\tvz=pts[3*k+2]-pts[2];\n\t\t\t\tm=ed[k][l];ed[k][l]=-1-m;\n\t\t\t\twhile(m!=i) {\n\t\t\t\t\tn=cycle_up(ed[k][nu[k]+l],m);\n\t\t\t\t\twx=pts[3*m]-*pts;\n\t\t\t\t\twy=pts[3*m+1]-pts[1];\n\t\t\t\t\twz=pts[3*m+2]-pts[2];\n\t\t\t\t\ttvol=ux*vy*wz+uy*vz*wx+uz*vx*wy-uz*vy*wx-uy*vx*wz-ux*vz*wy;\n\t\t\t\t\tvol+=tvol;\n\t\t\t\t\tcx+=(wx+vx-ux)*tvol;\n\t\t\t\t\tcy+=(wy+vy-uy)*tvol;\n\t\t\t\t\tcz+=(wz+vz-uz)*tvol;\n\t\t\t\t\tk=m;l=n;vx=wx;vy=wy;vz=wz;\n\t\t\t\t\tm=ed[k][l];ed[k][l]=-1-m;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treset_edges();\n\tif(vol>tolerance_sq) {\n\t\tvol=0.125/vol;\n\t\tcx=cx*vol+0.5*(*pts);\n\t\tcy=cy*vol+0.5*pts[1];\n\t\tcz=cz*vol+0.5*pts[2];\n\t} else cx=cy=cz=0;\n}\n\n/** Computes the maximum radius squared of a vertex from the center of the\n * cell. It can be used to determine when enough particles have been testing an\n * all planes that could cut the cell have been considered.\n * \\return The maximum radius squared of a vertex.*/\ndouble voronoicell_base::max_radius_squared() {\n\tdouble r,s,*ptsp=pts+3,*ptse=pts+3*p;\n\tr=*pts*(*pts)+pts[1]*pts[1]+pts[2]*pts[2];\n\twhile(ptsp<ptse) {\n\t\ts=*ptsp*(*ptsp);ptsp++;\n\t\ts+=*ptsp*(*ptsp);ptsp++;\n\t\ts+=*ptsp*(*ptsp);ptsp++;\n\t\tif(s>r) r=s;\n\t}\n\treturn r;\n}\n\n/** Calculates the total edge distance of the Voronoi cell.\n * \\return A floating point number holding the calculated distance. */\ndouble voronoicell_base::total_edge_distance() {\n\tint i,j,k;\n\tdouble dis=0,dx,dy,dz;\n\tfor(i=0;i<p-1;i++) for(j=0;j<nu[i];j++) {\n\t\tk=ed[i][j];\n\t\tif(k>i) {\n\t\t\tdx=pts[3*k]-pts[3*i];\n\t\t\tdy=pts[3*k+1]-pts[3*i+1];\n\t\t\tdz=pts[3*k+2]-pts[3*i+2];\n\t\t\tdis+=sqrt(dx*dx+dy*dy+dz*dz);\n\t\t}\n\t}\n\treturn 0.5*dis;\n}\n\n/** Outputs the edges of the Voronoi cell in POV-Ray format to an open file\n * stream, displacing the cell by given vector.\n * \\param[in] (x,y,z) a displacement vector to be added to the cell's position.\n * \\param[in] fp a file handle to write to. */\nvoid voronoicell_base::draw_pov(double x,double y,double z,FILE* fp) {\n\tint i,j,k;double *ptsp=pts,*pt2;\n\tchar posbuf1[128],posbuf2[128];\n\tfor(i=0;i<p;i++,ptsp+=3) {\n\t\tsprintf(posbuf1,\"%g,%g,%g\",x+*ptsp*0.5,y+ptsp[1]*0.5,z+ptsp[2]*0.5);\n\t\tfprintf(fp,\"sphere{<%s>,r}\\n\",posbuf1);\n\t\tfor(j=0;j<nu[i];j++) {\n\t\t\tk=ed[i][j];\n\t\t\tif(k<i) {\n\t\t\t\tpt2=pts+3*k;\n\t\t\t\tsprintf(posbuf2,\"%g,%g,%g\",x+*pt2*0.5,y+0.5*pt2[1],z+0.5*pt2[2]);\n\t\t\t\tif(strcmp(posbuf1,posbuf2)!=0) fprintf(fp,\"cylinder{<%s>,<%s>,r}\\n\",posbuf1,posbuf2);\n\t\t\t}\n\t\t}\n\t}\n}\n\n/** Outputs the edges of the Voronoi cell in gnuplot format to an output stream.\n * \\param[in] (x,y,z) a displacement vector to be added to the cell's position.\n * \\param[in] fp a file handle to write to. */\nvoid voronoicell_base::draw_gnuplot(double x,double y,double z,FILE *fp) {\n\tint i,j,k,l,m;\n\tfor(i=1;i<p;i++) for(j=0;j<nu[i];j++) {\n\t\tk=ed[i][j];\n\t\tif(k>=0) {\n\t\t\tfprintf(fp,\"%g %g %g\\n\",x+0.5*pts[3*i],y+0.5*pts[3*i+1],z+0.5*pts[3*i+2]);\n\t\t\tl=i;m=j;\n\t\t\tdo {\n\t\t\t\ted[k][ed[l][nu[l]+m]]=-1-l;\n\t\t\t\ted[l][m]=-1-k;\n\t\t\t\tl=k;\n\t\t\t\tfprintf(fp,\"%g %g %g\\n\",x+0.5*pts[3*k],y+0.5*pts[3*k+1],z+0.5*pts[3*k+2]);\n\t\t\t} while (search_edge(l,m,k));\n\t\t\tfputs(\"\\n\\n\",fp);\n\t\t}\n\t}\n\treset_edges();\n}\n\ninline bool voronoicell_base::search_edge(int l,int &m,int &k) {\n\tfor(m=0;m<nu[l];m++) {\n\t\tk=ed[l][m];\n\t\tif(k>=0) return true;\n\t}\n\treturn false;\n}\n\n/** Outputs the Voronoi cell in the POV mesh2 format, described in section\n * 1.3.2.2 of the POV-Ray documentation. The mesh2 output consists of a list of\n * vertex vectors, followed by a list of triangular faces. The routine also\n * makes use of the optional inside_vector specification, which makes the mesh\n * object solid, so the the POV-Ray Constructive Solid Geometry (CSG) can be\n * applied.\n * \\param[in] (x,y,z) a displacement vector to be added to the cell's position.\n * \\param[in] fp a file handle to write to. */\nvoid voronoicell_base::draw_pov_mesh(double x,double y,double z,FILE *fp) {\n\tint i,j,k,l,m,n;\n\tdouble *ptsp=pts;\n\tfprintf(fp,\"mesh2 {\\nvertex_vectors {\\n%d\\n\",p);\n\tfor(i=0;i<p;i++,ptsp+=3) fprintf(fp,\",<%g,%g,%g>\\n\",x+*ptsp*0.5,y+ptsp[1]*0.5,z+ptsp[2]*0.5);\n\tfprintf(fp,\"}\\nface_indices {\\n%d\\n\",(p-2)<<1);\n\tfor(i=1;i<p;i++) for(j=0;j<nu[i];j++) {\n\t\tk=ed[i][j];\n\t\tif(k>=0) {\n\t\t\ted[i][j]=-1-k;\n\t\t\tl=cycle_up(ed[i][nu[i]+j],k);\n\t\t\tm=ed[k][l];ed[k][l]=-1-m;\n\t\t\twhile(m!=i) {\n\t\t\t\tn=cycle_up(ed[k][nu[k]+l],m);\n\t\t\t\tfprintf(fp,\",<%d,%d,%d>\\n\",i,k,m);\n\t\t\t\tk=m;l=n;\n\t\t\t\tm=ed[k][l];ed[k][l]=-1-m;\n\t\t\t}\n\t\t}\n\t}\n\tfputs(\"}\\ninside_vector <0,0,1>\\n}\\n\",fp);\n\treset_edges();\n}\n\n/** Several routines in the class that gather cell-based statistics internally\n * track their progress by flipping edges to negative so that they know what\n * parts of the cell have already been tested. This function resets them back\n * to positive. When it is called, it assumes that every edge in the routine\n * should have already been flipped to negative, and it bails out with an\n * internal error if it encounters a positive edge. */\ninline void voronoicell_base::reset_edges() {\n\tint i,j;\n\tfor(i=0;i<p;i++) for(j=0;j<nu[i];j++) {\n\t\tif(ed[i][j]>=0) voro_fatal_error(\"Edge reset routine found a previously untested edge\",VOROPP_INTERNAL_ERROR);\n\t\ted[i][j]=-1-ed[i][j];\n\t}\n}\n\n/** Checks to see if a given vertex is inside, outside or within the test\n * plane. If the point is far away from the test plane, the routine immediately\n * returns whether it is inside or outside. If the routine is close the the\n * plane and within the specified tolerance, then the special check_marginal()\n * routine is called.\n * \\param[in] n the vertex to test.\n * \\param[out] ans the result of the scalar product used in evaluating the\n *                 location of the point.\n * \\return -1 if the point is inside the plane, 1 if the point is outside the\n *         plane, or 0 if the point is within the plane. */\ninline int voronoicell_base::m_test(int n,double &ans) {\n\tdouble *pp=pts+n+(n<<1);\n\tans=*(pp++)*px;\n\tans+=*(pp++)*py;\n\tans+=*pp*pz-prsq;\n\tif(ans<-tolerance2) {\n\t\treturn -1;\n\t} else if(ans>tolerance2) {\n\t\treturn 1;\n\t}\n\treturn check_marginal(n,ans);\n}\n\n/** Checks to see if a given vertex is inside, outside or within the test\n * plane, for the case when the point has been detected to be very close to the\n * plane. The routine ensures that the returned results are always consistent\n * with previous tests, by keeping a table of any marginal results. The routine\n * first sees if the vertex is in the table, and if it finds a previously\n * computed result it uses that. Otherwise, it computes a result for this\n * vertex and adds it the table.\n * \\param[in] n the vertex to test.\n * \\param[in] ans the result of the scalar product used in evaluating\n *                the location of the point.\n * \\return -1 if the point is inside the plane, 1 if the point is outside the\n *         plane, or 0 if the point is within the plane. */\nint voronoicell_base::check_marginal(int n,double &ans) {\n\tint i;\n\tfor(i=0;i<n_marg;i+=2) if(marg[i]==n) return marg[i+1];\n\tif(n_marg==current_marginal) {\n\t\tcurrent_marginal<<=1;\n\t\tif(current_marginal>max_marginal)\n\t\t\tvoro_fatal_error(\"Marginal case buffer allocation exceeded absolute maximum\",VOROPP_MEMORY_ERROR);\n#if VOROPP_VERBOSE >=2\n\t\tfprintf(stderr,\"Marginal cases buffer scaled up to %d\\n\",i);\n#endif\n\t\tint *pmarg=new int[current_marginal];\n\t\tfor(int j=0;j<n_marg;j++) pmarg[j]=marg[j];\n\t\tdelete [] marg;\n\t\tmarg=pmarg;\n\t}\n\tmarg[n_marg++]=n;\n\tmarg[n_marg++]=ans>tolerance?1:(ans<-tolerance?-1:0);\n\treturn marg[n_marg-1];\n}\n\n/** For each face of the Voronoi cell, this routine prints the out the normal\n * vector of the face, and scales it to the distance from the cell center to\n * that plane.\n * \\param[out] v the vector to store the results in. */\nvoid voronoicell_base::normals(std::vector<double> &v) {\n\tint i,j,k;\n\tv.clear();\n\tfor(i=1;i<p;i++) for(j=0;j<nu[i];j++) {\n\t\tk=ed[i][j];\n\t\tif(k>=0) normals_search(v,i,j,k);\n\t}\n\treset_edges();\n}\n\n/** This inline routine is called by normals(). It attempts to construct a\n * single normal vector that is associated with a particular face. It first\n * traces around the face, trying to find two vectors along the face edges\n * whose vector product is above the numerical tolerance. It then constructs\n * the normal vector using this product. If the face is too small, and none of\n * the vector products are large enough, the routine may return (0,0,0) as the\n * normal vector.\n * \\param[in] v the vector to store the results in.\n * \\param[in] i the initial vertex of the face to test.\n * \\param[in] j the index of an edge of the vertex.\n * \\param[in] k the neighboring vertex of i, set to ed[i][j]. */\ninline void voronoicell_base::normals_search(std::vector<double> &v,int i,int j,int k) {\n\ted[i][j]=-1-k;\n\tint l=cycle_up(ed[i][nu[i]+j],k),m;\n\tdouble ux,uy,uz,vx,vy,vz,wx,wy,wz,wmag;\n\tdo {\n\t\tm=ed[k][l];ed[k][l]=-1-m;\n\t\tux=pts[3*m]-pts[3*k];\n\t\tuy=pts[3*m+1]-pts[3*k+1];\n\t\tuz=pts[3*m+2]-pts[3*k+2];\n\n\t\t// Test to see if the length of this edge is above the tolerance\n\t\tif(ux*ux+uy*uy+uz*uz>tolerance_sq) {\n\t\t\twhile(m!=i) {\n\t\t\t\tl=cycle_up(ed[k][nu[k]+l],m);\n\t\t\t\tk=m;m=ed[k][l];ed[k][l]=-1-m;\n\t\t\t\tvx=pts[3*m]-pts[3*k];\n\t\t\t\tvy=pts[3*m+1]-pts[3*k+1];\n\t\t\t\tvz=pts[3*m+2]-pts[3*k+2];\n\n\t\t\t\t// Construct the vector product of this edge with\n\t\t\t\t// the previous one\n\t\t\t\twx=uz*vy-uy*vz;\n\t\t\t\twy=ux*vz-uz*vx;\n\t\t\t\twz=uy*vx-ux*vy;\n\t\t\t\twmag=wx*wx+wy*wy+wz*wz;\n\n\t\t\t\t// Test to see if this vector product of the\n\t\t\t\t// two edges is above the tolerance\n\t\t\t\tif(wmag>tolerance_sq) {\n\n\t\t\t\t\t// Construct the normal vector and print it\n\t\t\t\t\twmag=1/sqrt(wmag);\n\t\t\t\t\tv.push_back(wx*wmag);\n\t\t\t\t\tv.push_back(wy*wmag);\n\t\t\t\t\tv.push_back(wz*wmag);\n\n\t\t\t\t\t// Mark all of the remaining edges of this\n\t\t\t\t\t// face and exit\n\t\t\t\t\twhile(m!=i) {\n\t\t\t\t\t\tl=cycle_up(ed[k][nu[k]+l],m);\n\t\t\t\t\t\tk=m;m=ed[k][l];ed[k][l]=-1-m;\n\t\t\t\t\t}\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tv.push_back(0);\n\t\t\tv.push_back(0);\n\t\t\tv.push_back(0);\n\t\t\treturn;\n\t\t}\n\t\tl=cycle_up(ed[k][nu[k]+l],m);\n\t\tk=m;\n\t} while (k!=i);\n\tv.push_back(0);\n\tv.push_back(0);\n\tv.push_back(0);\n}\n\n\n/** Returns the number of faces of a computed Voronoi cell.\n * \\return The number of faces. */\nint voronoicell_base::number_of_faces() {\n\tint i,j,k,l,m,s=0;\n\tfor(i=1;i<p;i++) for(j=0;j<nu[i];j++) {\n\t\tk=ed[i][j];\n\t\tif(k>=0) {\n\t\t\ts++;\n\t\t\ted[i][j]=-1-k;\n\t\t\tl=cycle_up(ed[i][nu[i]+j],k);\n\t\t\tdo {\n\t\t\t\tm=ed[k][l];\n\t\t\t\ted[k][l]=-1-m;\n\t\t\t\tl=cycle_up(ed[k][nu[k]+l],m);\n\t\t\t\tk=m;\n\t\t\t} while (k!=i);\n\n\t\t}\n\t}\n\treset_edges();\n\treturn s;\n}\n\n/** Returns a vector of the vertex orders.\n * \\param[out] v the vector to store the results in. */\nvoid voronoicell_base::vertex_orders(std::vector<int> &v) {\n\tv.resize(p);\n\tfor(int i=0;i<p;i++) v[i]=nu[i];\n}\n\n/** Outputs the vertex orders.\n * \\param[out] fp the file handle to write to. */\nvoid voronoicell_base::output_vertex_orders(FILE *fp) {\n\tif(p>0) {\n\t\tfprintf(fp,\"%d\",*nu);\n\t\tfor(int *nup=nu+1;nup<nu+p;nup++) fprintf(fp,\" %d\",*nup);\n\t}\n}\n\n/** Returns a vector of the vertex vectors using the local coordinate system.\n * \\param[out] v the vector to store the results in. */\nvoid voronoicell_base::vertices(std::vector<double> &v) {\n\tv.resize(3*p);\n\tdouble *ptsp=pts;\n\tfor(int i=0;i<3*p;i+=3) {\n\t\tv[i]=*(ptsp++)*0.5;\n\t\tv[i+1]=*(ptsp++)*0.5;\n\t\tv[i+2]=*(ptsp++)*0.5;\n\t}\n}\n\n/** Outputs the vertex vectors using the local coordinate system.\n * \\param[out] fp the file handle to write to. */\nvoid voronoicell_base::output_vertices(FILE *fp) {\n\tif(p>0) {\n\t\tfprintf(fp,\"(%g,%g,%g)\",*pts*0.5,pts[1]*0.5,pts[2]*0.5);\n\t\tfor(double *ptsp=pts+3;ptsp<pts+3*p;ptsp+=3) fprintf(fp,\" (%g,%g,%g)\",*ptsp*0.5,ptsp[1]*0.5,ptsp[2]*0.5);\n\t}\n}\n\n\n/** Returns a vector of the vertex vectors in the global coordinate system.\n * \\param[out] v the vector to store the results in.\n * \\param[in] (x,y,z) the position vector of the particle in the global\n *                    coordinate system. */\nvoid voronoicell_base::vertices(double x,double y,double z,std::vector<double> &v) {\n\tv.resize(3*p);\n\tdouble *ptsp=pts;\n\tfor(int i=0;i<3*p;i+=3) {\n\t\tv[i]=x+*(ptsp++)*0.5;\n\t\tv[i+1]=y+*(ptsp++)*0.5;\n\t\tv[i+2]=z+*(ptsp++)*0.5;\n\t}\n}\n\n/** Outputs the vertex vectors using the global coordinate system.\n * \\param[out] fp the file handle to write to.\n * \\param[in] (x,y,z) the position vector of the particle in the global\n *                    coordinate system. */\nvoid voronoicell_base::output_vertices(double x,double y,double z,FILE *fp) {\n\tif(p>0) {\n\t\tfprintf(fp,\"(%g,%g,%g)\",x+*pts*0.5,y+pts[1]*0.5,z+pts[2]*0.5);\n\t\tfor(double *ptsp=pts+3;ptsp<pts+3*p;ptsp+=3) fprintf(fp,\" (%g,%g,%g)\",x+*ptsp*0.5,y+ptsp[1]*0.5,z+ptsp[2]*0.5);\n\t}\n}\n\n/** This routine returns the perimeters of each face.\n * \\param[out] v the vector to store the results in. */\nvoid voronoicell_base::face_perimeters(std::vector<double> &v) {\n\tv.clear();\n\tint i,j,k,l,m;\n\tdouble dx,dy,dz,perim;\n\tfor(i=1;i<p;i++) for(j=0;j<nu[i];j++) {\n\t\tk=ed[i][j];\n\t\tif(k>=0) {\n\t\t\tdx=pts[3*k]-pts[3*i];\n\t\t\tdy=pts[3*k+1]-pts[3*i+1];\n\t\t\tdz=pts[3*k+2]-pts[3*i+2];\n\t\t\tperim=sqrt(dx*dx+dy*dy+dz*dz);\n\t\t\ted[i][j]=-1-k;\n\t\t\tl=cycle_up(ed[i][nu[i]+j],k);\n\t\t\tdo {\n\t\t\t\tm=ed[k][l];\n\t\t\t\tdx=pts[3*m]-pts[3*k];\n\t\t\t\tdy=pts[3*m+1]-pts[3*k+1];\n\t\t\t\tdz=pts[3*m+2]-pts[3*k+2];\n\t\t\t\tperim+=sqrt(dx*dx+dy*dy+dz*dz);\n\t\t\t\ted[k][l]=-1-m;\n\t\t\t\tl=cycle_up(ed[k][nu[k]+l],m);\n\t\t\t\tk=m;\n\t\t\t} while (k!=i);\n\t\t\tv.push_back(0.5*perim);\n\t\t}\n\t}\n\treset_edges();\n}\n\n/** For each face, this routine outputs a bracketed sequence of numbers\n * containing a list of all the vertices that make up that face.\n * \\param[out] v the vector to store the results in. */\nvoid voronoicell_base::face_vertices(std::vector<int> &v) {\n\tint i,j,k,l,m,vp(0),vn;\n\tv.clear();\n\tfor(i=1;i<p;i++) for(j=0;j<nu[i];j++) {\n\t\tk=ed[i][j];\n\t\tif(k>=0) {\n\t\t\tv.push_back(0);\n\t\t\tv.push_back(i);\n\t\t\ted[i][j]=-1-k;\n\t\t\tl=cycle_up(ed[i][nu[i]+j],k);\n\t\t\tdo {\n\t\t\t\tv.push_back(k);\n\t\t\t\tm=ed[k][l];\n\t\t\t\ted[k][l]=-1-m;\n\t\t\t\tl=cycle_up(ed[k][nu[k]+l],m);\n\t\t\t\tk=m;\n\t\t\t} while (k!=i);\n\t\t\tvn=v.size();\n\t\t\tv[vp]=vn-vp-1;\n\t\t\tvp=vn;\n\t\t}\n\t}\n\treset_edges();\n}\n\n/** Outputs a list of the number of edges in each face.\n * \\param[out] v the vector to store the results in. */\nvoid voronoicell_base::face_orders(std::vector<int> &v) {\n\tint i,j,k,l,m,q;\n\tv.clear();\n\tfor(i=1;i<p;i++) for(j=0;j<nu[i];j++) {\n\t\tk=ed[i][j];\n\t\tif(k>=0) {\n\t\t\tq=1;\n\t\t\ted[i][j]=-1-k;\n\t\t\tl=cycle_up(ed[i][nu[i]+j],k);\n\t\t\tdo {\n\t\t\t\tq++;\n\t\t\t\tm=ed[k][l];\n\t\t\t\ted[k][l]=-1-m;\n\t\t\t\tl=cycle_up(ed[k][nu[k]+l],m);\n\t\t\t\tk=m;\n\t\t\t} while (k!=i);\n\t\t\tv.push_back(q);;\n\t\t}\n\t}\n\treset_edges();\n}\n\n/** Computes the number of edges that each face has and outputs a frequency\n * table of the results.\n * \\param[out] v the vector to store the results in. */\nvoid voronoicell_base::face_freq_table(std::vector<int> &v) {\n\tint i,j,k,l,m,q;\n\tv.clear();\n\tfor(i=1;i<p;i++) for(j=0;j<nu[i];j++) {\n\t\tk=ed[i][j];\n\t\tif(k>=0) {\n\t\t\tq=1;\n\t\t\ted[i][j]=-1-k;\n\t\t\tl=cycle_up(ed[i][nu[i]+j],k);\n\t\t\tdo {\n\t\t\t\tq++;\n\t\t\t\tm=ed[k][l];\n\t\t\t\ted[k][l]=-1-m;\n\t\t\t\tl=cycle_up(ed[k][nu[k]+l],m);\n\t\t\t\tk=m;\n\t\t\t} while (k!=i);\n\t\t\tif((unsigned int) q>=v.size()) v.resize(q+1,0);\n\t\t\tv[q]++;\n\t\t}\n\t}\n\treset_edges();\n}\n\n/** This routine tests to see whether the cell intersects a plane by starting\n * from the guess point up. If up intersects, then it immediately returns true.\n * Otherwise, it calls the plane_intersects_track() routine.\n * \\param[in] (x,y,z) the normal vector to the plane.\n * \\param[in] rsq the distance along this vector of the plane.\n * \\return False if the plane does not intersect the plane, true if it does. */\nbool voronoicell_base::plane_intersects(double x,double y,double z,double rsq) {\n\tdouble g=x*pts[3*up]+y*pts[3*up+1]+z*pts[3*up+2];\n\tif(g<rsq) return plane_intersects_track(x,y,z,rsq,g);\n\treturn true;\n}\n\n/** This routine tests to see if a cell intersects a plane. It first tests a\n * random sample of approximately sqrt(p)/4 points. If any of those are\n * intersect, then it immediately returns true. Otherwise, it takes the closest\n * point and passes that to plane_intersect_track() routine.\n * \\param[in] (x,y,z) the normal vector to the plane.\n * \\param[in] rsq the distance along this vector of the plane.\n * \\return False if the plane does not intersect the plane, true if it does. */\nbool voronoicell_base::plane_intersects_guess(double x,double y,double z,double rsq) {\n\tup=0;\n\tdouble g=x*pts[3*up]+y*pts[3*up+1]+z*pts[3*up+2];\n\tif(g<rsq) {\n\t\tint ca=1,cc=p>>3,mp=1;\n\t\tdouble m;\n\t\twhile(ca<cc) {\n\t\t\tm=x*pts[3*mp]+y*pts[3*mp+1]+z*pts[3*mp+2];\n\t\t\tif(m>g) {\n\t\t\t\tif(m>rsq) return true;\n\t\t\t\tg=m;up=mp;\n\t\t\t}\n\t\t\tca+=mp++;\n\t\t}\n\t\treturn plane_intersects_track(x,y,z,rsq,g);\n\t}\n\treturn true;\n}\n\n/* This routine tests to see if a cell intersects a plane, by tracing over the cell from\n * vertex to vertex, starting at up. It is meant to be called either by plane_intersects()\n * or plane_intersects_track(), when those routines cannot immediately resolve the case.\n * \\param[in] (x,y,z) the normal vector to the plane.\n * \\param[in] rsq the distance along this vector of the plane.\n * \\param[in] g the distance of up from the plane.\n * \\return False if the plane does not intersect the plane, true if it does. */\ninline bool voronoicell_base::plane_intersects_track(double x,double y,double z,double rsq,double g) {\n\tint count=0,ls,us,tp;\n\tdouble t;\n\n\t// The test point is outside of the cutting space\n\tfor(us=0;us<nu[up];us++) {\n\t\ttp=ed[up][us];\n\t\tt=x*pts[3*tp]+y*pts[3*tp+1]+z*pts[3*tp+2];\n\t\tif(t>g) {\n\t\t\tls=ed[up][nu[up]+us];\n\t\t\tup=tp;\n\t\t\twhile (t<rsq) {\n\t\t\t\tif(++count>=p) {\n#if VOROPP_VERBOSE >=1\n\t\t\t\t\tfputs(\"Bailed out of convex calculation\",stderr);\n#endif\n\t\t\t\t\tfor(tp=0;tp<p;tp++) if(x*pts[3*tp]+y*pts[3*tp+1]+z*pts[3*tp+2]>rsq) return true;\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\n\t\t\t\t// Test all the neighbors of the current point\n\t\t\t\t// and find the one which is closest to the\n\t\t\t\t// plane\n\t\t\t\tfor(us=0;us<ls;us++) {\n\t\t\t\t\ttp=ed[up][us];\n\t\t\t\t\tg=x*pts[3*tp]+y*pts[3*tp+1]+z*pts[3*tp+2];\n\t\t\t\t\tif(g>t) break;\n\t\t\t\t}\n\t\t\t\tif(us==ls) {\n\t\t\t\t\tus++;\n\t\t\t\t\twhile(us<nu[up]) {\n\t\t\t\t\t\ttp=ed[up][us];\n\t\t\t\t\t\tg=x*pts[3*tp]+y*pts[3*tp+1]+z*pts[3*tp+2];\n\t\t\t\t\t\tif(g>t) break;\n\t\t\t\t\t\tus++;\n\t\t\t\t\t}\n\t\t\t\t\tif(us==nu[up]) return false;\n\t\t\t\t}\n\t\t\t\tls=ed[up][nu[up]+us];up=tp;t=g;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n\treturn false;\n}\n\n/** Counts the number of edges of the Voronoi cell.\n * \\return the number of edges. */\nint voronoicell_base::number_of_edges() {\n\tint edges=0,*nup=nu;\n\twhile(nup<nu+p) edges+=*(nup++);\n\treturn edges>>1;\n}\n\n/** Outputs a custom string of information about the Voronoi cell. The string\n * of information follows a similar style as the C printf command, and detailed\n * information about its format is available at\n * http://math.lbl.gov/voro++/doc/custom.html.\n * \\param[in] format the custom string to print.\n * \\param[in] i the ID of the particle associated with this Voronoi cell.\n * \\param[in] (x,y,z) the position of the particle associated with this Voronoi\n *                    cell.\n * \\param[in] r a radius associated with the particle.\n * \\param[in] fp the file handle to write to. */\nvoid voronoicell_base::output_custom(const char *format,int i,double x,double y,double z,double r,FILE *fp) {\n\tchar *fmp=(const_cast<char*>(format));\n\tstd::vector<int> vi;\n\tstd::vector<double> vd;\n\twhile(*fmp!=0) {\n\t\tif(*fmp=='%') {\n\t\t\tfmp++;\n\t\t\tswitch(*fmp) {\n\n\t\t\t\t// Particle-related output\n\t\t\t\tcase 'i': fprintf(fp,\"%d\",i);break;\n\t\t\t\tcase 'x': fprintf(fp,\"%g\",x);break;\n\t\t\t\tcase 'y': fprintf(fp,\"%g\",y);break;\n\t\t\t\tcase 'z': fprintf(fp,\"%g\",z);break;\n\t\t\t\tcase 'q': fprintf(fp,\"%g %g %g\",x,y,z);break;\n\t\t\t\tcase 'r': fprintf(fp,\"%g\",r);break;\n\n\t\t\t\t// Vertex-related output\n\t\t\t\tcase 'w': fprintf(fp,\"%d\",p);break;\n\t\t\t\tcase 'p': output_vertices(fp);break;\n\t\t\t\tcase 'P': output_vertices(x,y,z,fp);break;\n\t\t\t\tcase 'o': output_vertex_orders(fp);break;\n\t\t\t\tcase 'm': fprintf(fp,\"%g\",0.25*max_radius_squared());break;\n\n\t\t\t\t// Edge-related output\n\t\t\t\tcase 'g': fprintf(fp,\"%d\",number_of_edges());break;\n\t\t\t\tcase 'E': fprintf(fp,\"%g\",total_edge_distance());break;\n\t\t\t\tcase 'e': face_perimeters(vd);voro_print_vector(vd,fp);break;\n\n\t\t\t\t// Face-related output\n\t\t\t\tcase 's': fprintf(fp,\"%d\",number_of_faces());break;\n\t\t\t\tcase 'F': fprintf(fp,\"%g\",surface_area());break;\n\t\t\t\tcase 'A': {\n\t\t\t\t\t\t  face_freq_table(vi);\n\t\t\t\t\t\t  voro_print_vector(vi,fp);\n\t\t\t\t\t  } break;\n\t\t\t\tcase 'a': face_orders(vi);voro_print_vector(vi,fp);break;\n\t\t\t\tcase 'f': face_areas(vd);voro_print_vector(vd,fp);break;\n\t\t\t\tcase 't': {\n\t\t\t\t\t\t  face_vertices(vi);\n\t\t\t\t\t\t  voro_print_face_vertices(vi,fp);\n\t\t\t\t\t  } break;\n\t\t\t\tcase 'l': normals(vd);\n\t\t\t\t\t  voro_print_positions(vd,fp);\n\t\t\t\t\t  break;\n\t\t\t\tcase 'n': neighbors(vi);\n\t\t\t\t\t  voro_print_vector(vi,fp);\n\t\t\t\t\t  break;\n\n\t\t\t\t// Volume-related output\n\t\t\t\tcase 'v': fprintf(fp,\"%g\",volume());break;\n\t\t\t\tcase 'c': {\n\t\t\t\t\t\t  double cx,cy,cz;\n\t\t\t\t\t\t  centroid(cx,cy,cz);\n\t\t\t\t\t\t  fprintf(fp,\"%g %g %g\",cx,cy,cz);\n\t\t\t\t\t  } break;\n\t\t\t\tcase 'C': {\n\t\t\t\t\t\t  double cx,cy,cz;\n\t\t\t\t\t\t  centroid(cx,cy,cz);\n\t\t\t\t\t\t  fprintf(fp,\"%g %g %g\",x+cx,y+cy,z+cz);\n\t\t\t\t\t  } break;\n\n\t\t\t\t// End-of-string reached\n\t\t\t\tcase 0: fmp--;break;\n\n\t\t\t\t// The percent sign is not part of a\n\t\t\t\t// control sequence\n\t\t\t\tdefault: putc('%',fp);putc(*fmp,fp);\n\t\t\t}\n\t\t} else putc(*fmp,fp);\n\t\tfmp++;\n\t}\n\tfputs(\"\\n\",fp);\n}\n\n/** This initializes the class to be a rectangular box. It calls the base class\n * initialization routine to set up the edge and vertex information, and then\n * sets up the neighbor information, with initial faces being assigned ID\n * numbers from -1 to -6.\n * \\param[in] (xmin,xmax) the minimum and maximum x coordinates.\n * \\param[in] (ymin,ymax) the minimum and maximum y coordinates.\n * \\param[in] (zmin,zmax) the minimum and maximum z coordinates. */\nvoid voronoicell_neighbor::init(double xmin,double xmax,double ymin,double ymax,double zmin,double zmax) {\n\tinit_base(xmin,xmax,ymin,ymax,zmin,zmax);\n\tint *q=mne[3];\n\t*q=-5;q[1]=-3;q[2]=-1;\n\tq[3]=-5;q[4]=-2;q[5]=-3;\n\tq[6]=-5;q[7]=-1;q[8]=-4;\n\tq[9]=-5;q[10]=-4;q[11]=-2;\n\tq[12]=-6;q[13]=-1;q[14]=-3;\n\tq[15]=-6;q[16]=-3;q[17]=-2;\n\tq[18]=-6;q[19]=-4;q[20]=-1;\n\tq[21]=-6;q[22]=-2;q[23]=-4;\n\t*ne=q;ne[1]=q+3;ne[2]=q+6;ne[3]=q+9;\n\tne[4]=q+12;ne[5]=q+15;ne[6]=q+18;ne[7]=q+21;\n}\n\n/** This initializes the class to be an octahedron. It calls the base class\n * initialization routine to set up the edge and vertex information, and then\n * sets up the neighbor information, with the initial faces being assigned ID\n * numbers from -1 to -8.\n * \\param[in] l The distance from the octahedron center to a vertex. Six\n *              vertices are initialized at (-l,0,0), (l,0,0), (0,-l,0),\n *              (0,l,0), (0,0,-l), and (0,0,l). */\nvoid voronoicell_neighbor::init_octahedron(double l) {\n\tinit_octahedron_base(l);\n\tint *q=mne[4];\n\t*q=-5;q[1]=-6;q[2]=-7;q[3]=-8;\n\tq[4]=-1;q[5]=-2;q[6]=-3;q[7]=-4;\n\tq[8]=-6;q[9]=-5;q[10]=-2;q[11]=-1;\n\tq[12]=-8;q[13]=-7;q[14]=-4;q[15]=-3;\n\tq[16]=-5;q[17]=-8;q[18]=-3;q[19]=-2;\n\tq[20]=-7;q[21]=-6;q[22]=-1;q[23]=-4;\n\t*ne=q;ne[1]=q+4;ne[2]=q+8;ne[3]=q+12;ne[4]=q+16;ne[5]=q+20;\n}\n\n/** This initializes the class to be a tetrahedron. It calls the base class\n * initialization routine to set up the edge and vertex information, and then\n * sets up the neighbor information, with the initial faces being assigned ID\n * numbers from -1 to -4.\n * \\param (x0,y0,z0) a position vector for the first vertex.\n * \\param (x1,y1,z1) a position vector for the second vertex.\n * \\param (x2,y2,z2) a position vector for the third vertex.\n * \\param (x3,y3,z3) a position vector for the fourth vertex. */\nvoid voronoicell_neighbor::init_tetrahedron(double x0,double y0,double z0,double x1,double y1,double z1,double x2,double y2,double z2,double x3,double y3,double z3) {\n\tinit_tetrahedron_base(x0,y0,z0,x1,y1,z1,x2,y2,z2,x3,y3,z3);\n\tint *q=mne[3];\n\t*q=-4;q[1]=-3;q[2]=-2;\n\tq[3]=-3;q[4]=-4;q[5]=-1;\n\tq[6]=-4;q[7]=-2;q[8]=-1;\n\tq[9]=-2;q[10]=-3;q[11]=-1;\n\t*ne=q;ne[1]=q+3;ne[2]=q+6;ne[3]=q+9;\n}\n\n/** This routine checks to make sure the neighbor information of each face is\n * consistent. */\nvoid voronoicell_neighbor::check_facets() {\n\tint i,j,k,l,m,q;\n\tfor(i=1;i<p;i++) for(j=0;j<nu[i];j++) {\n\t\tk=ed[i][j];\n\t\tif(k>=0) {\n\t\t\ted[i][j]=-1-k;\n\t\t\tq=ne[i][j];\n\t\t\tl=cycle_up(ed[i][nu[i]+j],k);\n\t\t\tdo {\n\t\t\t\tm=ed[k][l];\n\t\t\t\ted[k][l]=-1-m;\n\t\t\t\tif(ne[k][l]!=q) fprintf(stderr,\"Facet error at (%d,%d)=%d, started from (%d,%d)=%d\\n\",k,l,ne[k][l],i,j,q);\n\t\t\t\tl=cycle_up(ed[k][nu[k]+l],m);\n\t\t\t\tk=m;\n\t\t\t} while (k!=i);\n\t\t}\n\t}\n\treset_edges();\n}\n\n/** The class constructor allocates memory for storing neighbor information. */\nvoronoicell_neighbor::voronoicell_neighbor() {\n\tint i;\n\tmne=new int*[current_vertex_order];\n\tne=new int*[current_vertices];\n\tfor(i=0;i<3;i++) mne[i]=new int[init_n_vertices*i];\n\tmne[3]=new int[init_3_vertices*3];\n\tfor(i=4;i<current_vertex_order;i++) mne[i]=new int[init_n_vertices*i];\n}\n\n/** The class destructor frees the dynamically allocated memory for storing\n * neighbor information. */\nvoronoicell_neighbor::~voronoicell_neighbor() {\n\tfor(int i=current_vertex_order-1;i>=0;i--) if(mem[i]>0) delete [] mne[i];\n\tdelete [] mne;\n\tdelete [] ne;\n}\n\n/** Computes a vector list of neighbors. */\nvoid voronoicell_neighbor::neighbors(std::vector<int> &v) {\n\tv.clear();\n\tint i,j,k,l,m;\n\tfor(i=1;i<p;i++) for(j=0;j<nu[i];j++) {\n\t\tk=ed[i][j];\n\t\tif(k>=0) {\n\t\t\tv.push_back(ne[i][j]);\n\t\t\ted[i][j]=-1-k;\n\t\t\tl=cycle_up(ed[i][nu[i]+j],k);\n\t\t\tdo {\n\t\t\t\tm=ed[k][l];\n\t\t\t\ted[k][l]=-1-m;\n\t\t\t\tl=cycle_up(ed[k][nu[k]+l],m);\n\t\t\t\tk=m;\n\t\t\t} while (k!=i);\n\t\t}\n\t}\n\treset_edges();\n}\n\n/** Prints the vertices, their edges, the relation table, and also notifies if\n * any memory errors are visible. */\nvoid voronoicell_base::print_edges() {\n\tint j;\n\tdouble *ptsp=pts;\n\tfor(int i=0;i<p;i++,ptsp+=3) {\n\t\tprintf(\"%d %d  \",i,nu[i]);\n\t\tfor(j=0;j<nu[i];j++) printf(\" %d\",ed[i][j]);\n\t\tprintf(\"  \");\n\t\twhile(j<(nu[i]<<1)) printf(\" %d\",ed[i][j]);\n\t\tprintf(\"   %d\",ed[i][j]);\n\t\tprint_edges_neighbors(i);\n\t\tprintf(\"  %g %g %g %p\",*ptsp,ptsp[1],ptsp[2],(void*) ed[i]);\n\t\tif(ed[i]>=mep[nu[i]]+mec[nu[i]]*((nu[i]<<1)+1)) puts(\" Memory error\");\n\t\telse puts(\"\");\n\t}\n}\n\n/** This prints out the neighbor information for vertex i. */\nvoid voronoicell_neighbor::print_edges_neighbors(int i) {\n\tif(nu[i]>0) {\n\t\tint j=0;\n\t\tprintf(\"     (\");\n\t\twhile(j<nu[i]-1) printf(\"%d,\",ne[i][j++]);\n\t\tprintf(\"%d)\",ne[i][j]);\n\t} else printf(\"     ()\");\n}\n\n// Explicit instantiation\ntemplate bool voronoicell_base::nplane(voronoicell&,double,double,double,double,int);\ntemplate bool voronoicell_base::nplane(voronoicell_neighbor&,double,double,double,double,int);\ntemplate void voronoicell_base::check_memory_for_copy(voronoicell&,voronoicell_base*);\ntemplate void voronoicell_base::check_memory_for_copy(voronoicell_neighbor&,voronoicell_base*);\n\n}\n","// Voro++, a 3D cell-based Voronoi library\n//\n// Author   : Chris H. Rycroft (LBL / UC Berkeley)\n// Email    : chr@alum.mit.edu\n// Date     : August 30th 2011\n\n/** \\file cell.hh\n * \\brief Header file for the voronoicell and related classes. */\n\n#ifndef VOROPP_CELL_HH\n#define VOROPP_CELL_HH\n\n#include <vector>\n\n#include \"config.hh\"\n#include \"common.hh\"\n\nnamespace voro {\n\n/** \\brief A class representing a single Voronoi cell.\n *\n * This class represents a single Voronoi cell, as a collection of vertices\n * that are connected by edges. The class contains routines for initializing\n * the Voronoi cell to be simple shapes such as a box, tetrahedron, or octahedron.\n * It the contains routines for recomputing the cell based on cutting it\n * by a plane, which forms the key routine for the Voronoi cell computation.\n * It contains numerous routine for computing statistics about the Voronoi cell,\n * and it can output the cell in several formats.\n *\n * This class is not intended for direct use, but forms the base of the\n * voronoicell and voronoicell_neighbor classes, which extend it based on\n * whether neighboring particle ID information needs to be tracked. */\nclass voronoicell_base {\n\tpublic:\n\t\t/** This holds the current size of the arrays ed and nu, which\n\t\t * hold the vertex information. If more vertices are created\n\t\t * than can fit in this array, then it is dynamically extended\n\t\t * using the add_memory_vertices routine. */\n\t\tint current_vertices;\n\t\t/** This holds the current maximum allowed order of a vertex,\n\t\t * which sets the size of the mem, mep, and mec arrays. If a\n\t\t * vertex is created with more vertices than this, the arrays\n\t\t * are dynamically extended using the add_memory_vorder routine.\n\t\t */\n\t\tint current_vertex_order;\n\t\t/** This sets the size of the main delete stack. */\n\t\tint current_delete_size;\n\t\t/** This sets the size of the auxiliary delete stack. */\n\t\tint current_delete2_size;\n\t\t/** This sets the total number of vertices in the current cell.\n\t\t */\n\t\tint p;\n\t\t/** This is the index of particular point in the cell, which is\n\t\t * used to start the tracing routines for plane intersection\n\t\t * and cutting. These routines will work starting from any\n\t\t * point, but it's often most efficient to start from the last\n\t\t * point considered, since in many cases, the cell construction\n\t\t * algorithm may consider many planes with similar vectors\n\t\t * concurrently. */\n\t\tint up;\n\t\t/** This is a two dimensional array that holds information\n\t\t * about the edge connections of the vertices that make up the\n\t\t * cell. The two dimensional array is not allocated in the\n\t\t * usual method. To account for the fact the different vertices\n\t\t * have different orders, and thus require different amounts of\n\t\t * storage, the elements of ed[i] point to one-dimensional\n\t\t * arrays in the mep[] array of different sizes.\n\t\t *\n\t\t * More specifically, if vertex i has order m, then ed[i]\n\t\t * points to a one-dimensional array in mep[m] that has 2*m+1\n\t\t * entries. The first m elements hold the neighboring edges, so\n\t\t * that the jth edge of vertex i is held in ed[i][j]. The next\n\t\t * m elements hold a table of relations which is redundant but\n\t\t * helps speed up the computation. It satisfies the relation\n\t\t * ed[ed[i][j]][ed[i][m+j]]=i. The final entry holds a back\n\t\t * pointer, so that ed[i+2*m]=i. The back pointers are used\n\t\t * when rearranging the memory. */\n\t\tint **ed;\n\t\t/** This array holds the order of the vertices in the Voronoi\n\t\t * cell. This array is dynamically allocated, with its current\n\t\t * size held by current_vertices. */\n\t\tint *nu;\n\t\t/** This in an array with size 3*current_vertices for holding\n\t\t * the positions of the vertices. */\n\t\tdouble *pts;\n\t\tvoronoicell_base();\n\t\t~voronoicell_base();\n\t\tvoid init_base(double xmin,double xmax,double ymin,double ymax,double zmin,double zmax);\n\t\tvoid init_octahedron_base(double l);\n\t\tvoid init_tetrahedron_base(double x0,double y0,double z0,double x1,double y1,double z1,double x2,double y2,double z2,double x3,double y3,double z3);\n\t\tvoid translate(double x,double y,double z);\n\t\tvoid draw_pov(double x,double y,double z,FILE *fp=stdout);\n\t\t/** Outputs the cell in POV-Ray format, using cylinders for edges\n\t\t * and spheres for vertices, to a given file.\n\t\t * \\param[in] (x,y,z) a displacement to add to the cell's\n\t\t *                    position.\n\t\t * \\param[in] filename the name of the file to write to. */\n\t\tinline void draw_pov(double x,double y,double z,const char *filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"w\");\n\t\t\tdraw_pov(x,y,z,fp);\n\t\t\tfclose(fp);\n\t\t};\n\t\tvoid draw_pov_mesh(double x,double y,double z,FILE *fp=stdout);\n\t\t/** Outputs the cell in POV-Ray format as a mesh2 object to a\n\t\t * given file.\n\t\t * \\param[in] (x,y,z) a displacement to add to the cell's\n\t\t *                    position.\n\t\t * \\param[in] filename the name of the file to write to. */\n\t\tinline void draw_pov_mesh(double x,double y,double z,const char *filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"w\");\n\t\t\tdraw_pov_mesh(x,y,z,fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\tvoid draw_gnuplot(double x,double y,double z,FILE *fp=stdout);\n\t\t/** Outputs the cell in Gnuplot format a given file.\n\t\t * \\param[in] (x,y,z) a displacement to add to the cell's\n\t\t *                    position.\n\t\t * \\param[in] filename the name of the file to write to. */\n\t\tinline void draw_gnuplot(double x,double y,double z,const char *filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"w\");\n\t\t\tdraw_gnuplot(x,y,z,fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\tdouble volume();\n\t\tdouble max_radius_squared();\n\t\tdouble total_edge_distance();\n\t\tdouble surface_area();\n\t\tvoid centroid(double &cx,double &cy,double &cz);\n\t\tint number_of_faces();\n\t\tint number_of_edges();\n\t\tvoid vertex_orders(std::vector<int> &v);\n\t\tvoid output_vertex_orders(FILE *fp=stdout);\n\t\tvoid vertices(std::vector<double> &v);\n\t\tvoid output_vertices(FILE *fp=stdout);\n\t\tvoid vertices(double x,double y,double z,std::vector<double> &v);\n\t\tvoid output_vertices(double x,double y,double z,FILE *fp=stdout);\n\t\tvoid face_areas(std::vector<double> &v);\n\t\t/** Outputs the areas of the faces.\n\t\t * \\param[in] fp the file handle to write to. */\n\t\tinline void output_face_areas(FILE *fp=stdout) {\n\t\t\tstd::vector<double> v;face_areas(v);\n\t\t\tvoro_print_vector(v,fp);\n\t\t}\n\t\tvoid face_orders(std::vector<int> &v);\n\t\t/** Outputs a list of the number of sides of each face.\n\t\t * \\param[in] fp the file handle to write to. */\n\t\tinline void output_face_orders(FILE *fp=stdout) {\n\t\t\tstd::vector<int> v;face_orders(v);\n\t\t\tvoro_print_vector(v,fp);\n\t\t}\n\t\tvoid face_freq_table(std::vector<int> &v);\n\t\t/** Outputs a */\n\t\tinline void output_face_freq_table(FILE *fp=stdout) {\n\t\t\tstd::vector<int> v;face_freq_table(v);\n\t\t\tvoro_print_vector(v,fp);\n\t\t}\n\t\tvoid face_vertices(std::vector<int> &v);\n\t\t/** Outputs the */\n\t\tinline void output_face_vertices(FILE *fp=stdout) {\n\t\t\tstd::vector<int> v;face_vertices(v);\n\t\t\tvoro_print_face_vertices(v,fp);\n\t\t}\n\t\tvoid face_perimeters(std::vector<double> &v);\n\t\t/** Outputs a list of the perimeters of each face.\n\t\t * \\param[in] fp the file handle to write to. */\n\t\tinline void output_face_perimeters(FILE *fp=stdout) {\n\t\t\tstd::vector<double> v;face_perimeters(v);\n\t\t\tvoro_print_vector(v,fp);\n\t\t}\n\t\tvoid normals(std::vector<double> &v);\n\t\t/** Outputs a list of the perimeters of each face.\n\t\t * \\param[in] fp the file handle to write to. */\n\t\tinline void output_normals(FILE *fp=stdout) {\n\t\t\tstd::vector<double> v;normals(v);\n\t\t\tvoro_print_positions(v,fp);\n\t\t}\n\t\t/** Outputs a custom string of information about the Voronoi\n\t\t * cell to a file. It assumes the cell is at (0,0,0) and has a\n\t\t * the default_radius associated with it.\n\t\t * \\param[in] format the custom format string to use.\n\t\t * \\param[in] fp the file handle to write to. */\n\t\tinline void output_custom(const char *format,FILE *fp=stdout) {output_custom(format,0,0,0,0,default_radius,fp);}\n\t\tvoid output_custom(const char *format,int i,double x,double y,double z,double r,FILE *fp=stdout);\n\t\ttemplate<class vc_class>\n\t\tbool nplane(vc_class &vc,double x,double y,double z,double rsq,int p_id);\n\t\tbool plane_intersects(double x,double y,double z,double rsq);\n\t\tbool plane_intersects_guess(double x,double y,double z,double rsq);\n\t\tvoid construct_relations();\n\t\tvoid check_relations();\n\t\tvoid check_duplicates();\n\t\tvoid print_edges();\n\t\t/** Returns a list of IDs of neighboring particles\n\t\t * corresponding to each face.\n\t\t * \\param[out] v a reference to a vector in which to return the\n\t\t *               results. If no neighbor information is\n\t\t *               available, a blank vector is returned. */\n\t\tvirtual void neighbors(std::vector<int> &v) {v.clear();}\n\t\t/** This is a virtual function that is overridden by a routine\n\t\t * to print a list of IDs of neighboring particles\n\t\t * corresponding to each face. By default, when no neighbor\n\t\t * information is available, the routine does nothing.\n\t\t * \\param[in] fp the file handle to write to. */\n\t\tvirtual void output_neighbors(FILE *fp=stdout) {}\n\t\t/** This a virtual function that is overridden by a routine to\n\t\t * print the neighboring particle IDs for a given vertex. By\n\t\t * default, when no neighbor information is available, the\n\t\t * routine does nothing.\n\t\t * \\param[in] i the vertex to consider. */\n\t\tvirtual void print_edges_neighbors(int i) {};\n\t\t/** This is a simple inline function for picking out the index\n\t\t * of the next edge counterclockwise at the current vertex.\n\t\t * \\param[in] a the index of an edge of the current vertex.\n\t\t * \\param[in] p the number of the vertex.\n\t\t * \\return 0 if a=nu[p]-1, or a+1 otherwise. */\n\t\tinline int cycle_up(int a,int p) {return a==nu[p]-1?0:a+1;}\n\t\t/** This is a simple inline function for picking out the index\n\t\t * of the next edge clockwise from the current vertex.\n\t\t * \\param[in] a the index of an edge of the current vertex.\n\t\t * \\param[in] p the number of the vertex.\n\t\t * \\return nu[p]-1 if a=0, or a-1 otherwise. */\n\t\tinline int cycle_down(int a,int p) {return a==0?nu[p]-1:a-1;}\n\tprotected:\n\t\t/** This a one dimensional array that holds the current sizes\n\t\t * of the memory allocations for them mep array.*/\n\t\tint *mem;\n\t\t/** This is a one dimensional array that holds the current\n\t\t * number of vertices of order p that are stored in the mep[p]\n\t\t * array. */\n\t\tint *mec;\n\t\t/** This is a two dimensional array for holding the information\n\t\t * about the edges of the Voronoi cell. mep[p] is a\n\t\t * one-dimensional array for holding the edge information about\n\t\t * all vertices of order p, with each vertex holding 2*p+1\n\t\t * integers of information. The total number of vertices held\n\t\t * on mep[p] is stored in mem[p]. If the space runs out, the\n\t\t * code allocates more using the add_memory() routine. */\n\t\tint **mep;\n\t\tinline void reset_edges();\n\t\ttemplate<class vc_class>\n\t\tvoid check_memory_for_copy(vc_class &vc,voronoicell_base* vb);\n\t\tvoid copy(voronoicell_base* vb);\n\tprivate:\n\t\t/** This is the delete stack, used to store the vertices which\n\t\t * are going to be deleted during the plane cutting procedure.\n\t\t */\n\t\tint *ds,*stacke;\n\t\t/** This is the auxiliary delete stack, which has size set by\n\t\t * current_delete2_size. */\n\t\tint *ds2,*stacke2;\n\t\t/** This stores the current memory allocation for the marginal\n\t\t * cases. */\n\t\tint current_marginal;\n\t\t/** This stores the total number of marginal points which are\n\t\t * currently in the buffer. */\n\t\tint n_marg;\n\t\t/** This array contains a list of the marginal points, and also\n\t\t * the outcomes of the marginal tests. */\n\t\tint *marg;\n\t\t/** The x coordinate of the normal vector to the test plane. */\n\t\tdouble px;\n\t\t/** The y coordinate of the normal vector to the test plane. */\n\t\tdouble py;\n\t\t/** The z coordinate of the normal vector to the test plane. */\n\t\tdouble pz;\n\t\t/** The magnitude of the normal vector to the test plane. */\n\t\tdouble prsq;\n\t\ttemplate<class vc_class>\n\t\tvoid add_memory(vc_class &vc,int i,int *stackp2);\n\t\ttemplate<class vc_class>\n\t\tvoid add_memory_vertices(vc_class &vc);\n\t\ttemplate<class vc_class>\n\t\tvoid add_memory_vorder(vc_class &vc);\n\t\tvoid add_memory_ds(int *&stackp);\n\t\tvoid add_memory_ds2(int *&stackp2);\n\t\ttemplate<class vc_class>\n\t\tinline bool collapse_order1(vc_class &vc);\n\t\ttemplate<class vc_class>\n\t\tinline bool collapse_order2(vc_class &vc);\n\t\ttemplate<class vc_class>\n\t\tinline bool delete_connection(vc_class &vc,int j,int k,bool hand);\n\t\ttemplate<class vc_class>\n\t\tinline bool search_for_outside_edge(vc_class &vc,int &up);\n\t\ttemplate<class vc_class>\n\t\tinline void add_to_stack(vc_class &vc,int lp,int *&stackp2);\n\t\tinline bool plane_intersects_track(double x,double y,double z,double rs,double g);\n\t\tinline void normals_search(std::vector<double> &v,int i,int j,int k);\n\t\tinline bool search_edge(int l,int &m,int &k);\n\t\tinline int m_test(int n,double &ans);\n\t\tint check_marginal(int n,double &ans);\n\t\tfriend class voronoicell;\n\t\tfriend class voronoicell_neighbor;\n};\n\n/** \\brief Extension of the voronoicell_base class to represent a Voronoi\n * cell without neighbor information.\n *\n * This class is an extension of the voronoicell_base class, in cases when\n * is not necessary to track the IDs of neighboring particles associated\n * with each face of the Voronoi cell. */\nclass voronoicell : public voronoicell_base {\n\tpublic:\n\t\tusing voronoicell_base::nplane;\n\t\t/** Copies the information from another voronoicell class into\n\t\t * this class, extending memory allocation if necessary.\n\t\t * \\param[in] c the class to copy. */\n\t\tinline void operator=(voronoicell &c) {\n\t\t\tvoronoicell_base* vb((voronoicell_base*) &c);\n\t\t\tcheck_memory_for_copy(*this,vb);copy(vb);\n\t\t}\n\t\t/** Cuts a Voronoi cell using by the plane corresponding to the\n\t\t * perpendicular bisector of a particle.\n\t\t * \\param[in] (x,y,z) the position of the particle.\n\t\t * \\param[in] rsq the modulus squared of the vector.\n\t\t * \\param[in] p_id the plane ID, ignored for this case where no\n\t\t *                 neighbor tracking is enabled.\n\t\t * \\return False if the plane cut deleted the cell entirely,\n\t\t *         true otherwise. */\n\t\tinline bool nplane(double x,double y,double z,double rsq,int p_id) {\n\t\t\treturn nplane(*this,x,y,z,rsq,0);\n\t\t}\n\t\t/** Cuts a Voronoi cell using by the plane corresponding to the\n\t\t * perpendicular bisector of a particle.\n\t\t * \\param[in] (x,y,z) the position of the particle.\n\t\t * \\param[in] p_id the plane ID, ignored for this case where no\n\t\t *                 neighbor tracking is enabled.\n\t\t * \\return False if the plane cut deleted the cell entirely,\n\t\t *         true otherwise. */\n\t\tinline bool nplane(double x,double y,double z,int p_id) {\n\t\t\tdouble rsq=x*x+y*y+z*z;\n\t\t\treturn nplane(*this,x,y,z,rsq,0);\n\t\t}\n\t\t/** Cuts a Voronoi cell using by the plane corresponding to the\n\t\t * perpendicular bisector of a particle.\n\t\t * \\param[in] (x,y,z) the position of the particle.\n\t\t * \\param[in] rsq the modulus squared of the vector.\n\t\t * \\return False if the plane cut deleted the cell entirely,\n\t\t *         true otherwise. */\n\t\tinline bool plane(double x,double y,double z,double rsq) {\n\t\t\treturn nplane(*this,x,y,z,rsq,0);\n\t\t}\n\t\t/** Cuts a Voronoi cell using by the plane corresponding to the\n\t\t * perpendicular bisector of a particle.\n\t\t * \\param[in] (x,y,z) the position of the particle.\n\t\t * \\return False if the plane cut deleted the cell entirely,\n\t\t *         true otherwise. */\n\t\tinline bool plane(double x,double y,double z) {\n\t\t\tdouble rsq=x*x+y*y+z*z;\n\t\t\treturn nplane(*this,x,y,z,rsq,0);\n\t\t}\n\t\t/** Initializes the Voronoi cell to be rectangular box with the\n\t\t * given dimensions.\n\t\t * \\param[in] (xmin,xmax) the minimum and maximum x coordinates.\n\t\t * \\param[in] (ymin,ymax) the minimum and maximum y coordinates.\n\t\t * \\param[in] (zmin,zmax) the minimum and maximum z coordinates. */\n\t\tinline void init(double xmin,double xmax,double ymin,double ymax,double zmin,double zmax) {\n\t\t\tinit_base(xmin,xmax,ymin,ymax,zmin,zmax);\n\t\t}\n\t\t/** Initializes the cell to be an octahedron with vertices at\n\t\t * (l,0,0), (-l,0,0), (0,l,0), (0,-l,0), (0,0,l), and (0,0,-l).\n\t\t * \\param[in] l a parameter setting the size of the octahedron.\n\t\t */\n\t\tinline void init_octahedron(double l) {\n\t\t\tinit_octahedron_base(l);\n\t\t}\n\t\t/** Initializes the cell to be a tetrahedron.\n\t\t * \\param[in] (x0,y0,z0) the coordinates of the first vertex.\n\t\t * \\param[in] (x1,y1,z1) the coordinates of the second vertex.\n\t\t * \\param[in] (x2,y2,z2) the coordinates of the third vertex.\n\t\t * \\param[in] (x3,y3,z3) the coordinates of the fourth vertex.\n\t\t */\n\t\tinline void init_tetrahedron(double x0,double y0,double z0,double x1,double y1,double z1,double x2,double y2,double z2,double x3,double y3,double z3) {\n\t\t\tinit_tetrahedron_base(x0,y0,z0,x1,y1,z1,x2,y2,z2,x3,y3,z3);\n\t\t}\n\tprivate:\n\t\tinline void n_allocate(int i,int m) {};\n\t\tinline void n_add_memory_vertices(int i) {};\n\t\tinline void n_add_memory_vorder(int i) {};\n\t\tinline void n_set_pointer(int p,int n) {};\n\t\tinline void n_copy(int a,int b,int c,int d) {};\n\t\tinline void n_set(int a,int b,int c) {};\n\t\tinline void n_set_aux1(int k) {};\n\t\tinline void n_copy_aux1(int a,int b) {};\n\t\tinline void n_copy_aux1_shift(int a,int b) {};\n\t\tinline void n_set_aux2_copy(int a,int b) {};\n\t\tinline void n_copy_pointer(int a,int b) {};\n\t\tinline void n_set_to_aux1(int j) {};\n\t\tinline void n_set_to_aux2(int j) {};\n\t\tinline void n_allocate_aux1(int i) {};\n\t\tinline void n_switch_to_aux1(int i) {};\n\t\tinline void n_copy_to_aux1(int i,int m) {};\n\t\tinline void n_set_to_aux1_offset(int k,int m) {};\n\t\tinline void n_neighbors(std::vector<int> &v) {v.clear();};\n\t\tfriend class voronoicell_base;\n};\n\n/** \\brief Extension of the voronoicell_base class to represent a Voronoi cell\n * with neighbor information.\n *\n * This class is an extension of the voronoicell_base class, in cases when the\n * IDs of neighboring particles associated with each face of the Voronoi cell.\n * It contains additional data structures mne and ne for storing this\n * information. */\nclass voronoicell_neighbor : public voronoicell_base {\n\tpublic:\n\t\tusing voronoicell_base::nplane;\n\t\t/** This two dimensional array holds the neighbor information\n\t\t * associated with each vertex. mne[p] is a one dimensional\n\t\t * array which holds all of the neighbor information for\n\t\t * vertices of order p. */\n\t\tint **mne;\n\t\t/** This is a two dimensional array that holds the neighbor\n\t\t * information associated with each vertex. ne[i] points to a\n\t\t * one-dimensional array in mne[nu[i]]. ne[i][j] holds the\n\t\t * neighbor information associated with the jth edge of vertex\n\t\t * i. It is set to the ID number of the plane that made the\n\t\t * face that is clockwise from the jth edge. */\n\t\tint **ne;\n\t\tvoronoicell_neighbor();\n\t\t~voronoicell_neighbor();\n\t\tvoid operator=(voronoicell &c);\n\t\tvoid operator=(voronoicell_neighbor &c);\n\t\t/** Cuts the Voronoi cell by a particle whose center is at a\n\t\t * separation of (x,y,z) from the cell center. The value of rsq\n\t\t * should be initially set to \\f$x^2+y^2+z^2\\f$.\n\t\t * \\param[in] (x,y,z) the normal vector to the plane.\n\t\t * \\param[in] rsq the distance along this vector of the plane.\n\t\t * \\param[in] p_id the plane ID (for neighbor tracking only).\n\t\t * \\return False if the plane cut deleted the cell entirely,\n\t\t * true otherwise. */\n\t\tinline bool nplane(double x,double y,double z,double rsq,int p_id) {\n\t\t\treturn nplane(*this,x,y,z,rsq,p_id);\n\t\t}\n\t\t/** This routine calculates the modulus squared of the vector\n\t\t * before passing it to the main nplane() routine with full\n\t\t * arguments.\n\t\t * \\param[in] (x,y,z) the vector to cut the cell by.\n\t\t * \\param[in] p_id the plane ID (for neighbor tracking only).\n\t\t * \\return False if the plane cut deleted the cell entirely,\n\t\t *         true otherwise. */\n\t\tinline bool nplane(double x,double y,double z,int p_id) {\n\t\t\tdouble rsq=x*x+y*y+z*z;\n\t\t\treturn nplane(*this,x,y,z,rsq,p_id);\n\t\t}\n\t\t/** This version of the plane routine just makes up the plane\n\t\t * ID to be zero. It will only be referenced if neighbor\n\t\t * tracking is enabled.\n\t\t * \\param[in] (x,y,z) the vector to cut the cell by.\n\t\t * \\param[in] rsq the modulus squared of the vector.\n\t\t * \\return False if the plane cut deleted the cell entirely,\n\t\t *         true otherwise. */\n\t\tinline bool plane(double x,double y,double z,double rsq) {\n\t\t\treturn nplane(*this,x,y,z,rsq,0);\n\t\t}\n\t\t/** Cuts a Voronoi cell using the influence of a particle at\n\t\t * (x,y,z), first calculating the modulus squared of this\n\t\t * vector before passing it to the main nplane() routine. Zero\n\t\t * is supplied as the plane ID, which will be ignored unless\n\t\t * neighbor tracking is enabled.\n\t\t * \\param[in] (x,y,z) the vector to cut the cell by.\n\t\t * \\return False if the plane cut deleted the cell entirely,\n\t\t *         true otherwise. */\n\t\tinline bool plane(double x,double y,double z) {\n\t\t\tdouble rsq=x*x+y*y+z*z;\n\t\t\treturn nplane(*this,x,y,z,rsq,0);\n\t\t}\n\t\tvoid init(double xmin,double xmax,double ymin,double ymax,double zmin,double zmax);\n\t\tvoid init_octahedron(double l);\n\t\tvoid init_tetrahedron(double x0,double y0,double z0,double x1,double y1,double z1,double x2,double y2,double z2,double x3,double y3,double z3);\n\t\tvoid check_facets();\n\t\tvirtual void neighbors(std::vector<int> &v);\n\t\tvirtual void print_edges_neighbors(int i);\n\t\tvirtual void output_neighbors(FILE *fp=stdout) {\n\t\t\tstd::vector<int> v;neighbors(v);\n\t\t\tvoro_print_vector(v,fp);\n\t\t}\n\tprivate:\n\t\tint *paux1;\n\t\tint *paux2;\n\t\tinline void n_allocate(int i,int m) {mne[i]=new int[m*i];}\n\t\tinline void n_add_memory_vertices(int i) {\n\t\t\tint **pp=new int*[i];\n\t\t\tfor(int j=0;j<current_vertices;j++) pp[j]=ne[j];\n\t\t\tdelete [] ne;ne=pp;\n\t\t}\n\t\tinline void n_add_memory_vorder(int i) {\n\t\t\tint **p2=new int*[i];\n\t\t\tfor(int j=0;j<current_vertex_order;j++) p2[j]=mne[j];\n\t\t\tdelete [] mne;mne=p2;\n\t\t}\n\t\tinline void n_set_pointer(int p,int n) {\n\t\t\tne[p]=mne[n]+n*mec[n];\n\t\t}\n\t\tinline void n_copy(int a,int b,int c,int d) {ne[a][b]=ne[c][d];}\n\t\tinline void n_set(int a,int b,int c) {ne[a][b]=c;}\n\t\tinline void n_set_aux1(int k) {paux1=mne[k]+k*mec[k];}\n\t\tinline void n_copy_aux1(int a,int b) {paux1[b]=ne[a][b];}\n\t\tinline void n_copy_aux1_shift(int a,int b) {paux1[b]=ne[a][b+1];}\n\t\tinline void n_set_aux2_copy(int a,int b) {\n\t\t\tpaux2=mne[b]+b*mec[b];\n\t\t\tfor(int i=0;i<b;i++) ne[a][i]=paux2[i];\n\t\t}\n\t\tinline void n_copy_pointer(int a,int b) {ne[a]=ne[b];}\n\t\tinline void n_set_to_aux1(int j) {ne[j]=paux1;}\n\t\tinline void n_set_to_aux2(int j) {ne[j]=paux2;}\n\t\tinline void n_allocate_aux1(int i) {paux1=new int[i*mem[i]];}\n\t\tinline void n_switch_to_aux1(int i) {delete [] mne[i];mne[i]=paux1;}\n\t\tinline void n_copy_to_aux1(int i,int m) {paux1[m]=mne[i][m];}\n\t\tinline void n_set_to_aux1_offset(int k,int m) {ne[k]=paux1+m;}\n\t\tfriend class voronoicell_base;\n};\n\n}\n\n#endif\n","// Voro++, a 3D cell-based Voronoi library\n//\n// Author   : Chris H. Rycroft (LBL / UC Berkeley)\n// Email    : chr@alum.mit.edu\n// Date     : August 30th 2011\n\n/** \\file common.hh\n * \\brief Header file for the small helper functions. */\n\n#ifndef VOROPP_COMMON_HH\n#define VOROPP_COMMON_HH\n\n#include <cstdio>\n#include <cstdlib>\n#include <vector>\n\n#include \"config.hh\"\n\nnamespace voro {\n\n/** \\brief Function for printing fatal error messages and exiting.\n *\n * Function for printing fatal error messages and exiting.\n * \\param[in] p a pointer to the message to print.\n * \\param[in] status the status code to return with. */\ninline void voro_fatal_error(const char *p,int status) {\n\tfprintf(stderr,\"voro++: %s\\n\",p);\n\texit(status);\n}\n\n/** \\brief Prints a vector of positions.\n *\n * Prints a vector of positions as bracketed triplets.\n * \\param[in] v the vector to print.\n * \\param[in] fp the file stream to print to. */\ninline void voro_print_positions(std::vector<double> &v,FILE *fp=stdout) {\n\tif(v.size()>0) {\n\t\tfprintf(fp,\"(%g,%g,%g)\",v[0],v[1],v[2]);\n\t\tfor(int k=3;(unsigned int) k<v.size();k+=3) {\n\t\t\tfprintf(fp,\" (%g,%g,%g)\",v[k],v[k+1],v[k+2]);\n\t\t}\n\t}\n}\n\n/** \\brief Opens a file and checks the operation was successful.\n *\n * Opens a file, and checks the return value to ensure that the operation\n * was successful.\n * \\param[in] filename the file to open.\n * \\param[in] mode the cstdio fopen mode to use.\n * \\return The file handle. */\ninline FILE* safe_fopen(const char *filename,const char *mode) {\n\tFILE *fp=fopen(filename,mode);\n\tif(fp==NULL) {\n\t\tfprintf(stderr,\"voro++: Unable to open file '%s'\\n\",filename);\n\t\texit(VOROPP_FILE_ERROR);\n\t}\n\treturn fp;\n}\n\nvoid voro_print_vector(std::vector<int> &v,FILE *fp=stdout);\nvoid voro_print_vector(std::vector<double> &v,FILE *fp=stdout);\nvoid voro_print_face_vertices(std::vector<int> &v,FILE *fp=stdout);\n\n}\n\n#endif\n","// Voro++, a 3D cell-based Voronoi library\n//\n// Author   : Chris H. Rycroft (LBL / UC Berkeley)\n// Email    : chr@alum.mit.edu\n// Date     : August 30th 2011\n\n/** \\file common.cc\n * \\brief Implementations of the small helper functions. */\n\n#include \"common.hh\"\n\nnamespace voro {\n\n/** \\brief Prints a vector of integers.\n *\n * Prints a vector of integers.\n * \\param[in] v the vector to print.\n * \\param[in] fp the file stream to print to. */\nvoid voro_print_vector(std::vector<int> &v,FILE *fp) {\n\tint k=0,s=v.size();\n\twhile(k+4<s) {\n\t\tfprintf(fp,\"%d %d %d %d \",v[k],v[k+1],v[k+2],v[k+3]);\n\t\tk+=4;\n\t}\n\tif(k+3<=s) {\n\t\tif(k+4==s) fprintf(fp,\"%d %d %d %d\",v[k],v[k+1],v[k+2],v[k+3]);\n\t\telse fprintf(fp,\"%d %d %d\",v[k],v[k+1],v[k+2]);\n\t} else {\n\t\tif(k+2==s) fprintf(fp,\"%d %d\",v[k],v[k+1]);\n\t\telse fprintf(fp,\"%d\",v[k]);\n\t}\n}\n\n/** \\brief Prints a vector of doubles.\n *\n * Prints a vector of doubles.\n * \\param[in] v the vector to print.\n * \\param[in] fp the file stream to print to. */\nvoid voro_print_vector(std::vector<double> &v,FILE *fp) {\n\tint k=0,s=v.size();\n\twhile(k+4<s) {\n\t\tfprintf(fp,\"%g %g %g %g \",v[k],v[k+1],v[k+2],v[k+3]);\n\t\tk+=4;\n\t}\n\tif(k+3<=s) {\n\t\tif(k+4==s) fprintf(fp,\"%g %g %g %g\",v[k],v[k+1],v[k+2],v[k+3]);\n\t\telse fprintf(fp,\"%g %g %g\",v[k],v[k+1],v[k+2]);\n\t} else {\n\t\tif(k+2==s) fprintf(fp,\"%g %g\",v[k],v[k+1]);\n\t\telse fprintf(fp,\"%g\",v[k]);\n\t}\n}\n\n/** \\brief Prints a vector a face vertex information.\n *\n * Prints a vector of face vertex information. A value is read, which\n * corresponds to the number of vertices in the next face. The routine reads\n * this number of values and prints them as a bracked list. This is repeated\n * until the end of the vector is reached.\n * \\param[in] v the vector to interpret and print.\n * \\param[in] fp the file stream to print to. */\nvoid voro_print_face_vertices(std::vector<int> &v,FILE *fp) {\n\tint j,k=0,l;\n\tif(v.size()>0) {\n\t\tl=v[k++];\n\t\tif(l<=1) {\n\t\t\tif(l==1) fprintf(fp,\"(%d)\",v[k++]);\n\t\t\telse fputs(\"()\",fp);\n\t\t} else {\n\t\t\tj=k+l;\n\t\t\tfprintf(fp,\"(%d\",v[k++]);\n\t\t\twhile(k<j) fprintf(fp,\",%d\",v[k++]);\n\t\t\tfputs(\")\",fp);\n\t\t}\n\t\twhile((unsigned int) k<v.size()) {\n\t\t\tl=v[k++];\n\t\t\tif(l<=1) {\n\t\t\t\tif(l==1) fprintf(fp,\" (%d)\",v[k++]);\n\t\t\t\telse fputs(\" ()\",fp);\n\t\t\t} else {\n\t\t\t\tj=k+l;\n\t\t\t\tfprintf(fp,\" (%d\",v[k++]);\n\t\t\t\twhile(k<j) fprintf(fp,\",%d\",v[k++]);\n\t\t\t\tfputs(\")\",fp);\n\t\t\t}\n\t\t}\n\t}\n}\n\n}\n","// Voro++, a 3D cell-based Voronoi library\n//\n// Author   : Chris H. Rycroft (LBL / UC Berkeley)\n// Email    : chr@alum.mit.edu\n// Date     : August 30th 2011\n\n/** \\file v_base.cc\n * \\brief Function implementations for the base Voronoi container class. */\n\n#include \"v_base.hh\"\n#include \"config.hh\"\n\nnamespace voro {\n\n/** This function is called during container construction. The routine scans\n * all of the worklists in the wl[] array. For a given worklist of blocks\n * labeled \\f$w_1\\f$ to \\f$w_n\\f$, it computes a sequence \\f$r_0\\f$ to\n * \\f$r_n\\f$ so that $r_i$ is the minimum distance to all the blocks\n * \\f$w_{j}\\f$ where \\f$j>i\\f$ and all blocks outside the worklist. The values\n * of \\f$r_n\\f$ is calculated first, as the minimum distance to any block in\n * the shell surrounding the worklist. The \\f$r_i\\f$ are then computed in\n * reverse order by considering the distance to \\f$w_{i+1}\\f$. */\nvoro_base::voro_base(int nx_,int ny_,int nz_,double boxx_,double boxy_,double boxz_) :\n\tnx(nx_), ny(ny_), nz(nz_), nxy(nx_*ny_), nxyz(nxy*nz_), boxx(boxx_), boxy(boxy_), boxz(boxz_),\n\txsp(1/boxx_), ysp(1/boxy_), zsp(1/boxz_), mrad(new double[wl_hgridcu*wl_seq_length]) {\n\tconst unsigned int b1=1<<21,b2=1<<22,b3=1<<24,b4=1<<25,b5=1<<27,b6=1<<28;\n\tconst double xstep=boxx/wl_fgrid,ystep=boxy/wl_fgrid,zstep=boxz/wl_fgrid;\n\tint i,j,k,lx,ly,lz,q;\n\tunsigned int f,*e=const_cast<unsigned int*> (wl);\n\tdouble xlo,ylo,zlo,xhi,yhi,zhi,minr,*radp=mrad;\n\tfor(zlo=0,zhi=zstep,lz=0;lz<wl_hgrid;zlo=zhi,zhi+=zstep,lz++) {\n\t\tfor(ylo=0,yhi=ystep,ly=0;ly<wl_hgrid;ylo=yhi,yhi+=ystep,ly++) {\n\t\t\tfor(xlo=0,xhi=xstep,lx=0;lx<wl_hgrid;xlo=xhi,xhi+=xstep,lx++) {\n\t\t\t\tminr=large_number;\n\t\t\t\tfor(q=e[0]+1;q<wl_seq_length;q++) {\n\t\t\t\t\tf=e[q];\n\t\t\t\t\ti=(f&127)-64;\n\t\t\t\t\tj=(f>>7&127)-64;\n\t\t\t\t\tk=(f>>14&127)-64;\n\t\t\t\t\tif((f&b2)==b2) {\n\t\t\t\t\t\tcompute_minimum(minr,xlo,xhi,ylo,yhi,zlo,zhi,i-1,j,k);\n\t\t\t\t\t\tif((f&b1)==0) compute_minimum(minr,xlo,xhi,ylo,yhi,zlo,zhi,i+1,j,k);\n\t\t\t\t\t} else if((f&b1)==b1) compute_minimum(minr,xlo,xhi,ylo,yhi,zlo,zhi,i+1,j,k);\n\t\t\t\t\tif((f&b4)==b4) {\n\t\t\t\t\t\tcompute_minimum(minr,xlo,xhi,ylo,yhi,zlo,zhi,i,j-1,k);\n\t\t\t\t\t\tif((f&b3)==0) compute_minimum(minr,xlo,xhi,ylo,yhi,zlo,zhi,i,j+1,k);\n\t\t\t\t\t} else if((f&b3)==b3) compute_minimum(minr,xlo,xhi,ylo,yhi,zlo,zhi,i,j+1,k);\n\t\t\t\t\tif((f&b6)==b6) {\n\t\t\t\t\t\tcompute_minimum(minr,xlo,xhi,ylo,yhi,zlo,zhi,i,j,k-1);\n\t\t\t\t\t\tif((f&b5)==0) compute_minimum(minr,xlo,xhi,ylo,yhi,zlo,zhi,i,j,k+1);\n\t\t\t\t\t} else if((f&b5)==b5) compute_minimum(minr,xlo,xhi,ylo,yhi,zlo,zhi,i,j,k+1);\n\t\t\t\t}\n\t\t\t\tq--;\n\t\t\t\twhile(q>0) {\n\t\t\t\t\tradp[q]=minr;\n\t\t\t\t\tf=e[q];\n\t\t\t\t\ti=(f&127)-64;\n\t\t\t\t\tj=(f>>7&127)-64;\n\t\t\t\t\tk=(f>>14&127)-64;\n\t\t\t\t\tcompute_minimum(minr,xlo,xhi,ylo,yhi,zlo,zhi,i,j,k);\n\t\t\t\t\tq--;\n\t\t\t\t}\n\t\t\t\t*radp=minr;\n\t\t\t\te+=wl_seq_length;\n\t\t\t\tradp+=wl_seq_length;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/** Computes the minimum distance from a subregion to a given block. If this distance\n * is smaller than the value of minr, then it passes\n * \\param[in,out] minr a pointer to the current minimum distance. If the distance\n *                     computed in this function is smaller, then this distance is\n *                     set to the new one.\n * \\param[out] (xlo,ylo,zlo) the lower coordinates of the subregion being\n *                           considered.\n * \\param[out] (xhi,yhi,zhi) the upper coordinates of the subregion being\n *                           considered.\n * \\param[in] (ti,tj,tk) the coordinates of the block. */\nvoid voro_base::compute_minimum(double &minr,double &xlo,double &xhi,double &ylo,double &yhi,double &zlo,double &zhi,int ti,int tj,int tk) {\n\tdouble radsq,temp;\n\tif(ti>0) {temp=boxx*ti-xhi;radsq=temp*temp;}\n\telse if(ti<0) {temp=xlo-boxx*(1+ti);radsq=temp*temp;}\n\telse radsq=0;\n\n\tif(tj>0) {temp=boxy*tj-yhi;radsq+=temp*temp;}\n\telse if(tj<0) {temp=ylo-boxy*(1+tj);radsq+=temp*temp;}\n\n\tif(tk>0) {temp=boxz*tk-zhi;radsq+=temp*temp;}\n\telse if(tk<0) {temp=zlo-boxz*(1+tk);radsq+=temp*temp;}\n\n\tif(radsq<minr) minr=radsq;\n}\n\n/** Checks to see whether \"%n\" appears in a format sequence to determine\n * whether neighbor information is required or not.\n * \\param[in] format the format string to check.\n * \\return True if a \"%n\" is found, false otherwise. */\nbool voro_base::contains_neighbor(const char *format) {\n\tchar *fmp=(const_cast<char*>(format));\n\n\t// Check to see if \"%n\" appears in the format sequence\n\twhile(*fmp!=0) {\n\t\tif(*fmp=='%') {\n\t\t\tfmp++;\n\t\t\tif(*fmp=='n') return true;\n\t\t\telse if(*fmp==0) return false;\n\t\t}\n\t\tfmp++;\n\t}\n\n\treturn false;\n}\n\n#include \"v_base_wl.cc\"\n\n}\n","// Voro++, a 3D cell-based Voronoi library\n//\n// Author   : Chris H. Rycroft (LBL / UC Berkeley)\n// Email    : chr@alum.mit.edu\n// Date     : August 30th 2011\n\n/** \\file container.cc\n * \\brief Function implementations for the container and related classes. */\n\n#include \"container.hh\"\n\n\nnamespace voro {\n\n/** The class constructor sets up the geometry of container, initializing the\n * minimum and maximum coordinates in each direction, and setting whether each\n * direction is periodic or not. It divides the container into a rectangular\n * grid of blocks, and allocates memory for each of these for storing particle\n * positions and IDs.\n * \\param[in] (ax_,bx_) the minimum and maximum x coordinates.\n * \\param[in] (ay_,by_) the minimum and maximum y coordinates.\n * \\param[in] (az_,bz_) the minimum and maximum z coordinates.\n * \\param[in] (nx_,ny_,nz_) the number of grid blocks in each of the three\n *\t\t\t    coordinate directions.\n * \\param[in] (xperiodic_,yperiodic_,zperiodic_) flags setting whether the\n *                                               container is periodic in each\n *                                               coordinate direction.\n * \\param[in] init_mem the initial memory allocation for each block.\n * \\param[in] ps_ the number of floating point entries to store for each\n *                particle. */\ncontainer_base::container_base(double ax_,double bx_,double ay_,double by_,double az_,double bz_,\n\t\tint nx_,int ny_,int nz_,bool xperiodic_,bool yperiodic_,bool zperiodic_,int init_mem,int ps_)\n\t: voro_base(nx_,ny_,nz_,(bx_-ax_)/nx_,(by_-ay_)/ny_,(bz_-az_)/nz_),\n\tax(ax_), bx(bx_), ay(ay_), by(by_), az(az_), bz(bz_),\n\txperiodic(xperiodic_), yperiodic(yperiodic_), zperiodic(zperiodic_),\n\tid(new int*[nxyz]), p(new double*[nxyz]), co(new int[nxyz]), mem(new int[nxyz]), ps(ps_) {\n\tint l;\n\tfor(l=0;l<nxyz;l++) co[l]=0;\n\tfor(l=0;l<nxyz;l++) mem[l]=init_mem;\n\tfor(l=0;l<nxyz;l++) id[l]=new int[init_mem];\n\tfor(l=0;l<nxyz;l++) p[l]=new double[ps*init_mem];\n}\n\n/** The container destructor frees the dynamically allocated memory. */\ncontainer_base::~container_base() {\n\tint l;\n\tfor(l=0;l<nxyz;l++) delete [] p[l];\n\tfor(l=0;l<nxyz;l++) delete [] id[l];\n\tdelete [] id;\n\tdelete [] p;\n\tdelete [] co;\n\tdelete [] mem;\n}\n\n/** The class constructor sets up the geometry of container.\n * \\param[in] (ax_,bx_) the minimum and maximum x coordinates.\n * \\param[in] (ay_,by_) the minimum and maximum y coordinates.\n * \\param[in] (az_,bz_) the minimum and maximum z coordinates.\n * \\param[in] (nx_,ny_,nz_) the number of grid blocks in each of the three\n *                       coordinate directions.\n * \\param[in] (xperiodic_,yperiodic_,zperiodic_) flags setting whether the\n *                                               container is periodic in each\n *                                               coordinate direction.\n * \\param[in] init_mem the initial memory allocation for each block. */\ncontainer::container(double ax_,double bx_,double ay_,double by_,double az_,double bz_,\n\tint nx_,int ny_,int nz_,bool xperiodic_,bool yperiodic_,bool zperiodic_,int init_mem)\n\t: container_base(ax_,bx_,ay_,by_,az_,bz_,nx_,ny_,nz_,xperiodic_,yperiodic_,zperiodic_,init_mem,3),\n\tvc(*this,xperiodic_?2*nx_+1:nx_,yperiodic_?2*ny_+1:ny_,zperiodic_?2*nz_+1:nz_) {}\n\n/** The class constructor sets up the geometry of container.\n * \\param[in] (ax_,bx_) the minimum and maximum x coordinates.\n * \\param[in] (ay_,by_) the minimum and maximum y coordinates.\n * \\param[in] (az_,bz_) the minimum and maximum z coordinates.\n * \\param[in] (nx_,ny_,nz_) the number of grid blocks in each of the three\n *                       coordinate directions.\n * \\param[in] (xperiodic_,yperiodic_,zperiodic_) flags setting whether the\n *                                               container is periodic in each\n *                                               coordinate direction.\n * \\param[in] init_mem the initial memory allocation for each block. */\ncontainer_poly::container_poly(double ax_,double bx_,double ay_,double by_,double az_,double bz_,\n\tint nx_,int ny_,int nz_,bool xperiodic_,bool yperiodic_,bool zperiodic_,int init_mem)\n\t: container_base(ax_,bx_,ay_,by_,az_,bz_,nx_,ny_,nz_,xperiodic_,yperiodic_,zperiodic_,init_mem,4),\n\tvc(*this,xperiodic_?2*nx_+1:nx_,yperiodic_?2*ny_+1:ny_,zperiodic_?2*nz_+1:nz_) {ppr=p;}\n\n/** Put a particle into the correct region of the container.\n * \\param[in] n the numerical ID of the inserted particle.\n * \\param[in] (x,y,z) the position vector of the inserted particle. */\nvoid container::put(int n,double x,double y,double z) {\n\tint ijk;\n\tif(put_locate_block(ijk,x,y,z)) {\n\t\tid[ijk][co[ijk]]=n;\n\t\tdouble *pp=p[ijk]+3*co[ijk]++;\n\t\t*(pp++)=x;*(pp++)=y;*pp=z;\n\t}\n}\n\n/** Put a particle into the correct region of the container.\n * \\param[in] n the numerical ID of the inserted particle.\n * \\param[in] (x,y,z) the position vector of the inserted particle. \n * \\param[out] ijk the block where the particle was inserted\n * \\param[out] q the index of the particle within its block\n * \\return True if the particle was successfully placed; false otherwise */\nbool container::put(int n,double x,double y,double z, int &ijk, int &q) {\n    if(put_locate_block(ijk,x,y,z)) {\n        q = co[ijk];\n        id[ijk][co[ijk]]=n;\n        double *pp=p[ijk]+3*co[ijk]++;\n        *(pp++)=x;*(pp++)=y;*pp=z;\n        return true;\n    }\n    return false;\n}\n\n/** Delete a particle from the container (via swapnpop in its cell block)\n * \\param[in] ijk the block of the particle to swapnpop\n * \\param[in] q index of the particle to swapnpop\n * \\return index of cell that was swapped back to q if swap was needed, else -1 */\nint container::swapnpop(int ijk, int q) {\n    assert(q >= 0 && q < co[ijk]);\n    assert(co[ijk] > 0);\n    int lasti = co[ijk]-1;\n    int toret = -1;\n    if (q != lasti) {\n        toret = id[ijk][q] = id[ijk][lasti];\n        double *ppq = p[ijk]+3*q;\n        double *ppl = p[ijk]+3*lasti;\n        *(ppq++) = *(ppl++); // x\n        *(ppq++) = *(ppl++); // y\n        *(ppq++) = *(ppl++); // z\n    }\n    co[ijk]--;\n    return toret;\n}\n/** Put a particle into the correct region of the container.\n * \\param[in,out] ijk the block of the particle to move (will be updated if needed)\n * \\param[in,out] q index of the particle to move (will be updated if needed)\n * \\param[out] q index of the particle that needs incidental update (will always be the _input_ q, is a param just so function user will remember they need to store it and deal with it.)\n * \\return index of other cell that got an updated q index to accomplish the move,\n            or -1 if no other cell needed change */\nint container::move(int &ijk, int &q, int n, double x, double y, double z, int &needsupdate_q) {\n    if (q<0 || ijk<0) { // special case: it's not in the container\n        if (!put(n, x, y, z, ijk, q)) {\n            ijk = -1; q = -1;\n        }\n        return -1;\n    }\n    \n    assert(co[ijk] > q);\n    \n    int needsupdate = -1;\n    \n    int ijk_new;\n    if (put_remap(ijk_new, x, y, z)) {\n        if (ijk_new == ijk) { // same block, can just update position and be done\n            double *pp = p[ijk]+3*q;\n            *(pp++)=x;*(pp++)=y;*pp=z;\n        } else {\n            int n = id[ijk][q]; // save original id\n            needsupdate_q = q; // save original q\n            \n            // remove cell from old block\n            needsupdate = swapnpop(ijk, q);\n            \n            // add cell to new block\n            if(co[ijk_new]==mem[ijk_new]) add_particle_memory(ijk_new);\n            int q_new = co[ijk_new];\n            id[ijk_new][co[ijk_new]] = n;\n            double *pp=p[ijk_new]+3*co[ijk_new]++;\n            *(pp++)=x;*(pp++)=y;*pp=z;\n            \n            // update ijk and q\n            q = q_new;\n            ijk = ijk_new; // ijk is now _NEW_ ijk\n        }\n    } else { // we moved to a place we can't put particle -- e.g. outside bounding box\n        needsupdate_q = q; // save original q\n        needsupdate = swapnpop(ijk, q); // remove from block\n        \n        ijk = -1; q = -1; // link is now invalid; we can't place the cell\n    }\n    \n    return needsupdate;\n}\n\n/** Put a particle into the correct region of the container.\n * \\param[in] n the numerical ID of the inserted particle.\n * \\param[in] (x,y,z) the position vector of the inserted particle.\n * \\param[in] r the radius of the particle. */\nvoid container_poly::put(int n,double x,double y,double z,double r) {\n\tint ijk;\n\tif(put_locate_block(ijk,x,y,z)) {\n\t\tid[ijk][co[ijk]]=n;\n\t\tdouble *pp=p[ijk]+4*co[ijk]++;\n\t\t*(pp++)=x;*(pp++)=y;*(pp++)=z;*pp=r;\n\t\tif(max_radius<r) max_radius=r;\n\t}\n}\n\n/** Put a particle into the correct region of the container, also recording\n * into which region it was stored.\n * \\param[in] vo the ordering class in which to record the region.\n * \\param[in] n the numerical ID of the inserted particle.\n * \\param[in] (x,y,z) the position vector of the inserted particle. */\nvoid container::put(particle_order &vo,int n,double x,double y,double z) {\n\tint ijk;\n\tif(put_locate_block(ijk,x,y,z)) {\n\t\tid[ijk][co[ijk]]=n;\n\t\tvo.add(ijk,co[ijk]);\n\t\tdouble *pp=p[ijk]+3*co[ijk]++;\n\t\t*(pp++)=x;*(pp++)=y;*pp=z;\n\t}\n}\n\n/** Put a particle into the correct region of the container, also recording\n * into which region it was stored.\n * \\param[in] vo the ordering class in which to record the region.\n * \\param[in] n the numerical ID of the inserted particle.\n * \\param[in] (x,y,z) the position vector of the inserted particle.\n * \\param[in] r the radius of the particle. */\nvoid container_poly::put(particle_order &vo,int n,double x,double y,double z,double r) {\n\tint ijk;\n\tif(put_locate_block(ijk,x,y,z)) {\n\t\tid[ijk][co[ijk]]=n;\n\t\tvo.add(ijk,co[ijk]);\n\t\tdouble *pp=p[ijk]+4*co[ijk]++;\n\t\t*(pp++)=x;*(pp++)=y;*(pp++)=z;*pp=r;\n\t\tif(max_radius<r) max_radius=r;\n\t}\n}\n\n/** This routine takes a particle position vector, tries to remap it into the\n * primary domain. If successful, it computes the region into which it can be\n * stored and checks that there is enough memory within this region to store\n * it.\n * \\param[out] ijk the region index.\n * \\param[in,out] (x,y,z) the particle position, remapped into the primary\n *                        domain if necessary.\n * \\return True if the particle can be successfully placed into the container,\n * false otherwise. */\nbool container_base::put_locate_block(int &ijk,double &x,double &y,double &z) {\n\tif(put_remap(ijk,x,y,z)) {\n\t\tif(co[ijk]==mem[ijk]) add_particle_memory(ijk);\n\t\treturn true;\n\t}\n#if VOROPP_REPORT_OUT_OF_BOUNDS ==1\n\tfprintf(stderr,\"Out of bounds: (x,y,z)=(%g,%g,%g)\\n\",x,y,z);\n#endif\n\treturn false;\n}\n\n/** Takes a particle position vector and computes the region index into which\n * it should be stored. If the container is periodic, then the routine also\n * maps the particle position to ensure it is in the primary domain. If the\n * container is not periodic, the routine bails out.\n * \\param[out] ijk the region index.\n * \\param[in,out] (x,y,z) the particle position, remapped into the primary\n *                        domain if necessary.\n * \\return True if the particle can be successfully placed into the container,\n * false otherwise. */\ninline bool container_base::put_remap(int &ijk,double &x,double &y,double &z) {\n\tint l;\n\n\tijk=step_int((x-ax)*xsp);\n\tif(xperiodic) {l=step_mod(ijk,nx);x+=boxx*(l-ijk);ijk=l;}\n\telse if(ijk<0||ijk>=nx) return false;\n\n\tint j=step_int((y-ay)*ysp);\n\tif(yperiodic) {l=step_mod(j,ny);y+=boxy*(l-j);j=l;}\n\telse if(j<0||j>=ny) return false;\n\n\tint k=step_int((z-az)*zsp);\n\tif(zperiodic) {l=step_mod(k,nz);z+=boxz*(l-k);k=l;}\n\telse if(k<0||k>=nz) return false;\n\n\tijk+=nx*j+nxy*k;\n\treturn true;\n}\n    \nbool container_base::already_in_block(double x, double y, double z, double threshold, int except_cell) {\n    int ijk;\n    \n    bool inblock = false;\n    if(put_remap(ijk,x,y,z)) {\n        for (int i=0; i<co[ijk]; i++) {\n            if (id[ijk][i] == except_cell) continue;\n            double *pp = p[ijk]+i*ps;\n            double dx = *(pp++) - x;\n            double dy = *(pp++) - y;\n            double dz = *(pp++) - z;\n            double dsq = dx*dx+dy*dy+dz*dz;\n            inblock = inblock || (dsq < threshold);\n        }\n    }\n    return inblock;\n}\n\n/** Takes a position vector and attempts to remap it into the primary domain.\n * \\param[out] (ai,aj,ak) the periodic image displacement that the vector is in,\n *                       with (0,0,0) corresponding to the primary domain.\n * \\param[out] (ci,cj,ck) the index of the block that the position vector is\n *                        within, once it has been remapped.\n * \\param[in,out] (x,y,z) the position vector to consider, which is remapped\n *                        into the primary domain during the routine.\n * \\param[out] ijk the block index that the vector is within.\n * \\return True if the particle is within the container or can be remapped into\n * it, false if it lies outside of the container bounds. */\ninline bool container_base::remap(int &ai,int &aj,int &ak,int &ci,int &cj,int &ck,double &x,double &y,double &z,int &ijk) {\n\tci=step_int((x-ax)*xsp);\n\tif(ci<0||ci>=nx) {\n\t\tif(xperiodic) {ai=step_div(ci,nx);x-=ai*(bx-ax);ci-=ai*nx;}\n\t\telse return false;\n\t} else ai=0;\n\n\tcj=step_int((y-ay)*ysp);\n\tif(cj<0||cj>=ny) {\n\t\tif(yperiodic) {aj=step_div(cj,ny);y-=aj*(by-ay);cj-=aj*ny;}\n\t\telse return false;\n\t} else aj=0;\n\n\tck=step_int((z-az)*zsp);\n\tif(ck<0||ck>=nz) {\n\t\tif(zperiodic) {ak=step_div(ck,nz);z-=ak*(bz-az);ck-=ak*nz;}\n\t\telse return false;\n\t} else ak=0;\n\n\tijk=ci+nx*cj+nxy*ck;\n\treturn true;\n}\n\n/** Takes a vector and finds the particle whose Voronoi cell contains that\n * vector. This is equivalent to finding the particle which is nearest to the\n * vector. Additional wall classes are not considered by this routine.\n * \\param[in] (x,y,z) the vector to test.\n * \\param[out] (rx,ry,rz) the position of the particle whose Voronoi cell\n *                        contains the vector. If the container is periodic,\n *                        this may point to a particle in a periodic image of\n *                        the primary domain.\n * \\param[out] pid the ID of the particle.\n * \\return True if a particle was found. If the container has no particles,\n * then the search will not find a Voronoi cell and false is returned. */\nbool container::find_voronoi_cell(double x,double y,double z,double &rx,double &ry,double &rz,int &pid) {\n\tint ai,aj,ak,ci,cj,ck,ijk;\n\tparticle_record w;\n\tdouble mrs;\n\n\t// If the given vector lies outside the domain, but the container\n\t// is periodic, then remap it back into the domain\n\tif(!remap(ai,aj,ak,ci,cj,ck,x,y,z,ijk)) return false;\n\tvc.find_voronoi_cell(x,y,z,ci,cj,ck,ijk,w,mrs);\n\n\tif(w.ijk!=-1) {\n\n\t\t// Assemble the position vector of the particle to be returned,\n\t\t// applying a periodic remapping if necessary\n\t\tif(xperiodic) {ci+=w.di;if(ci<0||ci>=nx) ai+=step_div(ci,nx);}\n\t\tif(yperiodic) {cj+=w.dj;if(cj<0||cj>=ny) aj+=step_div(cj,ny);}\n\t\tif(zperiodic) {ck+=w.dk;if(ck<0||ck>=nz) ak+=step_div(ck,nz);}\n\t\trx=p[w.ijk][3*w.l]+ai*(bx-ax);\n\t\try=p[w.ijk][3*w.l+1]+aj*(by-ay);\n\t\trz=p[w.ijk][3*w.l+2]+ak*(bz-az);\n\t\tpid=id[w.ijk][w.l];\n\t\treturn true;\n\t}\n\n\t// If no particle if found then just return false\n\treturn false;\n}\n\n/** Takes a vector and finds the particle whose Voronoi cell contains that\n * vector. Additional wall classes are not considered by this routine.\n * \\param[in] (x,y,z) the vector to test.\n * \\param[out] (rx,ry,rz) the position of the particle whose Voronoi cell\n *                        contains the vector. If the container is periodic,\n *                        this may point to a particle in a periodic image of\n *                        the primary domain.\n * \\param[out] pid the ID of the particle.\n * \\return True if a particle was found. If the container has no particles,\n * then the search will not find a Voronoi cell and false is returned. */\nbool container_poly::find_voronoi_cell(double x,double y,double z,double &rx,double &ry,double &rz,int &pid) {\n\tint ai,aj,ak,ci,cj,ck,ijk;\n\tparticle_record w;\n\tdouble mrs;\n\n\t// If the given vector lies outside the domain, but the container\n\t// is periodic, then remap it back into the domain\n\tif(!remap(ai,aj,ak,ci,cj,ck,x,y,z,ijk)) return false;\n\tvc.find_voronoi_cell(x,y,z,ci,cj,ck,ijk,w,mrs);\n\n\tif(w.ijk!=-1) {\n\n\t\t// Assemble the position vector of the particle to be returned,\n\t\t// applying a periodic remapping if necessary\n\t\tif(xperiodic) {ci+=w.di;if(ci<0||ci>=nx) ai+=step_div(ci,nx);}\n\t\tif(yperiodic) {cj+=w.dj;if(cj<0||cj>=ny) aj+=step_div(cj,ny);}\n\t\tif(zperiodic) {ck+=w.dk;if(ck<0||ck>=nz) ak+=step_div(ck,nz);}\n\t\trx=p[w.ijk][4*w.l]+ai*(bx-ax);\n\t\try=p[w.ijk][4*w.l+1]+aj*(by-ay);\n\t\trz=p[w.ijk][4*w.l+2]+ak*(bz-az);\n\t\tpid=id[w.ijk][w.l];\n\t\treturn true;\n\t}\n\n\t// If no particle if found then just return false\n\treturn false;\n}\n\n/** Increase memory for a particular region.\n * \\param[in] i the index of the region to reallocate. */\nvoid container_base::add_particle_memory(int i) {\n\tint l,nmem=mem[i]<<1;\n\n\t// Carry out a check on the memory allocation size, and\n\t// print a status message if requested\n\tif(nmem>max_particle_memory)\n\t\tvoro_fatal_error(\"Absolute maximum memory allocation exceeded\",VOROPP_MEMORY_ERROR);\n#if VOROPP_VERBOSE >=3\n\tfprintf(stderr,\"Particle memory in region %d scaled up to %d\\n\",i,nmem);\n#endif\n\n\t// Allocate new memory and copy in the contents of the old arrays\n\tint *idp=new int[nmem];\n\tfor(l=0;l<co[i];l++) idp[l]=id[i][l];\n\tdouble *pp=new double[ps*nmem];\n\tfor(l=0;l<ps*co[i];l++) pp[l]=p[i][l];\n\n\t// Update pointers and delete old arrays\n\tmem[i]=nmem;\n\tdelete [] id[i];id[i]=idp;\n\tdelete [] p[i];p[i]=pp;\n}\n\n/** Import a list of particles from an open file stream into the container.\n * Entries of four numbers (Particle ID, x position, y position, z position)\n * are searched for. If the file cannot be successfully read, then the routine\n * causes a fatal error.\n * \\param[in] fp the file handle to read from. */\nvoid container::import(FILE *fp) {\n\tint i,j;\n\tdouble x,y,z;\n\twhile((j=fscanf(fp,\"%d %lg %lg %lg\",&i,&x,&y,&z))==4) put(i,x,y,z);\n\tif(j!=EOF) voro_fatal_error(\"File import error\",VOROPP_FILE_ERROR);\n}\n\n/** Import a list of particles from an open file stream, also storing the order\n * of that the particles are read. Entries of four numbers (Particle ID, x\n * position, y position, z position) are searched for. If the file cannot be\n * successfully read, then the routine causes a fatal error.\n * \\param[in,out] vo a reference to an ordering class to use.\n * \\param[in] fp the file handle to read from. */\nvoid container::import(particle_order &vo,FILE *fp) {\n\tint i,j;\n\tdouble x,y,z;\n\twhile((j=fscanf(fp,\"%d %lg %lg %lg\",&i,&x,&y,&z))==4) put(vo,i,x,y,z);\n\tif(j!=EOF) voro_fatal_error(\"File import error\",VOROPP_FILE_ERROR);\n}\n\n/** Import a list of particles from an open file stream into the container.\n * Entries of five numbers (Particle ID, x position, y position, z position,\n * radius) are searched for. If the file cannot be successfully read, then the\n * routine causes a fatal error.\n * \\param[in] fp the file handle to read from. */\nvoid container_poly::import(FILE *fp) {\n\tint i,j;\n\tdouble x,y,z,r;\n\twhile((j=fscanf(fp,\"%d %lg %lg %lg %lg\",&i,&x,&y,&z,&r))==5) put(i,x,y,z,r);\n\tif(j!=EOF) voro_fatal_error(\"File import error\",VOROPP_FILE_ERROR);\n}\n\n/** Import a list of particles from an open file stream, also storing the order\n * of that the particles are read. Entries of four numbers (Particle ID, x\n * position, y position, z position, radius) are searched for. If the file\n * cannot be successfully read, then the routine causes a fatal error.\n * \\param[in,out] vo a reference to an ordering class to use.\n * \\param[in] fp the file handle to read from. */\nvoid container_poly::import(particle_order &vo,FILE *fp) {\n\tint i,j;\n\tdouble x,y,z,r;\n\twhile((j=fscanf(fp,\"%d %lg %lg %lg %lg\",&i,&x,&y,&z,&r))==5) put(vo,i,x,y,z,r);\n\tif(j!=EOF) voro_fatal_error(\"File import error\",VOROPP_FILE_ERROR);\n}\n\n/** Outputs the a list of all the container regions along with the number of\n * particles stored within each. */\nvoid container_base::region_count() {\n\tint i,j,k,*cop=co;\n\tfor(k=0;k<nz;k++) for(j=0;j<ny;j++) for(i=0;i<nx;i++)\n\t\tprintf(\"Region (%d,%d,%d): %d particles\\n\",i,j,k,*(cop++));\n}\n\n/** Clears a container of particles. */\nvoid container::clear() {\n\tfor(int *cop=co;cop<co+nxyz;cop++) *cop=0;\n}\n\n/** Clears a container of particles, also clearing resetting the maximum radius\n * to zero. */\nvoid container_poly::clear() {\n\tfor(int *cop=co;cop<co+nxyz;cop++) *cop=0;\n\tmax_radius=0;\n}\n\n/** Computes all the Voronoi cells and saves customized information about them.\n * \\param[in] format the custom output string to use.\n * \\param[in] fp a file handle to write to. */\nvoid container::print_custom(const char *format,FILE *fp) {\n\tc_loop_all vl(*this);\n\tprint_custom(vl,format,fp);\n}\n\n/** Computes all the Voronoi cells and saves customized\n * information about them.\n * \\param[in] format the custom output string to use.\n * \\param[in] fp a file handle to write to. */\nvoid container_poly::print_custom(const char *format,FILE *fp) {\n\tc_loop_all vl(*this);\n\tprint_custom(vl,format,fp);\n}\n\n/** Computes all the Voronoi cells and saves customized information about them.\n * \\param[in] format the custom output string to use.\n * \\param[in] filename the name of the file to write to. */\nvoid container::print_custom(const char *format,const char *filename) {\n\tFILE *fp=safe_fopen(filename,\"w\");\n\tprint_custom(format,fp);\n\tfclose(fp);\n}\n\n/** Computes all the Voronoi cells and saves customized\n * information about them\n * \\param[in] format the custom output string to use.\n * \\param[in] filename the name of the file to write to. */\nvoid container_poly::print_custom(const char *format,const char *filename) {\n\tFILE *fp=safe_fopen(filename,\"w\");\n\tprint_custom(format,fp);\n\tfclose(fp);\n}\n\n/** Computes all of the Voronoi cells in the container, but does nothing\n * with the output. It is useful for measuring the pure computation time\n * of the Voronoi algorithm, without any additional calculations such as\n * volume evaluation or cell output. */\nvoid container::compute_all_cells() {\n\tvoronoicell c;\n\tc_loop_all vl(*this);\n\tif(vl.start()) do compute_cell(c,vl);\n\twhile(vl.inc());\n}\n\n/** Computes all of the Voronoi cells in the container, but does nothing\n * with the output. It is useful for measuring the pure computation time\n * of the Voronoi algorithm, without any additional calculations such as\n * volume evaluation or cell output. */\nvoid container_poly::compute_all_cells() {\n\tvoronoicell c;\n\tc_loop_all vl(*this);\n\tif(vl.start()) do compute_cell(c,vl);while(vl.inc());\n}\n\n/** Calculates all of the Voronoi cells and sums their volumes. In most cases\n * without walls, the sum of the Voronoi cell volumes should equal the volume\n * of the container to numerical precision.\n * \\return The sum of all of the computed Voronoi volumes. */\ndouble container::sum_cell_volumes() {\n\tvoronoicell c;\n\tdouble vol=0;\n\tc_loop_all vl(*this);\n\tif(vl.start()) do if(compute_cell(c,vl)) vol+=c.volume();while(vl.inc());\n\treturn vol;\n}\n\n/** Calculates all of the Voronoi cells and sums their volumes. In most cases\n * without walls, the sum of the Voronoi cell volumes should equal the volume\n * of the container to numerical precision.\n * \\return The sum of all of the computed Voronoi volumes. */\ndouble container_poly::sum_cell_volumes() {\n\tvoronoicell c;\n\tdouble vol=0;\n\tc_loop_all vl(*this);\n\tif(vl.start()) do if(compute_cell(c,vl)) vol+=c.volume();while(vl.inc());\n\treturn vol;\n}\n\n/** This function tests to see if a given vector lies within the container\n * bounds and any walls.\n * \\param[in] (x,y,z) the position vector to be tested.\n * \\return True if the point is inside the container, false if the point is\n *         outside. */\nbool container_base::point_inside(double x,double y,double z) {\n\tif(x<ax||x>bx||y<ay||y>by||z<az||z>bz) return false;\n\treturn point_inside_walls(x,y,z);\n}\n\n/** Draws an outline of the domain in gnuplot format.\n * \\param[in] fp the file handle to write to. */\nvoid container_base::draw_domain_gnuplot(FILE *fp) {\n\tfprintf(fp,\"%g %g %g\\n%g %g %g\\n%g %g %g\\n%g %g %g\\n\",ax,ay,az,bx,ay,az,bx,by,az,ax,by,az);\n\tfprintf(fp,\"%g %g %g\\n%g %g %g\\n%g %g %g\\n%g %g %g\\n\",ax,by,bz,bx,by,bz,bx,ay,bz,ax,ay,bz);\n\tfprintf(fp,\"%g %g %g\\n\\n%g %g %g\\n%g %g %g\\n\\n\",ax,by,bz,ax,ay,az,ax,ay,bz);\n\tfprintf(fp,\"%g %g %g\\n%g %g %g\\n\\n%g %g %g\\n%g %g %g\\n\\n\",bx,ay,az,bx,ay,bz,bx,by,az,bx,by,bz);\n}\n\n/** Draws an outline of the domain in POV-Ray format.\n * \\param[in] fp the file handle to write to. */\nvoid container_base::draw_domain_pov(FILE *fp) {\n\tfprintf(fp,\"cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\\n\"\n\t\t   \"cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\\n\",ax,ay,az,bx,ay,az,ax,by,az,bx,by,az);\n\tfprintf(fp,\"cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\\n\"\n\t\t   \"cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\\n\",ax,by,bz,bx,by,bz,ax,ay,bz,bx,ay,bz);\n\tfprintf(fp,\"cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\\n\"\n\t\t   \"cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\\n\",ax,ay,az,ax,by,az,bx,ay,az,bx,by,az);\n\tfprintf(fp,\"cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\\n\"\n\t\t   \"cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\\n\",bx,ay,bz,bx,by,bz,ax,ay,bz,ax,by,bz);\n\tfprintf(fp,\"cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\\n\"\n\t\t   \"cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\\n\",ax,ay,az,ax,ay,bz,bx,ay,az,bx,ay,bz);\n\tfprintf(fp,\"cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\\n\"\n\t\t   \"cylinder{<%g,%g,%g>,<%g,%g,%g>,rr}\\n\",bx,by,az,bx,by,bz,ax,by,az,ax,by,bz);\n\tfprintf(fp,\"sphere{<%g,%g,%g>,rr}\\nsphere{<%g,%g,%g>,rr}\\n\"\n\t\t   \"sphere{<%g,%g,%g>,rr}\\nsphere{<%g,%g,%g>,rr}\\n\",ax,ay,az,bx,ay,az,ax,by,az,bx,by,az);\n\tfprintf(fp,\"sphere{<%g,%g,%g>,rr}\\nsphere{<%g,%g,%g>,rr}\\n\"\n\t\t   \"sphere{<%g,%g,%g>,rr}\\nsphere{<%g,%g,%g>,rr}\\n\",ax,ay,bz,bx,ay,bz,ax,by,bz,bx,by,bz);\n}\n\n\n/** The wall_list constructor sets up an array of pointers to wall classes. */\nwall_list::wall_list() : walls(new wall*[init_wall_size]), wep(walls), wel(walls+init_wall_size),\n\tcurrent_wall_size(init_wall_size) {}\n\n/** The wall_list destructor frees the array of pointers to the wall classes.\n */\nwall_list::~wall_list() {\n\tdelete [] walls;\n}\n\n/** Adds all of the walls on another wall_list to this class.\n * \\param[in] wl a reference to the wall class. */\nvoid wall_list::add_wall(wall_list &wl) {\n\tfor(wall **wp=wl.walls;wp<wl.wep;wp++) add_wall(*wp);\n}\n\n/** Deallocates all of the wall classes pointed to by the wall_list. */\nvoid wall_list::deallocate() {\n\tfor(wall **wp=walls;wp<wep;wp++) delete *wp;\n}\n\n/** Increases the memory allocation for the walls array. */\nvoid wall_list::increase_wall_memory() {\n\tcurrent_wall_size<<=1;\n\tif(current_wall_size>max_wall_size)\n\t\tvoro_fatal_error(\"Wall memory allocation exceeded absolute maximum\",VOROPP_MEMORY_ERROR);\n\twall **nwalls=new wall*[current_wall_size],**nwp=nwalls,**wp=walls;\n\twhile(wp<wep) *(nwp++)=*(wp++);\n\tdelete [] walls;\n\twalls=nwalls;wel=walls+current_wall_size;wep=nwp;\n}\n\n}\n","// Voro++, a 3D cell-based Voronoi library\n//\n// Author   : Chris H. Rycroft (LBL / UC Berkeley)\n// Email    : chr@alum.mit.edu\n// Date     : August 30th 2011\n\n/** \\file v_base.hh\n * \\brief Header file for the base Voronoi container class. */\n\n#ifndef VOROPP_V_BASE_HH\n#define VOROPP_V_BASE_HH\n\n#include \"worklist.hh\"\n\nnamespace voro {\n\n/** \\brief Class containing data structures common across all particle container classes.\n *\n * This class contains constants and data structures that are common across all\n * particle container classes. It contains constants setting the size of the\n * underlying subgrid of blocks that forms the basis of the Voronoi cell\n * computations. It also constructs bound tables that are used in the Voronoi\n * cell computation, and contains a number of routines that are common across\n * all container classes. */\nclass voro_base {\n\tpublic:\n\t\t/** The number of blocks in the x direction. */\n\t\tconst int nx;\n\t\t/** The number of blocks in the y direction. */\n\t\tconst int ny;\n\t\t/** The number of blocks in the z direction. */\n\t\tconst int nz;\n\t\t/** A constant, set to the value of nx multiplied by ny, which\n\t\t * is used in the routines that step through blocks in\n\t\t * sequence. */\n\t\tconst int nxy;\n\t\t/** A constant, set to the value of nx*ny*nz, which is used in\n\t\t * the routines that step through blocks in sequence. */\n\t\tconst int nxyz;\n\t\t/** The size of a computational block in the x direction. */\n\t\tconst double boxx;\n\t\t/** The size of a computational block in the y direction. */\n\t\tconst double boxy;\n\t\t/** The size of a computational block in the z direction. */\n\t\tconst double boxz;\n\t\t/** The inverse box length in the x direction. */\n\t\tconst double xsp;\n\t\t/** The inverse box length in the y direction. */\n\t\tconst double ysp;\n\t\t/** The inverse box length in the z direction. */\n\t\tconst double zsp;\n\t\t/** An array to hold the minimum distances associated with the\n\t\t * worklists. This array is initialized during container\n\t\t * construction, by the initialize_radii() routine. */\n\t\tdouble *mrad;\n\t\t/** The pre-computed block worklists. */\n\t\tstatic const unsigned int wl[wl_seq_length*wl_hgridcu];\n\t\tbool contains_neighbor(const char* format);\n\t\tvoro_base(int nx_,int ny_,int nz_,double boxx_,double boxy_,double boxz_);\n\t\t~voro_base() {delete [] mrad;}\n\tprotected:\n\t\t/** A custom int function that returns consistent stepping\n\t\t * for negative numbers, so that (-1.5, -0.5, 0.5, 1.5) maps\n\t\t * to (-2,-1,0,1).\n\t\t * \\param[in] a the number to consider.\n\t\t * \\return The value of the custom int operation. */\n\t\tinline int step_int(double a) {return a<0?int(a)-1:int(a);}\n\t\t/** A custom modulo function that returns consistent stepping\n\t\t * for negative numbers. For example, (-2,-1,0,1,2) step_mod 2\n\t\t * is (0,1,0,1,0).\n\t\t * \\param[in] (a,b) the input integers.\n\t\t * \\return The value of a modulo b, consistent for negative\n\t\t * numbers. */\n\t\tinline int step_mod(int a,int b) {return a>=0?a%b:b-1-(b-1-a)%b;}\n\t\t/** A custom integer division function that returns consistent\n\t\t * stepping for negative numbers. For example, (-2,-1,0,1,2)\n\t\t * step_div 2 is (-1,-1,0,0,1).\n\t\t * \\param[in] (a,b) the input integers.\n\t\t * \\return The value of a div b, consistent for negative\n\t\t * numbers. */\n\t\tinline int step_div(int a,int b) {return a>=0?a/b:-1+(a+1)/b;}\n\tprivate:\n\t\tvoid compute_minimum(double &minr,double &xlo,double &xhi,double &ylo,double &yhi,double &zlo,double &zhi,int ti,int tj,int tk);\n};\n\n}\n\n#endif\n","// Voro++, a 3D cell-based Voronoi library\n//\n// Author   : Chris H. Rycroft (LBL / UC Berkeley)\n// Email    : chr@alum.mit.edu\n// Date     : August 30th 2011\n\n/** \\file v_compute.cc\n * \\brief Function implementantions for the voro_compute template. */\n\n#include \"worklist.hh\"\n#include \"v_compute.hh\"\n#include \"rad_option.hh\"\n#include \"container.hh\"\n#include \"container_prd.hh\"\n\nnamespace voro {\n\n/** The class constructor initializes constants from the container class, and\n * sets up the mask and queue used for Voronoi computations.\n * \\param[in] con_ a reference to the container class to use.\n * \\param[in] (hx_,hy_,hz_) the size of the mask to use. */\ntemplate<class c_class>\nvoro_compute<c_class>::voro_compute(c_class &con_,int hx_,int hy_,int hz_) :\n\tcon(con_), boxx(con_.boxx), boxy(con_.boxy), boxz(con_.boxz),\n\txsp(con_.xsp), ysp(con_.ysp), zsp(con_.zsp),\n\thx(hx_), hy(hy_), hz(hz_), hxy(hx_*hy_), hxyz(hxy*hz_), ps(con_.ps),\n\tid(con_.id), p(con_.p), co(con_.co), bxsq(boxx*boxx+boxy*boxy+boxz*boxz),\n\tmv(0), qu_size(3*(3+hxy+hz*(hx+hy))), wl(con_.wl), mrad(con_.mrad),\n\tmask(new unsigned int[hxyz]), qu(new int[qu_size]), qu_l(qu+qu_size) {\n\treset_mask();\n}\n\n/** Scans all of the particles within a block to see if any of them have a\n * smaller distance to the given test vector. If one is found, the routine\n * updates the minimum distance and store information about this particle.\n * \\param[in] ijk the index of the block.\n * \\param[in] (x,y,z) the test vector to consider (which may have already had a\n *                    periodic displacement applied to it).\n * \\param[in] (di,dj,dk) the coordinates of the current block, to store if the\n *\t\t\t particle record is updated.\n * \\param[in,out] w a reference to a particle record in which to store\n *\t\t    information about the particle whose Voronoi cell the\n *\t\t    vector is within.\n * \\param[in,out] mrs the current minimum distance, that may be updated if a\n * \t\t      closer particle is found. */\ntemplate<class c_class>\ninline void voro_compute<c_class>::scan_all(int ijk,double x,double y,double z,int di,int dj,int dk,particle_record &w,double &mrs) {\n\tdouble x1,y1,z1,rs;bool in_block=false;\n\tfor(int l=0;l<co[ijk];l++) {\n\t\tx1=p[ijk][ps*l]-x;\n\t\ty1=p[ijk][ps*l+1]-y;\n\t\tz1=p[ijk][ps*l+2]-z;\n\t\trs=con.r_current_sub(x1*x1+y1*y1+z1*z1,ijk,l);\n\t\tif(rs<mrs) {mrs=rs;w.l=l;in_block=true;}\n\t}\n\tif(in_block) {w.ijk=ijk;w.di=di;w.dj=dj,w.dk=dk;}\n}\n\n/** Finds the Voronoi cell that given vector is within. For containers that are\n * not radially dependent, this corresponds to findig the particle that is\n * closest to the vector; for the radical tessellation containers, this\n * corresponds to a finding the minimum weighted distance.\n * \\param[in] (x,y,z) the vector to consider.\n * \\param[in] (ci,cj,ck) the coordinates of the block that the test particle is\n *                       in relative to the container data structure.\n * \\param[in] ijk the index of the block that the test particle is in.\n * \\param[out] w a reference to a particle record in which to store information\n * \t\t about the particle whose Voronoi cell the vector is within.\n * \\param[out] mrs the minimum computed distance. */\ntemplate<class c_class>\nvoid voro_compute<c_class>::find_voronoi_cell(double x,double y,double z,int ci,int cj,int ck,int ijk,particle_record &w,double &mrs) {\n\tdouble qx=0,qy=0,qz=0,rs;\n\tint i,j,k,di,dj,dk,ei,ej,ek,f,g,disp;\n\tdouble fx,fy,fz,mxs,mys,mzs,*radp;\n\tunsigned int q,*e,*mijk;\n\n\t// Init setup for parameters to return\n\tw.ijk=-1;mrs=large_number;\n\n\tcon.initialize_search(ci,cj,ck,ijk,i,j,k,disp);\n\n\t// Test all particles in the particle's local region first\n\tscan_all(ijk,x,y,z,0,0,0,w,mrs);\n\n\t// Now compute the fractional position of the particle within its\n\t// region and store it in (fx,fy,fz). We use this to compute an index\n\t// (di,dj,dk) of which subregion the particle is within.\n\tunsigned int m1,m2;\n\tcon.frac_pos(x,y,z,ci,cj,ck,fx,fy,fz);\n\tdi=int(fx*xsp*wl_fgrid);dj=int(fy*ysp*wl_fgrid);dk=int(fz*zsp*wl_fgrid);\n\n\t// The indices (di,dj,dk) tell us which worklist to use, to test the\n\t// blocks in the optimal order. But we only store worklists for the\n\t// eighth of the region where di, dj, and dk are all less than half the\n\t// full grid. The rest of the cases are handled by symmetry. In this\n\t// section, we detect for these cases, by reflecting high values of di,\n\t// dj, and dk. For these cases, a mask is constructed in m1 and m2\n\t// which is used to flip the worklist information when it is loaded.\n\tif(di>=wl_hgrid) {\n\t\tmxs=boxx-fx;\n\t\tm1=127+(3<<21);m2=1+(1<<21);di=wl_fgrid-1-di;if(di<0) di=0;\n\t} else {m1=m2=0;mxs=fx;}\n\tif(dj>=wl_hgrid) {\n\t\tmys=boxy-fy;\n\t\tm1|=(127<<7)+(3<<24);m2|=(1<<7)+(1<<24);dj=wl_fgrid-1-dj;if(dj<0) dj=0;\n\t} else mys=fy;\n\tif(dk>=wl_hgrid) {\n\t\tmzs=boxz-fz;\n\t\tm1|=(127<<14)+(3<<27);m2|=(1<<14)+(1<<27);dk=wl_fgrid-1-dk;if(dk<0) dk=0;\n\t} else mzs=fz;\n\n\t// Do a quick test to account for the case when the minimum radius is\n\t// small enought that no other blocks need to be considered\n\trs=con.r_max_add(mrs);\n\tif(mxs*mxs>rs&&mys*mys>rs&&mzs*mzs>rs) return;\n\n\t// Now compute which worklist we are going to use, and set radp and e to\n\t// point at the right offsets\n\tijk=di+wl_hgrid*(dj+wl_hgrid*dk);\n\tradp=mrad+ijk*wl_seq_length;\n\te=(const_cast<unsigned int*> (wl))+ijk*wl_seq_length;\n\n\t// Read in how many items in the worklist can be tested without having to\n\t// worry about writing to the mask\n\tf=e[0];g=0;\n\tdo {\n\n\t\t// If mrs is less than the minimum distance to any untested\n\t\t// block, then we are done\n\t\tif(con.r_max_add(mrs)<radp[g]) return;\n\t\tg++;\n\n\t\t// Load in a block off the worklist, permute it with the\n\t\t// symmetry mask, and decode its position. These are all\n\t\t// integer bit operations so they should run very fast.\n\t\tq=e[g];q^=m1;q+=m2;\n\t\tdi=q&127;di-=64;\n\t\tdj=(q>>7)&127;dj-=64;\n\t\tdk=(q>>14)&127;dk-=64;\n\n\t\t// Check that the worklist position is in range\n\t\tei=di+i;if(ei<0||ei>=hx) continue;\n\t\tej=dj+j;if(ej<0||ej>=hy) continue;\n\t\tek=dk+k;if(ek<0||ek>=hz) continue;\n\n\t\t// Call the compute_min_max_radius() function. This returns\n\t\t// true if the minimum distance to the block is bigger than the\n\t\t// current mrs, in which case we skip this block and move on.\n\t\t// Otherwise, it computes the maximum distance to the block and\n\t\t// returns it in crs.\n\t\tif(compute_min_radius(di,dj,dk,fx,fy,fz,mrs)) continue;\n\n\t\t// Now compute which region we are going to loop over, adding a\n\t\t// displacement for the periodic cases\n\t\tijk=con.region_index(ci,cj,ck,ei,ej,ek,qx,qy,qz,disp);\n\n\t\t// If mrs is bigger than the maximum distance to the block,\n\t\t// then we have to test all particles in the block for\n\t\t// intersections. Otherwise, we do additional checks and skip\n\t\t// those particles which can't possibly intersect the block.\n\t\tscan_all(ijk,x-qx,y-qy,z-qz,di,dj,dk,w,mrs);\n\t} while(g<f);\n\n\t// Update mask value and initialize queue\n\tmv++;\n\tif(mv==0) {reset_mask();mv=1;}\n\tint *qu_s=qu,*qu_e=qu;\n\n\twhile(g<wl_seq_length-1) {\n\n\t\t// If mrs is less than the minimum distance to any untested\n\t\t// block, then we are done\n\t\tif(con.r_max_add(mrs)<radp[g]) return;\n\t\tg++;\n\n\t\t// Load in a block off the worklist, permute it with the\n\t\t// symmetry mask, and decode its position. These are all\n\t\t// integer bit operations so they should run very fast.\n\t\tq=e[g];q^=m1;q+=m2;\n\t\tdi=q&127;di-=64;\n\t\tdj=(q>>7)&127;dj-=64;\n\t\tdk=(q>>14)&127;dk-=64;\n\n\t\t// Compute the position in the mask of the current block. If\n\t\t// this lies outside the mask, then skip it. Otherwise, mark\n\t\t// it.\n\t\tei=di+i;if(ei<0||ei>=hx) continue;\n\t\tej=dj+j;if(ej<0||ej>=hy) continue;\n\t\tek=dk+k;if(ek<0||ek>=hz) continue;\n\t\tmijk=mask+ei+hx*(ej+hy*ek);\n\t\t*mijk=mv;\n\n\t\t// Skip this block if it is further away than the current\n\t\t// minimum radius\n\t\tif(compute_min_radius(di,dj,dk,fx,fy,fz,mrs)) continue;\n\n\t\t// Now compute which region we are going to loop over, adding a\n\t\t// displacement for the periodic cases\n\t\tijk=con.region_index(ci,cj,ck,ei,ej,ek,qx,qy,qz,disp);\n\t\tscan_all(ijk,x-qx,y-qy,z-qz,di,dj,dk,w,mrs);\n\n\t\tif(qu_e>qu_l-18) add_list_memory(qu_s,qu_e);\n\t\tscan_bits_mask_add(q,mijk,ei,ej,ek,qu_e);\n\t}\n\n\t// Do a check to see if we've reached the radius cutoff\n\tif(con.r_max_add(mrs)<radp[g]) return;\n\n\t// We were unable to completely compute the cell based on the blocks in\n\t// the worklist, so now we have to go block by block, reading in items\n\t// off the list\n\twhile(qu_s!=qu_e) {\n\n\t\t// Read the next entry of the queue\n\t\tif(qu_s==qu_l) qu_s=qu;\n\t\tei=*(qu_s++);ej=*(qu_s++);ek=*(qu_s++);\n\t\tdi=ei-i;dj=ej-j;dk=ek-k;\n\t\tif(compute_min_radius(di,dj,dk,fx,fy,fz,mrs)) continue;\n\n\t\tijk=con.region_index(ci,cj,ck,ei,ej,ek,qx,qy,qz,disp);\n\t\tscan_all(ijk,x-qx,y-qy,z-qz,di,dj,dk,w,mrs);\n\n\t\t// Test the neighbors of the current block, and add them to the\n\t\t// block list if they haven't already been tested\n\t\tif((qu_s<=qu_e?(qu_l-qu_e)+(qu_s-qu):qu_s-qu_e)<18) add_list_memory(qu_s,qu_e);\n\t\tadd_to_mask(ei,ej,ek,qu_e);\n\t}\n}\n\n/** Scans the six orthogonal neighbors of a given block and adds them to the\n * queue if they haven't been considered already. It assumes that the queue\n * will definitely have enough memory to add six entries at the end.\n * \\param[in] (ei,ej,ek) the block to consider.\n * \\param[in,out] qu_e a pointer to the end of the queue. */\ntemplate<class c_class>\ninline void voro_compute<c_class>::add_to_mask(int ei,int ej,int ek,int *&qu_e) {\n\tunsigned int *mijk=mask+ei+hx*(ej+hy*ek);\n\tif(ek>0) if(*(mijk-hxy)!=mv) {if(qu_e==qu_l) qu_e=qu;*(mijk-hxy)=mv;*(qu_e++)=ei;*(qu_e++)=ej;*(qu_e++)=ek-1;}\n\tif(ej>0) if(*(mijk-hx)!=mv) {if(qu_e==qu_l) qu_e=qu;*(mijk-hx)=mv;*(qu_e++)=ei;*(qu_e++)=ej-1;*(qu_e++)=ek;}\n\tif(ei>0) if(*(mijk-1)!=mv) {if(qu_e==qu_l) qu_e=qu;*(mijk-1)=mv;*(qu_e++)=ei-1;*(qu_e++)=ej;*(qu_e++)=ek;}\n\tif(ei<hx-1) if(*(mijk+1)!=mv) {if(qu_e==qu_l) qu_e=qu;*(mijk+1)=mv;*(qu_e++)=ei+1;*(qu_e++)=ej;*(qu_e++)=ek;}\n\tif(ej<hy-1) if(*(mijk+hx)!=mv) {if(qu_e==qu_l) qu_e=qu;*(mijk+hx)=mv;*(qu_e++)=ei;*(qu_e++)=ej+1;*(qu_e++)=ek;}\n\tif(ek<hz-1) if(*(mijk+hxy)!=mv) {if(qu_e==qu_l) qu_e=qu;*(mijk+hxy)=mv;*(qu_e++)=ei;*(qu_e++)=ej;*(qu_e++)=ek+1;}\n}\n\n/** Scans a worklist entry and adds any blocks to the queue\n * \\param[in] (ei,ej,ek) the block to consider.\n * \\param[in,out] qu_e a pointer to the end of the queue. */\ntemplate<class c_class>\ninline void voro_compute<c_class>::scan_bits_mask_add(unsigned int q,unsigned int *mijk,int ei,int ej,int ek,int *&qu_e) {\n\tconst unsigned int b1=1<<21,b2=1<<22,b3=1<<24,b4=1<<25,b5=1<<27,b6=1<<28;\n\tif((q&b2)==b2) {\n\t\tif(ei>0) {*(mijk-1)=mv;*(qu_e++)=ei-1;*(qu_e++)=ej;*(qu_e++)=ek;}\n\t\tif((q&b1)==0&&ei<hx-1) {*(mijk+1)=mv;*(qu_e++)=ei+1;*(qu_e++)=ej;*(qu_e++)=ek;}\n\t} else if((q&b1)==b1&&ei<hx-1) {*(mijk+1)=mv;*(qu_e++)=ei+1;*(qu_e++)=ej;*(qu_e++)=ek;}\n\tif((q&b4)==b4) {\n\t\tif(ej>0) {*(mijk-hx)=mv;*(qu_e++)=ei;*(qu_e++)=ej-1;*(qu_e++)=ek;}\n\t\tif((q&b3)==0&&ej<hy-1) {*(mijk+hx)=mv;*(qu_e++)=ei;*(qu_e++)=ej+1;*(qu_e++)=ek;}\n\t} else if((q&b3)==b3&&ej<hy-1) {*(mijk+hx)=mv;*(qu_e++)=ei;*(qu_e++)=ej+1;*(qu_e++)=ek;}\n\tif((q&b6)==b6) {\n\t\tif(ek>0) {*(mijk-hxy)=mv;*(qu_e++)=ei;*(qu_e++)=ej;*(qu_e++)=ek-1;}\n\t\tif((q&b5)==0&&ek<hz-1) {*(mijk+hxy)=mv;*(qu_e++)=ei;*(qu_e++)=ej;*(qu_e++)=ek+1;}\n\t} else if((q&b5)==b5&&ek<hz-1) {*(mijk+hxy)=mv;*(qu_e++)=ei;*(qu_e++)=ej;*(qu_e++)=ek+1;}\n}\n\n/** This routine computes a Voronoi cell for a single particle in the\n * container. It can be called by the user, but is also forms the core part of\n * several of the main functions, such as store_cell_volumes(), print_all(),\n * and the drawing routines. The algorithm constructs the cell by testing over\n * the neighbors of the particle, working outwards until it reaches those\n * particles which could not possibly intersect the cell. For maximum\n * efficiency, this algorithm is divided into three parts. In the first\n * section, the algorithm tests over the blocks which are in the immediate\n * vicinity of the particle, by making use of one of the precomputed worklists.\n * The code then continues to test blocks on the worklist, but also begins to\n * construct a list of neighboring blocks outside the worklist which may need\n * to be test. In the third section, the routine starts testing these\n * neighboring blocks, evaluating whether or not a particle in them could\n * possibly intersect the cell. For blocks that intersect the cell, it tests\n * the particles in that block, and then adds the block neighbors to the list\n * of potential places to consider.\n * \\param[in,out] c a reference to a voronoicell object.\n * \\param[in] ijk the index of the block that the test particle is in.\n * \\param[in] s the index of the particle within the test block.\n * \\param[in] (ci,cj,ck) the coordinates of the block that the test particle is\n *                       in relative to the container data structure.\n * \\return False if the Voronoi cell was completely removed during the\n *         computation and has zero volume, true otherwise. */\ntemplate<class c_class>\ntemplate<class v_cell>\nbool voro_compute<c_class>::compute_cell(v_cell &c,int ijk,int s,int ci,int cj,int ck) {\n\tstatic const int count_list[8]={7,11,15,19,26,35,45,59},*count_e=count_list+8;\n\tdouble x,y,z,x1,y1,z1,qx=0,qy=0,qz=0;\n\tdouble xlo,ylo,zlo,xhi,yhi,zhi,x2,y2,z2,rs;\n\tint i,j,k,di,dj,dk,ei,ej,ek,f,g,l,disp;\n\tdouble fx,fy,fz,gxs,gys,gzs,*radp;\n\tunsigned int q,*e,*mijk;\n\n\tif(!con.initialize_voronoicell(c,ijk,s,ci,cj,ck,i,j,k,x,y,z,disp)) return false;\n\tcon.r_init(ijk,s);\n\n\t// Initialize the Voronoi cell to fill the entire container\n\tdouble crs,mrs;\n\n\tint next_count=3,*count_p=(const_cast<int*> (count_list));\n\n\t// Test all particles in the particle's local region first\n\tfor(l=0;l<s;l++) {\n\t\tx1=p[ijk][ps*l]-x;\n\t\ty1=p[ijk][ps*l+1]-y;\n\t\tz1=p[ijk][ps*l+2]-z;\n\t\trs=con.r_scale(x1*x1+y1*y1+z1*z1,ijk,l);\n\t\tif(!c.nplane(x1,y1,z1,rs,id[ijk][l])) return false;\n\t}\n\tl++;\n\twhile(l<co[ijk]) {\n\t\tx1=p[ijk][ps*l]-x;\n\t\ty1=p[ijk][ps*l+1]-y;\n\t\tz1=p[ijk][ps*l+2]-z;\n\t\trs=con.r_scale(x1*x1+y1*y1+z1*z1,ijk,l);\n\t\tif(!c.nplane(x1,y1,z1,rs,id[ijk][l])) return false;\n\t\tl++;\n\t}\n\n\t// Now compute the maximum distance squared from the cell center to a\n\t// vertex. This is used to cut off the calculation since we only need\n\t// to test out to twice this range.\n\tmrs=c.max_radius_squared();\n\n\t// Now compute the fractional position of the particle within its\n\t// region and store it in (fx,fy,fz). We use this to compute an index\n\t// (di,dj,dk) of which subregion the particle is within.\n\tunsigned int m1,m2;\n\tcon.frac_pos(x,y,z,ci,cj,ck,fx,fy,fz);\n\tdi=int(fx*xsp*wl_fgrid);dj=int(fy*ysp*wl_fgrid);dk=int(fz*zsp*wl_fgrid);\n\n\t// The indices (di,dj,dk) tell us which worklist to use, to test the\n\t// blocks in the optimal order. But we only store worklists for the\n\t// eighth of the region where di, dj, and dk are all less than half the\n\t// full grid. The rest of the cases are handled by symmetry. In this\n\t// section, we detect for these cases, by reflecting high values of di,\n\t// dj, and dk. For these cases, a mask is constructed in m1 and m2\n\t// which is used to flip the worklist information when it is loaded.\n\tif(di>=wl_hgrid) {\n\t\tgxs=fx;\n\t\tm1=127+(3<<21);m2=1+(1<<21);di=wl_fgrid-1-di;if(di<0) di=0;\n\t} else {m1=m2=0;gxs=boxx-fx;}\n\tif(dj>=wl_hgrid) {\n\t\tgys=fy;\n\t\tm1|=(127<<7)+(3<<24);m2|=(1<<7)+(1<<24);dj=wl_fgrid-1-dj;if(dj<0) dj=0;\n\t} else gys=boxy-fy;\n\tif(dk>=wl_hgrid) {\n\t\tgzs=fz;\n\t\tm1|=(127<<14)+(3<<27);m2|=(1<<14)+(1<<27);dk=wl_fgrid-1-dk;if(dk<0) dk=0;\n\t} else gzs=boxz-fz;\n\tgxs*=gxs;gys*=gys;gzs*=gzs;\n\n\t// Now compute which worklist we are going to use, and set radp and e to\n\t// point at the right offsets\n\tijk=di+wl_hgrid*(dj+wl_hgrid*dk);\n\tradp=mrad+ijk*wl_seq_length;\n\te=(const_cast<unsigned int*> (wl))+ijk*wl_seq_length;\n\n\t// Read in how many items in the worklist can be tested without having to\n\t// worry about writing to the mask\n\tf=e[0];g=0;\n\tdo {\n\n\t\t// At the intervals specified by count_list, we recompute the\n\t\t// maximum radius squared\n\t\tif(g==next_count) {\n\t\t\tmrs=c.max_radius_squared();\n\t\t\tif(count_p!=count_e) next_count=*(count_p++);\n\t\t}\n\n\t\t// If mrs is less than the minimum distance to any untested\n\t\t// block, then we are done\n\t\tif(con.r_ctest(radp[g],mrs)) return true;\n\t\tg++;\n\n\t\t// Load in a block off the worklist, permute it with the\n\t\t// symmetry mask, and decode its position. These are all\n\t\t// integer bit operations so they should run very fast.\n\t\tq=e[g];q^=m1;q+=m2;\n\t\tdi=q&127;di-=64;\n\t\tdj=(q>>7)&127;dj-=64;\n\t\tdk=(q>>14)&127;dk-=64;\n\n\t\t// Check that the worklist position is in range\n\t\tei=di+i;if(ei<0||ei>=hx) continue;\n\t\tej=dj+j;if(ej<0||ej>=hy) continue;\n\t\tek=dk+k;if(ek<0||ek>=hz) continue;\n\n\t\t// Call the compute_min_max_radius() function. This returns\n\t\t// true if the minimum distance to the block is bigger than the\n\t\t// current mrs, in which case we skip this block and move on.\n\t\t// Otherwise, it computes the maximum distance to the block and\n\t\t// returns it in crs.\n\t\tif(compute_min_max_radius(di,dj,dk,fx,fy,fz,gxs,gys,gzs,crs,mrs)) continue;\n\n\t\t// Now compute which region we are going to loop over, adding a\n\t\t// displacement for the periodic cases\n\t\tijk=con.region_index(ci,cj,ck,ei,ej,ek,qx,qy,qz,disp);\n\n\t\t// If mrs is bigger than the maximum distance to the block,\n\t\t// then we have to test all particles in the block for\n\t\t// intersections. Otherwise, we do additional checks and skip\n\t\t// those particles which can't possibly intersect the block.\n\t\tif(co[ijk]>0) {\n\t\t\tl=0;x2=x-qx;y2=y-qy;z2=z-qz;\n\t\t\tif(!con.r_ctest(crs,mrs)) {\n\t\t\t\tdo {\n\t\t\t\t\tx1=p[ijk][ps*l]-x2;\n\t\t\t\t\ty1=p[ijk][ps*l+1]-y2;\n\t\t\t\t\tz1=p[ijk][ps*l+2]-z2;\n\t\t\t\t\trs=con.r_scale(x1*x1+y1*y1+z1*z1,ijk,l);\n\t\t\t\t\tif(!c.nplane(x1,y1,z1,rs,id[ijk][l])) return false;\n\t\t\t\t\tl++;\n\t\t\t\t} while (l<co[ijk]);\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tx1=p[ijk][ps*l]-x2;\n\t\t\t\t\ty1=p[ijk][ps*l+1]-y2;\n\t\t\t\t\tz1=p[ijk][ps*l+2]-z2;\n\t\t\t\t\trs=x1*x1+y1*y1+z1*z1;\n\t\t\t\t\tif(con.r_scale_check(rs,mrs,ijk,l)&&!c.nplane(x1,y1,z1,rs,id[ijk][l])) return false;\n\t\t\t\t\tl++;\n\t\t\t\t} while (l<co[ijk]);\n\t\t\t}\n\t\t}\n\t} while(g<f);\n\n\t// If we reach here, we were unable to compute the entire cell using\n\t// the first part of the worklist. This section of the algorithm\n\t// continues the worklist, but it now starts preparing the mask that we\n\t// need if we end up going block by block. We do the same as before,\n\t// but we put a mark down on the mask for every block that's tested.\n\t// The worklist also contains information about which neighbors of each\n\t// block are not also on the worklist, and we start storing those\n\t// points in a list in case we have to go block by block. Update the\n\t// mask counter, and if it wraps around then reset the whole mask; that\n\t// will only happen once every 2^32 tries.\n\tmv++;\n\tif(mv==0) {reset_mask();mv=1;}\n\n\t// Set the queue pointers\n\tint *qu_s=qu,*qu_e=qu;\n\n\twhile(g<wl_seq_length-1) {\n\n\t\t// At the intervals specified by count_list, we recompute the\n\t\t// maximum radius squared\n\t\tif(g==next_count) {\n\t\t\tmrs=c.max_radius_squared();\n\t\t\tif(count_p!=count_e) next_count=*(count_p++);\n\t\t}\n\n\t\t// If mrs is less than the minimum distance to any untested\n\t\t// block, then we are done\n\t\tif(con.r_ctest(radp[g],mrs)) return true;\n\t\tg++;\n\n\t\t// Load in a block off the worklist, permute it with the\n\t\t// symmetry mask, and decode its position. These are all\n\t\t// integer bit operations so they should run very fast.\n\t\tq=e[g];q^=m1;q+=m2;\n\t\tdi=q&127;di-=64;\n\t\tdj=(q>>7)&127;dj-=64;\n\t\tdk=(q>>14)&127;dk-=64;\n\n\t\t// Compute the position in the mask of the current block. If\n\t\t// this lies outside the mask, then skip it. Otherwise, mark\n\t\t// it.\n\t\tei=di+i;if(ei<0||ei>=hx) continue;\n\t\tej=dj+j;if(ej<0||ej>=hy) continue;\n\t\tek=dk+k;if(ek<0||ek>=hz) continue;\n\t\tmijk=mask+ei+hx*(ej+hy*ek);\n\t\t*mijk=mv;\n\n\t\t// Call the compute_min_max_radius() function. This returns\n\t\t// true if the minimum distance to the block is bigger than the\n\t\t// current mrs, in which case we skip this block and move on.\n\t\t// Otherwise, it computes the maximum distance to the block and\n\t\t// returns it in crs.\n\t\tif(compute_min_max_radius(di,dj,dk,fx,fy,fz,gxs,gys,gzs,crs,mrs)) continue;\n\n\t\t// Now compute which region we are going to loop over, adding a\n\t\t// displacement for the periodic cases\n\t\tijk=con.region_index(ci,cj,ck,ei,ej,ek,qx,qy,qz,disp);\n\n\t\t// If mrs is bigger than the maximum distance to the block,\n\t\t// then we have to test all particles in the block for\n\t\t// intersections. Otherwise, we do additional checks and skip\n\t\t// those particles which can't possibly intersect the block.\n\t\tif(co[ijk]>0) {\n\t\t\tl=0;x2=x-qx;y2=y-qy;z2=z-qz;\n\t\t\tif(!con.r_ctest(crs,mrs)) {\n\t\t\t\tdo {\n\t\t\t\t\tx1=p[ijk][ps*l]-x2;\n\t\t\t\t\ty1=p[ijk][ps*l+1]-y2;\n\t\t\t\t\tz1=p[ijk][ps*l+2]-z2;\n\t\t\t\t\trs=con.r_scale(x1*x1+y1*y1+z1*z1,ijk,l);\n\t\t\t\t\tif(!c.nplane(x1,y1,z1,rs,id[ijk][l])) return false;\n\t\t\t\t\tl++;\n\t\t\t\t} while (l<co[ijk]);\n\t\t\t} else {\n\t\t\t\tdo {\n\t\t\t\t\tx1=p[ijk][ps*l]-x2;\n\t\t\t\t\ty1=p[ijk][ps*l+1]-y2;\n\t\t\t\t\tz1=p[ijk][ps*l+2]-z2;\n\t\t\t\t\trs=x1*x1+y1*y1+z1*z1;\n\t\t\t\t\tif(con.r_scale_check(rs,mrs,ijk,l)&&!c.nplane(x1,y1,z1,rs,id[ijk][l])) return false;\n\t\t\t\t\tl++;\n\t\t\t\t} while (l<co[ijk]);\n\t\t\t}\n\t\t}\n\n\t\t// If there might not be enough memory on the list for these\n\t\t// additions, then add more\n\t\tif(qu_e>qu_l-18) add_list_memory(qu_s,qu_e);\n\n\t\t// Test the parts of the worklist element which tell us what\n\t\t// neighbors of this block are not on the worklist. Store them\n\t\t// on the block list, and mark the mask.\n\t\tscan_bits_mask_add(q,mijk,ei,ej,ek,qu_e);\n\t}\n\n\t// Do a check to see if we've reached the radius cutoff\n\tif(con.r_ctest(radp[g],mrs)) return true;\n\n\t// We were unable to completely compute the cell based on the blocks in\n\t// the worklist, so now we have to go block by block, reading in items\n\t// off the list\n\twhile(qu_s!=qu_e) {\n\n\t\t// If we reached the end of the list memory loop back to the\n\t\t// start\n\t\tif(qu_s==qu_l) qu_s=qu;\n\n\t\t// Read in a block off the list, and compute the upper and lower\n\t\t// coordinates in each of the three dimensions\n\t\tei=*(qu_s++);ej=*(qu_s++);ek=*(qu_s++);\n\t\txlo=(ei-i)*boxx-fx;xhi=xlo+boxx;\n\t\tylo=(ej-j)*boxy-fy;yhi=ylo+boxy;\n\t\tzlo=(ek-k)*boxz-fz;zhi=zlo+boxz;\n\n\t\t// Carry out plane tests to see if any particle in this block\n\t\t// could possibly intersect the cell\n\t\tif(ei>i) {\n\t\t\tif(ej>j) {\n\t\t\t\tif(ek>k) {if(corner_test(c,xlo,ylo,zlo,xhi,yhi,zhi)) continue;}\n\t\t\t\telse if(ek<k) {if(corner_test(c,xlo,ylo,zhi,xhi,yhi,zlo)) continue;}\n\t\t\t\telse {if(edge_z_test(c,xlo,ylo,zlo,xhi,yhi,zhi)) continue;}\n\t\t\t} else if(ej<j) {\n\t\t\t\tif(ek>k) {if(corner_test(c,xlo,yhi,zlo,xhi,ylo,zhi)) continue;}\n\t\t\t\telse if(ek<k) {if(corner_test(c,xlo,yhi,zhi,xhi,ylo,zlo)) continue;}\n\t\t\t\telse {if(edge_z_test(c,xlo,yhi,zlo,xhi,ylo,zhi)) continue;}\n\t\t\t} else {\n\t\t\t\tif(ek>k) {if(edge_y_test(c,xlo,ylo,zlo,xhi,yhi,zhi)) continue;}\n\t\t\t\telse if(ek<k) {if(edge_y_test(c,xlo,ylo,zhi,xhi,yhi,zlo)) continue;}\n\t\t\t\telse {if(face_x_test(c,xlo,ylo,zlo,yhi,zhi)) continue;}\n\t\t\t}\n\t\t} else if(ei<i) {\n\t\t\tif(ej>j) {\n\t\t\t\tif(ek>k) {if(corner_test(c,xhi,ylo,zlo,xlo,yhi,zhi)) continue;}\n\t\t\t\telse if(ek<k) {if(corner_test(c,xhi,ylo,zhi,xlo,yhi,zlo)) continue;}\n\t\t\t\telse {if(edge_z_test(c,xhi,ylo,zlo,xlo,yhi,zhi)) continue;}\n\t\t\t} else if(ej<j) {\n\t\t\t\tif(ek>k) {if(corner_test(c,xhi,yhi,zlo,xlo,ylo,zhi)) continue;}\n\t\t\t\telse if(ek<k) {if(corner_test(c,xhi,yhi,zhi,xlo,ylo,zlo)) continue;}\n\t\t\t\telse {if(edge_z_test(c,xhi,yhi,zlo,xlo,ylo,zhi)) continue;}\n\t\t\t} else {\n\t\t\t\tif(ek>k) {if(edge_y_test(c,xhi,ylo,zlo,xlo,yhi,zhi)) continue;}\n\t\t\t\telse if(ek<k) {if(edge_y_test(c,xhi,ylo,zhi,xlo,yhi,zlo)) continue;}\n\t\t\t\telse {if(face_x_test(c,xhi,ylo,zlo,yhi,zhi)) continue;}\n\t\t\t}\n\t\t} else {\n\t\t\tif(ej>j) {\n\t\t\t\tif(ek>k) {if(edge_x_test(c,xlo,ylo,zlo,xhi,yhi,zhi)) continue;}\n\t\t\t\telse if(ek<k) {if(edge_x_test(c,xlo,ylo,zhi,xhi,yhi,zlo)) continue;}\n\t\t\t\telse {if(face_y_test(c,xlo,ylo,zlo,xhi,zhi)) continue;}\n\t\t\t} else if(ej<j) {\n\t\t\t\tif(ek>k) {if(edge_x_test(c,xlo,yhi,zlo,xhi,ylo,zhi)) continue;}\n\t\t\t\telse if(ek<k) {if(edge_x_test(c,xlo,yhi,zhi,xhi,ylo,zlo)) continue;}\n\t\t\t\telse {if(face_y_test(c,xlo,yhi,zlo,xhi,zhi)) continue;}\n\t\t\t} else {\n\t\t\t\tif(ek>k) {if(face_z_test(c,xlo,ylo,zlo,xhi,yhi)) continue;}\n\t\t\t\telse if(ek<k) {if(face_z_test(c,xlo,ylo,zhi,xhi,yhi)) continue;}\n\t\t\t\telse voro_fatal_error(\"Compute cell routine revisiting central block, which should never\\nhappen.\",VOROPP_INTERNAL_ERROR);\n\t\t\t}\n\t\t}\n\n\t\t// Now compute the region that we are going to test over, and\n\t\t// set a displacement vector for the periodic cases\n\t\tijk=con.region_index(ci,cj,ck,ei,ej,ek,qx,qy,qz,disp);\n\n\t\t// Loop over all the elements in the block to test for cuts. It\n\t\t// would be possible to exclude some of these cases by testing\n\t\t// against mrs, but this will probably not save time.\n\t\tif(co[ijk]>0) {\n\t\t\tl=0;x2=x-qx;y2=y-qy;z2=z-qz;\n\t\t\tdo {\n\t\t\t\tx1=p[ijk][ps*l]-x2;\n\t\t\t\ty1=p[ijk][ps*l+1]-y2;\n\t\t\t\tz1=p[ijk][ps*l+2]-z2;\n\t\t\t\trs=con.r_scale(x1*x1+y1*y1+z1*z1,ijk,l);\n\t\t\t\tif(!c.nplane(x1,y1,z1,rs,id[ijk][l])) return false;\n\t\t\t\tl++;\n\t\t\t} while (l<co[ijk]);\n\t\t}\n\n\t\t// If there's not much memory on the block list then add more\n\t\tif((qu_s<=qu_e?(qu_l-qu_e)+(qu_s-qu):qu_s-qu_e)<18) add_list_memory(qu_s,qu_e);\n\n\t\t// Test the neighbors of the current block, and add them to the\n\t\t// block list if they haven't already been tested\n\t\tadd_to_mask(ei,ej,ek,qu_e);\n\t}\n\n\treturn true;\n}\n\n/** This function checks to see whether a particular block can possibly have\n * any intersection with a Voronoi cell, for the case when the closest point\n * from the cell center to the block is at a corner.\n * \\param[in,out] c a reference to a Voronoi cell.\n * \\param[in] (xl,yl,zl) the relative coordinates of the corner of the block\n *                       closest to the cell center.\n * \\param[in] (xh,yh,zh) the relative coordinates of the corner of the block\n *                       furthest away from the cell center.\n * \\return False if the block may intersect, true if does not. */\ntemplate<class c_class>\ntemplate<class v_cell>\nbool voro_compute<c_class>::corner_test(v_cell &c,double xl,double yl,double zl,double xh,double yh,double zh) {\n\tcon.r_prime(xl*xl+yl*yl+zl*zl);\n\tif(c.plane_intersects_guess(xh,yl,zl,con.r_cutoff(xl*xh+yl*yl+zl*zl))) return false;\n\tif(c.plane_intersects(xh,yh,zl,con.r_cutoff(xl*xh+yl*yh+zl*zl))) return false;\n\tif(c.plane_intersects(xl,yh,zl,con.r_cutoff(xl*xl+yl*yh+zl*zl))) return false;\n\tif(c.plane_intersects(xl,yh,zh,con.r_cutoff(xl*xl+yl*yh+zl*zh))) return false;\n\tif(c.plane_intersects(xl,yl,zh,con.r_cutoff(xl*xl+yl*yl+zl*zh))) return false;\n\tif(c.plane_intersects(xh,yl,zh,con.r_cutoff(xl*xh+yl*yl+zl*zh))) return false;\n\treturn true;\n}\n\n/** This function checks to see whether a particular block can possibly have\n * any intersection with a Voronoi cell, for the case when the closest point\n * from the cell center to the block is on an edge which points along the x\n * direction.\n * \\param[in,out] c a reference to a Voronoi cell.\n * \\param[in] (x0,x1) the minimum and maximum relative x coordinates of the\n *                    block.\n * \\param[in] (yl,zl) the relative y and z coordinates of the corner of the\n *                    block closest to the cell center.\n * \\param[in] (yh,zh) the relative y and z coordinates of the corner of the\n *                    block furthest away from the cell center.\n * \\return False if the block may intersect, true if does not. */\ntemplate<class c_class>\ntemplate<class v_cell>\ninline bool voro_compute<c_class>::edge_x_test(v_cell &c,double x0,double yl,double zl,double x1,double yh,double zh) {\n\tcon.r_prime(yl*yl+zl*zl);\n\tif(c.plane_intersects_guess(x0,yl,zh,con.r_cutoff(yl*yl+zl*zh))) return false;\n\tif(c.plane_intersects(x1,yl,zh,con.r_cutoff(yl*yl+zl*zh))) return false;\n\tif(c.plane_intersects(x1,yl,zl,con.r_cutoff(yl*yl+zl*zl))) return false;\n\tif(c.plane_intersects(x0,yl,zl,con.r_cutoff(yl*yl+zl*zl))) return false;\n\tif(c.plane_intersects(x0,yh,zl,con.r_cutoff(yl*yh+zl*zl))) return false;\n\tif(c.plane_intersects(x1,yh,zl,con.r_cutoff(yl*yh+zl*zl))) return false;\n\treturn true;\n}\n\n/** This function checks to see whether a particular block can possibly have\n * any intersection with a Voronoi cell, for the case when the closest point\n * from the cell center to the block is on an edge which points along the y\n * direction.\n * \\param[in,out] c a reference to a Voronoi cell.\n * \\param[in] (y0,y1) the minimum and maximum relative y coordinates of the\n *                    block.\n * \\param[in] (xl,zl) the relative x and z coordinates of the corner of the\n *                    block closest to the cell center.\n * \\param[in] (xh,zh) the relative x and z coordinates of the corner of the\n *                    block furthest away from the cell center.\n * \\return False if the block may intersect, true if does not. */\ntemplate<class c_class>\ntemplate<class v_cell>\ninline bool voro_compute<c_class>::edge_y_test(v_cell &c,double xl,double y0,double zl,double xh,double y1,double zh) {\n\tcon.r_prime(xl*xl+zl*zl);\n\tif(c.plane_intersects_guess(xl,y0,zh,con.r_cutoff(xl*xl+zl*zh))) return false;\n\tif(c.plane_intersects(xl,y1,zh,con.r_cutoff(xl*xl+zl*zh))) return false;\n\tif(c.plane_intersects(xl,y1,zl,con.r_cutoff(xl*xl+zl*zl))) return false;\n\tif(c.plane_intersects(xl,y0,zl,con.r_cutoff(xl*xl+zl*zl))) return false;\n\tif(c.plane_intersects(xh,y0,zl,con.r_cutoff(xl*xh+zl*zl))) return false;\n\tif(c.plane_intersects(xh,y1,zl,con.r_cutoff(xl*xh+zl*zl))) return false;\n\treturn true;\n}\n\n/** This function checks to see whether a particular block can possibly have\n * any intersection with a Voronoi cell, for the case when the closest point\n * from the cell center to the block is on an edge which points along the z\n * direction.\n * \\param[in,out] c a reference to a Voronoi cell.\n * \\param[in] (z0,z1) the minimum and maximum relative z coordinates of the block.\n * \\param[in] (xl,yl) the relative x and y coordinates of the corner of the\n *                    block closest to the cell center.\n * \\param[in] (xh,yh) the relative x and y coordinates of the corner of the\n *                    block furthest away from the cell center.\n * \\return False if the block may intersect, true if does not. */\ntemplate<class c_class>\ntemplate<class v_cell>\ninline bool voro_compute<c_class>::edge_z_test(v_cell &c,double xl,double yl,double z0,double xh,double yh,double z1) {\n\tcon.r_prime(xl*xl+yl*yl);\n\tif(c.plane_intersects_guess(xl,yh,z0,con.r_cutoff(xl*xl+yl*yh))) return false;\n\tif(c.plane_intersects(xl,yh,z1,con.r_cutoff(xl*xl+yl*yh))) return false;\n\tif(c.plane_intersects(xl,yl,z1,con.r_cutoff(xl*xl+yl*yl))) return false;\n\tif(c.plane_intersects(xl,yl,z0,con.r_cutoff(xl*xl+yl*yl))) return false;\n\tif(c.plane_intersects(xh,yl,z0,con.r_cutoff(xl*xh+yl*yl))) return false;\n\tif(c.plane_intersects(xh,yl,z1,con.r_cutoff(xl*xh+yl*yl))) return false;\n\treturn true;\n}\n\n/** This function checks to see whether a particular block can possibly have\n * any intersection with a Voronoi cell, for the case when the closest point\n * from the cell center to the block is on a face aligned with the x direction.\n * \\param[in,out] c a reference to a Voronoi cell.\n * \\param[in] xl the minimum distance from the cell center to the face.\n * \\param[in] (y0,y1) the minimum and maximum relative y coordinates of the\n *                    block.\n * \\param[in] (z0,z1) the minimum and maximum relative z coordinates of the\n *                    block.\n * \\return False if the block may intersect, true if does not. */\ntemplate<class c_class>\ntemplate<class v_cell>\ninline bool voro_compute<c_class>::face_x_test(v_cell &c,double xl,double y0,double z0,double y1,double z1) {\n\tcon.r_prime(xl*xl);\n\tif(c.plane_intersects_guess(xl,y0,z0,con.r_cutoff(xl*xl))) return false;\n\tif(c.plane_intersects(xl,y0,z1,con.r_cutoff(xl*xl))) return false;\n\tif(c.plane_intersects(xl,y1,z1,con.r_cutoff(xl*xl))) return false;\n\tif(c.plane_intersects(xl,y1,z0,con.r_cutoff(xl*xl))) return false;\n\treturn true;\n}\n\n/** This function checks to see whether a particular block can possibly have\n * any intersection with a Voronoi cell, for the case when the closest point\n * from the cell center to the block is on a face aligned with the y direction.\n * \\param[in,out] c a reference to a Voronoi cell.\n * \\param[in] yl the minimum distance from the cell center to the face.\n * \\param[in] (x0,x1) the minimum and maximum relative x coordinates of the\n *                    block.\n * \\param[in] (z0,z1) the minimum and maximum relative z coordinates of the\n *                    block.\n * \\return False if the block may intersect, true if does not. */\ntemplate<class c_class>\ntemplate<class v_cell>\ninline bool voro_compute<c_class>::face_y_test(v_cell &c,double x0,double yl,double z0,double x1,double z1) {\n\tcon.r_prime(yl*yl);\n\tif(c.plane_intersects_guess(x0,yl,z0,con.r_cutoff(yl*yl))) return false;\n\tif(c.plane_intersects(x0,yl,z1,con.r_cutoff(yl*yl))) return false;\n\tif(c.plane_intersects(x1,yl,z1,con.r_cutoff(yl*yl))) return false;\n\tif(c.plane_intersects(x1,yl,z0,con.r_cutoff(yl*yl))) return false;\n\treturn true;\n}\n\n/** This function checks to see whether a particular block can possibly have\n * any intersection with a Voronoi cell, for the case when the closest point\n * from the cell center to the block is on a face aligned with the z direction.\n * \\param[in,out] c a reference to a Voronoi cell.\n * \\param[in] zl the minimum distance from the cell center to the face.\n * \\param[in] (x0,x1) the minimum and maximum relative x coordinates of the\n *                    block.\n * \\param[in] (y0,y1) the minimum and maximum relative y coordinates of the\n *                    block.\n * \\return False if the block may intersect, true if does not. */\ntemplate<class c_class>\ntemplate<class v_cell>\ninline bool voro_compute<c_class>::face_z_test(v_cell &c,double x0,double y0,double zl,double x1,double y1) {\n\tcon.r_prime(zl*zl);\n\tif(c.plane_intersects_guess(x0,y0,zl,con.r_cutoff(zl*zl))) return false;\n\tif(c.plane_intersects(x0,y1,zl,con.r_cutoff(zl*zl))) return false;\n\tif(c.plane_intersects(x1,y1,zl,con.r_cutoff(zl*zl))) return false;\n\tif(c.plane_intersects(x1,y0,zl,con.r_cutoff(zl*zl))) return false;\n\treturn true;\n}\n\n\n/** This routine checks to see whether a point is within a particular distance\n * of a nearby region. If the point is within the distance of the region, then\n * the routine returns true, and computes the maximum distance from the point\n * to the region. Otherwise, the routine returns false.\n * \\param[in] (di,dj,dk) the position of the nearby region to be tested,\n *                       relative to the region that the point is in.\n * \\param[in] (fx,fy,fz) the displacement of the point within its region.\n * \\param[in] (gxs,gys,gzs) the maximum squared distances from the point to the\n *                          sides of its region.\n * \\param[out] crs a reference in which to return the maximum distance to the\n *                 region (only computed if the routine returns false).\n * \\param[in] mrs the distance to be tested.\n * \\return True if the region is further away than mrs, false if the region in\n *         within mrs. */\ntemplate<class c_class>\nbool voro_compute<c_class>::compute_min_max_radius(int di,int dj,int dk,double fx,double fy,double fz,double gxs,double gys,double gzs,double &crs,double mrs) {\n\tdouble xlo,ylo,zlo;\n\tif(di>0) {\n\t\txlo=di*boxx-fx;\n\t\tcrs=xlo*xlo;\n\t\tif(dj>0) {\n\t\t\tylo=dj*boxy-fy;\n\t\t\tcrs+=ylo*ylo;\n\t\t\tif(dk>0) {\n\t\t\t\tzlo=dk*boxz-fz;\n\t\t\t\tcrs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;\n\t\t\t\tcrs+=bxsq+2*(boxx*xlo+boxy*ylo+boxz*zlo);\n\t\t\t} else if(dk<0) {\n\t\t\t\tzlo=(dk+1)*boxz-fz;\n\t\t\t\tcrs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;\n\t\t\t\tcrs+=bxsq+2*(boxx*xlo+boxy*ylo-boxz*zlo);\n\t\t\t} else {\n\t\t\t\tif(con.r_ctest(crs,mrs)) return true;\n\t\t\t\tcrs+=boxx*(2*xlo+boxx)+boxy*(2*ylo+boxy)+gzs;\n\t\t\t}\n\t\t} else if(dj<0) {\n\t\t\tylo=(dj+1)*boxy-fy;\n\t\t\tcrs+=ylo*ylo;\n\t\t\tif(dk>0) {\n\t\t\t\tzlo=dk*boxz-fz;\n\t\t\t\tcrs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;\n\t\t\t\tcrs+=bxsq+2*(boxx*xlo-boxy*ylo+boxz*zlo);\n\t\t\t} else if(dk<0) {\n\t\t\t\tzlo=(dk+1)*boxz-fz;\n\t\t\t\tcrs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;\n\t\t\t\tcrs+=bxsq+2*(boxx*xlo-boxy*ylo-boxz*zlo);\n\t\t\t} else {\n\t\t\t\tif(con.r_ctest(crs,mrs)) return true;\n\t\t\t\tcrs+=boxx*(2*xlo+boxx)+boxy*(-2*ylo+boxy)+gzs;\n\t\t\t}\n\t\t} else {\n\t\t\tif(dk>0) {\n\t\t\t\tzlo=dk*boxz-fz;\n\t\t\t\tcrs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;\n\t\t\t\tcrs+=boxz*(2*zlo+boxz);\n\t\t\t} else if(dk<0) {\n\t\t\t\tzlo=(dk+1)*boxz-fz;\n\t\t\t\tcrs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;\n\t\t\t\tcrs+=boxz*(-2*zlo+boxz);\n\t\t\t} else {\n\t\t\t\tif(con.r_ctest(crs,mrs)) return true;\n\t\t\t\tcrs+=gzs;\n\t\t\t}\n\t\t\tcrs+=gys+boxx*(2*xlo+boxx);\n\t\t}\n\t} else if(di<0) {\n\t\txlo=(di+1)*boxx-fx;\n\t\tcrs=xlo*xlo;\n\t\tif(dj>0) {\n\t\t\tylo=dj*boxy-fy;\n\t\t\tcrs+=ylo*ylo;\n\t\t\tif(dk>0) {\n\t\t\t\tzlo=dk*boxz-fz;\n\t\t\t\tcrs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;\n\t\t\t\tcrs+=bxsq+2*(-boxx*xlo+boxy*ylo+boxz*zlo);\n\t\t\t} else if(dk<0) {\n\t\t\t\tzlo=(dk+1)*boxz-fz;\n\t\t\t\tcrs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;\n\t\t\t\tcrs+=bxsq+2*(-boxx*xlo+boxy*ylo-boxz*zlo);\n\t\t\t} else {\n\t\t\t\tif(con.r_ctest(crs,mrs)) return true;\n\t\t\t\tcrs+=boxx*(-2*xlo+boxx)+boxy*(2*ylo+boxy)+gzs;\n\t\t\t}\n\t\t} else if(dj<0) {\n\t\t\tylo=(dj+1)*boxy-fy;\n\t\t\tcrs+=ylo*ylo;\n\t\t\tif(dk>0) {\n\t\t\t\tzlo=dk*boxz-fz;\n\t\t\t\tcrs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;\n\t\t\t\tcrs+=bxsq+2*(-boxx*xlo-boxy*ylo+boxz*zlo);\n\t\t\t} else if(dk<0) {\n\t\t\t\tzlo=(dk+1)*boxz-fz;\n\t\t\t\tcrs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;\n\t\t\t\tcrs+=bxsq+2*(-boxx*xlo-boxy*ylo-boxz*zlo);\n\t\t\t} else {\n\t\t\t\tif(con.r_ctest(crs,mrs)) return true;\n\t\t\t\tcrs+=boxx*(-2*xlo+boxx)+boxy*(-2*ylo+boxy)+gzs;\n\t\t\t}\n\t\t} else {\n\t\t\tif(dk>0) {\n\t\t\t\tzlo=dk*boxz-fz;\n\t\t\t\tcrs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;\n\t\t\t\tcrs+=boxz*(2*zlo+boxz);\n\t\t\t} else if(dk<0) {\n\t\t\t\tzlo=(dk+1)*boxz-fz;\n\t\t\t\tcrs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;\n\t\t\t\tcrs+=boxz*(-2*zlo+boxz);\n\t\t\t} else {\n\t\t\t\tif(con.r_ctest(crs,mrs)) return true;\n\t\t\t\tcrs+=gzs;\n\t\t\t}\n\t\t\tcrs+=gys+boxx*(-2*xlo+boxx);\n\t\t}\n\t} else {\n\t\tif(dj>0) {\n\t\t\tylo=dj*boxy-fy;\n\t\t\tcrs=ylo*ylo;\n\t\t\tif(dk>0) {\n\t\t\t\tzlo=dk*boxz-fz;\n\t\t\t\tcrs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;\n\t\t\t\tcrs+=boxz*(2*zlo+boxz);\n\t\t\t} else if(dk<0) {\n\t\t\t\tzlo=(dk+1)*boxz-fz;\n\t\t\t\tcrs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;\n\t\t\t\tcrs+=boxz*(-2*zlo+boxz);\n\t\t\t} else {\n\t\t\t\tif(con.r_ctest(crs,mrs)) return true;\n\t\t\t\tcrs+=gzs;\n\t\t\t}\n\t\t\tcrs+=boxy*(2*ylo+boxy);\n\t\t} else if(dj<0) {\n\t\t\tylo=(dj+1)*boxy-fy;\n\t\t\tcrs=ylo*ylo;\n\t\t\tif(dk>0) {\n\t\t\t\tzlo=dk*boxz-fz;\n\t\t\t\tcrs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;\n\t\t\t\tcrs+=boxz*(2*zlo+boxz);\n\t\t\t} else if(dk<0) {\n\t\t\t\tzlo=(dk+1)*boxz-fz;\n\t\t\t\tcrs+=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;\n\t\t\t\tcrs+=boxz*(-2*zlo+boxz);\n\t\t\t} else {\n\t\t\t\tif(con.r_ctest(crs,mrs)) return true;\n\t\t\t\tcrs+=gzs;\n\t\t\t}\n\t\t\tcrs+=boxy*(-2*ylo+boxy);\n\t\t} else {\n\t\t\tif(dk>0) {\n\t\t\t\tzlo=dk*boxz-fz;crs=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;\n\t\t\t\tcrs+=boxz*(2*zlo+boxz);\n\t\t\t} else if(dk<0) {\n\t\t\t\tzlo=(dk+1)*boxz-fz;crs=zlo*zlo;if(con.r_ctest(crs,mrs)) return true;\n\t\t\t\tcrs+=boxz*(-2*zlo+boxz);\n\t\t\t} else {\n\t\t\t\tcrs=0;\n\t\t\t\tvoro_fatal_error(\"Min/max radius function called for central block, which should never\\nhappen.\",VOROPP_INTERNAL_ERROR);\n\t\t\t}\n\t\t\tcrs+=gys;\n\t\t}\n\t\tcrs+=gxs;\n\t}\n\treturn false;\n}\n\ntemplate<class c_class>\nbool voro_compute<c_class>::compute_min_radius(int di,int dj,int dk,double fx,double fy,double fz,double mrs) {\n\tdouble t,crs;\n\n\tif(di>0) {t=di*boxx-fx;crs=t*t;}\n\telse if(di<0) {t=(di+1)*boxx-fx;crs=t*t;}\n\telse crs=0;\n\n\tif(dj>0) {t=dj*boxy-fy;crs+=t*t;}\n\telse if(dj<0) {t=(dj+1)*boxy-fy;crs+=t*t;}\n\n\tif(dk>0) {t=dk*boxz-fz;crs+=t*t;}\n\telse if(dk<0) {t=(dk+1)*boxz-fz;crs+=t*t;}\n\n\treturn crs>con.r_max_add(mrs);\n}\n\n/** Adds memory to the queue.\n * \\param[in,out] qu_s a reference to the queue start pointer.\n * \\param[in,out] qu_e a reference to the queue end pointer. */\ntemplate<class c_class>\ninline void voro_compute<c_class>::add_list_memory(int*& qu_s,int*& qu_e) {\n\tqu_size<<=1;\n\tint *qu_n=new int[qu_size],*qu_c=qu_n;\n#if VOROPP_VERBOSE >=2\n\tfprintf(stderr,\"List memory scaled up to %d\\n\",qu_size);\n#endif\n\tif(qu_s<=qu_e) {\n\t\twhile(qu_s<qu_e) *(qu_c++)=*(qu_s++);\n\t} else {\n\t\twhile(qu_s<qu_l) *(qu_c++)=*(qu_s++);qu_s=qu;\n\t\twhile(qu_s<qu_e) *(qu_c++)=*(qu_s++);\n\t}\n\tdelete [] qu;\n\tqu_s=qu=qu_n;\n\tqu_l=qu+qu_size;\n\tqu_e=qu_c;\n}\n\n// Explicit template instantiation\ntemplate voro_compute<container>::voro_compute(container&,int,int,int);\ntemplate voro_compute<container_poly>::voro_compute(container_poly&,int,int,int);\ntemplate bool voro_compute<container>::compute_cell(voronoicell&,int,int,int,int,int);\ntemplate bool voro_compute<container>::compute_cell(voronoicell_neighbor&,int,int,int,int,int);\ntemplate void voro_compute<container>::find_voronoi_cell(double,double,double,int,int,int,int,particle_record&,double&);\ntemplate bool voro_compute<container_poly>::compute_cell(voronoicell&,int,int,int,int,int);\ntemplate bool voro_compute<container_poly>::compute_cell(voronoicell_neighbor&,int,int,int,int,int);\ntemplate void voro_compute<container_poly>::find_voronoi_cell(double,double,double,int,int,int,int,particle_record&,double&);\n\n// Explicit template instantiation\ntemplate voro_compute<container_periodic>::voro_compute(container_periodic&,int,int,int);\ntemplate voro_compute<container_periodic_poly>::voro_compute(container_periodic_poly&,int,int,int);\ntemplate bool voro_compute<container_periodic>::compute_cell(voronoicell&,int,int,int,int,int);\ntemplate bool voro_compute<container_periodic>::compute_cell(voronoicell_neighbor&,int,int,int,int,int);\ntemplate void voro_compute<container_periodic>::find_voronoi_cell(double,double,double,int,int,int,int,particle_record&,double&);\ntemplate bool voro_compute<container_periodic_poly>::compute_cell(voronoicell&,int,int,int,int,int);\ntemplate bool voro_compute<container_periodic_poly>::compute_cell(voronoicell_neighbor&,int,int,int,int,int);\ntemplate void voro_compute<container_periodic_poly>::find_voronoi_cell(double,double,double,int,int,int,int,particle_record&,double&);\n\n}\n","// Voro++, a 3D cell-based Voronoi library\n//\n// Author   : Chris H. Rycroft (LBL / UC Berkeley)\n// Email    : chr@alum.mit.edu\n// Date     : August 30th 2011\n\n/** \\file v_compute.hh\n * \\brief Header file for the voro_compute template and related classes. */\n\n#ifndef VOROPP_V_COMPUTE_HH\n#define VOROPP_V_COMPUTE_HH\n\n#include \"config.hh\"\n#include \"worklist.hh\"\n#include \"cell.hh\"\n\nnamespace voro {\n\n/** \\brief Structure for holding information about a particle.\n *\n * This small structure holds information about a single particle, and is used\n * by several of the routines in the voro_compute template for passing\n * information by reference between functions. */\nstruct particle_record {\n\t/** The index of the block that the particle is within. */\n\tint ijk;\n\t/** The number of particle within its block. */\n\tint l;\n\t/** The x-index of the block. */\n\tint di;\n\t/** The y-index of the block. */\n\tint dj;\n\t/** The z-index of the block. */\n\tint dk;\n};\n\n/** \\brief Template for carrying out Voronoi cell computations. */\ntemplate <class c_class>\nclass voro_compute {\n\tpublic:\n\t\t/** A reference to the container class on which to carry out*/\n\t\tc_class &con;\n\t\t/** The size of an internal computational block in the x\n\t\t * direction. */\n\t\tconst double boxx;\n\t\t/** The size of an internal computational block in the y\n\t\t * direction. */\n\t\tconst double boxy;\n\t\t/** The size of an internal computational block in the z\n\t\t * direction. */\n\t\tconst double boxz;\n\t\t/** The inverse box length in the x direction, set to\n\t\t * nx/(bx-ax). */\n\t\tconst double xsp;\n\t\t/** The inverse box length in the y direction, set to\n\t\t * ny/(by-ay). */\n\t\tconst double ysp;\n\t\t/** The inverse box length in the z direction, set to\n\t\t * nz/(bz-az). */\n\t\tconst double zsp;\n\t\t/** The number of boxes in the x direction for the searching mask. */\n\t\tconst int hx;\n\t\t/** The number of boxes in the y direction for the searching mask. */\n\t\tconst int hy;\n\t\t/** The number of boxes in the z direction for the searching mask. */\n\t\tconst int hz;\n\t\t/** A constant, set to the value of hx multiplied by hy, which\n\t\t * is used in the routines which step through mask boxes in\n\t\t * sequence. */\n\t\tconst int hxy;\n\t\t/** A constant, set to the value of hx*hy*hz, which is used in\n\t\t * the routines which step through mask boxes in sequence. */\n\t\tconst int hxyz;\n\t\t/** The number of floating point entries to store for each\n\t\t * particle. */\n\t\tconst int ps;\n\t\t/** This array holds the numerical IDs of each particle in each\n\t\t * computational box. */\n\t\tint **id;\n\t\t/** A two dimensional array holding particle positions. For the\n\t\t * derived container_poly class, this also holds particle\n\t\t * radii. */\n\t\tdouble **p;\n\t\t/** An array holding the number of particles within each\n\t\t * computational box of the container. */\n\t\tint *co;\n\t\tvoro_compute(c_class &con_,int hx_,int hy_,int hz_);\n\t\t/** The class destructor frees the dynamically allocated memory\n\t\t * for the mask and queue. */\n\t\t~voro_compute() {\n\t\t\tdelete [] qu;\n\t\t\tdelete [] mask;\n\t\t}\n\t\ttemplate<class v_cell>\n\t\tbool compute_cell(v_cell &c,int ijk,int s,int ci,int cj,int ck);\n\t\tvoid find_voronoi_cell(double x,double y,double z,int ci,int cj,int ck,int ijk,particle_record &w,double &mrs);\n\tprivate:\n\t\t/** A constant set to boxx*boxx+boxy*boxy+boxz*boxz, which is\n\t\t * frequently used in the computation. */\n\t\tconst double bxsq;\n\t\t/** This sets the current value being used to mark tested blocks\n\t\t * in the mask. */\n\t\tunsigned int mv;\n\t\t/** The current size of the search list. */\n\t\tint qu_size;\n\t\t/** A pointer to the array of worklists. */\n\t\tconst unsigned int *wl;\n\t\t/** An pointer to the array holding the minimum distances\n\t\t * associated with the worklists. */\n\t\tdouble *mrad;\n\t\t/** This array is used during the cell computation to determine\n\t\t * which blocks have been considered. */\n\t\tunsigned int *mask;\n\t\t/** An array is used to store the queue of blocks to test\n\t\t * during the Voronoi cell computation. */\n\t\tint *qu;\n\t\t/** A pointer to the end of the queue array, used to determine\n\t\t * when the queue is full. */\n\t\tint *qu_l;\n\t\ttemplate<class v_cell>\n\t\tbool corner_test(v_cell &c,double xl,double yl,double zl,double xh,double yh,double zh);\n\t\ttemplate<class v_cell>\n\t\tinline bool edge_x_test(v_cell &c,double x0,double yl,double zl,double x1,double yh,double zh);\n\t\ttemplate<class v_cell>\n\t\tinline bool edge_y_test(v_cell &c,double xl,double y0,double zl,double xh,double y1,double zh);\n\t\ttemplate<class v_cell>\n\t\tinline bool edge_z_test(v_cell &c,double xl,double yl,double z0,double xh,double yh,double z1);\n\t\ttemplate<class v_cell>\n\t\tinline bool face_x_test(v_cell &c,double xl,double y0,double z0,double y1,double z1);\n\t\ttemplate<class v_cell>\n\t\tinline bool face_y_test(v_cell &c,double x0,double yl,double z0,double x1,double z1);\n\t\ttemplate<class v_cell>\n\t\tinline bool face_z_test(v_cell &c,double x0,double y0,double zl,double x1,double y1);\n\t\tbool compute_min_max_radius(int di,int dj,int dk,double fx,double fy,double fz,double gx,double gy,double gz,double& crs,double mrs);\n\t\tbool compute_min_radius(int di,int dj,int dk,double fx,double fy,double fz,double mrs);\n\t\tinline void add_to_mask(int ei,int ej,int ek,int *&qu_e);\n\t\tinline void scan_bits_mask_add(unsigned int q,unsigned int *mijk,int ei,int ej,int ek,int *&qu_e);\n\t\tinline void scan_all(int ijk,double x,double y,double z,int di,int dj,int dk,particle_record &w,double &mrs);\n\t\tvoid add_list_memory(int*& qu_s,int*& qu_e);\n\t\t/** Resets the mask in cases where the mask counter wraps\n\t\t * around. */\n\t\tinline void reset_mask() {\n\t\t\tfor(unsigned int *mp(mask);mp<mask+hxyz;mp++) *mp=0;\n\t\t}\n};\n\n}\n\n#endif\n","// Voro++, a 3D cell-based Voronoi library\n//\n// Author   : Chris H. Rycroft (LBL / UC Berkeley)\n// Email    : chr@alum.mit.edu\n// Date     : August 30th 2011\n\n/** \\file container.hh\n * \\brief Header file for the container_base and related classes. */\n\n#ifndef VOROPP_CONTAINER_HH\n#define VOROPP_CONTAINER_HH\n\n#include <cstdio>\n#include <vector>\n\n#include \"config.hh\"\n#include \"common.hh\"\n#include \"v_base.hh\"\n#include \"cell.hh\"\n#include \"c_loops.hh\"\n#include \"v_compute.hh\"\n#include \"rad_option.hh\"\n\n#include <cassert>\n#include <iostream>\n#include <iomanip>\n\nnamespace voro {\n\n/** \\brief Pure virtual class from which wall objects are derived.\n *\n * This is a pure virtual class for a generic wall object. A wall object\n * can be specified by deriving a new class from this and specifying the\n * functions.*/\nclass wall {\n\tpublic:\n\t\tvirtual ~wall() {}\n\t\t/** A pure virtual function for testing whether a point is\n\t\t * inside the wall object. */\n\t\tvirtual bool point_inside(double x,double y,double z) = 0;\n\t\t/** A pure virtual function for cutting a cell without\n\t\t * neighbor-tracking with a wall. */\n\t\tvirtual bool cut_cell(voronoicell &c,double x,double y,double z) = 0;\n\t\t/** A pure virtual function for cutting a cell with\n\t\t * neighbor-tracking enabled with a wall. */\n\t\tvirtual bool cut_cell(voronoicell_neighbor &c,double x,double y,double z) = 0;\n};\n\n/** \\brief A class for storing a list of pointers to walls.\n *\n * This class stores a list of pointers to wall classes. It contains several\n * simple routines that make use of the wall classes (such as telling whether a\n * given position is inside all of the walls or not). It can be used by itself,\n * but also forms part of container_base, for associating walls with this\n * class. */\nclass wall_list {\n\tpublic:\n\t\t/** An array holding pointers to wall objects. */\n\t\twall **walls;\n\t\t/** A pointer to the next free position to add a wall pointer.\n\t\t */\n\t\twall **wep;\n\t\twall_list();\n\t\t~wall_list();\n\t\t/** Adds a wall to the list.\n\t\t * \\param[in] w the wall to add. */\n\t\tinline void add_wall(wall *w) {\n\t\t\tif(wep==wel) increase_wall_memory();\n\t\t\t*(wep++)=w;\n\t\t}\n\t\t/** Adds a wall to the list.\n\t\t * \\param[in] w a reference to the wall to add. */\n\t\tinline void add_wall(wall &w) {add_wall(&w);}\n\t\tvoid add_wall(wall_list &wl);\n\t\t/** Determines whether a given position is inside all of the\n\t\t * walls on the list.\n\t\t * \\param[in] (x,y,z) the position to test.\n\t\t * \\return True if it is inside, false if it is outside. */\n\t\tinline bool point_inside_walls(double x,double y,double z) {\n\t\t\tfor(wall **wp=walls;wp<wep;wp++) if(!((*wp)->point_inside(x,y,z))) return false;\n\t\t\treturn true;\n\t\t}\n\t\t/** Cuts a Voronoi cell by all of the walls currently on\n\t\t * the list.\n\t\t * \\param[in] c a reference to the Voronoi cell class.\n\t\t * \\param[in] (x,y,z) the position of the cell.\n\t\t * \\return True if the cell still exists, false if the cell is\n\t\t * deleted. */\n\t\ttemplate<class c_class>\n\t\tbool apply_walls(c_class &c,double x,double y,double z) {\n\t\t\tfor(wall **wp=walls;wp<wep;wp++) if(!((*wp)->cut_cell(c,x,y,z))) return false;\n\t\t\treturn true;\n\t\t}\n\t\tvoid deallocate();\n\tprotected:\n\t\tvoid increase_wall_memory();\n\t\t/** A pointer to the limit of the walls array, used to\n\t\t * determine when array is full. */\n\t\twall **wel;\n\t\t/** The current amount of memory allocated for walls. */\n\t\tint current_wall_size;\n};\n\n/** \\brief Class for representing a particle system in a three-dimensional\n * rectangular box.\n *\n * This class represents a system of particles in a three-dimensional\n * rectangular box. Any combination of non-periodic and periodic coordinates\n * can be used in the three coordinate directions. The class is not intended\n * for direct use, but instead forms the base of the container and\n * container_poly classes that add specialized routines for computing the\n * regular and radical Voronoi tessellations respectively. It contains routines\n * that are commonly between these two classes, such as those for drawing the\n * domain, and placing particles within the internal data structure.\n *\n * The class is derived from the wall_list class, which encapsulates routines\n * for associating walls with the container, and the voro_base class, which\n * encapsulates routines about the underlying computational grid. */\nclass container_base : public voro_base, public wall_list {\n\tpublic:\n\t\t/** The minimum x coordinate of the container. */\n\t\tconst double ax;\n\t\t/** The maximum x coordinate of the container. */\n\t\tconst double bx;\n\t\t/** The minimum y coordinate of the container. */\n\t\tconst double ay;\n\t\t/** The maximum y coordinate of the container. */\n\t\tconst double by;\n\t\t/** The minimum z coordinate of the container. */\n\t\tconst double az;\n\t\t/** The maximum z coordinate of the container. */\n\t\tconst double bz;\n\t\t/** A boolean value that determines if the x coordinate in\n\t\t * periodic or not. */\n\t\tconst bool xperiodic;\n\t\t/** A boolean value that determines if the y coordinate in\n\t\t * periodic or not. */\n\t\tconst bool yperiodic;\n\t\t/** A boolean value that determines if the z coordinate in\n\t\t * periodic or not. */\n\t\tconst bool zperiodic;\n\t\t/** This array holds the numerical IDs of each particle in each\n\t\t * computational box. */\n\t\tint **id;\n\t\t/** A two dimensional array holding particle positions. For the\n\t\t * derived container_poly class, this also holds particle\n\t\t * radii. */\n\t\tdouble **p;\n\t\t/** This array holds the number of particles within each\n\t\t * computational box of the container. */\n\t\tint *co;\n\t\t/** This array holds the maximum amount of particle memory for\n\t\t * each computational box of the container. If the number of\n\t\t * particles in a particular box ever approaches this limit,\n\t\t * more is allocated using the add_particle_memory() function.\n\t\t */\n\t\tint *mem;\n\t\t/** The amount of memory in the array structure for each\n\t\t * particle. This is set to 3 when the basic class is\n\t\t * initialized, so that the array holds (x,y,z) positions. If\n\t\t * the container class is initialized as part of the derived\n\t\t * class container_poly, then this is set to 4, to also hold\n\t\t * the particle radii. */\n\t\tconst int ps;\n\t\tcontainer_base(double ax_,double bx_,double ay_,double by_,double az_,double bz_,\n\t\t\t\tint nx_,int ny_,int nz_,bool xperiodic_,bool yperiodic_,bool zperiodic_,\n\t\t\t\tint init_mem,int ps_);\n\t\t~container_base();\n\t\tbool point_inside(double x,double y,double z);\n\t\tvoid region_count();\n\t\t/** Initializes the Voronoi cell prior to a compute_cell\n\t\t * operation for a specific particle being carried out by a\n\t\t * voro_compute class. The cell is initialized to fill the\n\t\t * entire container. For non-periodic coordinates, this is set\n\t\t * by the position of the walls. For periodic coordinates, the\n\t\t * space is equally divided in either direction from the\n\t\t * particle's initial position. Plane cuts made by any walls\n\t\t * that have been added are then applied to the cell.\n\t\t * \\param[in,out] c a reference to a voronoicell object.\n\t\t * \\param[in] ijk the block that the particle is within.\n\t\t * \\param[in] q the index of the particle within its block.\n\t\t * \\param[in] (ci,cj,ck) the coordinates of the block in the\n\t\t * \t\t\t container coordinate system.\n\t\t * \\param[out] (i,j,k) the coordinates of the test block\n\t\t * \t\t       relative to the voro_compute\n\t\t * \t\t       coordinate system.\n\t\t * \\param[out] (x,y,z) the position of the particle.\n\t\t * \\param[out] disp a block displacement used internally by the\n\t\t *\t\t    compute_cell routine.\n\t\t * \\return False if the plane cuts applied by walls completely\n\t\t * removed the cell, true otherwise. */\n\t\ttemplate<class v_cell>\n\t\tinline bool initialize_voronoicell(v_cell &c,int ijk,int q,int ci,int cj,int ck,\n\t\t\t\tint &i,int &j,int &k,double &x,double &y,double &z,int &disp) {\n\t\t\tdouble x1,x2,y1,y2,z1,z2,*pp=p[ijk]+ps*q;\n\t\t\tx=*(pp++);y=*(pp++);z=*pp;\n\t\t\tif(xperiodic) {x1=-(x2=0.5*(bx-ax));i=nx;} else {x1=ax-x;x2=bx-x;i=ci;}\n\t\t\tif(yperiodic) {y1=-(y2=0.5*(by-ay));j=ny;} else {y1=ay-y;y2=by-y;j=cj;}\n\t\t\tif(zperiodic) {z1=-(z2=0.5*(bz-az));k=nz;} else {z1=az-z;z2=bz-z;k=ck;}\n\t\t\tc.init(x1,x2,y1,y2,z1,z2);\n\t\t\tif(!apply_walls(c,x,y,z)) return false;\n\t\t\tdisp=ijk-i-nx*(j+ny*k);\n\t\t\treturn true;\n\t\t}\n\t\t/** Initializes parameters for a find_voronoi_cell call within\n\t\t * the voro_compute template.\n\t\t * \\param[in] (ci,cj,ck) the coordinates of the test block in\n\t\t * \t\t\t the container coordinate system.\n\t\t * \\param[in] ijk the index of the test block\n\t\t * \\param[out] (i,j,k) the coordinates of the test block\n\t\t * \t\t       relative to the voro_compute\n\t\t * \t\t       coordinate system.\n\t\t * \\param[out] disp a block displacement used internally by the\n\t\t *\t\t    find_voronoi_cell routine. */\n\t\tinline void initialize_search(int ci,int cj,int ck,int ijk,int &i,int &j,int &k,int &disp) {\n\t\t\ti=xperiodic?nx:ci;\n\t\t\tj=yperiodic?ny:cj;\n\t\t\tk=zperiodic?nz:ck;\n\t\t\tdisp=ijk-i-nx*(j+ny*k);\n\t\t}\n\t\t/** Returns the position of a particle currently being computed\n\t\t * relative to the computational block that it is within. It is\n\t\t * used to select the optimal worklist entry to use.\n\t\t * \\param[in] (x,y,z) the position of the particle.\n\t\t * \\param[in] (ci,cj,ck) the block that the particle is within.\n\t\t * \\param[out] (fx,fy,fz) the position relative to the block.\n\t\t */\n\t\tinline void frac_pos(double x,double y,double z,double ci,double cj,double ck,\n\t\t\t\tdouble &fx,double &fy,double &fz) {\n\t\t\tfx=x-ax-boxx*ci;\n\t\t\tfy=y-ay-boxy*cj;\n\t\t\tfz=z-az-boxz*ck;\n\t\t}\n\t\t/** Calculates the index of block in the container structure\n\t\t * corresponding to given coordinates.\n\t\t * \\param[in] (ci,cj,ck) the coordinates of the original block\n\t\t * \t\t\t in the current computation, relative\n\t\t * \t\t\t to the container coordinate system.\n\t\t * \\param[in] (ei,ej,ek) the displacement of the current block\n\t\t * \t\t\t from the original block.\n\t\t * \\param[in,out] (qx,qy,qz) the periodic displacement that\n\t\t * \t\t\t     must be added to the particles\n\t\t * \t\t\t     within the computed block.\n\t\t * \\param[in] disp a block displacement used internally by the\n\t\t * \t\t    find_voronoi_cell and compute_cell routines.\n\t\t * \\return The block index. */\n\t\tinline int region_index(int ci,int cj,int ck,int ei,int ej,int ek,double &qx,double &qy,double &qz,int &disp) {\n\t\t\tif(xperiodic) {if(ci+ei<nx) {ei+=nx;qx=-(bx-ax);} else if(ci+ei>=(nx<<1)) {ei-=nx;qx=bx-ax;} else qx=0;}\n\t\t\tif(yperiodic) {if(cj+ej<ny) {ej+=ny;qy=-(by-ay);} else if(cj+ej>=(ny<<1)) {ej-=ny;qy=by-ay;} else qy=0;}\n\t\t\tif(zperiodic) {if(ck+ek<nz) {ek+=nz;qz=-(bz-az);} else if(ck+ek>=(nz<<1)) {ek-=nz;qz=bz-az;} else qz=0;}\n\t\t\treturn disp+ei+nx*(ej+ny*ek);\n\t\t}\n\t\tvoid draw_domain_gnuplot(FILE *fp=stdout);\n\t\t/** Draws an outline of the domain in Gnuplot format.\n\t\t * \\param[in] filename the filename to write to. */\n\t\tinline void draw_domain_gnuplot(const char* filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"w\");\n\t\t\tdraw_domain_gnuplot(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\tvoid draw_domain_pov(FILE *fp=stdout);\n\t\t/** Draws an outline of the domain in Gnuplot format.\n\t\t * \\param[in] filename the filename to write to. */\n\t\tinline void draw_domain_pov(const char* filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"w\");\n\t\t\tdraw_domain_pov(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\t/** Sums up the total number of stored particles.\n\t\t * \\return The number of particles. */\n\t\tinline int total_particles() {\n\t\t\tint tp=*co;\n\t\t\tfor(int *cop=co+1;cop<co+nxyz;cop++) tp+=*cop;\n\t\t\treturn tp;\n\t\t}\n        bool already_in_block(double x, double y, double z, double threshold, int except_cell=-1); // checks if pt w/ these coords is already in the same block\n    \n\tprotected:\n\t\tvoid add_particle_memory(int i);\n\t\tbool put_locate_block(int &ijk,double &x,double &y,double &z);\n\t\tinline bool put_remap(int &ijk,double &x,double &y,double &z);\n\t\tinline bool remap(int &ai,int &aj,int &ak,int &ci,int &cj,int &ck,double &x,double &y,double &z,int &ijk);\n};\n\n/** \\brief Extension of the container_base class for computing regular Voronoi\n * tessellations.\n *\n * This class is an extension of the container_base class that has routines\n * specifically for computing the regular Voronoi tessellation with no\n * dependence on particle radii. */\nclass container : public container_base, public radius_mono {\n\tpublic:\n\t\tcontainer(double ax_,double bx_,double ay_,double by_,double az_,double bz_,\n\t\t\t\tint nx_,int ny_,int nz_,bool xperiodic_,bool yperiodic_,bool zperiodic_,int init_mem);\n\t\tvoid clear();\n\t\tvoid put(int n,double x,double y,double z);\n        bool put(int n,double x,double y,double z,int &ijk,int &q);\n\t\tvoid put(particle_order &vo,int n,double x,double y,double z);\n        int swapnpop(int ijk, int q);\n        int move(int &ijk, int &q, int n, double x, double y, double z, int &needsupdate_q);\n\t\tvoid import(FILE *fp=stdin);\n\t\tvoid import(particle_order &vo,FILE *fp=stdin);\n\t\t/** Imports a list of particles from an open file stream into\n\t\t * the container. Entries of four numbers (Particle ID, x\n\t\t * position, y position, z position) are searched for. If the\n\t\t * file cannot be successfully read, then the routine causes a\n\t\t * fatal error.\n\t\t * \\param[in] filename the name of the file to open and read\n\t\t *                     from. */\n\t\tinline void import(const char* filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"r\");\n\t\t\timport(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\t/** Imports a list of particles from an open file stream into\n\t\t * the container. Entries of four numbers (Particle ID, x\n\t\t * position, y position, z position) are searched for. In\n\t\t * addition, the order in which particles are read is saved\n\t\t * into an ordering class. If the file cannot be successfully\n\t\t * read, then the routine causes a fatal error.\n\t\t * \\param[in,out] vo the ordering class to use.\n\t\t * \\param[in] filename the name of the file to open and read\n\t\t *                     from. */\n\t\tinline void import(particle_order &vo,const char* filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"r\");\n\t\t\timport(vo,fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\tvoid compute_all_cells();\n\t\tdouble sum_cell_volumes();\n\t\t/** Dumps particle IDs and positions to a file.\n\t\t * \\param[in] vl the loop class to use.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\ttemplate<class c_loop>\n\t\tvoid draw_particles(c_loop &vl,FILE *fp) {\n\t\t\tdouble *pp;\n\t\t\tif(vl.start()) do {\n\t\t\t\tpp=p[vl.ijk]+3*vl.q;\n\t\t\t\tfprintf(fp,\"%d %g %g %g\\n\",id[vl.ijk][vl.q],*pp,pp[1],pp[2]);\n\t\t\t} while(vl.inc());\n\t\t}\n\t\t/** Dumps all of the particle IDs and positions to a file.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\tinline void draw_particles(FILE *fp=stdout) {\n\t\t\tc_loop_all vl(*this);\n\t\t\tdraw_particles(vl,fp);\n\t\t}\n\t\t/** Dumps all of the particle IDs and positions to a file.\n\t\t * \\param[in] filename the name of the file to write to. */\n\t\tinline void draw_particles(const char *filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"w\");\n\t\t\tdraw_particles(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\t/** Dumps particle positions in POV-Ray format.\n\t\t * \\param[in] vl the loop class to use.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\ttemplate<class c_loop>\n\t\tvoid draw_particles_pov(c_loop &vl,FILE *fp) {\n\t\t\tdouble *pp;\n\t\t\tif(vl.start()) do {\n\t\t\t\tpp=p[vl.ijk]+3*vl.q;\n\t\t\t\tfprintf(fp,\"// id %d\\nsphere{<%g,%g,%g>,s}\\n\",\n\t\t\t\t\t\tid[vl.ijk][vl.q],*pp,pp[1],pp[2]);\n\t\t\t} while(vl.inc());\n\t\t}\n\t\t/** Dumps all particle positions in POV-Ray format.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\tinline void draw_particles_pov(FILE *fp=stdout) {\n\t\t\tc_loop_all vl(*this);\n\t\t\tdraw_particles_pov(vl,fp);\n\t\t}\n\t\t/** Dumps all particle positions in POV-Ray format.\n\t\t * \\param[in] filename the name of the file to write to. */\n\t\tinline void draw_particles_pov(const char *filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"w\");\n\t\t\tdraw_particles_pov(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\t/** Computes Voronoi cells and saves the output in gnuplot\n\t\t * format.\n\t\t * \\param[in] vl the loop class to use.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\ttemplate<class c_loop>\n\t\tvoid draw_cells_gnuplot(c_loop &vl,FILE *fp) {\n\t\t\tvoronoicell c;double *pp;\n\t\t\tif(vl.start()) do if(compute_cell(c,vl)) {\n\t\t\t\tpp=p[vl.ijk]+ps*vl.q;\n\t\t\t\tc.draw_gnuplot(*pp,pp[1],pp[2],fp);\n\t\t\t} while(vl.inc());\n\t\t}\n\t\t/** Computes all Voronoi cells and saves the output in gnuplot\n\t\t * format.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\tinline void draw_cells_gnuplot(FILE *fp=stdout) {\n\t\t\tc_loop_all vl(*this);\n\t\t\tdraw_cells_gnuplot(vl,fp);\n\t\t}\n\t\t/** Computes all Voronoi cells and saves the output in gnuplot\n\t\t * format.\n\t\t * \\param[in] filename the name of the file to write to. */\n\t\tinline void draw_cells_gnuplot(const char *filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"w\");\n\t\t\tdraw_cells_gnuplot(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\t/** Computes Voronoi cells and saves the output in POV-Ray\n\t\t * format.\n\t\t * \\param[in] vl the loop class to use.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\ttemplate<class c_loop>\n\t\tvoid draw_cells_pov(c_loop &vl,FILE *fp) {\n\t\t\tvoronoicell c;double *pp;\n\t\t\tif(vl.start()) do if(compute_cell(c,vl)) {\n\t\t\t\tfprintf(fp,\"// cell %d\\n\",id[vl.ijk][vl.q]);\n\t\t\t\tpp=p[vl.ijk]+ps*vl.q;\n\t\t\t\tc.draw_pov(*pp,pp[1],pp[2],fp);\n\t\t\t} while(vl.inc());\n\t\t}\n\t\t/** Computes all Voronoi cells and saves the output in POV-Ray\n\t\t * format.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\tinline void draw_cells_pov(FILE *fp=stdout) {\n\t\t\tc_loop_all vl(*this);\n\t\t\tdraw_cells_pov(vl,fp);\n\t\t}\n\t\t/** Computes all Voronoi cells and saves the output in POV-Ray\n\t\t * format.\n\t\t * \\param[in] filename the name of the file to write to. */\n\t\tinline void draw_cells_pov(const char *filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"w\");\n\t\t\tdraw_cells_pov(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\t/** Computes the Voronoi cells and saves customized information\n\t\t * about them.\n\t\t * \\param[in] vl the loop class to use.\n\t\t * \\param[in] format the custom output string to use.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\ttemplate<class c_loop>\n\t\tvoid print_custom(c_loop &vl,const char *format,FILE *fp) {\n\t\t\tint ijk,q;double *pp;\n\t\t\tif(contains_neighbor(format)) {\n\t\t\t\tvoronoicell_neighbor c;\n\t\t\t\tif(vl.start()) do if(compute_cell(c,vl)) {\n\t\t\t\t\tijk=vl.ijk;q=vl.q;pp=p[ijk]+ps*q;\n\t\t\t\t\tc.output_custom(format,id[ijk][q],*pp,pp[1],pp[2],default_radius,fp);\n\t\t\t\t} while(vl.inc());\n\t\t\t} else {\n\t\t\t\tvoronoicell c;\n\t\t\t\tif(vl.start()) do if(compute_cell(c,vl)) {\n\t\t\t\t\tijk=vl.ijk;q=vl.q;pp=p[ijk]+ps*q;\n\t\t\t\t\tc.output_custom(format,id[ijk][q],*pp,pp[1],pp[2],default_radius,fp);\n\t\t\t\t} while(vl.inc());\n\t\t\t}\n\t\t}\n\t\tvoid print_custom(const char *format,FILE *fp=stdout);\n\t\tvoid print_custom(const char *format,const char *filename);\n\t\tbool find_voronoi_cell(double x,double y,double z,double &rx,double &ry,double &rz,int &pid);\n\t\t/** Computes the Voronoi cell for a particle currently being\n\t\t * referenced by a loop class.\n\t\t * \\param[out] c a Voronoi cell class in which to store the\n\t\t * \t\t computed cell.\n\t\t * \\param[in] vl the loop class to use.\n\t\t * \\return True if the cell was computed. If the cell cannot be\n\t\t * computed, if it is removed entirely by a wall or boundary\n\t\t * condition, then the routine returns false. */\n\t\ttemplate<class v_cell,class c_loop>\n\t\tinline bool compute_cell(v_cell &c,c_loop &vl) {\n\t\t\treturn vc.compute_cell(c,vl.ijk,vl.q,vl.i,vl.j,vl.k);\n\t\t}\n\t\t/** Computes the Voronoi cell for given particle.\n\t\t * \\param[out] c a Voronoi cell class in which to store the\n\t\t * \t\t computed cell.\n\t\t * \\param[in] ijk the block that the particle is within.\n\t\t * \\param[in] q the index of the particle within the block.\n\t\t * \\return True if the cell was computed. If the cell cannot be\n\t\t * computed, if it is removed entirely by a wall or boundary\n\t\t * condition, then the routine returns false. */\n\t\ttemplate<class v_cell>\n\t\tinline bool compute_cell(v_cell &c,int ijk,int q) {\n            assert(q >= 0 && ijk >= 0 && ijk < nxyz && co[ijk] >= 0 && q < co[ijk]);\n\n\t\t\tint k=ijk/nxy,ijkt=ijk-nxy*k,j=ijkt/nx,i=ijkt-j*nx;\n\t\t\treturn vc.compute_cell(c,ijk,q,i,j,k);\n\t\t}\n        inline bool valid_coords(int ijk, int q) {\n            return (q>=0 && ijk >= 0 && ijk < nxyz && co[ijk] >= 0 && q < co[ijk]);\n        }\n        inline void print_block(int ijk, int q) {\n            bool v = valid_coords(ijk, q);\n            std::cout << \"v=\" << v << \"; \";\n            if (v) {\n                std::cout << \"co[ijk]=\" << co[ijk] << \"; \";\n                for (int ii=0; ii<co[ijk]; ii++) {\n                    double *pp=p[ijk]+ii*3;\n                    std::cout << std::setprecision(17) << \"(\" << pp[0] << \",\" << pp[1] << \",\" << pp[2] << \") \";\n                }\n            }\n            std::cout << std::endl;\n        }\n\t\t/** Computes the Voronoi cell for a ghost particle at a given\n\t\t * location.\n\t\t * \\param[out] c a Voronoi cell class in which to store the\n\t\t * \t\t computed cell.\n\t\t * \\param[in] (x,y,z) the location of the ghost particle.\n\t\t * \\return True if the cell was computed. If the cell cannot be\n\t\t * computed, if it is removed entirely by a wall or boundary\n\t\t * condition, then the routine returns false. */\n\t\ttemplate<class v_cell>\n\t\tinline bool compute_ghost_cell(v_cell &c,double x,double y,double z) {\n\t\t\tint ijk;\n\t\t\tif(put_locate_block(ijk,x,y,z)) {\n\t\t\t\tdouble *pp=p[ijk]+3*co[ijk]++;\n\t\t\t\t*(pp++)=x;*(pp++)=y;*pp=z;\n\t\t\t\tbool q=compute_cell(c,ijk,co[ijk]-1);\n\t\t\t\tco[ijk]--;\n\t\t\t\treturn q;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\tprivate:\n\t\tvoro_compute<container> vc;\n\t\tfriend class voro_compute<container>;\n};\n\n/** \\brief Extension of the container_base class for computing radical Voronoi\n * tessellations.\n *\n * This class is an extension of container_base class that has routines\n * specifically for computing the radical Voronoi tessellation that depends on\n * the particle radii. */\nclass container_poly : public container_base, public radius_poly {\n\tpublic:\n\t\tcontainer_poly(double ax_,double bx_,double ay_,double by_,double az_,double bz_,\n\t\t\t\tint nx_,int ny_,int nz_,bool xperiodic_,bool yperiodic_,bool zperiodic_,int init_mem);\n\t\tvoid clear();\n\t\tvoid put(int n,double x,double y,double z,double r);\n\t\tvoid put(particle_order &vo,int n,double x,double y,double z,double r);\n\t\tvoid import(FILE *fp=stdin);\n\t\tvoid import(particle_order &vo,FILE *fp=stdin);\n\t\t/** Imports a list of particles from an open file stream into\n\t\t * the container_poly class. Entries of five numbers (Particle\n\t\t * ID, x position, y position, z position, radius) are searched\n\t\t * for. If the file cannot be successfully read, then the\n\t\t * routine causes a fatal error.\n\t\t * \\param[in] filename the name of the file to open and read\n\t\t *                     from. */\n\t\tinline void import(const char* filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"r\");\n\t\t\timport(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\t/** Imports a list of particles from an open file stream into\n\t\t * the container_poly class. Entries of five numbers (Particle\n\t\t * ID, x position, y position, z position, radius) are searched\n\t\t * for. In addition, the order in which particles are read is\n\t\t * saved into an ordering class. If the file cannot be\n\t\t * successfully read, then the routine causes a fatal error.\n\t\t * \\param[in,out] vo the ordering class to use.\n\t\t * \\param[in] filename the name of the file to open and read\n\t\t *                     from. */\n\t\tinline void import(particle_order &vo,const char* filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"r\");\n\t\t\timport(vo,fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\tvoid compute_all_cells();\n\t\tdouble sum_cell_volumes();\n\t\t/** Dumps particle IDs, positions and radii to a file.\n\t\t * \\param[in] vl the loop class to use.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\ttemplate<class c_loop>\n\t\tvoid draw_particles(c_loop &vl,FILE *fp) {\n\t\t\tdouble *pp;\n\t\t\tif(vl.start()) do {\n\t\t\t\tpp=p[vl.ijk]+4*vl.q;\n\t\t\t\tfprintf(fp,\"%d %g %g %g %g\\n\",id[vl.ijk][vl.q],*pp,pp[1],pp[2],pp[3]);\n\t\t\t} while(vl.inc());\n\t\t}\n\t\t/** Dumps all of the particle IDs, positions and radii to a\n\t\t * file.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\tinline void draw_particles(FILE *fp=stdout) {\n\t\t\tc_loop_all vl(*this);\n\t\t\tdraw_particles(vl,fp);\n\t\t}\n\t\t/** Dumps all of the particle IDs, positions and radii to a\n\t\t * file.\n\t\t * \\param[in] filename the name of the file to write to. */\n\t\tinline void draw_particles(const char *filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"w\");\n\t\t\tdraw_particles(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\t/** Dumps particle positions in POV-Ray format.\n\t\t * \\param[in] vl the loop class to use.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\ttemplate<class c_loop>\n\t\tvoid draw_particles_pov(c_loop &vl,FILE *fp) {\n\t\t\tdouble *pp;\n\t\t\tif(vl.start()) do {\n\t\t\t\tpp=p[vl.ijk]+4*vl.q;\n\t\t\t\tfprintf(fp,\"// id %d\\nsphere{<%g,%g,%g>,%g}\\n\",\n\t\t\t\t\t\tid[vl.ijk][vl.q],*pp,pp[1],pp[2],pp[3]);\n\t\t\t} while(vl.inc());\n\t\t}\n\t\t/** Dumps all the particle positions in POV-Ray format.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\tinline void draw_particles_pov(FILE *fp=stdout) {\n\t\t\tc_loop_all vl(*this);\n\t\t\tdraw_particles_pov(vl,fp);\n\t\t}\n\t\t/** Dumps all the particle positions in POV-Ray format.\n\t\t * \\param[in] filename the name of the file to write to. */\n\t\tinline void draw_particles_pov(const char *filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"w\");\n\t\t\tdraw_particles_pov(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\t/** Computes Voronoi cells and saves the output in gnuplot\n\t\t * format.\n\t\t * \\param[in] vl the loop class to use.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\ttemplate<class c_loop>\n\t\tvoid draw_cells_gnuplot(c_loop &vl,FILE *fp) {\n\t\t\tvoronoicell c;double *pp;\n\t\t\tif(vl.start()) do if(compute_cell(c,vl)) {\n\t\t\t\tpp=p[vl.ijk]+ps*vl.q;\n\t\t\t\tc.draw_gnuplot(*pp,pp[1],pp[2],fp);\n\t\t\t} while(vl.inc());\n\t\t}\n\t\t/** Compute all Voronoi cells and saves the output in gnuplot\n\t\t * format.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\tinline void draw_cells_gnuplot(FILE *fp=stdout) {\n\t\t\tc_loop_all vl(*this);\n\t\t\tdraw_cells_gnuplot(vl,fp);\n\t\t}\n\t\t/** Compute all Voronoi cells and saves the output in gnuplot\n\t\t * format.\n\t\t * \\param[in] filename the name of the file to write to. */\n\t\tinline void draw_cells_gnuplot(const char *filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"w\");\n\t\t\tdraw_cells_gnuplot(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\t/** Computes Voronoi cells and saves the output in POV-Ray\n\t\t * format.\n\t\t * \\param[in] vl the loop class to use.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\ttemplate<class c_loop>\n\t\tvoid draw_cells_pov(c_loop &vl,FILE *fp) {\n\t\t\tvoronoicell c;double *pp;\n\t\t\tif(vl.start()) do if(compute_cell(c,vl)) {\n\t\t\t\tfprintf(fp,\"// cell %d\\n\",id[vl.ijk][vl.q]);\n\t\t\t\tpp=p[vl.ijk]+ps*vl.q;\n\t\t\t\tc.draw_pov(*pp,pp[1],pp[2],fp);\n\t\t\t} while(vl.inc());\n\t\t}\n\t\t/** Computes all Voronoi cells and saves the output in POV-Ray\n\t\t * format.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\tinline void draw_cells_pov(FILE *fp=stdout) {\n\t\t\tc_loop_all vl(*this);\n\t\t\tdraw_cells_pov(vl,fp);\n\t\t}\n\t\t/** Computes all Voronoi cells and saves the output in POV-Ray\n\t\t * format.\n\t\t * \\param[in] filename the name of the file to write to. */\n\t\tinline void draw_cells_pov(const char *filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"w\");\n\t\t\tdraw_cells_pov(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\t/** Computes the Voronoi cells and saves customized information\n\t\t * about them.\n\t\t * \\param[in] vl the loop class to use.\n\t\t * \\param[in] format the custom output string to use.\n\t\t * \\param[in] fp a file handle to write to. */\n\t\ttemplate<class c_loop>\n\t\tvoid print_custom(c_loop &vl,const char *format,FILE *fp) {\n\t\t\tint ijk,q;double *pp;\n\t\t\tif(contains_neighbor(format)) {\n\t\t\t\tvoronoicell_neighbor c;\n\t\t\t\tif(vl.start()) do if(compute_cell(c,vl)) {\n\t\t\t\t\tijk=vl.ijk;q=vl.q;pp=p[ijk]+ps*q;\n\t\t\t\t\tc.output_custom(format,id[ijk][q],*pp,pp[1],pp[2],pp[3],fp);\n\t\t\t\t} while(vl.inc());\n\t\t\t} else {\n\t\t\t\tvoronoicell c;\n\t\t\t\tif(vl.start()) do if(compute_cell(c,vl)) {\n\t\t\t\t\tijk=vl.ijk;q=vl.q;pp=p[ijk]+ps*q;\n\t\t\t\t\tc.output_custom(format,id[ijk][q],*pp,pp[1],pp[2],pp[3],fp);\n\t\t\t\t} while(vl.inc());\n\t\t\t}\n\t\t}\n\t\t/** Computes the Voronoi cell for a particle currently being\n\t\t * referenced by a loop class.\n\t\t * \\param[out] c a Voronoi cell class in which to store the\n\t\t * \t\t computed cell.\n\t\t * \\param[in] vl the loop class to use.\n\t\t * \\return True if the cell was computed. If the cell cannot be\n\t\t * computed, if it is removed entirely by a wall or boundary\n\t\t * condition, then the routine returns false. */\n\t\ttemplate<class v_cell,class c_loop>\n\t\tinline bool compute_cell(v_cell &c,c_loop &vl) {\n\t\t\treturn vc.compute_cell(c,vl.ijk,vl.q,vl.i,vl.j,vl.k);\n\t\t}\n\t\t/** Computes the Voronoi cell for given particle.\n\t\t * \\param[out] c a Voronoi cell class in which to store the\n\t\t * \t\t computed cell.\n\t\t * \\param[in] ijk the block that the particle is within.\n\t\t * \\param[in] q the index of the particle within the block.\n\t\t * \\return True if the cell was computed. If the cell cannot be\n\t\t * computed, if it is removed entirely by a wall or boundary\n\t\t * condition, then the routine returns false. */\n\t\ttemplate<class v_cell>\n\t\tinline bool compute_cell(v_cell &c,int ijk,int q) {\n\t\t\tint k=ijk/nxy,ijkt=ijk-nxy*k,j=ijkt/nx,i=ijkt-j*nx;\n\t\t\treturn vc.compute_cell(c,ijk,q,i,j,k);\n\t\t}\n\t\t/** Computes the Voronoi cell for a ghost particle at a given\n\t\t * location.\n\t\t * \\param[out] c a Voronoi cell class in which to store the\n\t\t * \t\t computed cell.\n\t\t * \\param[in] (x,y,z) the location of the ghost particle.\n\t\t * \\param[in] r the radius of the ghost particle.\n\t\t * \\return True if the cell was computed. If the cell cannot be\n\t\t * computed, if it is removed entirely by a wall or boundary\n\t\t * condition, then the routine returns false. */\n\t\ttemplate<class v_cell>\n\t\tinline bool compute_ghost_cell(v_cell &c,double x,double y,double z,double r) {\n\t\t\tint ijk;\n\t\t\tif(put_locate_block(ijk,x,y,z)) {\n\t\t\t\tdouble *pp=p[ijk]+4*co[ijk]++,tm=max_radius;\n\t\t\t\t*(pp++)=x;*(pp++)=y;*(pp++)=z;*pp=r;\n\t\t\t\tif(r>max_radius) max_radius=r;\n\t\t\t\tbool q=compute_cell(c,ijk,co[ijk]-1);\n\t\t\t\tco[ijk]--;max_radius=tm;\n\t\t\t\treturn q;\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\t\tvoid print_custom(const char *format,FILE *fp=stdout);\n\t\tvoid print_custom(const char *format,const char *filename);\n\t\tbool find_voronoi_cell(double x,double y,double z,double &rx,double &ry,double &rz,int &pid);\n\tprivate:\n\t\tvoro_compute<container_poly> vc;\n\t\tfriend class voro_compute<container_poly>;\n};\n\n}\n\n#endif\n","// Voro++, a 3D cell-based Voronoi library\n//\n// Author   : Chris H. Rycroft (LBL / UC Berkeley)\n// Email    : chr@alum.mit.edu\n// Date     : August 30th 2011\n\n/** \\file rad_option.hh\n * \\brief Header file for the classes encapsulating functionality for the\n * regular and radical Voronoi tessellations. */\n\n#ifndef VOROPP_RAD_OPTION_HH\n#define VOROPP_RAD_OPTION_HH\n\n#include <cmath>\n\nnamespace voro {\n\n/** \\brief Class containing all of the routines that are specific to computing \n * the regular Voronoi tessellation.\n *\n * The container and container_periodic classes are derived from this class,\n * and during the Voronoi cell computation, these routines are used to create\n * the regular Voronoi tessellation. */\nclass radius_mono {\n\tprotected:\n\t\t/** This is called prior to computing a Voronoi cell for a\n\t\t * given particle to initialize any required constants.\n\t\t * \\param[in] ijk the block that the particle is within.\n\t\t * \\param[in] s the index of the particle within the block. */\n\t\tinline void r_init(int ijk,int s) {}\n\t\t/** Sets a required constant to be used when carrying out a\n\t\t * plane bounds check. */\n\t\tinline void r_prime(double rv) {}\n\t\t/** Carries out a radius bounds check.\n\t\t * \\param[in] crs the radius squared to be tested.\n\t\t * \\param[in] mrs the current maximum distance to a Voronoi\n\t\t *                vertex multiplied by two.\n\t\t * \\return True if particles at this radius could not possibly\n\t\t * cut the cell, false otherwise. */\n\t\tinline bool r_ctest(double crs,double mrs) {return crs>mrs;}\n\t\t/** Scales a plane displacement during a plane bounds check.\n\t\t * \\param[in] lrs the plane displacement.\n\t\t * \\return The scaled value. */\n\t\tinline double r_cutoff(double lrs) {return lrs;}\n\t\t/** Adds the maximum radius squared to a given value.\n\t\t * \\param[in] rs the value to consider.\n\t\t * \\return The value with the radius squared added. */\n\t\tinline double r_max_add(double rs) {return rs;}\n\t\t/** Subtracts the radius squared of a particle from a given \n\t\t * value.\n\t\t * \\param[in] rs the value to consider.\n\t\t * \\param[in] ijk the block that the particle is within.\n\t\t * \\param[in] q the index of the particle within the block. \n\t\t * \\return The value with the radius squared subtracted. */\n\t\tinline double r_current_sub(double rs,int ijk,int q) {return rs;}\n\t\t/** Scales a plane displacement prior to use in the plane cutting\n\t\t * algorithm.\n\t\t * \\param[in] rs the initial plane displacement.\n\t\t * \\param[in] ijk the block that the particle is within.\n\t\t * \\param[in] q the index of the particle within the block.\n\t\t * \\return The scaled plane displacement. */ \n\t\tinline double r_scale(double rs,int ijk,int q) {return rs;}\n\t\t/** Scales a plane displacement prior to use in the plane\n\t\t * cutting algorithm, and also checks if it could possibly cut\n\t\t * the cell.\n\t\t * \\param[in,out] rs the plane displacement to be scaled.\n\t\t * \\param[in] mrs the current maximum distance to a Voronoi\n\t\t *                vertex multiplied by two.\n\t\t * \\param[in] ijk the block that the particle is within.\n\t\t * \\param[in] q the index of the particle within the block.\n\t\t * \\return True if the cell could possibly cut the cell, false\n\t\t * otherwise. */\t\t\n\t\tinline bool r_scale_check(double &rs,double mrs,int ijk,int q) {return rs<mrs;}\n};\n\n/**  \\brief Class containing all of the routines that are specific to computing \n * the radical Voronoi tessellation.\n *\n * The container_poly and container_periodic_poly classes are derived from this\n * class, and during the Voronoi cell computation, these routines are used to\n * create the radical Voronoi tessellation. */\nclass radius_poly {\n\tpublic:\n\t\t/** A two-dimensional array holding particle positions and radii. */\t\t\t\n\t\tdouble **ppr;\n\t\t/** The current maximum radius of any particle, used to\n\t\t * determine when to cut off the radical Voronoi computation.\n\t\t * */\n\t\tdouble max_radius;\n\t\t/** The class constructor sets the maximum particle radius to\n\t\t * be zero. */\n\t\tradius_poly() : max_radius(0) {}\n\tprotected:\n\t\t/** This is called prior to computing a Voronoi cell for a\n\t\t * given particle to initialize any required constants.\n\t\t * \\param[in] ijk the block that the particle is within.\n\t\t * \\param[in] s the index of the particle within the block. */\n\t\tinline void r_init(int ijk,int s) {\n\t\t\tr_rad=ppr[ijk][4*s+3]*ppr[ijk][4*s+3];\n\t\t\tr_mul=r_rad-max_radius*max_radius;\n\t\t}\n\t\t/** Sets a required constant to be used when carrying out a\n\t\t * plane bounds check. */\n\t\tinline void r_prime(double rv) {r_val=1+r_mul/rv;}\n\t\t/** Carries out a radius bounds check.\n\t\t * \\param[in] crs the radius squared to be tested.\n\t\t * \\param[in] mrs the current maximum distance to a Voronoi\n\t\t *                vertex multiplied by two.\n\t\t * \\return True if particles at this radius could not possibly\n\t\t * cut the cell, false otherwise. */\t\t\n\t\tinline bool r_ctest(double crs,double mrs) {return crs+r_mul>sqrt(mrs*crs);}\n\t\t/** Scales a plane displacement during a plane bounds check.\n\t\t * \\param[in] lrs the plane displacement.\n\t\t * \\return The scaled value. */\t\t\n\t\tinline double r_cutoff(double lrs) {return lrs*r_val;}\n\t\t/** Adds the maximum radius squared to a given value.\n\t\t * \\param[in] rs the value to consider.\n\t\t * \\return The value with the radius squared added. */\t\t\n\t\tinline double r_max_add(double rs) {return rs+max_radius*max_radius;}\n\t\t/** Subtracts the radius squared of a particle from a given \n\t\t * value.\n\t\t * \\param[in] rs the value to consider.\n\t\t * \\param[in] ijk the block that the particle is within.\n\t\t * \\param[in] q the index of the particle within the block. \n\t\t * \\return The value with the radius squared subtracted. */\n\t\tinline double r_current_sub(double rs,int ijk,int q) {\n\t\t\treturn rs-ppr[ijk][4*q+3]*ppr[ijk][4*q+3];\n\t\t}\n\t\t/** Scales a plane displacement prior to use in the plane cutting\n\t\t * algorithm.\n\t\t * \\param[in] rs the initial plane displacement.\n\t\t * \\param[in] ijk the block that the particle is within.\n\t\t * \\param[in] q the index of the particle within the block.\n\t\t * \\return The scaled plane displacement. */ \n\t\tinline double r_scale(double rs,int ijk,int q) {\n\t\t\treturn rs+r_rad-ppr[ijk][4*q+3]*ppr[ijk][4*q+3];\n\t\t}\n\t\t/** Scales a plane displacement prior to use in the plane\n\t\t * cutting algorithm, and also checks if it could possibly cut\n\t\t * the cell.\n\t\t * \\param[in,out] rs the plane displacement to be scaled.\n\t\t * \\param[in] mrs the current maximum distance to a Voronoi\n\t\t *                vertex multiplied by two.\n\t\t * \\param[in] ijk the block that the particle is within.\n\t\t * \\param[in] q the index of the particle within the block.\n\t\t * \\return True if the cell could possibly cut the cell, false\n\t\t * otherwise. */\n\t\tinline bool r_scale_check(double &rs,double mrs,int ijk,int q) {\n\t\t\tdouble trs=rs;\n\t\t\trs+=r_rad-ppr[ijk][4*q+3]*ppr[ijk][4*q+3];\n\t\t\treturn rs<sqrt(mrs*trs);\n\t\t}\n\tprivate:\n\t\tdouble r_rad,r_mul,r_val;\n};\n\n}\n#endif\n","// Voro++, a 3D cell-based Voronoi library\n//\n// Author   : Chris H. Rycroft (LBL / UC Berkeley)\n// Email    : chr@alum.mit.edu\n// Date     : August 30th 2011\n\n/** \\file pre_container.cc\n * \\brief Function implementations for the pre_container and related classes.\n */\n\n#include <cmath>\n\n#include \"config.hh\"\n#include \"pre_container.hh\"\n\nnamespace voro {\n\n/** The class constructor sets up the geometry of container, initializing the\n * minimum and maximum coordinates in each direction. It allocates an initial\n * chunk into which to store particle information.\n * \\param[in] (ax_,bx_) the minimum and maximum x coordinates.\n * \\param[in] (ay_,by_) the minimum and maximum y coordinates.\n * \\param[in] (az_,bz_) the minimum and maximum z coordinates.\n * \\param[in] (xperiodic_,yperiodic_,zperiodic_ ) flags setting whether the\n *                                                container is periodic in each\n *                                                coordinate direction.\n * \\param[in] ps_ the number of floating point entries to store for each\n *                particle. */\npre_container_base::pre_container_base(double ax_,double bx_,double ay_,double by_,double az_,double bz_,\n\tbool xperiodic_,bool yperiodic_,bool zperiodic_,int ps_) :\n\tax(ax_), bx(bx_), ay(ay_), by(by_), az(az_), bz(bz_),\n\txperiodic(xperiodic_), yperiodic(yperiodic_), zperiodic(zperiodic_), ps(ps_),\n\tindex_sz(init_chunk_size), pre_id(new int*[index_sz]), end_id(pre_id),\n\tpre_p(new double*[index_sz]), end_p(pre_p) {\n\t\tch_id=*end_id=new int[pre_container_chunk_size];\n\t\tl_id=end_id+index_sz;e_id=ch_id+pre_container_chunk_size;\n\t\tch_p=*end_p=new double[ps*pre_container_chunk_size];\n}\n\n/** The destructor frees the dynamically allocated memory. */\npre_container_base::~pre_container_base() {\n\tdelete [] *end_p;\n\tdelete [] *end_id;\n\twhile (end_id!=pre_id) {\n\t\tend_p--;\n\t\tdelete [] *end_p;\n\t\tend_id--;\n\t\tdelete [] *end_id;\n\t}\n\tdelete [] pre_p;\n\tdelete [] pre_id;\n}\n\n/** Makes a guess at the optimal grid of blocks to use, computing in\n * a way that\n * \\param[out] (nx,ny,nz) the number of blocks to use. */\nvoid pre_container_base::guess_optimal(int &nx,int &ny,int &nz) {\n\tdouble dx=bx-ax,dy=by-ay,dz=bz-az;\n\tdouble ilscale=pow(total_particles()/(optimal_particles*dx*dy*dz),1/3.0);\n\tnx=int(dx*ilscale+1);\n\tny=int(dy*ilscale+1);\n\tnz=int(dz*ilscale+1);\n}\n\n/** Stores a particle ID and position, allocating a new memory chunk if\n * necessary. For coordinate directions in which the container is not periodic,\n * the routine checks to make sure that the particle is within the container\n * bounds. If the particle is out of bounds, it is not stored.\n * \\param[in] n the numerical ID of the inserted particle.\n * \\param[in] (x,y,z) the position vector of the inserted particle. */\nvoid pre_container::put(int n,double x,double y,double z) {\n\tif((xperiodic||(x>=ax&&x<=bx))&&(yperiodic||(y>=ay&&y<=by))&&(zperiodic||(z>=az&&z<=bz))) {\n\t\tif(ch_id==e_id) new_chunk();\n\t\t*(ch_id++)=n;\n\t\t*(ch_p++)=x;*(ch_p++)=y;*(ch_p++)=z;\n\t}\n#if VOROPP_REPORT_OUT_OF_BOUNDS ==1\n\telse fprintf(stderr,\"Out of bounds: (x,y,z)=(%g,%g,%g)\\n\",x,y,z);\n#endif\n}\n\n/** Stores a particle ID and position, allocating a new memory chunk if necessary.\n * \\param[in] n the numerical ID of the inserted particle.\n * \\param[in] (x,y,z) the position vector of the inserted particle.\n * \\param[in] r the radius of the particle. */\nvoid pre_container_poly::put(int n,double x,double y,double z,double r) {\n\tif((xperiodic||(x>=ax&&x<=bx))&&(yperiodic||(y>=ay&&y<=by))&&(zperiodic||(z>=az&&z<=bz))) {\n\t\tif(ch_id==e_id) new_chunk();\n\t\t*(ch_id++)=n;\n\t\t*(ch_p++)=x;*(ch_p++)=y;*(ch_p++)=z;*(ch_p++)=r;\n\t}\n#if VOROPP_REPORT_OUT_OF_BOUNDS ==1\n\telse fprintf(stderr,\"Out of bounds: (x,y,z)=(%g,%g,%g)\\n\",x,y,z);\n#endif\n}\n\n/** Transfers the particles stored within the class to a container class.\n * \\param[in] con the container class to transfer to. */\nvoid pre_container::setup(container &con) {\n\tint **c_id=pre_id,*idp,*ide,n;\n\tdouble **c_p=pre_p,*pp,x,y,z;\n\twhile(c_id<end_id) {\n\t\tidp=*(c_id++);ide=idp+pre_container_chunk_size;\n\t\tpp=*(c_p++);\n\t\twhile(idp<ide) {\n\t\t\tn=*(idp++);x=*(pp++);y=*(pp++);z=*(pp++);\n\t\t\tcon.put(n,x,y,z);\n\t\t}\n\t}\n\tidp=*c_id;\n\tpp=*c_p;\n\twhile(idp<ch_id) {\n\t\tn=*(idp++);x=*(pp++);y=*(pp++);z=*(pp++);\n\t\tcon.put(n,x,y,z);\n\t}\n}\n\n/** Transfers the particles stored within the class to a container_poly class.\n * \\param[in] con the container_poly class to transfer to. */\nvoid pre_container_poly::setup(container_poly &con) {\n\tint **c_id=pre_id,*idp,*ide,n;\n\tdouble **c_p=pre_p,*pp,x,y,z,r;\n\twhile(c_id<end_id) {\n\t\tidp=*(c_id++);ide=idp+pre_container_chunk_size;\n\t\tpp=*(c_p++);\n\t\twhile(idp<ide) {\n\t\t\tn=*(idp++);x=*(pp++);y=*(pp++);z=*(pp++);r=*(pp++);\n\t\t\tcon.put(n,x,y,z,r);\n\t\t}\n\t}\n\tidp=*c_id;\n\tpp=*c_p;\n\twhile(idp<ch_id) {\n\t\tn=*(idp++);x=*(pp++);y=*(pp++);z=*(pp++);r=*(pp++);\n\t\tcon.put(n,x,y,z,r);\n\t}\n}\n\n/** Transfers the particles stored within the class to a container class, also\n * recording the order in which particles were stored.\n * \\param[in] vo the ordering class to use.\n * \\param[in] con the container class to transfer to. */\nvoid pre_container::setup(particle_order &vo,container &con) {\n\tint **c_id=pre_id,*idp,*ide,n;\n\tdouble **c_p=pre_p,*pp,x,y,z;\n\twhile(c_id<end_id) {\n\t\tidp=*(c_id++);ide=idp+pre_container_chunk_size;\n\t\tpp=*(c_p++);\n\t\twhile(idp<ide) {\n\t\t\tn=*(idp++);x=*(pp++);y=*(pp++);z=*(pp++);\n\t\t\tcon.put(vo,n,x,y,z);\n\t\t}\n\t}\n\tidp=*c_id;\n\tpp=*c_p;\n\twhile(idp<ch_id) {\n\t\tn=*(idp++);x=*(pp++);y=*(pp++);z=*(pp++);\n\t\tcon.put(vo,n,x,y,z);\n\t}\n}\n\n/** Transfers the particles stored within the class to a container_poly class,\n * also recording the order in which particles were stored.\n * \\param[in] vo the ordering class to use.\n * \\param[in] con the container_poly class to transfer to. */\nvoid pre_container_poly::setup(particle_order &vo,container_poly &con) {\n\tint **c_id=pre_id,*idp,*ide,n;\n\tdouble **c_p=pre_p,*pp,x,y,z,r;\n\twhile(c_id<end_id) {\n\t\tidp=*(c_id++);ide=idp+pre_container_chunk_size;\n\t\tpp=*(c_p++);\n\t\twhile(idp<ide) {\n\t\t\tn=*(idp++);x=*(pp++);y=*(pp++);z=*(pp++);r=*(pp++);\n\t\t\tcon.put(vo,n,x,y,z,r);\n\t\t}\n\t}\n\tidp=*c_id;\n\tpp=*c_p;\n\twhile(idp<ch_id) {\n\t\tn=*(idp++);x=*(pp++);y=*(pp++);z=*(pp++);r=*(pp++);\n\t\tcon.put(vo,n,x,y,z,r);\n\t}\n}\n\n/** Import a list of particles from an open file stream into the container.\n * Entries of four numbers (Particle ID, x position, y position, z position)\n * are searched for. If the file cannot be successfully read, then the routine\n * causes a fatal error.\n * \\param[in] fp the file handle to read from. */\nvoid pre_container::import(FILE *fp) {\n\tint i,j;\n\tdouble x,y,z;\n\twhile((j=fscanf(fp,\"%d %lg %lg %lg\",&i,&x,&y,&z))==4) put(i,x,y,z);\n\tif(j!=EOF) voro_fatal_error(\"File import error\",VOROPP_FILE_ERROR);\n}\n\n/** Import a list of particles from an open file stream, also storing the order\n * of that the particles are read. Entries of four numbers (Particle ID, x\n * position, y position, z position) are searched for. If the file cannot be\n * successfully read, then the routine causes a fatal error.\n * \\param[in] fp the file handle to read from. */\nvoid pre_container_poly::import(FILE *fp) {\n\tint i,j;\n\tdouble x,y,z,r;\n\twhile((j=fscanf(fp,\"%d %lg %lg %lg %lg\",&i,&x,&y,&z,&r))==5) put(i,x,y,z,r);\n\tif(j!=EOF) voro_fatal_error(\"File import error\",VOROPP_FILE_ERROR);\n}\n\n/** Allocates a new chunk of memory for storing particles. */\nvoid pre_container_base::new_chunk() {\n\tend_id++;end_p++;\n\tif(end_id==l_id) extend_chunk_index();\n\tch_id=*end_id=new int[pre_container_chunk_size];\n\te_id=ch_id+pre_container_chunk_size;\n\tch_p=*end_p=new double[ps*pre_container_chunk_size];\n}\n\n/** Extends the index of chunks. */\nvoid pre_container_base::extend_chunk_index() {\n\tindex_sz<<=1;\n\tif(index_sz>max_chunk_size)\n\t\tvoro_fatal_error(\"Absolute memory limit on chunk index reached\",VOROPP_MEMORY_ERROR);\n#if VOROPP_VERBOSE >=2\n\tfprintf(stderr,\"Pre-container chunk index scaled up to %d\\n\",index_sz);\n#endif\n\tint **n_id=new int*[index_sz],**p_id=n_id,**c_id=pre_id;\n\tdouble **n_p=new double*[index_sz],**p_p=n_p,**c_p=pre_p;\n\twhile(c_id<end_id) {\n\t\t*(p_id++)=*(c_id++);\n\t\t*(p_p++)=*(c_p++);\n\t}\n\tdelete [] pre_id;pre_id=n_id;end_id=p_id;l_id=pre_id+index_sz;\n\tdelete [] pre_p;pre_p=n_p;end_p=p_p;\n}\n\n}\n","// Voro++, a 3D cell-based Voronoi library\n//\n// Author   : Chris H. Rycroft (LBL / UC Berkeley)\n// Email    : chr@alum.mit.edu\n// Date     : August 30th 2011\n\n/** \\file pre_container.hh\n * \\brief Header file for the pre_container and related classes. */\n\n#ifndef VOROPP_PRE_CONTAINER_HH\n#define VOROPP_PRE_CONTAINER_HH\n\n#include <cstdio>\n\n#include \"c_loops.hh\"\n#include \"container.hh\"\n\nnamespace voro {\n\n/** \\brief A class for storing an arbitrary number of particles, prior to setting\n * up a container geometry.\n *\n * The pre_container_base class can dynamically import and store an arbitrary\n * number of particles. Once the particles have been read in, an appropriate\n * container class can be set up with the optimal grid size, and the particles\n * can be transferred.\n *\n * The pre_container_base class is not intended for direct use, but forms the\n * base of the pre_container and pre_container_poly classes, that add routines\n * depending on whether particle radii need to be tracked or not. */\nclass pre_container_base {\n\tpublic:\n\t\t/** The minimum x coordinate of the container. */\n\t\tconst double ax;\n\t\t/** The maximum x coordinate of the container. */\n\t\tconst double bx;\n\t\t/** The minimum y coordinate of the container. */\n\t\tconst double ay;\n\t\t/** The maximum y coordinate of the container. */\n\t\tconst double by;\n\t\t/** The minimum z coordinate of the container. */\n\t\tconst double az;\n\t\t/** The maximum z coordinate of the container. */\n\t\tconst double bz;\n\t\t/** A boolean value that determines if the x coordinate in\n\t\t * periodic or not. */\n\t\tconst bool xperiodic;\n\t\t/** A boolean value that determines if the y coordinate in\n\t\t * periodic or not. */\n\t\tconst bool yperiodic;\n\t\t/** A boolean value that determines if the z coordinate in\n\t\t * periodic or not. */\n\t\tconst bool zperiodic;\n\t\tvoid guess_optimal(int &nx,int &ny,int &nz);\n\t\tpre_container_base(double ax_,double bx_,double ay_,double by_,double az_,double bz_,bool xperiodic_,bool yperiodic_,bool zperiodic_,int ps_);\n\t\t~pre_container_base();\n\t\t/** Calculates and returns the total number of particles stored\n\t\t * within the class.\n\t\t * \\return The number of particles. */\n\t\tinline int total_particles() {\n\t\t\treturn (end_id-pre_id)*pre_container_chunk_size+(ch_id-*end_id);\n\t\t}\n\tprotected:\n\t\t/** The number of doubles associated with a single particle\n\t\t * (three for the standard container, four when radius\n\t\t * information is stored). */\n\t\tconst int ps;\n\t\tvoid new_chunk();\n\t\tvoid extend_chunk_index();\n\t\t/** The size of the chunk index. */\n\t\tint index_sz;\n\t\t/** A pointer to the chunk index to store the integer particle\n\t\t * IDs. */\n\t\tint **pre_id;\n\t\t/** A pointer to the last allocated integer ID chunk. */\n\t\tint **end_id;\n\t\t/** A pointer to the end of the integer ID chunk index, used to\n\t\t * determine when the chunk index is full. */\n\t\tint **l_id;\n\t\t/** A pointer to the next available slot on the current\n\t\t * particle ID chunk. */\n\t\tint *ch_id;\n\t\t/** A pointer to the end of the current integer chunk. */\n\t\tint *e_id;\n\t\t/** A pointer to the chunk index to store the floating point\n\t\t * information associated with particles. */\n\t\tdouble **pre_p;\n\t\t/** A pointer to the last allocated chunk of floating point\n\t\t * information. */\n\t\tdouble **end_p;\n\t\t/** A pointer to the next available slot on the current\n\t\t * floating point chunk. */\n\t\tdouble *ch_p;\n};\n\n/** \\brief A class for storing an arbitrary number of particles without radius\n * information, prior to setting up a container geometry.\n *\n * The pre_container class is an extension of the pre_container_base class for\n * cases when no particle radius information is available. */\nclass pre_container : public pre_container_base {\n\tpublic:\n\t\t/** The class constructor sets up the geometry of container,\n\t\t * initializing the minimum and maximum coordinates in each\n\t\t * direction.\n\t\t * \\param[in] (ax_,bx_) the minimum and maximum x coordinates.\n\t\t * \\param[in] (ay_,by_) the minimum and maximum y coordinates.\n\t\t * \\param[in] (az_,bz_) the minimum and maximum z coordinates.\n\t\t * \\param[in] (xperiodic_,yperiodic_,zperiodic_ ) flags setting whether the\n\t\t *                                                container is periodic in\n\t\t *                                                each coordinate direction. */\n\t\tpre_container(double ax_,double bx_,double ay_,double by_,double az_,double bz_,\n\t\t\t\tbool xperiodic_,bool yperiodic_,bool zperiodic_)\n\t\t\t: pre_container_base(ax_,bx_,ay_,by_,az_,bz_,xperiodic_,yperiodic_,zperiodic_,3) {};\n\t\tvoid put(int n,double x,double y,double z);\n\t\tvoid import(FILE *fp=stdin);\n\t\t/** Imports particles from a file.\n\t\t * \\param[in] filename the name of the file to read from. */\n\t\tinline void import(const char* filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"r\");\n\t\t\timport(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\tvoid setup(container &con);\n\t\tvoid setup(particle_order &vo,container &con);\n};\n\n/** \\brief A class for storing an arbitrary number of particles with radius\n * information, prior to setting up a container geometry.\n *\n * The pre_container_poly class is an extension of the pre_container_base class\n * for cases when particle radius information is available. */\nclass pre_container_poly : public pre_container_base {\n\tpublic:\n\t\t/** The class constructor sets up the geometry of container,\n\t\t * initializing the minimum and maximum coordinates in each\n\t\t * direction.\n\t\t * \\param[in] (ax_,bx_) the minimum and maximum x coordinates.\n\t\t * \\param[in] (ay_,by_) the minimum and maximum y coordinates.\n\t\t * \\param[in] (az_,bz_) the minimum and maximum z coordinates.\n\t\t * \\param[in] (xperiodic_,yperiodic_,zperiodic_ ) flags setting whether the\n\t\t *                                                container is periodic in\n\t\t *                                                each coordinate direction. */\n\t\tpre_container_poly(double ax_,double bx_,double ay_,double by_,double az_,double bz_,\n\t\t\t\tbool xperiodic_,bool yperiodic_,bool zperiodic_)\n\t\t\t: pre_container_base(ax_,bx_,ay_,by_,az_,bz_,xperiodic_,yperiodic_,zperiodic_,4) {};\n\t\tvoid put(int n,double x,double y,double z,double r);\n\t\tvoid import(FILE *fp=stdin);\n\t\t/** Imports particles from a file.\n\t\t * \\param[in] filename the name of the file to read from. */\n\t\tinline void import(const char* filename) {\n\t\t\tFILE *fp=safe_fopen(filename,\"r\");\n\t\t\timport(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t\tvoid setup(container_poly &con);\n\t\tvoid setup(particle_order &vo,container_poly &con);\n};\n\n}\n\n#endif\n","#include <emscripten/bind.h>\r\n#ifdef USE_CXA_DEMANGLE\r\n#include <../lib/libcxxabi/include/cxxabi.h>\r\n#endif\r\n#include <list>\r\n#include <vector>\r\n#include <typeinfo>\r\n#include <algorithm>\r\n#include <emscripten/emscripten.h>\r\n#include <climits>\r\n#include <limits>\r\n\r\nusing namespace emscripten;\r\n\r\nextern \"C\" {\r\n    const char* __attribute__((used)) __getTypeName(const std::type_info* ti) {\r\n        if (has_unbound_type_names) {\r\n#ifdef USE_CXA_DEMANGLE\r\n            int stat;\r\n            char* demangled = abi::__cxa_demangle(ti->name(), NULL, NULL, &stat);\r\n            if (stat == 0 && demangled) {\r\n                return demangled;\r\n            }\r\n\r\n            switch (stat) {\r\n                case -1:\r\n                    return strdup(\"<allocation failure>\");\r\n                case -2:\r\n                    return strdup(\"<invalid C++ symbol>\");\r\n                case -3:\r\n                    return strdup(\"<invalid argument>\");\r\n                default:\r\n                    return strdup(\"<unknown error>\");\r\n            }\r\n#else\r\n            return strdup(ti->name());\r\n#endif\r\n        } else {\r\n            char str[80];\r\n            sprintf(str, \"%p\", reinterpret_cast<const void*>(ti));\r\n            return strdup(str);\r\n        }\r\n    }\r\n}\r\n\r\nnamespace {\r\n    template<typename T>\r\n    static void register_integer(const char* name) {\r\n        using namespace internal;\r\n        _embind_register_integer(TypeID<T>::get(), name, sizeof(T), std::numeric_limits<T>::min(), std::numeric_limits<T>::max());\r\n    }\r\n\r\n    template<typename T>\r\n    static void register_float(const char* name) {\r\n        using namespace internal;\r\n        _embind_register_float(TypeID<T>::get(), name, sizeof(T));\r\n    }\r\n\r\n\r\n    // matches typeMapping in embind.js\r\n    enum TypedArrayIndex {\r\n        Int8Array,\r\n        Uint8Array,\r\n        Int16Array,\r\n        Uint16Array,\r\n        Int32Array,\r\n        Uint32Array,\r\n        Float32Array,\r\n        Float64Array,\r\n    };\r\n\r\n    template<typename T>\r\n    constexpr TypedArrayIndex getTypedArrayIndex() {\r\n        static_assert(\r\n            (std::is_floating_point<T>::value && (sizeof(T) == 4 || sizeof(T) == 8)) ||\r\n            (std::is_integral<T>::value && (sizeof(T) == 1 || sizeof(T) == 2 || sizeof(T) == 4)),\r\n            \"type does not map to a typed array\");\r\n        return std::is_floating_point<T>::value\r\n            ? (sizeof(T) == 4\r\n               ? Float32Array\r\n               : Float64Array)\r\n            : (sizeof(T) == 1\r\n               ? (std::is_signed<T>::value ? Int8Array : Uint8Array)\r\n               : (sizeof(T) == 2\r\n                  ? (std::is_signed<T>::value ? Int16Array : Uint16Array)\r\n                  : (std::is_signed<T>::value ? Int32Array : Uint32Array)));\r\n    }\r\n\r\n    template<typename T>\r\n    static void register_memory_view(const char* name) {\r\n        using namespace internal;\r\n        _embind_register_memory_view(TypeID<memory_view<T>>::get(), getTypedArrayIndex<T>(), name);\r\n    }\r\n}\r\n\r\nEMSCRIPTEN_BINDINGS(native_and_builtin_types) {\r\n    using namespace emscripten::internal;\r\n\r\n    _embind_register_void(TypeID<void>::get(), \"void\");\r\n    \r\n    _embind_register_bool(TypeID<bool>::get(), \"bool\", sizeof(bool), true, false);\r\n\r\n    register_integer<char>(\"char\");\r\n    register_integer<signed char>(\"signed char\");\r\n    register_integer<unsigned char>(\"unsigned char\");\r\n    register_integer<signed short>(\"short\");\r\n    register_integer<unsigned short>(\"unsigned short\");\r\n    register_integer<signed int>(\"int\");\r\n    register_integer<unsigned int>(\"unsigned int\");\r\n    register_integer<signed long>(\"long\");\r\n    register_integer<unsigned long>(\"unsigned long\");\r\n    \r\n    register_float<float>(\"float\");\r\n    register_float<double>(\"double\");\r\n    \r\n    _embind_register_std_string(TypeID<std::string>::get(), \"std::string\");\r\n    _embind_register_std_string(TypeID<std::basic_string<unsigned char> >::get(), \"std::basic_string<unsigned char>\");\r\n    _embind_register_std_wstring(TypeID<std::wstring>::get(), sizeof(wchar_t), \"std::wstring\");\r\n    _embind_register_emval(TypeID<val>::get(), \"emscripten::val\");\r\n\r\n    // Some of these types are aliases for each other. Luckily,\r\n    // embind.js's _embind_register_memory_view ignores duplicate\r\n    // registrations rather than asserting, so the first\r\n    // register_memory_view call for a particular type will take\r\n    // precedence.\r\n\r\n    register_memory_view<char>(\"emscripten::memory_view<char>\");\r\n    register_memory_view<signed char>(\"emscripten::memory_view<signed char>\");\r\n    register_memory_view<unsigned char>(\"emscripten::memory_view<unsigned char>\");\r\n\r\n    register_memory_view<short>(\"emscripten::memory_view<short>\");\r\n    register_memory_view<unsigned short>(\"emscripten::memory_view<unsigned short>\");\r\n    register_memory_view<int>(\"emscripten::memory_view<int>\");\r\n    register_memory_view<unsigned int>(\"emscripten::memory_view<unsigned int>\");\r\n    register_memory_view<long>(\"emscripten::memory_view<long>\");\r\n    register_memory_view<unsigned long>(\"emscripten::memory_view<unsigned long>\");\r\n\r\n    register_memory_view<int8_t>(\"emscripten::memory_view<int8_t>\");\r\n    register_memory_view<uint8_t>(\"emscripten::memory_view<uint8_t>\");\r\n    register_memory_view<int16_t>(\"emscripten::memory_view<int16_t>\");\r\n    register_memory_view<uint16_t>(\"emscripten::memory_view<uint16_t>\");\r\n    register_memory_view<int32_t>(\"emscripten::memory_view<int32_t>\");\r\n    register_memory_view<uint32_t>(\"emscripten::memory_view<uint32_t>\");\r\n\r\n    register_memory_view<float>(\"emscripten::memory_view<float>\");\r\n    register_memory_view<double>(\"emscripten::memory_view<double>\");\r\n    register_memory_view<long double>(\"emscripten::memory_view<long double>\");\r\n}\r\n","// -*- C++ -*-\n//===-------------------------- typeinfo ----------------------------------===//\n//\n//                     The LLVM Compiler Infrastructure\n//\n// This file is dual licensed under the MIT and the University of Illinois Open\n// Source Licenses. See LICENSE.TXT for details.\n//\n//===----------------------------------------------------------------------===//\n\n#ifndef __LIBCPP_TYPEINFO\n#define __LIBCPP_TYPEINFO\n\n/*\n\n    typeinfo synopsis\n\nnamespace std {\n\nclass type_info\n{\npublic:\n    virtual ~type_info();\n\n    bool operator==(const type_info& rhs) const noexcept;\n    bool operator!=(const type_info& rhs) const noexcept;\n\n    bool before(const type_info& rhs) const noexcept;\n    size_t hash_code() const noexcept;\n    const char* name() const noexcept;\n\n    type_info(const type_info& rhs) = delete;\n    type_info& operator=(const type_info& rhs) = delete;\n};\n\nclass bad_cast\n    : public exception\n{\npublic:\n    bad_cast() noexcept;\n    bad_cast(const bad_cast&) noexcept;\n    bad_cast& operator=(const bad_cast&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\nclass bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() noexcept;\n    bad_typeid(const bad_typeid&) noexcept;\n    bad_typeid& operator=(const bad_typeid&) noexcept;\n    virtual const char* what() const noexcept;\n};\n\n}  // std\n\n*/\n\n#include <__config>\n#include <exception>\n#include <cstddef>\n#include <cstdint>\n\n#if !defined(_LIBCPP_HAS_NO_PRAGMA_SYSTEM_HEADER)\n#pragma GCC system_header\n#endif\n\nnamespace std  // purposefully not using versioning namespace\n{\n\nclass _LIBCPP_EXCEPTION_ABI type_info\n{\n    type_info& operator=(const type_info&);\n    type_info(const type_info&);\nprotected:\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n    const char* __type_name;\n#else\n    // A const char* with the non-unique RTTI bit possibly set.\n    uintptr_t __type_name;\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    explicit type_info(const char* __n)\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        : __type_name(__n) {}\n#else\n        : __type_name(reinterpret_cast<uintptr_t>(__n)) {}\n#endif\n\npublic:\n    virtual ~type_info();\n\n    _LIBCPP_INLINE_VISIBILITY\n    const char* name() const _NOEXCEPT\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        {return __type_name;}\n#else\n        {return reinterpret_cast<const char*>(__type_name & ~_LIBCPP_NONUNIQUE_RTTI_BIT);}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool before(const type_info& __arg) const _NOEXCEPT\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        {return __type_name < __arg.__type_name;}\n#else\n        {if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n           return __type_name < __arg.__type_name;\n         return __compare_nonunique_names(__arg) < 0;}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    size_t hash_code() const _NOEXCEPT\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        {return *reinterpret_cast<const size_t*>(&__type_name);}\n#else\n        {if (!(__type_name & _LIBCPP_NONUNIQUE_RTTI_BIT)) return __type_name;\n         const char *__ptr = name();\n         size_t __hash = 5381;\n         while (unsigned char __c = static_cast<unsigned char>(*__ptr++))\n           __hash = (__hash * 33) ^ __c;\n         return __hash;}\n#endif\n\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator==(const type_info& __arg) const _NOEXCEPT\n#ifndef _LIBCPP_NONUNIQUE_RTTI_BIT\n        {return __type_name == __arg.__type_name;}\n#else\n        {if (__type_name == __arg.__type_name) return true;\n         if (!((__type_name & __arg.__type_name) & _LIBCPP_NONUNIQUE_RTTI_BIT))\n           return false;\n         return __compare_nonunique_names(__arg) == 0;}\n#endif\n    _LIBCPP_INLINE_VISIBILITY\n    bool operator!=(const type_info& __arg) const _NOEXCEPT\n        {return !operator==(__arg);}\n\n#ifdef _LIBCPP_NONUNIQUE_RTTI_BIT\n  private:\n    _LIBCPP_INLINE_VISIBILITY\n    int __compare_nonunique_names(const type_info &__arg) const _NOEXCEPT\n        {return __builtin_strcmp(name(), __arg.name());}\n#endif\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_cast\n    : public exception\n{\npublic:\n    bad_cast() _NOEXCEPT;\n    virtual ~bad_cast() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\nclass _LIBCPP_EXCEPTION_ABI bad_typeid\n    : public exception\n{\npublic:\n    bad_typeid() _NOEXCEPT;\n    virtual ~bad_typeid() _NOEXCEPT;\n    virtual const char* what() const _NOEXCEPT;\n};\n\n}  // std\n\n#endif  // __LIBCPP_TYPEINFO\n"]}